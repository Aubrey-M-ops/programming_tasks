,Issue Key,Type,Priority,Affects Version/s,Component/s,Labels,Status,Resolution,Fix Version/s,Assignee,Reporter,Votes,Watchers,Created,Updated,Description,Comments
0,CAMEL-18270,Bug,Major,3.18.0,"3.14.5, 3.18.1, 3.19.0","
None
",Resolved,Fixed,"3.14.5, 3.18.1, 3.19.0",Claus Ibsen,Florian Fiby,0,2,2022-07-14 07:35:08+00:00,2022-07-29 08:32:01+00:00,"Our imap mail route on the production system gets blocked when someone or an other systems moves / deletes an email from the inbox, while the camel mail route is loading the mail. As we do not have full control on the mailboxes we enabled skipFailedMessage but the issue remains.


The following exception is written is the log, but the mail consumer is blocked. The issue can only be resolved by a restart of the service.




2022-07-14 09:17:28.714  WARN 5465 --- [fice365.com:993] o.a.c.i.engine.DefaultReactiveExecutor   : Error executing reactive work due to Error accessing headers due to: Cannot load header. This exception is ignored.
org.apache.camel.RuntimeCamelException: Error accessing headers due to: Cannot load header
    at org.apache.camel.component.mail.MailMessage.populateInitialHeaders(MailMessage.java:107) ~[camel-mail-3.18.0.jar:3.18.0]
    at org.apache.camel.support.DefaultMessage.createHeaders(DefaultMessage.java:331) ~[camel-support-3.18.0.jar:3.18.0]
    at org.apache.camel.support.DefaultMessage.hasHeaders(DefaultMessage.java:305) ~[camel-support-3.18.0.jar:3.18.0]
    at org.apache.camel.support.AbstractExchange.copy(AbstractExchange.java:140) ~[camel-support-3.18.0.jar:3.18.0]
    at org.apache.camel.support.DefaultExchange.copy(DefaultExchange.java:27) ~[camel-support-3.18.0.jar:3.18.0]
    at org.apache.camel.support.ExchangeHelper.createCopy(ExchangeHelper.java:322) ~[camel-support-3.18.0.jar:3.18.0]
    at org.apache.camel.processor.errorhandler.RedeliveryErrorHandler.defensiveCopyExchangeIfNeeded(RedeliveryErrorHandler.java:304) ~[camel-core-processor-3.18.0.jar:3.18.0]
    at org.apache.camel.processor.errorhandler.RedeliveryErrorHandler$RedeliveryTask.prepare(RedeliveryErrorHandler.java:680) ~[camel-core-processor-3.18.0.jar:3.18.0]
    at org.apache.camel.processor.PrototypeTaskFactory.acquire(PrototypeTaskFactory.java:29) ~[camel-core-processor-3.18.0.jar:3.18.0]
    at org.apache.camel.processor.errorhandler.RedeliveryErrorHandler.process(RedeliveryErrorHandler.java:210) ~[camel-core-processor-3.18.0.jar:3.18.0]
    at org.apache.camel.impl.engine.CamelInternalProcessor.process(CamelInternalProcessor.java:399) ~[camel-base-engine-3.18.0.jar:3.18.0]
    at org.apache.camel.processor.Pipeline$PipelineTask.run(Pipeline.java:109) ~[camel-core-processor-3.18.0.jar:3.18.0]
    at org.apache.camel.impl.engine.DefaultReactiveExecutor$Worker.schedule(DefaultReactiveExecutor.java:189) ~[camel-base-engine-3.18.0.jar:3.18.0]
    at org.apache.camel.impl.engine.DefaultReactiveExecutor.scheduleMain(DefaultReactiveExecutor.java:61) ~[camel-base-engine-3.18.0.jar:3.18.0]
    at org.apache.camel.processor.Pipeline.process(Pipeline.java:184) ~[camel-core-processor-3.18.0.jar:3.18.0]
    at org.apache.camel.impl.engine.CamelInternalProcessor.process(CamelInternalProcessor.java:399) ~[camel-base-engine-3.18.0.jar:3.18.0]
    at org.apache.camel.impl.engine.DefaultAsyncProcessorAwaitManager.process(DefaultAsyncProcessorAwaitManager.java:83) ~[camel-base-engine-3.18.0.jar:3.18.0]
    at org.apache.camel.support.AsyncProcessorSupport.process(AsyncProcessorSupport.java:41) ~[camel-support-3.18.0.jar:3.18.0]
    at org.apache.camel.component.mail.MailConsumer.processExchange(MailConsumer.java:451) ~[camel-mail-3.18.0.jar:3.18.0]
    at org.apache.camel.component.mail.MailConsumer.processBatch(MailConsumer.java:260) ~[camel-mail-3.18.0.jar:3.18.0]
    at org.apache.camel.component.mail.MailConsumer.poll(MailConsumer.java:165) ~[camel-mail-3.18.0.jar:3.18.0]
    at org.apache.camel.support.ScheduledPollConsumer.doRun(ScheduledPollConsumer.java:202) ~[camel-support-3.18.0.jar:3.18.0]
    at org.apache.camel.support.ScheduledPollConsumer.run(ScheduledPollConsumer.java:116) ~[camel-support-3.18.0.jar:3.18.0]
    at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515) ~[na:na]
    at java.base/java.util.concurrent.FutureTask.runAndReset$$$capture(FutureTask.java:305) ~[na:na]
    at java.base/java.util.concurrent.FutureTask.runAndReset(FutureTask.java) ~[na:na]
    at java.base/java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:305) ~[na:na]
    at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128) ~[na:na]
    at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628) ~[na:na]
    at java.base/java.lang.Thread.run(Thread.java:829) ~[na:na]
Caused by: javax.mail.MessagingException: Cannot load header
    at com.sun.mail.imap.IMAPMessage.loadHeaders(IMAPMessage.java:1583) ~[jakarta.mail-1.6.5.jar:1.6.5]
    at com.sun.mail.imap.IMAPMessage.getAllHeaders(IMAPMessage.java:992) ~[jakarta.mail-1.6.5.jar:1.6.5]
    at org.apache.camel.component.mail.MailBinding.extractHeadersFromMail(MailBinding.java:649) ~[camel-mail-3.18.0.jar:3.18.0]
    at org.apache.camel.component.mail.MailMessage.populateInitialHeaders(MailMessage.java:104) ~[camel-mail-3.18.0.jar:3.18.0]
    ... 29 common frames omitted




 


I've reproduced the issue with a break point on MailConsumer.processExchange. When the process hits this break point, I've move the mail and the route was blocked.


I think the route blocks on DefaultAsyncProcessorAwaitManager.await Line 107, but I'm not sure about it.


The expected behavior for me with skipFailedMessage=true, would be an ERROR in the log and processing of the next mail.


Is this a bug or is there a workaround for this issue?


Maybe this is related with CAMEL-16829","fibyflo:1658267266:2022-07-20T05:47:46.316+0000:1658267266:2022-07-20T05:47:46.316+0000:There was an other incident with same blocking outcome, the route was blocked and no new mails were processed . Camel 3.4 is also affected:

{{2022-07-18 16:21:24.762  WARN 1 --- [Camel (PROD) thread #1 - imaps://outlook.office365.com:993] o.a.c.i.engine.DefaultReactiveExecutor   : Error executing reactive work due to Error accessing headers due to: * BYE Jakarta Mail Exception: java.net.SocketTimeoutE}}
{{{}xception: Read timed out. This exception is ignored.{}}}{{{}org.apache.camel.RuntimeCamelException: Error accessing headers due to: * BYE Jakarta Mail Exception: java.net.SocketTimeoutException: Read timed out{}}}
{{        at org.apache.camel.component.mail.MailMessage.populateInitialHeaders(MailMessage.java:107) ~[camel-mail-3.4.6.jar!/:3.4.6]}}
{{        at org.apache.camel.support.DefaultMessage.createHeaders(DefaultMessage.java:310) ~[camel-support-3.4.6.jar!/:3.4.6]}}
{{        at org.apache.camel.support.DefaultMessage.hasHeaders(DefaultMessage.java:282) ~[camel-support-3.4.6.jar!/:3.4.6]}}
{{        at org.apache.camel.support.DefaultExchange.copy(DefaultExchange.java:129) ~[camel-support-3.4.6.jar!/:3.4.6]}}
{{        at org.apache.camel.support.ExchangeHelper.createCopy(ExchangeHelper.java:330) ~[camel-support-3.4.6.jar!/:3.4.6]}}
{{        at org.apache.camel.processor.errorhandler.RedeliveryErrorHandler.defensiveCopyExchangeIfNeeded(RedeliveryErrorHandler.java:266) ~[camel-base-3.4.6.jar!/:3.4.6]}}
{{        at org.apache.camel.processor.errorhandler.RedeliveryErrorHandler$RedeliveryTask.<init>(RedeliveryErrorHandler.java:590) ~[camel-base-3.4.6.jar!/:3.4.6]}}
{{        at org.apache.camel.processor.errorhandler.RedeliveryErrorHandler.process(RedeliveryErrorHandler.java:171) ~[camel-base-3.4.6.jar!/:3.4.6]}}
{{        at org.apache.camel.processor.CamelInternalProcessor.process(CamelInternalProcessor.java:286) ~[camel-base-3.4.6.jar!/:3.4.6]}}
{{        at org.apache.camel.processor.Pipeline$PipelineTask.run(Pipeline.java:90) ~[camel-base-3.4.6.jar!/:3.4.6]}}
{{        at org.apache.camel.impl.engine.DefaultReactiveExecutor$Worker.schedule(DefaultReactiveExecutor.java:148) ~[camel-base-3.4.6.jar!/:3.4.6]}}
{{        at org.apache.camel.impl.engine.DefaultReactiveExecutor.scheduleMain(DefaultReactiveExecutor.java:60) ~[camel-base-3.4.6.jar!/:3.4.6]}}
{{        at org.apache.camel.processor.Pipeline.process(Pipeline.java:147) ~[camel-base-3.4.6.jar!/:3.4.6]}}
{{        at org.apache.camel.processor.CamelInternalProcessor.process(CamelInternalProcessor.java:286) ~[camel-base-3.4.6.jar!/:3.4.6]}}
{{        at org.apache.camel.impl.engine.DefaultAsyncProcessorAwaitManager.process(DefaultAsyncProcessorAwaitManager.java:83) ~[camel-base-3.4.6.jar!/:3.4.6]}}
{{        at org.apache.camel.support.AsyncProcessorSupport.process(AsyncProcessorSupport.java:40) ~[camel-support-3.4.6.jar!/:3.4.6]}}
{{        at org.apache.camel.component.mail.MailConsumer.processExchange(MailConsumer.java:431) ~[camel-mail-3.4.6.jar!/:3.4.6]}}
{{        at org.apache.camel.component.mail.MailConsumer.processBatch(MailConsumer.java:248) ~[camel-mail-3.4.6.jar!/:3.4.6]}}
{{        at org.apache.camel.component.mail.MailConsumer.poll(MailConsumer.java:161) ~[camel-mail-3.4.6.jar!/:3.4.6]}}
{{        at org.apache.camel.support.ScheduledPollConsumer.doRun(ScheduledPollConsumer.java:187) ~[camel-support-3.4.6.jar!/:3.4.6]}}
{{        at org.apache.camel.support.ScheduledPollConsumer.run(ScheduledPollConsumer.java:106) ~[camel-support-3.4.6.jar!/:3.4.6]}}
{{        at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515) ~[na:na]}}
{{        at java.base/java.util.concurrent.FutureTask.runAndReset(FutureTask.java:305) ~[na:na]}}
{{        at java.base/java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:305) ~[na:na]}}
{{        at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128) ~[na:na]}}
{{        at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628) ~[na:na]}}
{{        at java.base/java.lang.Thread.run(Thread.java:829) ~[na:na]}}
{{Caused by: javax.mail.FolderClosedException: * BYE Jakarta Mail Exception: java.net.SocketTimeoutException: Read timed out}}
{{        at com.sun.mail.imap.IMAPMessage.loadHeaders(IMAPMessage.java:1575) ~[jakarta.mail-1.6.5.jar!/:1.6.5]}}
{{        at com.sun.mail.imap.IMAPMessage.getAllHeaders(IMAPMessage.java:992) ~[jakarta.mail-1.6.5.jar!/:1.6.5]}}
{{        at org.apache.camel.component.mail.MailBinding.extractHeadersFromMail(MailBinding.java:610) ~[camel-mail-3.4.6.jar!/:3.4.6]}}
{{        at org.apache.camel.component.mail.MailMessage.populateInitialHeaders(MailMessage.java:104) ~[camel-mail-3.4.6.jar!/:3.4.6]}}
{{        ... 26 common frames omitted}}
fibyflo:1658297896:2022-07-20T14:18:16.921+0000:1658297896:2022-07-20T14:18:16.921+0000:Hi [~davsclaus], 

I'm searching the camel code for possible workarounds for this issue and found https://issues.apache.org/jira/browse/CAMEL-16938 you worked on. So maybe you can help with my reported issue?

As far as I understand it by now, each mail is processed with a thread and if the RuntimeCamelException occurs, the route is blocked by waiting for the thread and does not process any new mails.

The issue seams located in DefaultReactiveExecutor.scheduleMain by catching the RuntimeCamelException without cleaning up the thread. Therefore this could also affect other camel components, not just mail.

My issue could be created by wrong mailserver handling or server side issues, but the blocking state of the route can't be right.

 
fibyflo:1658379558:2022-07-21T12:59:18.170+0000:1658379558:2022-07-21T12:59:18.170+0000:I was able to get the route working, with an small but not clean workaround, by rethrowing t:

{{try {}}
{{if (stats) {}}
{{executor.pendingTasks.decrement();}}
{{}}}
{{if (LOG.isTraceEnabled()) {}}
{{LOG.trace(""Worker #{} running: {}"", number, polled);}}
{{}}}
{{polled.run();}}
{{} catch (Throwable t) {}}
{{LOG.error(""Error executing reactive work due to {}. This exception is ignored."",}}
{{t.getMessage(), t);}}
{{throw t;}}
{{}}}
davsclaus:1658995285:2022-07-28T16:01:25.875+0000:1658995285:2022-07-28T16:01:25.875+0000:Thanks for reporting and the detailed analysis.


davsclaus:1659053275:2022-07-29T08:07:55.690+0000:1659053275:2022-07-29T08:07:55.690+0000:Thanks this will be fixed by the linked ticket"
0,CAMEL-18269,Task,Major,None,3.19.0,"
None
",Resolved,Fixed,3.19.0,Andrea Cosentino,Marco Carletti,0,2,2022-07-13 10:48:51+00:00,2022-07-18 04:48:06+00:00,"Since the version of Camel Spring Boot has been released camel-spring-boot-3.18.0 the version of the examples should be updated as well, increasing the snapshot and creating the tag","Federico Mariani:1657870948:2022-07-15T15:42:28.140+0000:1657870948:2022-07-15T15:42:28.140+0000:https://github.com/apache/camel-spring-boot-examples/pull/71
mcarlett:1657881498:2022-07-15T18:38:18.494+0000:1657881534:2022-07-15T18:38:54.881+0000:build fails due to CAMEL-18271"
0,CAMEL-18268,Task,Minor,None,3.19.0,"
None
",Resolved,Fixed,3.19.0,Andrea Cosentino,Marco Carletti,0,1,2022-07-13 08:27:00+00:00,2022-07-25 07:17:03+00:00,The camel-dependencies version is 3.18.0-SNAPSHOT in  https://github.com/apache/camel-spring-boot/blob/main/pom.xml#L26 and the current version is 3.19.0-SNAPSHOT https://github.com/apache/camel-spring-boot/blob/main/pom.xml#L31,
0,CAMEL-18267,New Feature,Major,None,3.19.0,"
None
",Resolved,Fixed,3.19.0,Unassigned,Andrea Cosentino,0,2,2022-07-12 17:07:16+00:00,2022-09-07 08:12:40+00:00,"In case of rotation, update, patch etc. We need to trigger a reload.


This might be a service running with the properties source or something we could enable on-demand.


In this way we could react to events.","acosentino:1657616904:2022-07-12T17:08:24.772+0000:1657616904:2022-07-12T17:08:24.772+0000:cc [~davsclaus] [~lburgazzoli]
davsclaus:1662002867:2022-09-01T11:27:47.750+0000:1662002867:2022-09-01T11:27:47.750+0000:Let me get started and add some API in camel-core we can use from the vaults
davsclaus:1662069800:2022-09-02T06:03:20.091+0000:1662069800:2022-09-02T06:03:20.091+0000:Docs is at
https://camel.apache.org/manual/context-reload.html"
0,CAMEL-18266,Bug,Major,3.18.0,"3.18.1, 3.19.0","
None
",Resolved,Fixed,"3.18.1, 3.19.0",Zheng Feng,Zheng Feng,0,1,2022-07-12 08:11:44+00:00,2022-07-12 12:21:00+00:00,"It looks like there is a missing  bean schema in ResourceHelper.hasSchema(String uri). And 


XsltUriResolver falls back to use classpath schema.",
0,CAMEL-18265,Task,Major,None,None,"
None
",Open,Unresolved,4.x,Andrea Cosentino,Andrea Cosentino,0,1,2022-07-11 16:59:34+00:00,2023-08-09 09:07:29+00:00,No Desc,
0,CAMEL-18264,Improvement,Major,"3.14.4, 3.18.0","3.14.5, 3.18.1, 3.19.0","
None
",Resolved,Fixed,"3.14.5, 3.18.1, 3.19.0",Unassigned,Konrad Stachera,0,2,2022-07-11 08:38:01+00:00,2022-08-15 06:57:39+00:00,"When server requires ssh-dss host key algorithm it is not possible to configure sFTP camel component to use such key type, therefore connecting fails with ""com.jcraft.jsch.JSchException: Algorithm negotiation fail"". 


When these two properties are added in debug mode:




session.setConfig(""server_host_key"", session.getConfig(""server_host_key"") + "",ssh-dss"") 
session.setConfig(""PubkeyAcceptedAlgorithms"", session.getConfig(""PubkeyAcceptedAlgorithms"") + "",ssh-dss"") 



in SftpOperations class:





the connection is established successfully.


It should be possible to configure ""server_host_key"" and ""PubkeyAcceptedAlgorithms"" in camel sFTP component.","KonradStachera:1659055316:2022-07-29T08:41:56.487+0000:1659055316:2022-07-29T08:41:56.487+0000:I'll open PR for this today
davsclaus:1659230007:2022-07-31T09:13:27.206+0000:1659230007:2022-07-31T09:13:27.206+0000:Thanks for the PR"
0,CAMEL-18263,Task,Major,3.18.0,None,"
None
",Resolved,Fixed,3.19.0,Nicolas Filotto,Nicolas Filotto,0,1,2022-07-11 07:18:12+00:00,2022-08-02 14:11:35+00:00,The tests `testSuspendModeConfiguredWithBoth` and `testSuspendModeConfiguredWithEnvVariable` of `BacklogDebuggerTest` are both failing on Java 17 as we can see here https://ci-builds.apache.org/job/Camel/job/Camel%20JDK16/job/main/334/testReport/junit/org.apache.camel.management/,nfilotto:1657495997:2022-07-11T07:33:17.654+0000:1657495997:2022-07-11T07:33:17.654+0000:The corresponding PR https://github.com/apache/camel/pull/7996
0,CAMEL-18262,Bug,Major,3.18.0,"3.18.1, 3.19.0","
None
",Resolved,Fixed,"3.18.1, 3.19.0",Unassigned,j vh,0,3,2022-07-09 01:11:39+00:00,2022-07-31 12:45:59+00:00,"Using Route Templates as described here in the Camel docs: route-template, I cannot get any exception handling to work unless I define it within the class that is constructing the template itself.
Specifically,  trying to use global exception handling in the class that calls TemplatedRouteBuilder.builder() to build a route from my template. Expected exceptions are not caught.
And there is no .onException() method implementation to customize the handling that could be called in the list of fluent methods starting with TemplatedRouteBuilder.build().


I have already posted this, with my example code, in the Camel mailing list. Please have a look at the discussion here: [mail-archive|https://lists.apache.org/thread/26kp2tpfbgj9mxpfdr106f36xyj51d7g]


This is the hi-level description from that mail article:




Hi-level overview:
- 2 projects: 1 camel template base jar and 1 springboot camel application (that builds its route using the template from the other project).
- the base jar builds a route template
- the application jar builds a route using the template from the base jar
- the desire here is to do some extra customization in the application (at templated-route creation time) to setup extra exception handling that is not included in the base template.
- I have also tried to define global level exception handling using onException() in my application project's configure() method. But this is not catching anything either.
 



There is a overview of the code in the mail article as well. But I also have a simplified single spring-boot test project with junit that I can provide if needed.","rhuanrcoha:1657309518:2022-07-09T03:45:18.496+0000:1657309518:2022-07-09T03:45:18.496+0000:Hi,

Could you provide the sample reproducer you said? 

 

If you add the Custom Error Handler like below, is it working? Reading the scenario looks like the auto-discovery from spring-boot did not find the MyCustomErrorHandler. 

 
{code:java}
context.addRoutes(new MyCustomErrorHandler());{code}
jvh:1657345099:2022-07-09T13:38:19.460+0000:1657345135:2022-07-09T13:38:55.188+0000:Hi [~rhuanrcoha],
I've added a 7zip file with the sample code. This is a simplified version (single maven project) of what I described in the mail-archive article (two maven projects).
You can duplicate the problem in 2 different ways:
 * Run the RunRouteTest junit. This will mock out the route's file component and inject a test msg to show that the global exception handling is not invoked
 * Or just run the project via ""mvn spring-boot:run"" and copy a testfile into the input_directory in the project base directory. This will trigger the route to start. The testfile can have anything in it. A single line of text will suffice.

In either scenario, you'll see that the default rollback exception handling kicks in, and my handled(true) setup from L31, and the log on L32 are never executed from the class: CreateRoute.

Note: the reason for the exception is that the code is trying to send a REST POST to a REST API on port 9000 running on your localhost. (See the 2nd template parameter on L38 in the CreateRoute class).

I will also try out your suggestion for the custom error handler and let you know how that goes.
jvh:1657348045:2022-07-09T14:27:25.892+0000:1657518458:2022-07-11T13:47:38.043+0000:Hi [~rhuanrcoha],
I've just tried your suggestion as shown below and it is also NOT working.
But if this is not exactly what you wanted to try - let me know.
Thanks,
{code:java}
   @Override
   public void configure() throws Exception {
      camelContext.addRoutes(new MyCustomErrorHandler());

      final String routeId = TemplatedRouteBuilder.builder(camelContext, ""route-template-1"")
            .routeId(""my-test-file-route"")
            .parameter(""input-directory-param-id"", ""input-directory"")
            .parameter(""rest-endpoint-id"", ""http://localhost:9000/TestSink/any-string"")
            .parameter(""route-id-param-id"", ""my-internal-route-id"")
            .add();
      log.info(""Route {} created from template"", routeId);
   }{code}
{code:java}
public class MyCustomErrorHandler implements RoutesBuilder {
   @Override
   public void addRoutesToCamelContext(final CamelContext context) throws Exception {
      context.addRoutes(new RouteBuilder() {
          @Override
          public void configure() throws Exception {
             onException(ConnectException.class)
             .handled(true)
             .log(LoggingLevel.ERROR, log, ""--> Exception: ${exception.message}, Delivery was NOT rolled back"")
             .end();
          }
      });
   }
   @Override
   public Set<String> updateRoutesToCamelContext(final CamelContext context) throws Exception {
       return null;
    }
}
{code}
rhuanrcoha:1657359615:2022-07-09T17:40:15.498+0000:1657359653:2022-07-09T17:40:53.138+0000:Hi,

The template does not use the routes configured inside the RouterBuilder. A way to configure it is by creating the RouteConfigurationBuilder as below.

 
{code:java}
@Component
public class MyCustomErrorHandler extends RouteConfigurationBuilder {
   @Override
   public void configuration() throws Exception {
       routeConfiguration(""my-error-handler"").
       onException(ConnectException.class)
      .handled(true)
      .log(LoggingLevel.ERROR, log, ""--> Exception: ${exception.message}, Delivery was NOT rolled back"");

     }
}{code}
Thus you configure it inside the template
{code:java}
routeTemplate(""route-template-1"")
.templateParameter(""input-directory-param-id"")
.templateParameter(""rest-endpoint-id"")
.templateParameter(""route-id-param-id"")

.from(""file:{{input-directory-param-id}}"")
.routeConfigurationId(""my-error-handler"")//He is the configuration. If needed you can use the template parameter.
.log(LoggingLevel.INFO, log, ""--> Read file: ${header.CamelFileName}"")
.to(""{{rest-endpoint-id}}"")
.id(""{{route-id-param-id}}"")
.log(LoggingLevel.INFO, log, ""--> File: ${header.CamelFileName} sent to rest-endpoint: {{rest-endpoint-id}}"");{code}
However, I have seen it has a bug and the template is not using the RouteConfigurationBuilder. I have found the root cause and I`ll send a PR soon to solve that. 
rhuanrcoha:1657393508:2022-07-10T03:05:08.037+0000:1657393525:2022-07-10T03:05:25.520+0000:Hi,

I sent a PR to solve this issue. I`m sharing the sample updated with the RouteConfigurationBuilder. As soon as the PR is merged you can test.

 

[^camel-template-so.zip]
jvh:1657519929:2022-07-11T14:12:09.054+0000:1657520273:2022-07-11T14:17:53.256+0000:Thanks for clarifying the error handler implementation, and also fixing the bug :)

I've re-coded my custom error handler to follow your pattern, and have also used a template parameter to pass in the route configuration id for the error handler.

So, yes, as soon as the PR is merged, I can test this out.

Or let me know if there is a SNAPSHOT build somewhere that I could test with, rather than waiting for the release.
rhuanrcoha:1657947060:2022-07-16T12:51:00.360+0000:1657947077:2022-07-16T12:51:17.768+0000:Hi [~jvh],

To test now the updates you can build this branch [https://github.com/rhuan080/camel/tree/CAMEL-18262.] The PR was approved and will be merged soon.
davsclaus:1658736679:2022-07-25T16:11:19.050+0000:1658736679:2022-07-25T16:11:19.050+0000:Thanks for reporting and the PR"
0,CAMEL-18261,Improvement,Minor,None,"4.0-RC2, 4.0.0","
None
",Resolved,Fixed,"4.0-RC2, 4.0.0",Vaishnavi R,ALEXANDRE DAVI ZANELATTO,0,2,2022-07-08 19:12:52+00:00,2023-07-11 13:00:06+00:00,"Add the following options to mongodb component:



ssl: A boolean to enable or disables TLS/SSL for the connection;
directConnection: Allow a driver to force a Single topology type with a connection string containing one host;
retryWrites: Enable retryable writes.



These options are currently missing from the mongodb endpoint URI.","valdar:1674460630:2023-01-23T15:57:10.174+0000:1674460630:2023-01-23T15:57:10.174+0000:I was about to open a similar issue then I stumbled upon this [~acosentino], related to https://issues.apache.org/jira/browse/CAMEL-18969"
0,CAMEL-18260,Improvement,Major,3.18.0,"3.18.1, 3.19.0","
None
",Resolved,Fixed,"3.18.1, 3.19.0",Nicolas Filotto,Nicolas Filotto,0,1,2022-07-08 12:47:29+00:00,2022-07-08 17:19:27+00:00,"While investigating on https://github.com/camel-tooling/camel-idea-plugin/issues/734, I realized that is was actually due to the fact that when a change is made on an exchange, the corresponding backlog tracer event message is not modified such that the change is not reflected in the debugger variables.","nfilotto:1657263310:2022-07-08T14:55:10.752+0000:1657263310:2022-07-08T14:55:10.752+0000:The corresponding PR https://github.com/apache/camel/pull/7991
nfilotto:1657271967:2022-07-08T17:19:27.540+0000:1657271967:2022-07-08T17:19:27.540+0000:The PR for the backport https://github.com/apache/camel/pull/7994"
0,CAMEL-18259,Improvement,Minor,None,Future,"
None
",Open,Unresolved,Future,Unassigned,James Netherton,0,1,2022-07-07 06:35:31+00:00,2023-08-09 09:07:35+00:00,"The FHIR component has a polling consumer where it can do polling operations against a FHIR server. Seems we have no documentation or tests for this though, so it'd be useful to add some.",
0,CAMEL-18258,Improvement,Minor,None,3.19.0,"
None
",Resolved,Fixed,3.19.0,Claudio Miranda,Claudio Miranda,0,1,2022-07-06 22:25:21+00:00,2022-07-08 15:12:45+00:00,"Couple of small enhancements to camel-splunk and camel-splunk-hec



Explicit documentation about the token in camel-splunk-hec is not the user's token, but the token generated for the HEC.
Add support for token authentication, a safe alternative to the user's password.
Escape the error cause when authenticating to splunk (original stacktrace is lost)
Document about using the realtime consumer.",
0,CAMEL-18257,New Feature,Major,None,3.18.0,"
None
",Resolved,Fixed,3.18.0,Andrea Cosentino,Andrea Cosentino,0,1,2022-07-05 11:43:21+00:00,2022-07-13 09:44:00+00:00,No Desc,
0,CAMEL-18256,New Feature,Major,None,None,"
None
",Resolved,Fixed,3.19.0,Andrea Cosentino,Andrea Cosentino,0,1,2022-07-05 09:18:28+00:00,2022-07-05 10:47:28+00:00,No Desc,
0,CAMEL-18255,Bug,Minor,"3.14.1, 3.17.0","3.14.6, 3.18.4, 3.19.0","
None
",Resolved,Fixed,"3.14.6, 3.18.4, 3.19.0",Unassigned,Michael Rambichler,0,4,2022-07-01 15:51:33+00:00,2022-10-29 06:43:22+00:00,"We realized a sever memory leak in a standard route:


 


I reproduced it and made a simple MemoryAllocation Check.


Just for curiosity i made another test with:  (.errorhandler(no errorhandler)) and the memory leak does not occure.


 


Sample route to reproduce:


 


from(""scheduler:testScheduler?repeatCount=1"")


                .log(""Starting route test-route"")


                .process(exchange -> {


                    Iterator<String> infiniteIter = new Iterator<>() {


                        private int integer = 0;


 


                        @Override public boolean hasNext()


{                             return true;                         }


                        @Override public String next()


{                             return String.valueOf(integer++);                         }


                    };


                    exchange.getMessage().setBody(infiniteIter);


                })


                .split().body().streaming()


                    .log(""inside split: ${body}"")


                .end()


                .log(""test-route never finishes"");","davsclaus:1656666480:2022-07-01T17:08:00.710+0000:1656666480:2022-07-01T17:08:00.710+0000:Can you maybe put together this as an unit test or something that is ready to try so we can more quickly jump on this
davsclaus:1656667848:2022-07-01T17:30:48.505+0000:1656667848:2022-07-01T17:30:48.505+0000:I cannot reproduce any leak with your sample route above. The objects are allocated but can be GC so you can go down to < 30mb when GC kicks in.
davsclaus:1656668331:2022-07-01T17:38:51.887+0000:1656668331:2022-07-01T17:38:51.887+0000:Running as unit test then there is some additonal overhead with the NotifyBuilder that comes out of the box with camel-core tests, but these objects are not leaking.
rambichler:1656674429:2022-07-01T19:20:29.978+0000:1656674429:2022-07-01T19:20:29.978+0000:I have added a example project in github: [https://github.com/michael-salzburg/splitMemoryTest.git]

The issue is the mdc logging: 

{color:#FF0000}camel.springboot.use-mdc-logging=true{color}

Without: Memory Consumption around 100MB. with mdc-logging=true Consumption goes up till END. GC does not work.
davsclaus:1656678167:2022-07-01T20:22:47.562+0000:1656678167:2022-07-01T20:22:47.562+0000:Thanks for spotting its MDC - MDC is low priority and candidate for deprecation and removal in the future.
rambichler:1656843905:2022-07-03T18:25:05.950+0000:1656843926:2022-07-03T18:25:26.570+0000:Hi [~davsclaus] 

The issue is quite independent of MDC.

See my example in [https://github.com/michael-salzburg/splitMemoryTest.git]

 

I spend some time to analyse it further:

 

If you override the method of the DefaultUnitOfWork or MDCUnitOfWork and return {color:#de350b}true{color}: Then the Memory Leak occurs. 

@Override
public boolean isBeforeAfterProcess() {
{color:#de350b}return true; //like its set e.g. in MDCUnitOfWork{color}
}

 

The current MDCUnitOfWork returns true in this case.

But i wasn't able to analyse the impact in deep of this change, yet.

 

Btw. You mentioned MDC is low prio/candidate for dprecation: We use MDC logging of especially the breadcrumbId heavily in our system. That would have major impact in our environment.
klease78:1657086591:2022-07-06T13:49:51.135+0000:1657086591:2022-07-06T13:49:51.135+0000:[~rambichler] The root of the problem seems to be in these lines: [CamelInternalProcessor.java#L405-L411|https://github.com/apache/camel/blob/8f94758145dd26e52b335da6765c46a9d0b95482/core/camel-base-engine/src/main/java/org/apache/camel/impl/engine/CamelInternalProcessor.java#L405-L411]

This puts a lambda to run the afterProcess method on the queue of the ReactiveExecutor. Each Exchange produced by the splitter is wrapped in a DefaultErrorHandler but there is already a DefaultErrorHandler wrapping the processor(s) following the split(). The ErrorHandler queues a SimpleTask using scheduleMain which backs up any other elements on the queue to a backup queue. The sequence is a bit difficult to follow but the end result is that the backed-up queue containing the lambda to run the MDCUnitOfWork.afterProcess() method is not run when the processing of the Exchange finishes but only when all Exchanges produced by the split() have been processed. Then they are all run, but in the reverse order in which they where added to the scheduler! This causes the memory leak.

The use of the scheduler to run afterProcess() was added back in CAMEL-17153 to resolve a problem caused by removing it in CAMEL-16034 (which is exactly the problem you are experiencing.)

I think it might work to invoke the uow.afterProcess() in the async callback itself, since that task is run at the correct point in the process, so I'm going to test this approach.
rambichler:1657087922:2022-07-06T14:12:02.734+0000:1657087922:2022-07-06T14:12:02.734+0000:Great [~klease78] for this analysis. I got stucked in debugging at exactly your position.
klease78:1657093922:2022-07-06T15:52:02.521+0000:1657093922:2022-07-06T15:52:02.521+0000:Unfortunately my idea fixes your issue but causes test failures, so I need to search for a better solution.
rastislav.papp:1666748522:2022-10-26T09:42:02.807+0000:1666748522:2022-10-26T09:42:02.807+0000:[~davsclaus], [~klease78], could we get a fix for 3.14.x LTS?"
0,CAMEL-18254,Improvement,Major,None,3.20.0,"
None
",Resolved,Fixed,3.20.0,Claus Ibsen,Claus Ibsen,0,1,2022-07-01 10:59:51+00:00,2022-10-13 11:33:47+00:00,"We should look at making kamelets not log their default options, as that is a bit noisy.


For example running


camel-kamelets-examples/jbang/metrics main *1 ❯ camel run metrics.yaml --console


You see


2022-07-01 12:57:44.883  INFO 54705 — [           main] org.apache.camel.main.BaseMainSupport    : Property-placeholders summary
2022-07-01 12:57:44.883  INFO 54705 — [           main] org.apache.camel.main.BaseMainSupport    :     [timer-source.kamelet.yaml]    period=1000
2022-07-01 12:57:44.884  INFO 54705 — [           main] org.apache.camel.main.BaseMainSupport    :     [timer-source.kamelet.yaml]    message=hello
2022-07-01 12:57:44.884  INFO 54705 — [           main] org.apache.camel.main.BaseMainSupport    :     [timer-source.kamelet.yaml]    contentType=text/plain
2022-07-01 12:57:44.884  INFO 54705 — [           main] org.apache.camel.main.BaseMainSupport    :     [timer-source.kamelet.yaml]    templateId=timer-source


The only specific option we use in this example is message=hello. The other values are default values.","davsclaus:1656644437:2022-07-01T11:00:37.090+0000:1656644437:2022-07-01T11:00:37.090+0000:Also the source seems wrong as its metrics.yaml that set this via

 uri: kamelet:timer-source?message=hello
"
0,CAMEL-18253,Bug,Minor,"3.14.4, 3.17.0","3.14.5, 3.18.0","
None
",Resolved,Fixed,"3.14.5, 3.18.0",Otavio Rodolfo Piske,Otavio Rodolfo Piske,0,2,2022-07-01 07:55:06+00:00,2022-07-01 11:32:28+00:00,"Any code that calls the (potentially) safe contains method on the Kafka idempotent repository may cause it to incorrectly report an additional number of duplicate messages because it uses incrementAndGet on the counter:


 


https://github.com/apache/camel/blob/camel-3.17.x/components/camel-kafka/src/main/java/org/apache/camel/processor/idempotent/kafka/KafkaIdempotentRepository.java#L375-L382","davsclaus:1656643212:2022-07-01T10:40:12.499+0000:1656643212:2022-07-01T10:40:12.499+0000:Can you backport to 3.14.x branch
orpiske:1656643283:2022-07-01T10:41:23.774+0000:1656643283:2022-07-01T10:41:23.774+0000:Yes I can. I am working on it."
0,CAMEL-18252,Bug,Minor,3.17.0,3.18.0,"
None
",Resolved,Fixed,3.18.0,Benjamin Graf,Benjamin Graf,0,1,2022-07-01 06:32:44+00:00,2022-07-01 16:57:44+00:00,"Using BridgeExceptionHandlerToErrorHandler together with OnCompletion prevents to process the Exception because it temporarily gets removed from exchange and there is no other reference available. JavaDoc of OnCompletionProcessor mentions



the caused exception is stored as a property (Exchange.EXCEPTION_CAUGHT) on the exchange




Might be a possible solution to be set in BridgeExceptionHandlerToErrorHandler 


Small test case to verify, see log of missing Exception. (logging null value!)",
0,CAMEL-18251,Improvement,Major,None,3.18.0,"
None
",Resolved,Fixed,3.18.0,Claus Ibsen,Claus Ibsen,0,1,2022-06-30 14:06:11+00:00,2022-10-25 12:24:00+00:00,"So you can quickly try and run 


            uri: microprofile-metrics:counter:messages


And not have an error


Caused by: java.lang.IllegalStateException: No usable MetricRegistry has been configured
	at org.apache.camel.component.microprofile.metrics.MicroProfileMetricsHelper.getMetricRegistry(MicroProfileMetricsHelper.java:112)
	at org.apache.camel.component.microprofile.metrics.MicroProfileMetricsComponent.createEndpoint(MicroProfileMetricsComponent.java:39)
	at org.apache.camel.support.DefaultComponent.createEndpoint(DefaultComponent.java:171)
	at org.apache.camel.impl.engine.AbstractCamelContext.doGetEndpoint(AbstractCamelContext.java:951)",davsclaus:1656569269:2022-06-30T14:07:49.879+0000:1656569269:2022-06-30T14:07:49.879+0000:And make it possible to configure the registry from applicaton.properties
0,CAMEL-18250,Bug,Minor,"3.14.4, 3.17.0","3.14.5, 3.18.0","
None
",Resolved,Fixed,"3.14.5, 3.18.0",Babak Vahdat,Babak Vahdat,0,1,2022-06-30 11:52:03+00:00,2022-07-01 10:41:22+00:00,"As because then there is an implicit 0 (as int) to ""0"" (as string) conversion happening.",
0,CAMEL-18249,Task,Major,"3.16.0, 3.17.0",3.18.0,"
None
",Resolved,Fixed,3.18.0,Otavio Rodolfo Piske,Otavio Rodolfo Piske,0,1,2022-06-29 15:13:39+00:00,2022-06-30 07:22:14+00:00,"Logging changes in Apache ActiveMQ version 5.17.x [1] have caused some of our test logs to stop working. For some reason, the tests are ignoring the log4j.properties file and not creating the test log file. When we upgraded it [2], they stopped working.


 


1. https://issues.apache.org/jira/browse/AMQ-7426
2. 7aac02347cca64d1cf84c790292c61ec5c5ec20e",
0,CAMEL-18248,Improvement,Minor,3.17.0,3.18.0,"
None
",Resolved,Fixed,3.18.0,Claus Ibsen,Aurélien Pupier,0,2,2022-06-29 13:31:03+00:00,2022-06-29 14:00:22+00:00,"It would be nice to provide ProducerTemplate as Injectable bean when creating a Camel main test using annotations.


In test, we will be able to write something like:



@BeanInject
 ProducerTemplate producerTemplate;




advantages:



lifecycle handled by the framework test
no need to call context.createProducerTemplate() and destroy it
coherence with Camel Spring Boot annotation which is providing 

@Autowired
    ProducerTemplate producerTemplate;",davsclaus:1656482422:2022-06-29T14:00:22.272+0000:1656482422:2022-06-29T14:00:22.272+0000:This is made general so you can also do this outside camel-test
0,CAMEL-18247,Dependency upgrade,Minor,None,3.18.0,"
None
",Resolved,Fixed,3.18.0,Claus Ibsen,Claus Ibsen,0,1,2022-06-29 12:36:18+00:00,2022-06-29 13:54:05+00:00,No Desc,
0,CAMEL-18246,Dependency upgrade,Major,None,None,"
None
",Resolved,Fixed,"3.18.1, 3.19.0",Alex Dettinger,Alex Dettinger,0,2,2022-06-29 11:17:20+00:00,2022-07-30 08:32:23+00:00,"It relates to CAMEL-QUARKUS-3763.


hdfs could be upgraded to 3.3.3, so that's ok.


However, hbase can't be updated to hadoop-common 2.10.2 as some tests fail. Plus we are not sure whether 2.10.2 is really safer. If it's not maintained actively, maybe deprecation would be needed.","davsclaus:1656473942:2022-06-29T11:39:02.291+0000:1656473942:2022-06-29T11:39:02.291+0000:Would you check if we can upgrade or do something for the camel-3.14.x branch
aldettinger:1656478511:2022-06-29T12:55:11.861+0000:1656478511:2022-06-29T12:55:11.861+0000:yep, I need to sort the dependency issue in the PR first: https://github.com/apache/camel/pull/7928. Let's see whether https://issues.apache.org/jira/browse/HADOOP-18317 could help.

If the issue is really fixed, then let's see after if something could be done for camel-3.14.x branch.
aldettinger:1656546811:2022-06-30T07:53:31.092+0000:1656552419:2022-06-30T09:26:59.733+0000:For hbase we tried to update the hadoop-common version to 3.2.3 in [https://github.com/apache/camel/pull/7940.] but it has broken some ci tests.
aldettinger:1656632117:2022-07-01T07:35:17.230+0000:1656632117:2022-07-01T07:35:17.230+0000:Ok, we finally reverted everything as some itests were broken in CI. Let's retake this step by step after the release.
aldettinger:1656912425:2022-07-04T13:27:05.466+0000:1656912425:2022-07-04T13:27:05.466+0000:So indeed, the update to hadoop-common 2.10.2 is breaking the hbase tests, plus we are not sure whether it's really safer (https://issues.apache.org/jira/browse/HADOOP-18317).

 

However, it should be possible to upgrade the hadoop3-version to 3.3.3:

https://github.com/apache/camel/pull/7970
aldettinger:1656978659:2022-07-05T07:50:59.554+0000:1656978659:2022-07-05T07:50:59.554+0000:Backporting to 3.18.x: https://github.com/apache/camel/pull/7972
aldettinger:1657106969:2022-07-06T19:29:29.585+0000:1657106969:2022-07-06T19:29:29.585+0000:Backported to 3.18.x: https://github.com/apache/camel/commit/792c12240aeeed7d658edaacf68b796e64a5b22f"
0,CAMEL-18245,Improvement,Major,None,3.18.0,"
None
",Resolved,Fixed,3.18.0,Claus Ibsen,Claus Ibsen,0,1,2022-06-29 07:13:43+00:00,2022-06-29 07:20:51+00:00,"2022-06-29 09:11:18.761  WARN 4258 — [           main] lver.dns.DnsServerAddressStreamProviders : Can not find io.netty.resolver.dns.macos.MacOSDnsServerAddressStreamProvider in the classpath, fallback to system defaults. This may result in incorrect DNS resolutions on MacOS.


We need to detect that you run on mac, and then automatic add that dependency",davsclaus:1656458451:2022-06-29T07:20:51.547+0000:1656458451:2022-06-29T07:20:51.547+0000:This is after the vertx upgrade
0,CAMEL-18244,Task,Minor,3.14.0,"3.18.3, 3.19.0","
None
",Resolved,Fixed,"3.18.3, 3.19.0",Unassigned,Lucia Drozdová,0,1,2022-06-29 06:27:40+00:00,2022-09-06 12:15:49+00:00,"The code samples for Advanced AmazonSQS Configuration and Creating or updating an SQS queue needs to be fixed:



the code sample Advanced AmazonSQS Configuration is only a sample for sending messages:
	
https://camel.apache.org/components/3.14.x/aws2-sqs-component.html#_advanced_amazonsqs_configuration


we fixed the code sample for Creating or updating an SQS, but it is needed to come out with better example
	
https://camel.apache.org/components/3.14.x/aws2-sqs-component.html#_creating_or_updating_an_sqs_queue",
0,CAMEL-18243,Task,Minor,3.14.0,"3.18.3, 3.19.0","
None
",Resolved,Fixed,"3.18.3, 3.19.0",Unassigned,Mario Majernik,0,1,2022-06-28 15:17:20+00:00,2022-09-05 16:54:41+00:00,"Option maxBlockMs contains description:
	


The configuration controls how long sending to kafka will block. These methods can be blocked for multiple reasons.

`to kafka will block` -> what
`These methods` -> what methods?
Looks like the first sentence is not finished or there should be one more.
docs: https://camel.apache.org/components/3.14.x/kafka-component.html#_component_option_maxBlockMs


Options metricsSampleWindowMs and noOfMetricsSample have exactly the same description.
	
https://camel.apache.org/components/3.14.x/kafka-component.html#_component_option_metricsSampleWindowMs
https://camel.apache.org/components/3.14.x/kafka-component.html#_component_option_noOfMetricsSample


[PROPOSITION] Option requestRequiredAcks have a very long description. Would be much more readable if the options will be described in the bullet list (acks=-1, acks=0, acks=1, acks=all)
	
https://camel.apache.org/components/3.14.x/kafka-component.html#_component_option_requestRequiredAcks


Option kerberosPrincipalToLocalRules contains sentence:
	


For more details on the format please see the security authorization and acls documentation.. Multiple values can be separated by a comma. 

but there are no links to the mentioned documentations.
https://camel.apache.org/components/3.14.x/kafka-component.html#_component_option_kerberosPrincipalToLocalRules",
0,CAMEL-18242,Dependency upgrade,Major,3.14.4,3.14.5,"
None
",Resolved,Fixed,3.14.5,Unassigned,Claus Ibsen,0,1,2022-06-28 15:12:35+00:00,2022-08-16 09:45:16+00:00,We should upgrade to a newer spring boot version for the next 3.14.x release,
0,CAMEL-18241,Task,Minor,3.14.0,"3.18.3, 3.19.0","
None
",Resolved,Fixed,"3.18.3, 3.19.0",Unassigned,Mario Majernik,0,1,2022-06-28 15:00:27+00:00,2022-09-06 11:23:47+00:00,"Docs: https://access.redhat.com/webassets/avalon/d/red_hat_integration/2022.q2/apache-camel-3.14-doc/components/3.14.x/http-component.html#_response_code


Last sentence of chapter:




There is a sample below demonstrating this. 



but there is no sample in the docs regarding this.",
0,CAMEL-18240,Task,Minor,3.14.0,"3.18.3, 3.19.0","
None
",Resolved,Fixed,"3.18.3, 3.19.0",Claus Ibsen,Mario Majernik,0,2,2022-06-28 14:56:05+00:00,2022-09-07 07:47:02+00:00,"Api operation contains incomplete URL in the description:
	


API for extended FHIR operations https://www

Docs: https://camel.apache.org/components/3.14.x/fhir-component.html#_api_parameters_13_apis


[PROPOSITION] Each API method contains method signatures. They are shown as one long string which is not readable very well. I.E.
	


org.hl7.fhir.instance.model.api.IBaseResource resourceByUrl(Class<org.hl7.fhir.instance.model.api.IBaseResource> resource, org.hl7.fhir.instance.model.api.IIdType iUrl, String ifVersionMatches, Boolean returnNull, org.hl7.fhir.instance.model.api.IBaseResource returnResource, Boolean throwError, java.util.Map<org.apache.camel.component.fhir.api.ExtraParameters, Object> extraParameters); 

Would be much more readable if each parameter would be on separate line:






org.hl7.fhir.instance.model.api.IBaseResource resourceByUrl(Class<org.hl7.fhir.instance.model.api.IBaseResource> resource,
org.hl7.fhir.instance.model.api.IIdType iUrl,
String ifVersionMatches,
Boolean returnNull,
org.hl7.fhir.instance.model.api.IBaseResource returnResource,
Boolean throwError, java.util.Map<org.apache.camel.component.fhir.api.ExtraParameters, Object> extraParameters); 



APIs read, update, validate - their methods are missing descriptions at all
	
i.e.: https://camel.apache.org/components/3.14.x/fhir-component.html#_api_validate


All API operation's methods - Alias column is always empty --> could be erased from tables.
	
i.e. method resource and its table:
		
https://camel.apache.org/components/3.14.x/fhir-component.html#_api_validate","davsclaus:1662188199:2022-09-03T14:56:39.860+0000:1662188199:2022-09-03T14:56:39.860+0000:We scrape the docs from javadoc / source code and if fhir does not provide any then there is nothing to show
davsclaus:1662508019:2022-09-07T07:46:59.751+0000:1662508019:2022-09-07T07:46:59.751+0000:I created a ticket about the website updates
I have added the missing docs"
0,CAMEL-18239,Task,Minor,3.14.0,"3.18.3, 3.19.0","
None
",Resolved,Fixed,"3.18.3, 3.19.0",Unassigned,Mario Majernik,0,1,2022-06-28 14:34:34+00:00,2022-09-05 18:18:46+00:00,"Docs: https://camel.apache.org/components/3.14.x/bean-component.html#_using


Missing java code example after: 




You can use the createProxy() methods on ProxyHelper to create a proxy that will generate exchanges and send them to any endpoint:



Similar next chapter in docs: https://camel.apache.org/components/3.14.x/bean-component.html#_bean_as_endpoint


Missing code examples after the first and third sentence:





In the route below:







The source for the bean is just a plain POJO:",
0,CAMEL-18238,Improvement,Minor,None,4.x,"
None
",Open,Unresolved,4.x,Claus Ibsen,Claus Ibsen,0,1,2022-06-28 10:56:41+00:00,2023-09-23 11:40:43+00:00,"With CAMEL-18171 then when using configmap or secret then we should capture these names so we know what are in use.


This can aid for deployment which allows us to generate manifest files that refer to the used cm/secrets so k8s can mount these automatic.",
0,CAMEL-18237,Improvement,Minor,None,3.18.0,"
None
",Resolved,Fixed,3.18.0,Claus Ibsen,Claus Ibsen,0,1,2022-06-28 08:59:46+00:00,2022-09-12 08:56:05+00:00,A helper method that can report how long since an time occurred as you see in Kubernetes Age columns.,
0,CAMEL-18236,Bug,Minor,3.15.0,None,"
None
",Resolved,Information Provided,None,Unassigned,Vincent,0,3,2022-06-28 07:05:01+00:00,2022-09-03 14:54:58+00:00,"Hi,


 


I have a strange comportement with camel and beans containing properties. 


 


I have a route ""SimpleRoute"" in which a configurable processor is injected ""FakeProcessor"" :


 


 




@Named
public class SimpleRoute extends RouteBuilder {

    private final FakeProcessor fakeProcessor;    

    @Inject
    public SimpleRoute(FakeProcessor fakeProcessor) {
        this.fakeProcessor = fakeProcessor;
    }    

    @Override
    public void configure() throws Exception {
        from(""direct:input"")
            .process(fakeProcessor)
            .log(""Input processed"");
    }
}



 




@Named(""fakeProcessor"")
@Singleton
public class FakeProcessor implements Processor {
    private String property;    

    @Inject
    public FakeProcessor(@ConfigProperty(""${configuration.path}"") String property) {
        this.property = property;
    }

    @Override
    public void process(Exchange exchange) throws Exception {    } 
}





@Named(""fakeProcessor2"")
@Singleton public class FakeProcessor2 implements Processor {
     private String property; 
   
     @Inject     
     public FakeProcessor2(@ConfigProperty(""${configuration.path}"") String property) {         this.property = property;     }
    
     @Override     
     public void process(Exchange exchange) throws Exception {    } 
}




The property ""${configuration.path}"" is interpreted in bean FakeProcessor2 but not in bean FakeProcessor (which is injected to my route).


 


Here is the blueprint file :


 




<?xml version=""1.0"" encoding=""UTF-8""?>
<blueprint xmlns=""http://www.osgi.org/xmlns/blueprint/v1.0.0""
           xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance""
           xmlns:camel=""http://camel.apache.org/schema/blueprint""
           xmlns:cm=""http://aries.apache.org/blueprint/xmlns/blueprint-cm/v1.1.0""            xsi:schemaLocation=""
             http://www.osgi.org/xmlns/blueprint/v1.0.0 https://www.osgi.org/xmlns/blueprint/v1.0.0/blueprint.xsd"">    

<cm:property-placeholder id=""voo.esb.services.contactoccurence.sendemail"" persistent-id=""voo.esb.services.contactoccurence.sendemail"">
        <cm:default-properties>
            <cm:property name=""camel.context.trace"" value=""false""/>
            <cm:property name=""consumer.name"" value=""ContactOccurenceSendEmail""/>
            <cm:property name=""configuration.path"" value=""${karaf.base}/etc/voo.esb.services.contactoccurence.sendemail.yml""/>
        </cm:default-properties>
    </cm:property-placeholder>

<camel:camelContext id=""contactoccurenceSendEmailCamelContext"" trace=""{{camel.context.trace}}"" autoStartup=""true"">
        <camel:propertyPlaceholder id=""propertyPlaceholder"" location=""blueprint:voo.esb.services.contactoccurence.sendemail""/>->
        <camel:routeBuilder ref=""simpleRoute""/>
    </camel:camelContext>  
   
    <bean id=""fakeProcessor"" class=""be.voo.esb.services.contactoccurence.sendemail.processor.FakeProcessor"">
        <argument value=""${configuration.path}""/>
    </bean>

    <bean id=""fakeProcessor2"" class=""be.voo.esb.services.contactoccurence.sendemail.processor.FakeProcessor2"">
        <argument value=""${configuration.path}""/>
    </bean> 

    <bean id=""simpleRoute"" class=""be.voo.esb.services.contactoccurence.sendemail.SimpleRoute"" scope=""prototype"">
        <argument ref=""fakeProcessor""/>
    </bean>
</blueprint> 



 


Do you have any ideas? 


 


Thank you for your help!","davsclaus:1656371538:2022-06-28T07:12:18.171+0000:1656371538:2022-06-28T07:12:18.171+0000:Are you mixing OSGi blueprint with CDI ?
v.broucke:1656375907:2022-06-28T08:25:07.364+0000:1656375907:2022-06-28T08:25:07.364+0000:Hi Claus Ibsen,

 

The project runs into a Karaf 4.3.6. I don't if it answers to your question?

 

 
davsclaus:1656376150:2022-06-28T08:29:10.428+0000:1656376150:2022-06-28T08:29:10.428+0000:It does not as it looks like the unit test code uses CDI annotation such as @Named and @Singleton 
v.broucke:1656376316:2022-06-28T08:31:56.067+0000:1656376351:2022-06-28T08:32:31.521+0000:These annotation are used by the maven blueprint plugin which generates the blueprint file shown above.

 

I run this simple project whith camel 3.16 and 3.17 and the problem still occurs.
davsclaus:1656378276:2022-06-28T09:04:36.401+0000:1656378276:2022-06-28T09:04:36.401+0000:Well its not a camel issue per see but a karaf / blueprint issue. Can you reach out to their community to ask for help.
v.broucke:1656378480:2022-06-28T09:08:00.187+0000:1656378487:2022-06-28T09:08:07.939+0000:The problem also occurs with CamelBlueprintTestSupport
v.broucke:1656474438:2022-06-29T11:47:18.422+0000:1656474438:2022-06-29T11:47:18.422+0000:I found a workaround : if cm:property-placeholder is declared before camel:camelContext, it works. I don't know if is it possible that camelContext wait the cm:property-placeholder is created before it instantiate himself?
davsclaus:1656544993:2022-06-30T07:23:13.774+0000:1656544993:2022-06-30T07:23:13.774+0000:If cm:property-placeholder have a ""depends-on"" attribute you can set that to link to the <camelContext> by the id name
v.broucke:1656560888:2022-06-30T11:48:08.856+0000:1656560888:2022-06-30T11:48:08.856+0000:I tried your solution but it doesn't work... It seems that camelContext doesn't take into account the ""depends-on"" attribute.

 

It works if I put the camelContext and the cm:property-placeholder in the same file and if cm:property-placeholder is declared first, like this :

 

 
{code:java}
<?xml version=""1.0"" encoding=""UTF-8""?>
<blueprint xmlns=""http://www.osgi.org/xmlns/blueprint/v1.0.0""
           xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance""
           xmlns:camel=""http://camel.apache.org/schema/blueprint""
           xmlns:cm=""http://aries.apache.org/blueprint/xmlns/blueprint-cm/v1.0.0""
           xsi:schemaLocation=""
             http://www.osgi.org/xmlns/blueprint/v1.0.0 https://www.osgi.org/xmlns/blueprint/v1.0.0/blueprint.xsd"">    
    <cm:property-placeholder id=""voo.esb.services.poc.camelproperty"" persistent-id=""voo.esb.services.poc.camelproperty"">
        <cm:default-properties>
            <cm:property name=""camel.context.trace"" value=""false""/>
            <cm:property name=""configuration.path"" value=""${karaf.base}/etc/voo.esb.services.contactoccurence.sendemail.yml""/>
        </cm:default-properties>
    </cm:property-placeholder>
    
    <camel:camelContext id=""camelPropertyPocCamelContext"" trace=""{{camel.context.trace}}"" autoStartup=""true"">
        <camel:routeBuilder ref=""simpleRoute""/>
    </camel:camelContext>
</blueprint> {code}
 

 

But in my case, I have two files, blueprint.xml and environment.xml like this :

 

+blueprint.xml+

 
{code:java}
<?xml version=""1.0"" encoding=""UTF-8""?>
<blueprint xmlns=""http://www.osgi.org/xmlns/blueprint/v1.0.0""
           xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance""
           xmlns:camel=""http://camel.apache.org/schema/blueprint""
           xsi:schemaLocation=""
             http://www.osgi.org/xmlns/blueprint/v1.0.0 https://www.osgi.org/xmlns/blueprint/v1.0.0/blueprint.xsd"">    
    
    <camel:camelContext id=""camelPropertyPocCamelContext"" trace=""{{camel.context.trace}}"" autoStartup=""true"">
        <camel:routeBuilder ref=""simpleRoute""/>
    </camel:camelContext>

</blueprint>{code}
 

 

+environment.xml+

 
{code:java}
<?xml version=""1.0"" encoding=""UTF-8""?>
<blueprint xmlns=""http://www.osgi.org/xmlns/blueprint/v1.0.0""            
          xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance""            
          xmlns:camel=""http://camel.apache.org/schema/blueprint""                  
          xsi:schemaLocation=""
            http://www.osgi.org/xmlns/blueprint/v1.0.0 https://www.osgi.org/xmlns/blueprint/v1.0.0/blueprint.xsd"">  

    <cm:property-placeholder id=""voo.esb.services.poc.camelproperty"" persistent-id=""voo.esb.services.poc.camelproperty"">
        <cm:default-properties>             
            <cm:property name=""camel.context.trace"" value=""false""/>             
            <cm:property name=""configuration.path"" value=""${karaf.base}/etc/voo.esb.services.contactoccurence.sendemail.yml""/>         
        </cm:default-properties>     
    </cm:property-placeholder>

</blueprint> {code}
That allows me to have a different environment.xml file with differents properties for my UnitTests.

 

 
davsclaus:1658968419:2022-07-28T08:33:39.816+0000:1658968419:2022-07-28T08:33:39.816+0000:You should ask on OSGi blueprint how that works when you split into multiple files as you need a way to make blueprint read environment.xml first. 
Not sure what rule they have or if you rename the file so it starts with A in case its loaded sorted etc."
0,CAMEL-18235,Improvement,Minor,None,4.x,"
None
",Open,Unresolved,4.x,Unassigned,Claus Ibsen,0,1,2022-06-28 04:20:01+00:00,2023-08-09 09:07:47+00:00,"some of the other components in camel-google or camel-minio seems to have it as true, but s3 is false.


Noticed this in this PR
https://github.com/apache/camel/pull/7901",
0,CAMEL-18234,Bug,Minor,3.17.0,"3.20.7, 3.21.1, 3.22.0, 4.0.0","
None
",Resolved,Fixed,"3.20.7, 3.21.1, 3.22.0, 4.0.0",Claus Ibsen,Dylan Piergies,0,2,2022-06-27 21:38:01+00:00,2023-07-27 07:15:06+00:00,"An aws2-sqs route fails to configure in Camel/Spring Boot when the camel.component.aws2-sqs.trust-all-certificates Spring property is set to true and a proxy is configured.


Consider route:


@Component
public class SqsRoute extends EndpointRouteBuilder {
  @Override
  public void configure() throws Exception {
    from(aws2Sqs(""srcQueue""))
      .to(aws2Sqs(""dstQueue""));
{{  }}}
}


And in application.yml:


camel:
  component:
    aws2-sqs:
      use-default-credentials-provider: true
      proxy-protocol: http
      proxy-host: localhost
      proxy-port: 8118
      trust-all-certificates: true
  springboot:
    main-run-controller: true


Exception is thrown:


org.apache.camel.FailedToCreateRouteException: Failed to create route route1: Route(route1)[From[aws2-sqs://srcQueue] -> [To[aws2-sqs://ds... because of Failed to resolve endpoint: aws2-sqs://srcQueue due to: The httpClient and the httpClientBuilder can't both be configured.
    at org.apache.camel.reifier.RouteReifier.createRoute(RouteReifier.java:80) ~[camel-core-reifier-3.16.0.jar:3.16.0]
    at org.apache.camel.impl.DefaultModelReifierFactory.createRoute(DefaultModelReifierFactory.java:49) ~[camel-core-engine-3.16.0.jar:3.16.0]
    at org.apache.camel.impl.DefaultCamelContext.startRouteDefinitions(DefaultCamelContext.java:887) ~[camel-core-engine-3.16.0.jar:3.16.0]
    at org.apache.camel.impl.DefaultCamelContext.startRouteDefinitions(DefaultCamelContext.java:775) ~[camel-core-engine-3.16.0.jar:3.16.0]
    at org.apache.camel.impl.engine.AbstractCamelContext.doInit(AbstractCamelContext.java:2937) ~[camel-base-engine-3.16.0.jar:3.16.0]
    at org.apache.camel.support.service.BaseService.init(BaseService.java:83) ~[camel-api-3.16.0.jar:3.16.0]
    at org.apache.camel.impl.engine.AbstractCamelContext.init(AbstractCamelContext.java:2620) ~[camel-base-engine-3.16.0.jar:3.16.0]
    at org.apache.camel.support.service.BaseService.start(BaseService.java:111) ~[camel-api-3.16.0.jar:3.16.0]
    at org.apache.camel.impl.engine.AbstractCamelContext.start(AbstractCamelContext.java:2639) ~[camel-base-engine-3.16.0.jar:3.16.0]
    at org.apache.camel.impl.DefaultCamelContext.start(DefaultCamelContext.java:255) ~[camel-core-engine-3.16.0.jar:3.16.0]
    at org.apache.camel.spring.SpringCamelContext.start(SpringCamelContext.java:119) ~[camel-spring-3.16.0.jar:3.16.0]
    at org.apache.camel.spring.SpringCamelContext.onApplicationEvent(SpringCamelContext.java:151) ~[camel-spring-3.16.0.jar:3.16.0]
    at org.springframework.context.event.SimpleApplicationEventMulticaster.doInvokeListener(SimpleApplicationEventMulticaster.java:176) ~[spring-context-5.3.19.jar:5.3.19]
    at org.springframework.context.event.SimpleApplicationEventMulticaster.invokeListener(SimpleApplicationEventMulticaster.java:169) ~[spring-context-5.3.19.jar:5.3.19]
    at org.springframework.context.event.SimpleApplicationEventMulticaster.multicastEvent(SimpleApplicationEventMulticaster.java:143) ~[spring-context-5.3.19.jar:5.3.19]
    at org.springframework.context.support.AbstractApplicationContext.publishEvent(AbstractApplicationContext.java:421) ~[spring-context-5.3.19.jar:5.3.19]
    at org.springframework.context.support.AbstractApplicationContext.publishEvent(AbstractApplicationContext.java:378) ~[spring-context-5.3.19.jar:5.3.19]
    at org.springframework.context.support.AbstractApplicationContext.finishRefresh(AbstractApplicationContext.java:938) ~[spring-context-5.3.19.jar:5.3.19]
    at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:586) ~[spring-context-5.3.19.jar:5.3.19]
    at org.springframework.boot.SpringApplication.refresh(SpringApplication.java:740) ~[spring-boot-2.6.7.jar:2.6.7]
    at org.springframework.boot.SpringApplication.refreshContext(SpringApplication.java:415) ~[spring-boot-2.6.7.jar:2.6.7]
    at org.springframework.boot.SpringApplication.run(SpringApplication.java:303) ~[spring-boot-2.6.7.jar:2.6.7]
    at org.springframework.boot.SpringApplication.run(SpringApplication.java:1312) ~[spring-boot-2.6.7.jar:2.6.7]
    at org.springframework.boot.SpringApplication.run(SpringApplication.java:1301) ~[spring-boot-2.6.7.jar:2.6.7]
    at org.dylanpiergies.camel.CamelApplication.main(CamelApplication.java:9) ~[main/:na]
Caused by: org.apache.camel.ResolveEndpointFailedException: Failed to resolve endpoint: aws2-sqs://srcQueue due to: The httpClient and the httpClientBuilder can't both be configured.
    at org.apache.camel.impl.engine.AbstractCamelContext.doGetEndpoint(AbstractCamelContext.java:982) ~[camel-base-engine-3.16.0.jar:3.16.0]
    at org.apache.camel.impl.engine.AbstractCamelContext.getEndpoint(AbstractCamelContext.java:893) ~[camel-base-engine-3.16.0.jar:3.16.0]
    at org.apache.camel.builder.endpoint.AbstractEndpointBuilder.resolve(AbstractEndpointBuilder.java:66) ~[camel-endpointdsl-3.16.0.jar:3.16.0]
    at org.apache.camel.reifier.RouteReifier.doCreateRoute(RouteReifier.java:92) ~[camel-core-reifier-3.16.0.jar:3.16.0]
    at org.apache.camel.reifier.RouteReifier.createRoute(RouteReifier.java:74) ~[camel-core-reifier-3.16.0.jar:3.16.0]
    ... 24 common frames omitted
Caused by: java.lang.IllegalArgumentException: The httpClient and the httpClientBuilder can't both be configured.
    at software.amazon.awssdk.utils.Validate.isTrue(Validate.java:76) ~[utils-2.17.152.jar:na]
    at software.amazon.awssdk.core.client.builder.SdkDefaultClientBuilder.resolveSyncHttpClient(SdkDefaultClientBuilder.java:322) ~[sdk-core-2.17.152.jar:na]
    at software.amazon.awssdk.core.client.builder.SdkDefaultClientBuilder.finalizeSyncConfiguration(SdkDefaultClientBuilder.java:277) ~[sdk-core-2.17.152.jar:na]
    at software.amazon.awssdk.core.client.builder.SdkDefaultClientBuilder.syncClientConfiguration(SdkDefaultClientBuilder.java:173) ~[sdk-core-2.17.152.jar:na]
    at software.amazon.awssdk.services.sqs.DefaultSqsClientBuilder.buildClient(DefaultSqsClientBuilder.java:27) ~[sqs-2.17.152.jar:na]
    at software.amazon.awssdk.services.sqs.DefaultSqsClientBuilder.buildClient(DefaultSqsClientBuilder.java:22) ~[sqs-2.17.152.jar:na]
    at software.amazon.awssdk.core.client.builder.SdkDefaultClientBuilder.build(SdkDefaultClientBuilder.java:140) ~[sdk-core-2.17.152.jar:na]
    at org.apache.camel.component.aws2.sqs.client.impl.Sqs2ClientIAMOptimized.getSQSClient(Sqs2ClientIAMOptimized.java:86) ~[camel-aws2-sqs-3.16.0.jar:3.16.0]
    at org.apache.camel.component.aws2.sqs.Sqs2Endpoint.doInit(Sqs2Endpoint.java:145) ~[camel-aws2-sqs-3.16.0.jar:3.16.0]
    at org.apache.camel.support.service.BaseService.init(BaseService.java:83) ~[camel-api-3.16.0.jar:3.16.0]
    at org.apache.camel.support.service.ServiceHelper.initService(ServiceHelper.java:84) ~[camel-api-3.16.0.jar:3.16.0]
    at org.apache.camel.impl.engine.AbstractCamelContext.internalAddService(AbstractCamelContext.java:1544) ~[camel-base-engine-3.16.0.jar:3.16.0]
    at org.apache.camel.impl.engine.AbstractCamelContext.addService(AbstractCamelContext.java:1489) ~[camel-base-engine-3.16.0.jar:3.16.0]
    at org.apache.camel.impl.engine.AbstractCamelContext.addService(AbstractCamelContext.java:1484) ~[camel-base-engine-3.16.0.jar:3.16.0]
    at org.apache.camel.impl.engine.AbstractCamelContext.addService(AbstractCamelContext.java:1479) ~[camel-base-engine-3.16.0.jar:3.16.0]
    at org.apache.camel.impl.engine.AbstractCamelContext.doGetEndpoint(AbstractCamelContext.java:966) ~[camel-base-engine-3.16.0.jar:3.16.0]
    ... 28 common frames omitted","davsclaus:1690319374:2023-07-26T05:09:34.745+0000:1690319374:2023-07-26T05:09:34.745+0000:Can you try with newer version?
dlp:1690343954:2023-07-26T11:59:14.623+0000:1690343954:2023-07-26T11:59:14.623+0000:Can confirm that the issue still exists in Camel 3.20.6, 3.21.0 and the current 4.0.0-SNAPSHOT.
davsclaus:1690344921:2023-07-26T12:15:21.957+0000:1690344921:2023-07-26T12:15:21.957+0000:Okay I think I have a fix and now I see

2023-07-26 14:14:56.021  WARN 68064 --- [           main] awssdk.http.apache.ApacheHttpClient : SSL Certificate verification is disabled. This is not a safe setting and should only be used for testing.
dlp:1690345191:2023-07-26T12:19:51.293+0000:1690345191:2023-07-26T12:19:51.293+0000:This sounds correct, assuming you have a proxy configured as well. The issue only occurred with this combination of configuration settings.
davsclaus:1690345298:2023-07-26T12:21:38.102+0000:1690345298:2023-07-26T12:21:38.102+0000:Okay it looks its the same problem in some of the other aws components.

This kind of fix needs for the others as well
https://github.com/apache/camel/pull/10837
davsclaus:1690350307:2023-07-26T13:45:07.309+0000:1690350307:2023-07-26T13:45:07.309+0000:OK PR now has updated all components"
0,CAMEL-18233,Improvement,Minor,3.17.0,3.18.0,"
None
",Resolved,Fixed,3.18.0,James Netherton,James Netherton,0,1,2022-06-27 10:21:16+00:00,2022-06-27 12:55:24+00:00,"The change I made to CamelMicroProfilePropertiesSource in https://issues.apache.org/jira/browse/CAMEL-17996 causes some issues in Camel Quarkus where config profiles are in use. See https://github.com/apache/camel-quarkus/issues/3879.


We likely need to catch the NoSuchElementException coming from SmallRye Config so that the properties that are resolvable can be picked up.",
0,CAMEL-18232,Bug,Minor,3.15.0,3.18.0,"
None
",Resolved,Fixed,3.18.0,Claus Ibsen,Claus Ibsen,0,1,2022-06-27 07:58:13+00:00,2022-07-29 07:44:53+00:00,"On some JDK11 then it may be that the string replace does not seem to work as StringHelper.replaceAll we used in the past, that was removed in this commit
https://github.com/apache/camel/commit/8d900aba707710e60de40f4d5b60c2c2ddc270b3


Then you can see this kind of errors




│ 2022-06-27 07:56:40.833  INFO 1 --- [           main] e.camel.impl.engine.AbstractCamelContext : Apache Camel 3.18.0-SNAPSHOT (camel-1) shutdown in 111ms (uptime:282ms JVM-uptime:6s428ms)        │
│ Exception in thread ""main"" java.lang.IllegalArgumentException: Pattern is invalid: Camel (camel-1) thread ##counter# - #name# in resolved thread name: Camel (camel-1) thread ##counter# - timer:/ │
│     at org.apache.camel.util.concurrent.ThreadHelper.resolveThreadName(ThreadHelper.java:65)                                                                                                       │
│     at org.apache.camel.impl.engine.BaseExecutorServiceManager.resolveThreadName(BaseExecutorServiceManager.java:159)                                                                              │
│     at org.apache.camel.component.timer.TimerComponent.getTimer(TimerComponent.java:57)                                                                                                            │
│     at org.apache.camel.component.timer.TimerEndpoint.getTimer(TimerEndpoint.java:247)                                                                                                             │
│     at org.apache.camel.component.timer.TimerConsumer.onCamelContextStarted(TimerConsumer.java:149)                                                                                                │
│     at org.apache.camel.impl.engine.InternalRouteStartupManager.safelyStartRouteServices(InternalRouteStartupManager.java:223)                                                                     │
│     at org.apache.camel.impl.engine.InternalRouteStartupManager.doStartOrResumeRoutes(InternalRouteStartupManager.java:147)                                                                        │
│     at org.apache.camel.impl.engine.AbstractCamelContext.doStartCamel(AbstractCamelContext.java:3361)                                                                                              │
│     at org.apache.camel.impl.engine.AbstractCamelContext.doStartContext(AbstractCamelContext.java:3032)                                                                                            │
│     at org.apache.camel.impl.engine.AbstractCamelContext.doStart(AbstractCamelContext.java:2987)                                                                                                   │
│     at org.apache.camel.support.service.BaseService.start(BaseService.java:119)                                                                                                                    │
│     at org.apache.camel.impl.engine.AbstractCamelContext.start(AbstractCamelContext.java:2648)                                                                                                     │
│     at org.apache.camel.impl.DefaultCamelContext.start(DefaultCamelContext.java:262)                                                                                                               │
│     at org.apache.camel.main.Main.doStart(Main.java:139)                                                                                                                                           │
│     at org.apache.camel.support.service.BaseService.start(BaseService.java:119)                                                                                                                    │
│     at org.apache.camel.main.MainSupport.run(MainSupport.java:89)                                                                                                                                  │
│     at org.apache.camel.main.MainCommandLineSupport.run(MainCommandLineSupport.java:221)                                                                                                           │
│     at com.foo.acme.CamelApplication.main(CamelApplication.java:9)","davsclaus:1656288680:2022-06-27T08:11:20.659+0000:1656288680:2022-06-27T08:11:20.659+0000: java.specification.name=Java Platform API Specification, java.vm.specification.vendor=Oracle Corporation, java.awt.graphicsenv=sun.awt.X11GraphicsEnvironment, sun.management.compiler=HotSpot 64-Bit Tiered Compilers, java.runtime.version=11.0.15+10, user.name=root, path.separator=:, os.version=5.10.47-linuxkit, java.runtime.name=OpenJDK Runtime Environment, file.encoding=UTF-8, java.vm.name=OpenJDK 64-Bit Server VM, java.vendor.version=Temurin-11.0.15+10, java.vendor.url.bug=https://github.com/adoptium/adoptium-support/issues, java.io.tmpdir=/tmp, java.version=11.0.15, user.dir=/, os.arch=amd64, java.vm.specification.name=Java Virtual Machine Specification, java.awt.printerjob=sun.print.PSPrinterJob, sun.os.patch.level=unknown, java.library.path=/usr/java/packages/lib:/usr/lib64:/lib64:/lib:/usr/lib, java.vm.info=mixed mode, java.vendor=Eclipse Adoptium, java.vm.version=11.0.15+10, sun.io.unicode.encoding=UnicodeLittle, java.class.version=55.0}
davsclaus:1656301670:2022-06-27T11:47:50.405+0000:1656301670:2022-06-27T11:47:50.405+0000:Ah it may be that the runtime (amd64) is on different OS arch than the build (arm64)
davsclaus:1656302146:2022-06-27T11:55:46.633+0000:1656302146:2022-06-27T11:55:46.633+0000:Yes it was using jib to build then you can define the os arch for M1
{code}
            <plugin>
                <groupId>com.google.cloud.tools</groupId>
                <artifactId>jib-maven-plugin</artifactId>
                <version>3.2.1</version>
                <configuration>
                    <to>
                        <image>com.foo/acme</image>
                    </to>
                    <from>
                        <platforms>
                            <platform>
                                <architecture>arm64</architecture>
                                <os>linux</os>
                            </platform>
                        </platforms>
                    </from>
                </configuration>
            </plugin>
{code}

davsclaus:1656321370:2022-06-27T17:16:10.409+0000:1656321370:2022-06-27T17:16:10.409+0000:Since it was a OS arch problem we could consider going back but keep a few improvements. However the committed code now works in both situations which make Camel work better overall ;)
davsclaus:1656371393:2022-06-28T07:09:53.355+0000:1656371393:2022-06-28T07:09:53.355+0000:Okay we are back to as before but are using replaceFirst that is fast."
0,CAMEL-18231,Dependency upgrade,Minor,None,3.18.0,"
None
",Resolved,Fixed,3.18.0,James Netherton,James Netherton,0,1,2022-06-27 06:55:59+00:00,2022-06-27 17:16:41+00:00,"Quarkus has moved on to Vert.x 4.3.1. To make Camel Quarkus upgrade to Camel 3.18.x  in a smooth way, we should upgrade Camel to also use 4.3.x.",
0,CAMEL-18230,Improvement,Minor,None,None,"

refactor

",Resolved,Invalid,None,Unassigned,Alvin Tan Jian Jia,0,2,2022-06-26 20:24:47+00:00,2022-06-27 04:33:43+00:00,"Summary


I have identified a few classes with refactoring potential, specifically error handlers . The issue was refactored once on Nov 12, 2020 along with other classes in commit d1be1a6bbc11d87d19a52ffcda25f0187a4b4055. Given the duration of the last refactoring, could it be possible to improve the overall package of error handlers further? I am probably not qualified and experienced enough to point out the exact code needs to be refactored, given my limited knowledge of the project and codebase.


Urgency


Low priority. For maintenance of code in the long run.


Hi,


I am currently doing some research on Estimating Time Taken for Software Refactoring. Camel is one of my case studies being a highly popular project. Would appreciate your kind feedback on the appropriateness of the estimated time to refactor.


I am specifically looking at potential for refactoring, such as breaking functions that are too long into shorter functions, or to remove code duplication. Would you agree that there could be some modification to the code to make it better in the listed classes? And if so, is the estimated time appropriate to carry out the improvement? I will be grateful for any help you can provide.



ErrorHandlerRefReifier.java - 2 hours
ErrorHandlerReifier.java - 3 hours
NoErrorHandlerReifier.java - 1 hour
DefaultErrorHandlerReifier.java - 2 hours
DeadLetterChannelReifier.java - 1 hour
ErrorHandlerHelper.java - 2 hours
DefaultErrorHandlerProperties.java - 4 hours



 


The attached csv file contains the other recommendations from my research. Thank you once again for any help you can provide.


 


Regards,


Alvin","rhuanrcoha:1656251351:2022-06-26T21:49:11.762+0000:1656251351:2022-06-26T21:49:11.762+0000:Hi [~tanjianjia@gmail.com] ,

It depends on the changes proposed. 2h for updating a class is very relative. What are the changes? How many dependencies does it have? 

I think the update should be described. Example:  ErrorHandlerRefReifier.java - 2 hours - What are the changes here? The time depends on that. Another thing for me is, time for updates is not a good metric. It depends on many things.
tanjianjia@gmail.com:1656252710:2022-06-26T22:11:50.695+0000:1656252710:2022-06-26T22:11:50.695+0000:Hi [~rhuanrcoha],

Thank you so much for your inputs! I totally agree with the pain points that you have just raised. I am trying to obtain developer feedback on whether my research is accurate in 
 # Pointing out areas that require refactoring.
 # Estimating the time required for refactoring.

 

+What are the changes?+

I do not think that I am qualified enough to propose changes given my limited experience to the code base. I am hoping to work with someone experienced on the project. For the listed classes, if you feel that there could be refactoring carried out to improve the classes, I hope to track the time required for you to carry out the refactoring activity.

 

+Estimated Time+

The estimated time here is given by a model trained on all of the previous refactoring activities on Camel, taking into account the refactored class dependencies, line of code involved, number of methods involved, complexity of code etc. It is a rough estimate here estimating the time required for refactoring.

For example, in the past commit 4b2c7bf93c94461133dd4a58122a25a9b90f48a4, refactoring is carried out that involved 29 dependencies involving 4 classes and 10 total refactored lines.

 

The specifics of the research can be found at [https://github.com/alvintanjianjia/SoftwareRemodularization.] Please let me know if you require more details, or are there any areas that I can help to make this process easier.

 

Thank you.

Regards,

Alvin

 "
0,CAMEL-18229,Improvement,Major,None,3.18.0,"
None
",Resolved,Fixed,3.18.0,Claus Ibsen,Claus Ibsen,0,1,2022-06-26 12:09:23+00:00,2022-06-26 13:10:54+00:00,Today we can do setter/getter style for generated configures. But when you want to generate for 3rd party class that is build style (withXXX) then it would be good to support this.,
0,CAMEL-18228,Improvement,Major,None,3.18.0,"
None
",Resolved,Fixed,3.18.0,Claus Ibsen,Claus Ibsen,0,1,2022-06-24 18:59:40+00:00,2022-06-26 07:39:22+00:00,"When a build returns an interface instead of the class itself, then we need to check for that as we dont support this (eg fabric8 kubernetes client)


        if (allowBuilderPattern && parameterCount == 1 && method.getDeclaringClass().isAssignableFrom(type)) {


when type is an interface we need to check something else",
0,CAMEL-18227,Bug,Major,3.17.0,,"
None
",Closed,Not A Problem,None,Jeremy Ross,Jeremy Ross,0,1,2022-06-24 15:18:40+00:00,2022-06-24 17:12:36+00:00,No Desc,"jeremyross:1656061956:2022-06-24T17:12:36.433+0000:1656061956:2022-06-24T17:12:36.433+0000:On second look, streams are being closed."
0,CAMEL-18226,Improvement,Major,None,3.18.0,"
None
",Resolved,Fixed,3.18.0,Claus Ibsen,Claus Ibsen,0,1,2022-06-24 06:57:58+00:00,2023-03-26 07:38:18+00:00,"Reported on chat
https://camel.zulipchat.com/#narrow/stream/257298-camel/topic/Inputstream.2FCloseables/near/285607751",
0,CAMEL-18225,Bug,Minor,3.14.3,None,"
None
",Resolved,Not A Bug,None,Unassigned,Raymond,0,2,2022-06-24 06:16:31+00:00,2022-06-24 12:26:24+00:00,"I created a custom dataformat and call it with the XML-IO DSL like this:


    <unmarshal>
      <custom ref=""myCustomDataformat""/>
    </unmarshal>


I get the following error:


org.apache.camel.xml.io.XmlPullParserException: Unexpected element '{}custom'


According to the XSD I would expect the custom element to be available


https://camel.apache.org/schema/spring/camel-spring-3.14.3.xsd


Also in Camel in Action2 (page 340) there is an example of this.


 


I load the XML with the ""xml-io"" library and ""dataformat"" is also on the classpath.


On the documentation page:


https://camel.apache.org/components/3.14.x/dataformats/index.html


The 'custom' dataformat isn't listed however and there is no documentation of it. Is it still supported?


Complete stacktrace:


org.apache.camel.xml.io.XmlPullParserException: Unexpected element '{}custom'
        at org.apache.camel.xml.in.BaseParser.handleUnexpectedElement(BaseParser.java:187)
        at org.apache.camel.xml.in.BaseParser.doParse(BaseParser.java:107)
        at org.apache.camel.xml.in.ModelParser.doParseUnmarshalDefinition(ModelParser.java:1449)
        at org.apache.camel.xml.in.ModelParser.doParseProcessorDefinitionRef(ModelParser.java:3212)
        at org.apache.camel.xml.in.ModelParser.lambda$outputDefinitionElementHandler$4(ModelParser.java:132)
        at org.apache.camel.xml.in.ModelParser.lambda$doParseRouteDefinition$71(ModelParser.java:1031)
        at org.apache.camel.xml.in.BaseParser.doParse(BaseParser.java:106)
        at org.apache.camel.xml.in.ModelParser.doParseRouteDefinition(ModelParser.java:1005)
        at org.apache.camel.xml.in.ModelParser.parseSingleRoutesDefinition(ModelParser.java:1185)
        at org.apache.camel.xml.in.ModelParser.parseRoutesDefinition(ModelParser.java:1178)
        at org.apache.camel.dsl.xml.io.XmlRoutesBuilderLoader$1.configure(XmlRoutesBuilderLoader.java:78)
        at org.apache.camel.builder.RouteBuilder.checkInitialized(RouteBuilder.java:607)
        at org.apache.camel.builder.RouteBuilder.configureRoutes(RouteBuilder.java:553)
        at org.apache.camel.builder.RouteBuilder.updateRoutesToCamelContext(RouteBuilder.java:515)
        at org.apache.camel.spi.RoutesLoader.updateRoutes(RoutesLoader.java:105)
        at org.apache.camel.spi.RoutesLoader.updateRoutes(RoutesLoader.java:87)","davsclaus:1656023755:2022-06-24T06:35:55.913+0000:1656023755:2022-06-24T06:35:55.913+0000:Can you try with 3.17.0 release, and also put together a reproducer example that is easy for us to run and try.
davsclaus:1656023848:2022-06-24T06:37:28.657+0000:1656024094:2022-06-24T06:41:34.245+0000:Ah its named customDataFormat in 3.14.x (it may be that the xml-io parser uses that name).

Camel 3.15 onwards the data formats names have been aligned and renamed, see the upgrade guide:
https://camel.apache.org/manual/camel-3x-upgrade-guide-3_15.html
skin27:1656026758:2022-06-24T07:25:58.747+0000:1656026758:2022-06-24T07:25:58.747+0000:I can confirm that:

    <unmarshal>
      <customDataFormat ref=""myCustomDataFormat""/>
    </unmarshal>

works in 3.14.3.

I actually tried it based on the XSD, but I probably used customDataformat instead of customDataFormat... I also checked the migration guides (until 3.14), but couldn't find anything specific about the ""custom"" --> ""customDataFormat"".

Small question: In Camel 2 one could load dataformats like this:

<camelContext xmlns=""http://camel.apache.org/schema/spring"">
<dataFormats>
<crypto id=""myCrypto"" algorithm=""DES"" keyRef=""secretKey""/>
</dataFormats>
<route>
<from uri=""direct:start""/>
<marshal ref=""myCrypto""/>
<to uri=""mock:encrypted""/>
<unmarshal ref=""myCrypto""/>
<to uri=""mock:unencrypted""/>
</route>
</camelContext>

I know load it like this:

<route>
<from uri=""direct:start""/>
<marshal ref=""myCrypto""/>
<to uri=""mock:encrypted""/>
<unmarshal ref=""myCrypto""/>
<to uri=""mock:unencrypted""/>
</route>

Is it possible to load dataformats centrally from routeConfiguration? or do I need to pack it into

<routes xmlns=""http://camel.apache.org/schema/spring"">
<dataFormats>
<crypto id=""myCrypto"" algorithm=""DES"" keyRef=""secretKey""/>
</dataFormats>
<route>
<from uri=""direct:start""/>
<marshal ref=""myCrypto""/>
<to uri=""mock:encrypted""/>
<unmarshal ref=""myCrypto""/>
<to uri=""mock:unencrypted""/>
</route>
</routes>
davsclaus:1656034962:2022-06-24T09:42:42.713+0000:1656034962:2022-06-24T09:42:42.713+0000:Route configuration can only configure those 4 things listed in the top of the page
https://camel.apache.org/manual/route-configuration.html
skin27:1656041894:2022-06-24T11:38:14.685+0000:1656044784:2022-06-24T12:26:24.062+0000:Yes, I found out. Tried both solutions I came up with in my last post. But they were not working. I got the route in Camel 2 format as input (which I can't control) so I needed to change it from:

<camelContext xmlns=""http://camel.apache.org/schema/spring"">
<dataFormats>
<crypto id=""myCrypto"" algorithm=""DES"" keyRef=""secretKey""/>
</dataFormats>
<route>
<from uri=""direct:start""/>
<marshal ref=""myCrypto""/>
<to uri=""mock:encrypted""/>
<unmarshal ref=""myCrypto""/>
<to uri=""mock:unencrypted""/>
</route>
</camelContext>

to

<route>
<from uri=""direct:start""/>
<marshal ref=""myCrypto""/>
<to uri=""mock:encrypted""/>
<unmarshal>
       <crypto algorithm=""DES"" keyRef=""secretKey""/>
</unmarshal>
<to uri=""mock:unencrypted""/>
</route>

or

<route>
<from uri=""direct:start""/>
<marshal ref=""myCrypto""/>
<to uri=""mock:encrypted""/>
<to uri=""dataformat:crypto:unmarshal?algorithm=DES&keyRef=secretKey/>
</unmarshal>
<to uri=""mock:unencrypted""/>
</route>

This works, but it would be nice to do if by reference and load it centrally from the routeConfiguration also."
0,CAMEL-18224,Improvement,Major,None,3.18.0,"
None
",Resolved,Fixed,3.18.0,Claus Ibsen,Claus Ibsen,0,1,2022-06-24 04:34:31+00:00,2022-06-24 05:29:04+00:00,"If you use configmap:xxx then you need camel-kubernetes on the classpath, we can detect this and auto download it.",
0,CAMEL-18223,New Feature,Major,None,3.18.0,"
None
",Resolved,Fixed,3.18.0,Nicolas Filotto,Nicolas Filotto,0,1,2022-06-23 14:09:40+00:00,2022-06-26 08:02:15+00:00,"The textual route Debugger has several requirements to make it work properly (camel-debug in classpath, JMX enabled, CAMEL_DEBUGGER_SUSPEND set to true...) thus it could be interesting to propose a new maven goal to the camel plugin to set up everything automatically.",nfilotto:1656062545:2022-06-24T17:22:25.705+0000:1656062545:2022-06-24T17:22:25.705+0000:The corresponding PR https://github.com/apache/camel/pull/7877
0,CAMEL-18222,Improvement,Major,None,3.18.0,"
None
",Resolved,Fixed,3.18.0,Claus Ibsen,Claus Ibsen,0,1,2022-06-23 10:26:14+00:00,2022-06-24 13:46:13+00:00,"If there is an existing client such as when running on quarkus or spring-boot that can setup this via their k8s integration.


And we should also make it possible to configure the client options on component level",
0,CAMEL-18221,Improvement,Minor,None,3.18.0,"
None
",Resolved,Fixed,3.18.0,James Netherton,James Netherton,0,1,2022-06-23 10:11:15+00:00,2022-06-23 12:07:27+00:00,"I was playing with camel-rest-openapi and RestProducerFactory on Camel Quarkus to invoke some REST endpoints that I defined in an OpenAPI document.


Seems the component can only handle JSON formatted documents. The default format for Quarkus OpenAPI is YAML, so it'd be nice if the Camel component could handle that.",
0,CAMEL-18189,New Feature,Major,None,4.0.0,"
None
",Resolved,Fixed,4.0.0,Grzegorz Grzybek,Claus Ibsen,0,2,2022-06-13 07:30:01+00:00,2023-08-04 17:17:15+00:00,"We may consider a root tag such as <beans> that are Camel specific and therefore works on all runtimes, where we can have basic support for dependency injection with <bean> and also embed Camel <routes> and <rests> and <routeConfigurations> and <routeTemplates> etc all in the same file.


This can be handy for low-code projects with Camel K / Camel JBang.","davsclaus:1681689785:2023-04-17T08:03:05.165+0000:1681689785:2023-04-17T08:03:05.165+0000:This requires to add <beans> to the camel-core-model, and have it included in all DSLs
- java
- xml io
- yaml
- spring xml (legacy) does not need to support this as it uses spring <bean>

Then a basic dependency injection for end users to just setup some basic bean.

yaml-dsl already have -beans today where you can setup beans


ggrzybek:1681690051:2023-04-17T08:07:31.636+0000:1681690071:2023-04-17T08:07:51.723+0000:Thanks for the reminder :)

New {{beans}} is not a problem - the problem is whether it should match/reflect entire {{org.springframework.beans.factory.config.BeanDefinition}} model or be some kind of least common denominator with only:
* class name
* set of property values (with refs?)
* set of constructor arguments
* parent?
* depends-on?
* factory-method?
* post-construct / pre-destroy?
* scope (prototype / singleton)?
ggrzybek:1682405295:2023-04-25T14:48:15.485+0000:1682407020:2023-04-25T15:17:00.466+0000:bq. yaml-dsl already have -beans today where you can setup beans

{{org.apache.camel.dsl.yaml.deserializers.NamedBeanDefinition}} was indeed added with CAMEL-16584.
But there's also {{org.apache.camel.xml.in.ModelParser#doParseBeanDefinition()}} which deals with {{org.apache.camel.model.BeanDefinition}}

But these look like the good old _beans_ you can use as processors and which are configured in {{org.apache.camel.model.ProcessorDefinition}} (and derived classes)...
I'm not sure how easy it'd be allow top level {{<bean>}} elements. On the other hand it wouldn't be wise to duplicate the beans... Still thinking (you know - i always have to re-learn Camel after getting back to its core after some time...).

EDIT: {{org.apache.camel.model.BeanDefinition}} has already {{@jakarta.xml.bind.annotation.XmlRootElement}} and can be used at top-level. Indeed it should be a matter of top-level {{beans}} and handling it in different DSLs... to be continued.
ggrzybek:1682489101:2023-04-26T14:05:01.896+0000:1682489140:2023-04-26T14:05:40.877+0000:For a tiny moment I was thinking it's a matter of adding {{<beans>}} ({{org.apache.camel.model.BeansDefinition)}} in addition to existing {{<bean>}} ({{org.apache.camel.model.BeanDefinition}}) model.

The point is that {{org.apache.camel.reifier.BeanReifier#createProcessor()}} which uses {{org.apache.camel.model.BeanDefinition}} to create a _bean_ is using it to create a processor delegating to a method of a bean - there's no way to configure properties of the bean created and whatever form is used:
{code:xml}
  <bean xmlns=""http://camel.apache.org/schema/spring"" beanType=""fqcn"" />
{code}
{code:xml}
  <bean xmlns=""http://camel.apache.org/schema/spring"" ref=""ref-to-a-bean"" />
{code}

the bean is created by the registry - using the first form (with classname), the {{@Autowired}} Spring annotation is used and the bean may have the properties injected, however there's no way to declare in XML the properties/constructor arguments.

Existing {{<bean>}} means ""bean processor which calls a bean (from the registry) method"" and it wouldn't be wise to add 2nd meaning: ""bean definition for a bean instance to put into the underlying registry""...

{{org.apache.camel.dsl.yaml.deserializers.BeansDeserializer#construct()}} is actually doing what should be done, but narrowed to yaml DSL - it parses the input (yaml) and adds the created beans (with proper {{properties}} handling - though without constructor args for example) to a registry obtained from {{org.apache.camel.CamelContext#getRegistry()}}... This doesn't help much in general (for XML DSL).

In other words, IMO {{org.apache.camel.model.BeanDefinition}} can't be reused to play two roles:
* bean processor
* bean definition (to populate the registry)

The naming curse is also visible here - for the new {{<bean>}} element:
* the XML element name should be different ({{<bean-definition>}}?)
* the new class in {{org.apache.camel.model}} should rather be called {{BeanDefinitionDefinition}} (:panic\:) and should NOT extend {{org.apache.camel.model.ProcessorDefinition}}

Well, the journey continues.
ggrzybek:1685327159:2023-05-29T10:25:59.122+0000:1685327159:2023-05-29T10:25:59.122+0000:CAMEL-16757 shows me that ""beans"" should be added rather through
{code:java}
org.apache.camel.builder.RouteConfigurationBuilder#configuration()
{code}
than through:
{code:java}
org.apache.camel.builder.RouteBuilder#configure()
{code}

ggrzybek:1686025213:2023-06-06T12:20:13.576+0000:1686025213:2023-06-06T12:20:13.576+0000:PR: https://github.com/apache/camel/pull/10268
ggrzybek:1686107585:2023-06-07T11:13:05.970+0000:1686107585:2023-06-07T11:13:05.970+0000:Final PR with the documentation updates: https://github.com/apache/camel/pull/10283
ggrzybek:1686111008:2023-06-07T12:10:08.767+0000:1686111008:2023-06-07T12:10:08.767+0000:The fixes are present in main branch for Camel 4.0."
0,CAMEL-18188,Improvement,Major,None,3.18.0,"
None
",Resolved,Fixed,3.18.0,Claus Ibsen,Claus Ibsen,1,1,2022-06-13 07:15:44+00:00,2022-06-13 12:22:16+00:00,"It would be better to use directly apache maven to download JARs on demand. It requires to use a more cumbersome API to do this, but it should be more reliable with all the ""difficulties"" that Maven has.",
0,CAMEL-18187,Bug,Major,3.14.3,"3.14.4, 3.18.0","
None
",Resolved,Fixed,"3.14.4, 3.18.0",Claus Ibsen,Luca Burgazzoli,0,2,2022-06-11 08:52:59+00:00,2022-06-20 16:34:53+00:00,"When polling multiple events from slack, there is an inconsistent of the payload generated for the exchange that complete the batch:



This is an exchange part of the batch (CamelBatchComplete=false) and as it can be observed, the bodyType is com.slack.api.model.Message





10:47:28.470 INFO  [raw] (Camel (camel-1) thread #1 - slack://demo) Exchange[
  Id: B2F6BECBBE1B6C2-0000000000000001
  ExchangePattern: InOnly
  Properties: {camel.route.route1.B2F6BECBBE1B6C2-0000000000000001=io.smallrye.metrics.app.TimerImpl$Context@1bcda3c3, CamelBatchComplete=false, CamelBatchIndex=0, CamelBatchSize=2, CamelToEndpoint=log://raw?multiline=true&showAll=true, eventTimer:camel.exchange=io.smallrye.metrics.app.TimerImpl@7d791b4c, eventTimerContext:camel.exchange=io.smallrye.metrics.app.TimerImpl$Context@53f8d078}
  Headers: {}
  BodyType: com.slack.api.model.Message
  Body: Message(...)
]





This is the exchange that closes the batch (CamelBatchComplete=true) and as it can be observed, the bodyType is byte[]:





10:47:28.477 INFO  [raw] (Camel (camel-1) thread #1 - slack://demo) Exchange[
  Id: B2F6BECBBE1B6C2-0000000000000001
  ExchangePattern: InOnly
  Properties: {camel.route.route1.B2F6BECBBE1B6C2-0000000000000001=io.smallrye.metrics.app.TimerImpl$Context@328e8fdf, CamelBatchComplete=true, CamelBatchIndex=1, CamelBatchSize=2, CamelToEndpoint=log://raw?multiline=true&showAll=true, eventTimer:camel.exchange=io.smallrye.metrics.app.TimerImpl@7d791b4c, eventTimerContext:camel.exchange=io.smallrye.metrics.app.TimerImpl$Context@53f8d078}
  Headers: {Content-Type=application/json, org.apache.kafka.clients.producer.RecordMetadata=[]}
  BodyType: byte[]
  Body: {""type"":""message"",""subtype"":""bot_message"", ... }
]","lb:1654910142:2022-06-11T09:15:42.269+0000:1654910142:2022-06-11T09:15:42.269+0000:It seems to be related to exchange pooling as if *camel.main.exchange-factory* is set to *prototype*, then the problem disappear.
davsclaus:1655682495:2022-06-20T07:48:15.929+0000:1655682495:2022-06-20T07:48:15.929+0000:Yeah there is something odd, I see an empty body with pooled exchanges

{code}
09:46:53.487 [Camel (camel-1) thread #3 - slack://test] INFO  sink - Exchange[Id: 3627EB01F7517B0-0000000000000003, ExchangePattern: InOnly, Properties: {CamelBatchComplete=false, CamelBatchIndex=0, CamelBatchSize=3, CamelToEndpoint=log://sink?showAll=true&showAllProperties=true}, Headers: {}, BodyType: com.slack.api.model.Message, Body: Message(type=message, subtype=null, team=T06MULGG5, channel=null, user=U06MWFG8N, username=null, text=2, blocks=[RichTextBlock(type=rich_text, elements=[RichTextSectionElement(type=rich_text_section, elements=[RichTextSectionElement.Text(type=text, text=2, style=null)])], blockId=O9Zln)], attachments=null, ts=1655711206.761289, threadTs=null, intro=false, starred=false, wibblr=false, pinnedTo=null, reactions=null, botId=null, botLink=null, displayAsBot=false, botProfile=null, icons=null, file=null, files=null, upload=false, parentUserId=null, inviter=null, clientMsgId=706da455-2a1d-4612-bf24-aeed3b3e1717, comment=null, topic=null, purpose=null, edited=null, unfurlLinks=false, unfurlMedia=false, threadBroadcast=false, locked=false, replies=null, replyCount=null, replyUsers=null, replyUsersCount=null, latestReply=null, subscribed=false, xFiles=null, hidden=false, lastRead=null, root=null, itemType=null, item=null)]
09:46:53.487 [Camel (camel-1) thread #3 - slack://test] INFO  sink - Exchange[Id: 3627EB01F7517B0-0000000000000004, ExchangePattern: InOnly, Properties: {CamelBatchComplete=false, CamelBatchIndex=1, CamelBatchSize=3, CamelToEndpoint=log://sink?showAll=true&showAllProperties=true}, Headers: {}, BodyType: null, Body: [Body is null]]
09:46:53.488 [Camel (camel-1) thread #3 - slack://test] INFO  sink - Exchange[Id: 3627EB01F7517B0-0000000000000005, ExchangePattern: InOnly, Properties: {CamelBatchComplete=true, CamelBatchIndex=2, CamelBatchSize=3, CamelToEndpoint=log://sink?showAll=true&showAllProperties=true}, Headers: {}, BodyType: com.slack.api.model.Message, Body: Message(type=message, subtype=null, team=T06MULGG5, channel=null, user=U06MWFG8N, username=null, text=3, blocks=[RichTextBlock(type=rich_text, elements=[RichTextSectionElement(type=rich_text_section, elements=[RichTextSectionElement.Text(type=text, text=3, style=null)])], blockId=uHEV)], attachments=null, ts=1655711208.197219, threadTs=null, intro=false, starred=false, wibblr=false, pinnedTo=null, reactions=null, botId=null, botLink=null, displayAsBot=false, botProfile=null, icons=null, file=null, files=null, upload=false, parentUserId=null, inviter=null, clientMsgId=1cdf4d24-94eb-4134-acc8-ea996d24b766, comment=null, topic=null, purpose=null, edited=null, unfurlLinks=false, unfurlMedia=false, threadBroadcast=false, locked=false, replies=null, replyCount=null, replyUsers=null, replyUsersCount=null, latestReply=null, subscribed=false, xFiles=null, hidden=false, lastRead=null, root=null, itemType=null, item=null)]
{code}
davsclaus:1655685161:2022-06-20T08:32:41.104+0000:1655685161:2022-06-20T08:32:41.104+0000:Okay so its some camel components in pooled mode that can trigger an exchange to be released twice, leading to the exchange being inserted into pool twice and hence its concurrently being used, and hence why we see this problem.

This is only for components that uses auto release = true
davsclaus:1655698006:2022-06-20T12:06:46.532+0000:1655698006:2022-06-20T12:06:46.532+0000:Okay have a fix but it needs a bit better depending on kind of consumer (general vs batch)"
0,CAMEL-18186,Improvement,Minor,3.11.7,4.x,"
None
",Open,Unresolved,4.x,Unassigned,chio chuan ooi,0,2,2022-06-11 03:56:02+00:00,2023-08-09 09:08:49+00:00,"When saga coordinator finalize the step, new exchange is being created, all the tracing information in the previous exchange is not being propagated to the new exchange and causing new trace is being generated.  


 




    private Exchange createExchange(Endpoint endpoint, CamelSagaStep step) {
        Exchange exchange = endpoint.createExchange();
        exchange.getIn().setHeader(Exchange.SAGA_LONG_RUNNING_ACTION, getId());

        Map<String, Object> values = optionValues.get(step);
        if (values != null) {
            for (Map.Entry<String, Object> entry : values.entrySet()) {
                exchange.getIn().setHeader(entry.getKey(), entry.getValue());
            }
        }
        return exchange;
    }","davsclaus:1689563033:2023-07-17T11:03:53.560+0000:1689563033:2023-07-17T11:03:53.560+0000:Did you work on a new PR
chiochuan@gmail.com:1689717332:2023-07-19T05:55:32.602+0000:1689717332:2023-07-19T05:55:32.602+0000:try to fix that but seem the camel-tracing was not part of the camel-core. 

Not manage to fix on that"
0,CAMEL-18185,Bug,Major,None,"3.14.4, 3.18.0","
None
",Resolved,Fixed,"3.14.4, 3.18.0",Claus Ibsen,Luca Burgazzoli,0,3,2022-06-10 23:10:46+00:00,2022-06-20 16:35:50+00:00,"Running a camel component to read from slack lead to the following error:




Exchange[854F138824ACA43-0000000000000003]. Caused by: [org.apache.camel.NoTypeConversionAvailableException - No type converter available to convert from type: null to the required type: java.io.InputStream with value null]
	at org.apache.camel.support.MessageSupport.getMandatoryBody(MessageSupport.java:125)
	at org.apache.camel.support.processor.UnmarshalProcessor.process(UnmarshalProcessor.java:58)
	at org.apache.camel.processor.errorhandler.RedeliveryErrorHandler$RedeliveryTask.doRun(RedeliveryErrorHandler.java:812)
	at org.apache.camel.processor.errorhandler.RedeliveryErrorHandler$RedeliveryTask.run(RedeliveryErrorHandler.java:720)
	at org.apache.camel.impl.engine.DefaultReactiveExecutor$Worker.schedule(DefaultReactiveExecutor.java:193)
	at org.apache.camel.impl.engine.DefaultReactiveExecutor.scheduleMain(DefaultReactiveExecutor.java:64)
	at org.apache.camel.processor.Pipeline.process(Pipeline.java:184)
	at org.apache.camel.impl.engine.CamelInternalProcessor.process(CamelInternalProcessor.java:398)
	at org.apache.camel.component.slack.SlackConsumer.processBatch(SlackConsumer.java:133)
	at org.apache.camel.component.slack.SlackConsumer.poll(SlackConsumer.java:87)
	at org.apache.camel.support.ScheduledPollConsumer.doRun(ScheduledPollConsumer.java:202)
	at org.apache.camel.support.ScheduledPollConsumer.run(ScheduledPollConsumer.java:116)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)
	at java.base/java.util.concurrent.FutureTask.runAndReset(FutureTask.java:305)
	at java.base/java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:305)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)
	at java.base/java.lang.Thread.run(Thread.java:829)
Caused by: org.apache.camel.NoTypeConversionAvailableException: No type converter available to convert from type: null to the required type: java.io.InputStream with value null
	at org.apache.camel.impl.converter.CoreTypeConverterRegistry.mandatoryConvertTo(CoreTypeConverterRegistry.java:275)
	at org.apache.camel.support.MessageSupport.getMandatoryBody(MessageSupport.java:123)
	... 17 more","rhuanrcoha:1654874357:2022-06-10T23:19:17.763+0000:1654874357:2022-06-10T23:19:17.763+0000:If possible, could you attach a simple reproducer of this issue?
lb:1654908545:2022-06-11T08:49:05.943+0000:1654908545:2022-06-11T08:49:05.943+0000:I'm trying to create one but I was unable so far
davsclaus:1655714150:2022-06-20T16:35:50.241+0000:1655714150:2022-06-20T16:35:50.241+0000:It due to that exchange pooling bug"
0,CAMEL-18184,New Feature,Minor,None,3.18.0,"
None
",Resolved,Fixed,3.18.0,Unassigned,Rastislav Papp,0,2,2022-06-10 13:18:20+00:00,2022-06-17 06:44:04+00:00,"camel-test-blueprint module does not have a junit 5 variant. It is just 1 class, and the change is very small (mostly switching to camel-test-junit5 and changing some imports). I'll create a PR.","rastislav.papp:1654990657:2022-06-12T07:37:37.435+0000:1654990657:2022-06-12T07:37:37.435+0000:created PR #160 on camel-karaf
davsclaus:1655419444:2022-06-17T06:44:04.345+0000:1655419444:2022-06-17T06:44:04.345+0000:You are welcome to look at the archetypes in camel-karaf as it is using the old junit 4 for testing."
0,CAMEL-18183,Dependency upgrade,Minor,"3.14.3, 3.17.0","3.14.4, 3.18.0","
None
",Resolved,Fixed,"3.14.4, 3.18.0",Unassigned,Xilai Dai,0,2,2022-06-10 08:34:22+00:00,2022-06-14 09:21:24+00:00,"https://repo1.maven.org/maven2/org/apache/camel/karaf/apache-camel/3.17.0/apache-camel-3.17.0-features.xml




  <feature name='camel-azure-storage-datalake' version='3.17.0' start-level='50'>
    ......
    <bundle>mvn:org.apache.camel/camel-azure-storage-blob/3.17.0</bundle>
  </feature>
 



""mvn:org.apache.camel/camel-azure-storage-blob"" should be ""mvn:org.apache.camel/camel-azure-storage-datalake"".",nfilotto:1655169684:2022-06-14T09:21:24.703+0000:1655169684:2022-06-14T09:21:24.703+0000:Good catch [~xldai] thank you
0,CAMEL-18182,Bug,Minor,3.14.2,3.19.0,"
None
",Resolved,Cannot Reproduce,3.19.0,Unassigned,birkh,0,2,2022-06-10 00:47:34+00:00,2022-08-04 16:04:27+00:00,No Desc,"davsclaus:1654807581:2022-06-10T04:46:21.935+0000:1654807581:2022-06-10T04:46:21.935+0000:Can you provide more details, and a sample project to reproduce this.
office:1654824313:2022-06-10T09:25:13.085+0000:1654824313:2022-06-10T09:25:13.085+0000:[camel-servlet-demo|https://github.com/birkh8792/camel-servlet-demo]
davsclaus:1654829573:2022-06-10T10:52:53.873+0000:1654829573:2022-06-10T10:52:53.873+0000:Can you explain in more details in the readme how to run and try this and how to send the data, and what you expect should happend and what is wrong.

office:1654987783:2022-06-12T06:49:43.600+0000:1654987819:2022-06-12T06:50:19.396+0000:i am sorry,the camel-servlet can not receive post request(postman form/data),detail info [img|https://github.com/birkh8792/camel-servlet-demo/blob/master/img.png]
davsclaus:1659600256:2022-08-04T16:04:16.064+0000:1659600256:2022-08-04T16:04:16.064+0000:With latest release then I can get the form-data username and password.

2022-08-04 18:01:22.499  INFO 84597 --- [nio-8080-exec-1] c.l.route.ServletFormDataRouteBuilder    : requestMethod-->POST
------WebKitFormBoundaryBAPaDgMZzii4INuD
Content-Disposition: form-data; name=""username""

donald
------WebKitFormBoundaryBAPaDgMZzii4INuD
Content-Disposition: form-data; name=""password""

duck
------WebKitFormBoundaryBAPaDgMZzii4INuD--
"
0,CAMEL-18181,Task,Minor,3.17.0,,"
None
",Resolved,Information Provided,None,Unassigned,Otavio Rodolfo Piske,0,3,2022-06-09 14:31:22+00:00,2022-09-03 14:52:03+00:00,"It fails with:


 


```


Error:  Failed to execute goal org.apache.camel:camel-package-maven-plugin:3.18.0-SNAPSHOT:generate (generate) on project camel-core-engine: Error generating data org.apache.maven.plugin.MojoExecutionException: Error reading file D:\a\camel\camel\core\camel-core-engine\src\main\docs\modules\eips\pages\aggregate-eip.adoc Reason: org.apache.maven.plugin.MojoFailureException: File D:\a\camel\camel\core\camel-core-engine\src\main\docs\modules\eips\pages\aggregate-eip.adoc has unexpected structure with no empty line. -> [Help 1]


```","rgala:1654812869:2022-06-10T06:14:29.407+0000:1654812869:2022-06-10T06:14:29.407+0000:There is also an issue on Windows while building *docs* module:
{noformat}
[INFO] [16:28:38] Error: EPERM: operation not permitted, symlink '..\..\..\..\..\core\camel-base\src\main\docs\properties-component.adoc' -> 'C:\Users\***J\TEMP\git\camel\docs\components\modules\ROOT\pages\properties-component.adoc'{noformat}
I believe this is because I have no administrator privileges on the machine and YARN cannot create links.
davsclaus:1662187918:2022-09-03T14:51:58.126+0000:1662187918:2022-09-03T14:51:58.126+0000:You can skip building the docs I think there is a profile for that, try with -P fastinstall"
0,CAMEL-18180,Task,Minor,None,3.x,"
None
",Resolved,Fixed,3.x,Unassigned,Rafał Gała,0,3,2022-06-09 12:56:21+00:00,2022-09-03 14:50:54+00:00,"Please consider adding the



*.adoc text eol=lf



in .gitattributes to force LF line endings in .adoc files to avoid issues with 




String[] lines = text.split(""\n""); 



in UpdateReadmeMojo class when a git checkout was made on a Windows machine with GIT configuration set to autocrlf = true.","davsclaus:1654810620:2022-06-10T05:37:00.841+0000:1654810620:2022-06-10T05:37:00.841+0000:[~orpiske] did you fix this?
orpiske:1654816948:2022-06-10T07:22:28.279+0000:1654816948:2022-06-10T07:22:28.279+0000:[~davsclaus]  18181 should be done, but this one no. I saw that [~rgala] sent a PR for this one. I'll take a look later."
0,CAMEL-18179,Dependency upgrade,Minor,None,"3.18.2, 3.19.0","
None
",Resolved,Fixed,"3.18.2, 3.19.0",Jean-Baptiste Onofré,Xilai Dai,0,4,2022-06-09 12:32:51+00:00,2022-09-04 10:38:34+00:00,"There is no ""camel-jira"" karaf feature available in Camel 3, e.g in the https://repo1.maven.org/maven2/org/apache/camel/karaf/apache-camel/3.17.0/apache-camel-3.17.0-features.xml
for sure currently the libraries from com.atlassian.jira are not in the maven central but under here http://packages.atlassian.com/maven-external/,
also the libraries are plain jar, NOT OSGi bundle, 
But it would be good to the users if we can make camel-jira OSGi-ready.","jbonofre:1656403808:2022-06-28T16:10:08.273+0000:1656403808:2022-06-28T16:10:08.273+0000:Here's the ready to use {{camel-jira}} feature: [https://github.com/jbonofre/camel-karaf/commit/4bfda7c2e859b8f6109cd195e863a2ecf372218e]

I'm just waiting SMX bundles release (including guava, google-http-client and atlassian-jira-client bundles) to open the PR.
nfilotto:1656409074:2022-06-28T17:37:54.600+0000:1656409074:2022-06-28T17:37:54.600+0000:Great Job [~jbonofre] ! And many thanks for the fix
nfilotto:1658236133:2022-07-19T21:08:53.442+0000:1658236343:2022-07-19T21:12:23.409+0000:Hi, the SMX bundles seem to have been released so is there something else left to do before fixing it ? (I mean appart from adjusting your changes consequently in your branch and proposing a PR)

Thx in advance,

Nicolas
jbonofre:1658264312:2022-07-20T04:58:32.020+0000:1658264312:2022-07-20T04:58:32.020+0000:I'm updating my branch (with the released version and property) and I will open the PR. I'm on it right now :)
jbonofre:1658265766:2022-07-20T05:22:46.200+0000:1658265766:2022-07-20T05:22:46.200+0000:Done, PR is ready: https://github.com/apache/camel-karaf/pull/171
xldai:1659568675:2022-08-04T07:17:55.392+0000:1659568675:2022-08-04T07:17:55.392+0000:[~jbonofre], Any chance to backport the fixes into 3.18.x which is LTS version if I'm not wrong?
jbonofre:1659568856:2022-08-04T07:20:56.147+0000:1659568856:2022-08-04T07:20:56.147+0000:[~xldai] sure, no problem, I will backport on 3.18.x.
nfilotto:1662259114:2022-09-04T10:38:34.957+0000:1662259114:2022-09-04T10:38:34.957+0000:Backport included into https://github.com/apache/camel-karaf/pull/185"
0,CAMEL-18178,Sub-task,Major,None,3.18.0,"
None
",Resolved,Fixed,3.18.0,Andrea Cosentino,Andrea Cosentino,0,1,2022-06-09 07:42:45+00:00,2022-06-09 07:52:01+00:00,No Desc,
0,CAMEL-18177,Improvement,Minor,None,"4.0-RC1, 4.0.0","
None
",Resolved,Workaround,"4.0-RC1, 4.0.0",Claus Ibsen,Luca Burgazzoli,0,2,2022-06-09 06:35:43+00:00,2023-05-24 12:59:32+00:00,"According to slack's doc:




If you exceed a rate limit when using any of our HTTP-based APIs (including Incoming Webhooks), Slack will return a HTTP 429 Too Many Requests error, and a Retry-After HTTP header containing the number of seconds until you can retry.




We should explore if we can honor the  Retry-After seconds to perform the next poll.","davsclaus:1662187749:2022-09-03T14:49:09.879+0000:1662187749:2022-09-03T14:49:09.879+0000:Ah yeah if the consumer is scheduled we could maybe grab that seconds and then store that in some state and then skip the poll if still reminding seconds left - then we can have some kind of method a component  can implement that can support grabbing this rate limit until header
lb:1670898642:2022-12-13T10:30:42.593+0000:1670898642:2022-12-13T10:30:42.593+0000:/cc [~acosentino]
davsclaus:1670980665:2022-12-14T09:17:45.150+0000:1670980665:2022-12-14T09:17:45.150+0000:We can change the default scheduler value in camel-slack to be less frequent. 
davsclaus:1684904230:2023-05-24T12:57:10.479+0000:1684904230:2023-05-24T12:57:10.479+0000:Okay I am changing the default delay from 0.5s to 10s that should help this out of the box."
0,CAMEL-18176,Sub-task,Major,None,None,"
None
",Resolved,Fixed,3.18.0,Andrea Cosentino,Andrea Cosentino,0,1,2022-06-08 12:57:48+00:00,2022-06-15 12:57:14+00:00,To have a way to test the vault locally,
0,CAMEL-18175,Improvement,Major,None,3.18.0,"
None
",Resolved,Fixed,3.18.0,Claus Ibsen,Claus Ibsen,0,1,2022-06-08 12:19:06+00:00,2022-06-13 12:22:10+00:00,"Such as camel-jira where atlassiant has a special jar that are built by some custom maven plugin and it sets


<packaging>atlassian-plugin</packaging>


then this confused apache ivy/groovy grape downloader.


Similar for osgi with <packaging>osgi</packaging>",
0,CAMEL-18174,Task,Major,3.17.0,3.18.0,"
None
",Resolved,Fixed,3.18.0,Otavio Rodolfo Piske,Otavio Rodolfo Piske,0,1,2022-06-08 11:15:06+00:00,2022-06-13 09:02:48+00:00,In some circumstances the offset may not be present in all the exchanges. Currently the resume API throws an error if this happen. It should be modified to allow users to set intermittent mode.,orpiske:1655082168:2022-06-13T09:02:48.328+0000:1655082168:2022-06-13T09:02:48.328+0000:Fixed with the linked PR.
0,CAMEL-18173,Improvement,Major,None,3.18.0,"
None
",Resolved,Fixed,3.18.0,Claus Ibsen,Claus Ibsen,0,1,2022-06-08 10:31:51+00:00,2022-06-08 10:32:14+00:00,No Desc,
0,CAMEL-18172,Improvement,Minor,None,3.18.0,"
None
",Resolved,Fixed,3.18.0,Claus Ibsen,Luca Burgazzoli,0,1,2022-06-08 09:01:06+00:00,2022-06-08 12:06:29+00:00,"The default RefLanguage component lazily resolve the ref expression hence it does not work with kamelets as the route template engine leverages a ThreadLocal bean repository to reify the route template, then such repo si cleared out and not more known by the routing engine.


A way to workaround it is to create a custom ref language, as example:




import org.apache.camel.Expression;
import org.apache.camel.Predicate;
import org.apache.camel.language.ref.RefLanguage;
import org.apache.camel.support.PredicateToExpressionAdapter;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public class EagerRefLanguage extends RefLanguage {
    private static final Logger LOGGER = LoggerFactory.getLogger(EagerRefLanguage.class);

    @Override
    public Expression createExpression(final String expression) {
        Expression exp = getCamelContext().getRegistry().lookupByNameAndType(expression, Expression.class);
        if (exp != null) {
            LOGGER.debug(""Found and instance of {} expression in the registry {}"", expression, exp);
            exp.init(getCamelContext());
            return exp;
        }

        Predicate pred = getCamelContext().getRegistry().lookupByNameAndType(expression, Predicate.class);
        if (pred != null) {
            LOGGER.debug(""Found and instance of {} predicate in the registry {}"", expression, pred);
            pred.init(getCamelContext());
            return PredicateToExpressionAdapter.toExpression(pred);
        }

        return super.createExpression(expression);
    }
}




And bind it to the registry so camel will use as beans from the registry ahve priority over discovery form service loader.


This is clearly an hack but we may want to bring such optimization to camel core, so i.e. if a ref expression is not dynamic, then we can load it when the ref is reified.",
0,CAMEL-18171,New Feature,Major,None,3.18.0,"
None
",Resolved,Fixed,3.18.0,Claus Ibsen,Claus Ibsen,0,1,2022-06-07 20:09:52+00:00,2022-06-28 17:06:28+00:00,"We should have a custom property function so you can refer to configmaps using {{ }} style, eg


Something ala:


kafka:cheese?brokers=configmap:mykafka/brokers


This requires to query the config map from k8s so we need camel-kubernetes.","davsclaus:1655950876:2022-06-23T10:21:16.597+0000:1656200384:2022-06-26T07:39:44.470+0000:TODO: configmap *DONE*
TODO: secret *DONE*
TODO: docs *DONE*
TODO: add option to configure to load configmap/secrets from file volume (need to specify path) *DONE*
davsclaus:1655965866:2022-06-23T14:31:06.349+0000:1656391403:2022-06-28T12:43:23.534+0000:TODO: Local mode where there is no k8s but you want to use {{configmap:xxx}} then we should allow to load from properties with name.key naming convention *DONE*
davsclaus:1656053110:2022-06-24T14:45:10.527+0000:1656372792:2022-06-28T07:33:12.322+0000:TODO: Allow to configure k8s client via properties ala camel.kubernetes-client.xxx=yyy *DONE*
TODO: docs *DONE*
TODO: running inside k8s should create a default client if none exists as it can work with defaults when running inside k8s *DONE*"
0,CAMEL-18170,Improvement,Minor,None,3.18.0,"
None
",Resolved,Fixed,3.18.0,Otavio Rodolfo Piske,Claudio Miranda,0,4,2022-06-07 18:42:19+00:00,2022-07-15 07:56:31+00:00,"Add support to use service account key parameter to google components: sheets, calendar, mail, drive. 
Similar to google bigquery component.","rhuanrcoha:1654603146:2022-06-07T19:59:06.757+0000:1654603172:2022-06-07T19:59:32.118+0000:Starting to work on this improvement.
rhuanrcoha:1654603560:2022-06-07T20:06:00.944+0000:1654603585:2022-06-07T20:06:25.996+0000:[~orpiske] could you assign it to you as I cannot assign it to me yet? I`m starting to work on this.
orpiske:1654639217:2022-06-08T06:00:17.802+0000:1654639217:2022-06-08T06:00:17.802+0000:[~rhuanrcoha] thanks for looking at this one. I assigned it to myself as requested.
rhuanrcoha:1654789329:2022-06-09T23:42:09.749+0000:1654789329:2022-06-09T23:42:09.749+0000:I sent a PR adding the support to google-drive to use service account key as base64. Google drive component uses the parameter keyResource instead the serviceAccountKey. I think we should rename it from keyResource to serviceAccountKey, for a better semantic. Can I open an issue to this improvement?

- [x] Google Driver

- [ ] sheets

- [ ] calendar

- [ ] mail
rhuanrcoha:1654793111:2022-06-10T00:45:11.261+0000:1654803321:2022-06-10T03:35:21.741+0000:[~claudio4j] just as a double-check. When you said ""Add support to use {{service account key}} parameter to google components: sheets, calendar, mail, drive.
Similar to google bigquery component"" you said about service account key as a URI to .json or about base64? Those components already support `service account key`. You should just configure the `keyResource` option  `(keyResource=path/to/service-account.json)`. Now, I added support to define it as base64, like the BigQuery component `(keyResource=base64:<base64-value>)`
claudio4j:1654837153:2022-06-10T12:59:13.696+0000:1654837153:2022-06-10T12:59:13.696+0000:[~rhuanrcoha] you are right, renaming the existing keyResource parameter is the best option. Thanks for noticing this, less work to do.
rhuanrcoha:1654843078:2022-06-10T14:37:58.511+0000:1654843078:2022-06-10T14:37:58.511+0000:Hi [~claudio4j] ! Thank you for clarifying! I did rename this option to google drive and I`ll do this to the remaining components. 
orpiske:1655172111:2022-06-14T10:01:51.835+0000:1655172111:2022-06-14T10:01:51.835+0000:[~rhuanrcoha]  thanks for your contribution for this issue. I wanted to check if this is complete, so I can close the issue?
rhuanrcoha:1655185264:2022-06-14T13:41:04.478+0000:1655185264:2022-06-14T13:41:04.478+0000:I`ll send a PR updating the camel-google-calendar, camel-google-mail, and camel-google-sheets.
davsclaus:1656324890:2022-06-27T18:14:50.787+0000:1656324890:2022-06-27T18:14:50.787+0000:Which ones are still missing ?
rhuanrcoha:1656682226:2022-07-01T21:30:26.403+0000:1656682290:2022-07-01T21:31:30.930+0000:Hi [~davsclaus] 

No. You can close this ticket, as the components were updated "
0,CAMEL-18169,New Feature,Trivial,None,,"
None
",Resolved,Won't Fix,None,Unassigned,Michael Rambichler,0,1,2022-06-07 12:34:27+00:00,2022-06-08 04:26:40+00:00,"For convinience I would like to have camel dsl extended with following method:


.setException(..)


 


Then the following example would be one liner.


 


Example:


.doTry()
    // try something
.endDoTry()
doCatch(Exception.class)
   // Set the exception after our compensation logic is performed in order for the route error handler to kick in.
                    .process(exchange -> {
                        Exception exception = exchange.getProperty(Exchange.EXCEPTION_CAUGHT, Exception.class);
                        if (exception != null) 

{
                            exchange.setException(exception);
                        }

                    })
.end();",
0,CAMEL-18168,Improvement,Minor,3.17.0,3.x,"
None
",Resolved,Cannot Reproduce,3.x,Unassigned,Joe Siponen,0,2,2022-06-07 10:00:42+00:00,2022-06-10 05:59:54+00:00,"I have this restConfiguration in a quarkus (2.9.2.Final) application:




    @ConfigProperty(name = ""quarkus.http.root-path"")
    String quarkusHttpRootPath;
    @ConfigProperty(name = ""quarkus.application.name"")
    String quarkusApplicationName;
   public void configure() throws Exception {
        restConfiguration()
            .dataFormatProperty(""prettyPrint"", ""true"")
            //.port(8080) - Not applicable, using quarkus http server
            //.host(""0.0.0.0"") - Not applicable, using quarkus http server
            .enableCORS(true)
            // turn on openapi api-doc
            .apiContextPath(""/openapi"")
            .apiVendorExtension(true)
            .apiProperty(""base.path"", quarkusHttpRootPath)
            .apiProperty(""api.title"", quarkusApplicationName)
            .apiProperty(""api.version"", ""1.0.0"")
            // and enable CORS
            .apiProperty(""cors"", ""true"");
     //... routes etc
}




I attempted to do the same configuration in my application's application.yml instead as my understanding is that quarkus uses camel-main to bootstrap/start camel (but could be a misunderstanding on my part...).


I consulted https://camel.apache.org/components/3.17.x/others/main.html#_camel_rest_dsl_configurations and saw some options listed there that fits nicely with my goal. I ended up with this configuration in my application.yml:


 




camel:
  context:
    name: ""${quarkus.application.name}""
  rest:
    enableCORS: true
    apiContextPath: ""/openapi""
    apiVendorExtension: true
    apiProperties:
      ""[base.path]"": ""${quarkus.http.root-path}""
      ""[api.title]"": ""${quarkus.application.name} API""
      ""[api.version]"": ""${quarkus.application.version}""



 


And I also tried the same settings in application.properties:


 




camel.rest.apiProperties.""[api.title]""=${quarkus.application.name} API
camel.rest.apiProperties.""[api.version]""=${quarkus.application.version}
camel.rest.apiProperties.""[base.path]""=${quarkus.http.root-path}



 


But, I am not able to set the apiProperties in any of the above ways. 


For instance, the api.title is not shown in the Swagger UI and the base.path is not set (a 404 is generated when the API is invoked by Swagger). The application itself starts without any errors.


It seems that there is something missing here to make this configurable in both camel-main standalone and camel quarkus.","jsiponen:1654567298:2022-06-07T10:01:38.334+0000:1654567298:2022-06-07T10:01:38.334+0000:See discussion in https://camel.zulipchat.com/#narrow/stream/257298-camel/topic/camel-main.20restConfiguration.20in.20quarkus.20application.2Eyml.3F
davsclaus:1654811982:2022-06-10T05:59:42.190+0000:1654811982:2022-06-10T05:59:42.190+0000:Added unit test in camel-main
https://github.com/apache/camel/commit/cabcdfef05001386b99a801a102885e208c58725

See how its doing this in the properties file.

If there is still a problem then its a camel-quarkus/quarkus issue as how it does configuration from yaml|properties, and you then need to. create a ticket in camel-quarkus (github)"
0,CAMEL-18167,Improvement,Major,3.17.0,3.18.0,"
None
",Resolved,Fixed,3.18.0,Zheng Feng,Zheng Feng,0,1,2022-06-06 01:11:46+00:00,2022-06-08 13:36:08+00:00,"This issue comes across https://github.com/apache/camel-quarkus/issues/3829


I think it could be better to check PresignedRequest.isBrowserExecutable() flag and show a message when it is false.",
0,CAMEL-18166,New Feature,Minor,3.17.0,3.18.0,"
None
",Resolved,Fixed,3.18.0,Claus Ibsen,Sergei Portnov,0,2,2022-06-04 10:44:25+00:00,2022-06-04 19:14:25+00:00,"The problem seems to be that org.apache.camel.spring.boot.SpringBootRoutesCollector only works with LambdaRouteBuilder but not with LambdaEndpointRouteBuilder


Zulip discussion


Example:




@SpringBootApplication
public class CamelTestApplication {

  @Bean
  public LambdaEndpointRouteBuilder lambdaEndpointRouteBuilder() {
    return rb -> rb
        .from(rb.timer(""timer"").period(1000L))
        .to(rb.bean(""myService"").method(""doWork""));
  }  

  public static void main(String[] args) {
    SpringApplication.run(CamelTestApplication.class, args);
  }
}","davsclaus:1654310752:2022-06-04T10:45:52.747+0000:1654310752:2022-06-04T10:45:52.747+0000:This is not currently supported and need to be added as a new feature to auto discover these special routes
davsclaus:1654341265:2022-06-04T19:14:25.780+0000:1654341265:2022-06-04T19:14:25.780+0000:This is now possible, see the new example
https://github.com/apache/camel-spring-boot-examples/tree/main/endpointdsl"
0,CAMEL-18165,Improvement,Major,None,3.18.0,"
None
",Resolved,Fixed,3.18.0,Claus Ibsen,Luca Burgazzoli,0,2,2022-06-03 12:47:40+00:00,2022-06-04 08:11:02+00:00,"In the camel-jackson component, the Jackson Type converter must explicitly be enabled but I wonder if some basic conversion (i.e. InputStream/String/byte[]/Map <--> JsonNode) can be enabled by default.


The reason for that is that in may case, including the new camel-jq component I'm working on, being able to converts to/from JsonNode out of the box without having to explicitly enable the type conversion would be a very nice enhancement.","lb:1654231682:2022-06-03T12:48:02.450+0000:1654231682:2022-06-03T12:48:02.450+0000:Original discussion: https://github.com/apache/camel/pull/7715#issuecomment-1145717274
davsclaus:1654301414:2022-06-04T08:10:14.522+0000:1654301414:2022-06-04T08:10:14.522+0000:Add out of the box type converters for converting to/from JSonNode"
0,CAMEL-18164,New Feature,Major,None,3.19.0,"
None
",Resolved,Duplicate,3.19.0,Unassigned,Claus Ibsen,0,1,2022-06-03 08:10:39+00:00,2022-09-03 14:47:22+00:00,"To make it consistent with camel-jbang to run on either spring boot or quarkus then it would be good to have a starter for platform-http.


We can try to hook into the spring http server and if we can't find a general way we may need to assume its based on tomcat / servlet.",
0,CAMEL-18163,New Feature,Major,None,3.19.0,"
None
",Resolved,Won't Fix,3.19.0,Claus Ibsen,Claus Ibsen,0,1,2022-06-03 08:09:10+00:00,2022-09-06 11:17:23+00:00,To make it easy for camel-main to have a health check endpoint at /q/health as we do with camel-jbang and camel-k / camel-quarkus etc.,
0,CAMEL-18162,Task,Trivial,None,,"
None
",Resolved,Won't Fix,None,Unassigned,Aurélien Pupier,0,1,2022-06-03 08:00:13+00:00,2023-07-17 11:04:05+00:00,"https://github.com/apache/camel-examples/tags
As of today, teh latest tag is 3.16.0
Camel 3.17.0 was released on 19-05-2022",
0,CAMEL-18161,Task,Major,None,,"
None
",Resolved,Fixed,None,Otavio Rodolfo Piske,Otavio Rodolfo Piske,0,1,2022-06-02 07:51:37+00:00,2022-06-13 09:03:25+00:00,"Some resume core classes have methods like getXXX whereas other have them as XXX. This should be fixed.


 


Examples: OffsetKey and Offset have different name patterns.",orpiske:1655082205:2022-06-13T09:03:25.623+0000:1655082205:2022-06-13T09:03:25.623+0000:Fixed with the linked PR.
0,CAMEL-18160,Bug,Minor,3.17.0,3.18.0,"
None
",Resolved,Fixed,3.18.0,Karen Lease,Karen Lease,0,2,2022-06-01 21:16:52+00:00,2022-06-02 05:54:24+00:00,"The typeConverterExists attribute set on camelContext has no effect on custom type converters because it is set on the TypeConverterRegistry after the custom converters are registered.


This is demonstrated by the failing unit test in the related PR. The duplicate converter should override the initial one but it is ignored instead.",davsclaus:1654120464:2022-06-02T05:54:24.188+0000:1654120464:2022-06-02T05:54:24.188+0000:Thanks for the unit test - I fixed to setup this eager so the test passes now
0,CAMEL-18159,Bug,Major,3.14.3,"3.14.4, 3.18.0","
None
",Resolved,Fixed,"3.14.4, 3.18.0",Unassigned,Artem St,0,2,2022-06-01 15:41:20+00:00,2022-06-04 07:20:14+00:00,"For route like:




from(""direct:startSlashed"")
  .toD(""activemq://${header.where}"");



If we pass exchange with specified header where any value, for example ""bar"" the jms endpoint will parse destination not as ""bar"", but as ""//bar"" and will send message to queue ""//bar"".


 


Test file (wich will be fall) is attached","davsclaus:1654083827:2022-06-01T19:43:47.375+0000:1654083827:2022-06-01T19:43:47.375+0000:This is potential in other like kafka, sjms, spring-rabbitmq etc that are also having this. Can you check these as well?
davsclaus:1654084000:2022-06-01T19:46:40.560+0000:1654084000:2022-06-01T19:46:40.560+0000:PRs for the other components is welcome
ArtemSt:1654142713:2022-06-02T12:05:13.491+0000:1654142713:2022-06-02T12:05:13.491+0000:Should I refer this issue in PR or create new one for other component?
davsclaus:1654145155:2022-06-02T12:45:55.565+0000:1654145155:2022-06-02T12:45:55.565+0000:You can refer to this one and add a comment which components you have fixed
davsclaus:1654298414:2022-06-04T07:20:14.512+0000:1654298414:2022-06-04T07:20:14.512+0000:Thanks for the help"
0,CAMEL-18158,Task,Minor,None,4.x,"

easy
help-wanted

",Open,Unresolved,4.x,Unassigned,Otavio Rodolfo Piske,0,1,2022-06-01 07:37:44+00:00,2023-08-09 09:09:00+00:00,Based on a suggestion from Claus in this PR: https://github.com/apache/camel/pull/7694#pullrequestreview-990818819,orpiske:1654040338:2022-06-01T07:38:58.575+0000:1654040338:2022-06-01T07:38:58.575+0000:Added related ticket that triggered the suggestion.
0,CAMEL-18157,Bug,Major,3.14.3,"3.14.4, 3.18.0","
None
",Resolved,Fixed,"3.14.4, 3.18.0",Unassigned,Andrea Evangelista,1,4,2022-05-31 14:16:21+00:00,2022-06-01 04:37:51+00:00,"The settings provided by the query parameter ""parameters"" are ignored when useHeadersAsParameters is true.


Example:


jdbc:xxxxx?useHeadersAsParameters=true&statement.fetchSize=100&outputType=StreamList&resetAutoCommit=false


In this specific case statement.fetchSize=100 will be ignored and all the rows will be fetched in memory for an sql query like this one:


SELECT * from MY-BIG-TABLE","gangel:1653980681:2022-05-31T15:04:41.009+0000:1653980681:2022-05-31T15:04:41.009+0000:It seems that processing huge tables may cause quickly OOM and high CPU rate in that case :(  
andrea81:1653987842:2022-05-31T17:04:02.814+0000:1653988452:2022-05-31T17:14:12.002+0000:I will do a pull request with the following changes in the JdbcProducer class:
{code:java}
/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.jdbc;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLDataException;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;

import javax.sql.DataSource;

import org.apache.camel.Exchange;
import org.apache.camel.ExtendedExchange;
import org.apache.camel.spi.Synchronization;
import org.apache.camel.support.DefaultProducer;
import org.apache.camel.support.PropertyBindingSupport;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public class JdbcProducer extends DefaultProducer {

    private static final Logger LOG = LoggerFactory.getLogger(JdbcProducer.class);

    private final DataSource dataSource;
    private final ConnectionStrategy connectionStrategy;
    private final int readSize;
    private final Map<String, Object> parameters;

    public JdbcProducer(JdbcEndpoint endpoint, DataSource dataSource, ConnectionStrategy connectionStrategy,
                        int readSize, Map<String, Object> parameters) {
        super(endpoint);
        this.dataSource = dataSource;
        this.connectionStrategy = connectionStrategy;
        this.readSize = readSize;
        this.parameters = parameters;
    }

    @Override
    public JdbcEndpoint getEndpoint() {
        return (JdbcEndpoint) super.getEndpoint();
    }

    /**
     * Execute sql of exchange and set results on output
     */
    @Override
    public void process(Exchange exchange) throws Exception {
        if (getEndpoint().isResetAutoCommit()) {
            processingSqlBySettingAutoCommit(exchange);
        } else {
            processingSqlWithoutSettingAutoCommit(exchange);
        }
    }

    private void processingSqlBySettingAutoCommit(Exchange exchange) throws Exception {
        String sql = exchange.getIn().getBody(String.class);
        Connection conn = null;
        Boolean autoCommit = null;
        boolean shouldCloseResources = true;

        try {
            conn = connectionStrategy.getConnection(dataSource);
            autoCommit = conn.getAutoCommit();
            if (autoCommit) {
                conn.setAutoCommit(false);
            }

            shouldCloseResources = createAndExecuteSqlStatement(exchange, sql, conn);

            conn.commit();
        } catch (Exception e) {
            try {
                if (conn != null) {
                    conn.rollback();
                }
            } catch (Throwable sqle) {
                LOG.warn(""Error occurred during JDBC rollback. This exception will be ignored."", sqle);
            }
            throw e;
        } finally {
            if (shouldCloseResources) {
                resetAutoCommit(conn, autoCommit);
                closeQuietly(conn);
            }
        }
    }

    private void processingSqlWithoutSettingAutoCommit(Exchange exchange) throws Exception {
        String sql = exchange.getIn().getBody(String.class);
        Connection conn = null;
        boolean shouldCloseResources = true;

        try {
            conn = connectionStrategy.getConnection(dataSource);
            shouldCloseResources = createAndExecuteSqlStatement(exchange, sql, conn);
        } finally {
            if (shouldCloseResources && !connectionStrategy.isConnectionTransactional(conn, dataSource)) {
                closeQuietly(conn);
            }
        }
    }

    private boolean createAndExecuteSqlStatement(Exchange exchange, String sql, Connection conn) throws Exception {
        if (getEndpoint().isUseHeadersAsParameters()) {
            return doCreateAndExecuteSqlStatementWithHeaders(exchange, sql, conn);
        } else {
            return doCreateAndExecuteSqlStatement(exchange, sql, conn);
        }
    }

    private boolean doCreateAndExecuteSqlStatementWithHeaders(Exchange exchange, String sql, Connection conn) throws Exception {
        PreparedStatement ps = null;
        ResultSet rs = null;
        boolean shouldCloseResources = true;

        try {
            final String preparedQuery
                    = getEndpoint().getPrepareStatementStrategy().prepareQuery(sql, getEndpoint().isAllowNamedParameters());

            Boolean shouldRetrieveGeneratedKeys
                    = exchange.getIn().getHeader(JdbcConstants.JDBC_RETRIEVE_GENERATED_KEYS, false, Boolean.class);

            if (shouldRetrieveGeneratedKeys) {
                Object expectedGeneratedColumns = exchange.getIn().getHeader(JdbcConstants.JDBC_GENERATED_COLUMNS);
                if (expectedGeneratedColumns == null) {
                    ps = conn.prepareStatement(preparedQuery, Statement.RETURN_GENERATED_KEYS);
                } else if (expectedGeneratedColumns instanceof String[]) {
                    ps = conn.prepareStatement(preparedQuery, (String[]) expectedGeneratedColumns);
                } else if (expectedGeneratedColumns instanceof int[]) {
                    ps = conn.prepareStatement(preparedQuery, (int[]) expectedGeneratedColumns);
                } else {
                    throw new IllegalArgumentException(
                            ""Header specifying expected returning columns isn't an instance of String[] or int[] but ""
                                                       + expectedGeneratedColumns.getClass());
                }
            } else {
                ps = conn.prepareStatement(preparedQuery);
            }
            
            bindParameters(exchange, ps);

            //Check for statement paramters:

            int expectedCount = ps.getParameterMetaData().getParameterCount();

            if (expectedCount > 0) {
                Iterator<?> it = getEndpoint().getPrepareStatementStrategy()
                        .createPopulateIterator(sql, preparedQuery, expectedCount, exchange, exchange.getIn().getBody());
                getEndpoint().getPrepareStatementStrategy().populateStatement(ps, it, expectedCount);
            }

            LOG.debug(""Executing JDBC PreparedStatement: {}"", sql);

            boolean stmtExecutionResult = ps.execute();
            if (stmtExecutionResult) {
                rs = ps.getResultSet();
                shouldCloseResources = setResultSet(exchange, conn, rs);
            } else {
                int updateCount = ps.getUpdateCount();
                // and then set the new header
                exchange.getMessage().setHeader(JdbcConstants.JDBC_UPDATE_COUNT, updateCount);
            }

            if (shouldRetrieveGeneratedKeys) {
                setGeneratedKeys(exchange, conn, ps.getGeneratedKeys());
            }
        } finally {
            if (shouldCloseResources) {
                closeQuietly(rs);
                closeQuietly(ps);
            }
        }
        return shouldCloseResources;
    }

    private void bindParameters(Exchange exchange, Statement ps) {
        if (parameters != null && !parameters.isEmpty()) {
            Map<String, Object> copy = new HashMap<>(parameters);
            PropertyBindingSupport.bindProperties(exchange.getContext(), ps, copy);
        }
    }

    private boolean doCreateAndExecuteSqlStatement(Exchange exchange, String sql, Connection conn) throws Exception {

        ResultSet rs = null;
        boolean shouldCloseResources = true;

        try {
            // We might need to leave it open to allow post-processing of the result set. This is why we
            // are not using try-with-resources here.
            Statement stmt = conn.createStatement();

            bindParameters(exchange, stmt);

            LOG.debug(""Executing JDBC Statement: {}"", sql);

            Boolean shouldRetrieveGeneratedKeys
                    = exchange.getIn().getHeader(JdbcConstants.JDBC_RETRIEVE_GENERATED_KEYS, false, Boolean.class);

            boolean stmtExecutionResult;
            if (shouldRetrieveGeneratedKeys) {
                Object expectedGeneratedColumns = exchange.getIn().getHeader(JdbcConstants.JDBC_GENERATED_COLUMNS);
                if (expectedGeneratedColumns == null) {
                    stmtExecutionResult = stmt.execute(sql, Statement.RETURN_GENERATED_KEYS);
                } else if (expectedGeneratedColumns instanceof String[]) {
                    stmtExecutionResult = stmt.execute(sql, (String[]) expectedGeneratedColumns);
                } else if (expectedGeneratedColumns instanceof int[]) {
                    stmtExecutionResult = stmt.execute(sql, (int[]) expectedGeneratedColumns);
                } else {
                    throw new IllegalArgumentException(
                            ""Header specifying expected returning columns isn't an instance of String[] or int[] but ""
                                                       + expectedGeneratedColumns.getClass());
                }
            } else {
                stmtExecutionResult = stmt.execute(sql);
            }

            if (stmtExecutionResult) {
                rs = stmt.getResultSet();
                shouldCloseResources = setResultSet(exchange, conn, rs);
            } else {
                int updateCount = stmt.getUpdateCount();
                // and then set the new header
                exchange.getMessage().setHeader(JdbcConstants.JDBC_UPDATE_COUNT, updateCount);
            }

            if (shouldRetrieveGeneratedKeys) {
                setGeneratedKeys(exchange, conn, stmt.getGeneratedKeys());
            }
        } finally {
            if (shouldCloseResources) {
                closeQuietly(rs);
            }
        }
        return shouldCloseResources;
    }

    private void closeQuietly(ResultSet rs) {
        if (rs != null) {
            try {
                if (!rs.isClosed()) {
                    rs.close();
                }
            } catch (Throwable sqle) {
                LOG.debug(""Error by closing result set"", sqle);
            }
        }
    }

    private void closeQuietly(Statement stmt) {
        if (stmt != null) {
            try {
                if (!stmt.isClosed()) {
                    stmt.close();
                }
            } catch (Throwable sqle) {
                LOG.debug(""Error by closing statement"", sqle);
            }
        }
    }

    private void resetAutoCommit(Connection con, Boolean autoCommit) {
        if (con != null && autoCommit != null) {
            try {
                con.setAutoCommit(autoCommit);
            } catch (Throwable sqle) {
                LOG.debug(""Error by resetting auto commit to its original value"", sqle);
            }
        }
    }

    private void closeQuietly(Connection con) {
        if (con != null) {
            try {
                if (!con.isClosed()) {
                    con.close();
                }
            } catch (Throwable sqle) {
                LOG.debug(""Error by closing connection"", sqle);
            }
        }
    }

    /**
     * Sets the generated if any to the Exchange in headers : - {@link JdbcConstants#JDBC_GENERATED_KEYS_ROW_COUNT} :
     * the row count of generated keys - {@link JdbcConstants#JDBC_GENERATED_KEYS_DATA} : the generated keys data
     *
     * @param exchange      The exchange where to store the generated keys
     * @param conn          Current JDBC connection
     * @param generatedKeys The result set containing the generated keys
     */
    protected void setGeneratedKeys(Exchange exchange, Connection conn, ResultSet generatedKeys) throws SQLException {
        if (generatedKeys != null) {
            ResultSetIterator iterator = new ResultSetIterator(
                    conn, generatedKeys, getEndpoint().isUseJDBC4ColumnNameAndLabelSemantics(),
                    getEndpoint().isUseGetBytesForBlob());
            List<Map<String, Object>> data = extractRows(iterator);

            exchange.getMessage().setHeader(JdbcConstants.JDBC_GENERATED_KEYS_ROW_COUNT, data.size());
            exchange.getMessage().setHeader(JdbcConstants.JDBC_GENERATED_KEYS_DATA, data);
        }
    }

    /**
     * Sets the result from the ResultSet to the Exchange as its OUT body.
     *
     * @return whether to close resources
     */
    protected boolean setResultSet(Exchange exchange, Connection conn, ResultSet rs) throws SQLException {
        boolean answer = true;

        ResultSetIterator iterator = new ResultSetIterator(
                conn, rs, getEndpoint().isUseJDBC4ColumnNameAndLabelSemantics(), getEndpoint().isUseGetBytesForBlob());

        JdbcOutputType outputType = getEndpoint().getOutputType();
        exchange.getMessage().setHeader(JdbcConstants.JDBC_COLUMN_NAMES, iterator.getColumnNames());
        if (outputType == JdbcOutputType.StreamList) {
            exchange.getMessage()
                    .setBody(new StreamListIterator(
                            getEndpoint().getCamelContext(), getEndpoint().getOutputClass(), getEndpoint().getBeanRowMapper(),
                            iterator));
            exchange.adapt(ExtendedExchange.class).addOnCompletion(new ResultSetIteratorCompletion(iterator));
            // do not close resources as we are in streaming mode
            answer = false;
        } else if (outputType == JdbcOutputType.SelectList) {
            List<?> list = extractRows(iterator);
            exchange.getMessage().setHeader(JdbcConstants.JDBC_ROW_COUNT, list.size());
            exchange.getMessage().setBody(list);
        } else if (outputType == JdbcOutputType.SelectOne) {
            exchange.getMessage().setBody(extractSingleRow(iterator));
        }

        return answer;
    }

    @SuppressWarnings(""unchecked"")
    private List extractRows(ResultSetIterator iterator) throws SQLException {
        List result = new ArrayList();
        int maxRowCount = readSize == 0 ? Integer.MAX_VALUE : readSize;
        for (int i = 0; iterator.hasNext() && i < maxRowCount; i++) {
            Map<String, Object> row = iterator.next();
            Object value;
            if (getEndpoint().getOutputClass() != null) {
                value = JdbcHelper.newBeanInstance(getEndpoint().getCamelContext(), getEndpoint().getOutputClass(),
                        getEndpoint().getBeanRowMapper(), row);
            } else {
                value = row;
            }
            result.add(value);
        }
        return result;
    }

    private Object extractSingleRow(ResultSetIterator iterator) throws SQLException {
        if (!iterator.hasNext()) {
            return null;
        }

        Map<String, Object> row = iterator.next();
        if (iterator.hasNext()) {
            throw new SQLDataException(""Query result not unique for outputType=SelectOne."");
        } else if (getEndpoint().getOutputClass() != null) {
            return JdbcHelper.newBeanInstance(getEndpoint().getCamelContext(), getEndpoint().getOutputClass(),
                    getEndpoint().getBeanRowMapper(), row);
        } else if (row.size() == 1) {
            return row.values().iterator().next();
        } else {
            return row;
        }
    }

    private static final class ResultSetIteratorCompletion implements Synchronization {
        private final ResultSetIterator iterator;

        private ResultSetIteratorCompletion(ResultSetIterator iterator) {
            this.iterator = iterator;
        }

        @Override
        public void onComplete(Exchange exchange) {
            iterator.close();
            iterator.closeConnection();
        }

        @Override
        public void onFailure(Exchange exchange) {
            iterator.close();
            iterator.closeConnection();
        }
    }
}
 {code}
Has been introduced the common method:
{code:java}
private void bindParameters(Exchange exchange, Statement ps) {
    if (parameters != null && !parameters.isEmpty()) {
        Map<String, Object> copy = new HashMap<>(parameters);
        PropertyBindingSupport.bindProperties(exchange.getContext(), ps, copy);
    }
}{code}
to be used by:
 - *private boolean doCreateAndExecuteSqlStatementWithHeaders(Exchange exchange, String sql, Connection conn) throws Exception {*
 - *private boolean doCreateAndExecuteSqlStatement(Exchange exchange, String sql, Connection conn) throws Exception {*
davsclaus:1653992344:2022-05-31T18:19:04.281+0000:1653992344:2022-05-31T18:19:04.281+0000:Yes you are welcome to send a PR against the main branch
andrea81:1653994463:2022-05-31T18:54:23.456+0000:1653994463:2022-05-31T18:54:23.456+0000:[~davsclaus]:
Here my PR:
[https://github.com/apache/camel/pull/7701]

thanks for your time
davsclaus:1654029471:2022-06-01T04:37:51.928+0000:1654029471:2022-06-01T04:37:51.928+0000:Thanks for reporting and the PR"
0,CAMEL-18156,New Feature,Major,None,None,"
None
",Resolved,Fixed,3.19.0,Thomas Diesler,Thomas Diesler,0,1,2022-05-31 11:33:48+00:00,2022-07-15 07:58:15+00:00,"With Nessus Aries we explore aspects of digital identy and verifiable credentials based on Hyperledger Aries.


Who is going to control our digitial identity? Digital forms of our birth certificate, passport, drivers license, medical records, vaccination certificates, univeristy degrees, property certificates, etc. Is it the state, a corporation or should we be in control ourselves?


https://github.com/tdiesler/nessus-aries","tdiesler:1653975258:2022-05-31T13:34:18.494+0000:1653976043:2022-05-31T13:47:23.511+0000:The component preview is currently in [branch CAMEL-18156|https://github.com/tdiesler/camel/tree/CAMEL-18156/components/camel-hyperledger-aries]

This is now waiting on the [ACA-Py 0.7.4|https://github.com/hyperledger/aries-cloudagent-python] release, the associated [Java client|https://github.com/hyperledger-labs/acapy-java-client] release and [Nessus Aries|https://github.com/tdiesler/nessus-aries] release.

Here are the [docs|https://github.com/tdiesler/camel/blob/CAMEL-18156/components/camel-hyperledger-aries/src/main/docs/hyperledger-aries-component.adoc] ...
tdiesler:1656983075:2022-07-05T09:04:35.923+0000:1656983075:2022-07-05T09:04:35.923+0000:PR: https://github.com/apache/camel/pull/7973"
0,CAMEL-18155,Improvement,Minor,None,3.19.0,"
None
",Resolved,Fixed,3.19.0,Unassigned,Claus Ibsen,0,1,2022-05-31 08:42:17+00:00,2022-09-03 14:46:20+00:00,"if you run


camel build


then it has a number of sub commands, but you cant seem them, you have to run


camel build --help


lets see if we can show the sub commands when you just run
camel build",
0,CAMEL-18154,Dependency upgrade,Major,None,3.18.0,"
None
",Resolved,Fixed,3.18.0,Claus Ibsen,Claus Ibsen,0,1,2022-05-30 18:57:32+00:00,2022-05-31 08:41:06+00:00,For camel-jbang and others it would be better to capture all dependencies instead of only what was downloaded due not already on cp,
0,CAMEL-18153,Dependency upgrade,Major,None,3.18.0,"
None
",Resolved,Fixed,3.18.0,Claus Ibsen,Claus Ibsen,0,1,2022-05-30 16:47:04+00:00,2022-05-31 18:47:34+00:00,No Desc,
0,CAMEL-18152,Task,Major,None,None,"
None
",Resolved,Fixed,3.19.0,Otavio Rodolfo Piske,Otavio Rodolfo Piske,0,1,2022-05-30 09:40:46+00:00,2022-10-07 12:24:04+00:00,"Currently, we have to write a configuration file for the adapter to be loaded. Ideally, we could check during build if the consumer implements resumableaware of if an adapter is in the component build path, and then generate the file.",orpiske:1658889975:2022-07-27T10:46:15.325+0000:1658889975:2022-07-27T10:46:15.325+0000:Merged with the linked PR.
0,CAMEL-18151,New Feature,Major,None,3.18.0,"
None
",Resolved,Fixed,3.18.0,Claus Ibsen,Claus Ibsen,0,1,2022-05-30 07:29:17+00:00,2022-06-17 13:34:32+00:00,No Desc,"davsclaus:1653959564:2022-05-31T09:12:44.316+0000:1654139444:2022-06-02T11:10:44.958+0000:TODO: spring-boot *DONE*
TODO: quarkus *DONE*
TODO: standalone *DONE*
davsclaus:1653960425:2022-05-31T09:27:05.526+0000:1653992241:2022-05-31T18:17:21.697+0000:TODO: if using out of the box kamelets we should include the camel-kamelets-catalog *DONE*
davsclaus:1654053223:2022-06-01T11:13:43.185+0000:1654062324:2022-06-01T13:45:24.375+0000:TODO: move xml,yaml files etc to src/man/resources/camel  *DONE*
davsclaus:1654063234:2022-06-01T14:00:34.247+0000:1655442002:2022-06-17T13:00:02.824+0000:TODO: Add option to copy mvn wrapper files *DONE*
TODO: Add option to chose maven or gradle
TODO: Add option to add 3rd party maven repository to pom *DONE*
davsclaus:1654152301:2022-06-02T14:45:01.272+0000:1654492051:2022-06-06T13:07:31.742+0000:TODO: detect kamelet dependencies more eager (eg postman demo requires docker-compose running to connect to kafka) *DONE*
TODO: local.properties should be merged into application.properties for quarkus (and lets do the same for spring boot) *DONE*
TODO: Filter out duplicate dependencies in generated pom.xml *DONE*
TODO: BaseExport command for common shared code *DONE*
davsclaus:1654661842:2022-06-08T12:17:22.826+0000:1654732197:2022-06-09T07:49:57.182+0000:TODO: Add option to log output of silent run that can be used for trouble shooting *DONE*
davsclaus:1655412333:2022-06-17T04:45:33.904+0000:1655440565:2022-06-17T12:36:05.553+0000:TODO: camel export to read from properties which runtime and gav to use *DONE*"
0,CAMEL-18150,Improvement,Major,None,3.18.0,"
None
",Resolved,Fixed,3.18.0,Claus Ibsen,Claus Ibsen,0,2,2022-05-29 07:24:32+00:00,2022-06-28 08:51:20+00:00,Events currently does not have any timestamp when they were fired. This information can be useful for tooling that displays events so users can see when it happened.,"davsclaus:1656377480:2022-06-28T08:51:20.192+0000:1656377480:2022-06-28T08:51:20.192+0000:Added option you can turn on to enable this

camelEventsTimestampEnabled"
0,CAMEL-18149,New Feature,Major,None,3.18.0,"
None
",Resolved,Workaround,3.18.0,Claus Ibsen,Claus Ibsen,0,1,2022-05-27 10:33:07+00:00,2022-06-22 12:49:15+00:00,"in camel-kamelet-main we have a basic developer console, but we should move this to a generic camel-platform-http so it can be reused in other places like on camel spring boot.","davsclaus:1655873339:2022-06-22T12:48:59.488+0000:1655873339:2022-06-22T12:48:59.488+0000:Added developer console to camel spring boot, see the camel-console docs"
0,CAMEL-18148,Task,Major,3.17.0,3.20.0,"
None
",Resolved,Fixed,3.20.0,Otavio Rodolfo Piske,Otavio Rodolfo Piske,0,1,2022-05-27 09:59:19+00:00,2022-11-03 17:25:18+00:00,"The serialization process for the offset data is very simple and does not allow us to implement more elaborate resume processes, observability and other features.","orpiske:1656403267:2022-06-28T16:01:07.385+0000:1656403267:2022-06-28T16:01:07.385+0000:I pushed this one to 3.19. I am still investigating the best approach for it.
orpiske:1666759298:2022-10-26T12:41:38.776+0000:1666759298:2022-10-26T12:41:38.776+0000:All the code related to the serialization has been adjusted to be cleaner, faster and more extensible. This should allow us to implement more complex features in the resume API."
0,CAMEL-18147,New Feature,Minor,None,,"
None
",Resolved,Fixed,None,Unassigned,Federico Mariani,0,2,2022-05-27 09:49:04+00:00,2022-06-06 08:59:55+00:00,Add an example for camel-master using camel-kubernetes-starter,Federico Mariani:1653616183:2022-05-27T09:49:43.622+0000:1653616183:2022-05-27T09:49:43.622+0000:[~mcarlett] [https://github.com/apache/camel-spring-boot-examples/pull/65] 
0,CAMEL-18146,Bug,Major,3.17.0,3.18.0,"
None
",Resolved,Fixed,3.18.0,Claus Ibsen,Jake Mehring,0,2,2022-05-26 18:12:31+00:00,2022-05-31 17:24:10+00:00,"This property was changed from being defaulted if null to being defaulted if null or empty in the 3.17 release. Currently the only way to disable server host name verification is to pass the Kafka consumer an empty string which is impossible after that change.


 


Relevant Code: https://github.com/apache/camel/blob/main/components/camel-kafka/src/main/java/org/apache/camel/component/kafka/KafkaConfiguration.java#L436


Relevant Docs: https://docs.confluent.io/platform/current/kafka/authentication_ssl.html#optional-settings


 


Solution is just to revert addPropertyIfNotEmpty to be addPropertyIfNotNull for this property.","davsclaus:1653989032:2022-05-31T17:23:52.270+0000:1653989032:2022-05-31T17:23:52.270+0000:You can now use ""none"" or ""false"" to disable this"
0,CAMEL-18145,Test,Minor,3.18.0,4.x,"
None
",Open,Unresolved,4.x,Andrea Cosentino,Claus Ibsen,0,1,2022-05-26 11:53:37+00:00,2023-08-09 09:09:12+00:00,"Message History (source location and message history is disabled)
---------------------------------------------------------------------------------------------------------------------------------------
Source                                   ID                             Processor                                          Elapsed (ms)
                                         route6/route6                  from[direct://rotateSecret]                                  29
	...
                                         route6/to8                     aws-secrets-manager://test?operation=rotateSecret             0


Stacktrace
---------------------------------------------------------------------------------------------------------------------------------------
software.amazon.awssdk.services.secretsmanager.model.ResourceNotFoundException: Lambda does not exist or could not be accessed (Service: SecretsManager, Status Code: 400, Request ID: KYCVGVN52HR0PX630EFH1HN44VH32JHHJC8DOFTB0GWO9LHG4OIO)
	at software.amazon.awssdk.core.internal.http.CombinedResponseHandler.handleErrorResponse(CombinedResponseHandler.java:125) ~[sdk-core-2.17.198.jar:?]
	at software.amazon.awssdk.core.internal.http.CombinedResponseHandler.handleResponse(CombinedResponseHandler.java:82) ~[sdk-core-2.17.198.jar:?]
	at software.amazon.awssdk.core.internal.http.CombinedResponseHandler.handle(CombinedResponseHandler.java:60) ~[sdk-core-2.17.198.jar:?]
	at software.amazon.awssdk.core.internal.http.CombinedResponseHandler.handle(CombinedResponseHandler.java:41) ~[sdk-core-2.17.198.jar:?]
	at software.amazon.awssdk.core.internal.http.pipeline.stages.HandleResponseStage.execute(HandleResponseStage.java:40) ~[sdk-core-2.17.198.jar:?]
	at software.amazon.awssdk.core.internal.http.pipeline.stages.HandleResponseStage.execute(HandleResponseStage.java:30) ~[sdk-core-2.17.198.jar:?]
	at software.amazon.awssdk.core.internal.http.pipeline.RequestPipelineBuilder$ComposingRequestPipelineStage.execute(RequestPipelineBuilder.java:206) ~[sdk-core-2.17.198.jar:?]
	at software.amazon.awssdk.core.internal.http.pipeline.stages.ApiCallAttemptTimeoutTrackingStage.execute(ApiCallAttemptTimeoutTrackingStage.java:73) ~[sdk-core-2.17.198.jar:?]
	at software.amazon.awssdk.core.internal.http.pipeline.stages.ApiCallAttemptTimeoutTrackingStage.execute(ApiCallAttemptTimeoutTrackingStage.java:42) ~[sdk-core-2.17.198.jar:?]
	at software.amazon.awssdk.core.internal.http.pipeline.stages.TimeoutExceptionHandlingStage.execute(TimeoutExceptionHandlingStage.java:78) ~[sdk-core-2.17.198.jar:?]
	at software.amazon.awssdk.core.internal.http.pipeline.stages.TimeoutExceptionHandlingStage.execute(TimeoutExceptionHandlingStage.java:40) ~[sdk-core-2.17.198.jar:?]
	at software.amazon.awssdk.core.internal.http.pipeline.stages.ApiCallAttemptMetricCollectionStage.execute(ApiCallAttemptMetricCollectionStage.java:50) ~[sdk-core-2.17.198.jar:?]
	at software.amazon.awssdk.core.internal.http.pipeline.stages.ApiCallAttemptMetricCollectionStage.execute(ApiCallAttemptMetricCollectionStage.java:36) ~[sdk-core-2.17.198.jar:?]
	at software.amazon.awssdk.core.internal.http.pipeline.stages.RetryableStage.execute(RetryableStage.java:81) ~[sdk-core-2.17.198.jar:?]
	at software.amazon.awssdk.core.internal.http.pipeline.stages.RetryableStage.execute(RetryableStage.java:36) ~[sdk-core-2.17.198.jar:?]
	at software.amazon.awssdk.core.internal.http.pipeline.RequestPipelineBuilder$ComposingRequestPipelineStage.execute(RequestPipelineBuilder.java:206) ~[sdk-core-2.17.198.jar:?]
	at software.amazon.awssdk.core.internal.http.StreamManagingStage.execute(StreamManagingStage.java:56) ~[sdk-core-2.17.198.jar:?]
	at software.amazon.awssdk.core.internal.http.StreamManagingStage.execute(StreamManagingStage.java:36) ~[sdk-core-2.17.198.jar:?]
	at software.amazon.awssdk.core.internal.http.pipeline.stages.ApiCallTimeoutTrackingStage.executeWithTimer(ApiCallTimeoutTrackingStage.java:80) ~[sdk-core-2.17.198.jar:?]
	at software.amazon.awssdk.core.internal.http.pipeline.stages.ApiCallTimeoutTrackingStage.execute(ApiCallTimeoutTrackingStage.java:60) ~[sdk-core-2.17.198.jar:?]
	at software.amazon.awssdk.core.internal.http.pipeline.stages.ApiCallTimeoutTrackingStage.execute(ApiCallTimeoutTrackingStage.java:42) ~[sdk-core-2.17.198.jar:?]
	at software.amazon.awssdk.core.internal.http.pipeline.stages.ApiCallMetricCollectionStage.execute(ApiCallMetricCollectionStage.java:48) ~[sdk-core-2.17.198.jar:?]
	at software.amazon.awssdk.core.internal.http.pipeline.stages.ApiCallMetricCollectionStage.execute(ApiCallMetricCollectionStage.java:31) ~[sdk-core-2.17.198.jar:?]
	at software.amazon.awssdk.core.internal.http.pipeline.RequestPipelineBuilder$ComposingRequestPipelineStage.execute(RequestPipelineBuilder.java:206) ~[sdk-core-2.17.198.jar:?]
	at software.amazon.awssdk.core.internal.http.pipeline.RequestPipelineBuilder$ComposingRequestPipelineStage.execute(RequestPipelineBuilder.java:206) ~[sdk-core-2.17.198.jar:?]
	at software.amazon.awssdk.core.internal.http.pipeline.stages.ExecutionFailureExceptionReportingStage.execute(ExecutionFailureExceptionReportingStage.java:37) ~[sdk-core-2.17.198.jar:?]
	at software.amazon.awssdk.core.internal.http.pipeline.stages.ExecutionFailureExceptionReportingStage.execute(ExecutionFailureExceptionReportingStage.java:26) ~[sdk-core-2.17.198.jar:?]
	at software.amazon.awssdk.core.internal.http.AmazonSyncHttpClient$RequestExecutionBuilderImpl.execute(AmazonSyncHttpClient.java:193) ~[sdk-core-2.17.198.jar:?]
	at software.amazon.awssdk.core.internal.handler.BaseSyncClientHandler.invoke(BaseSyncClientHandler.java:103) ~[sdk-core-2.17.198.jar:?]
	at software.amazon.awssdk.core.internal.handler.BaseSyncClientHandler.doExecute(BaseSyncClientHandler.java:167) ~[sdk-core-2.17.198.jar:?]
	at software.amazon.awssdk.core.internal.handler.BaseSyncClientHandler.lambda$execute$1(BaseSyncClientHandler.java:82) ~[sdk-core-2.17.198.jar:?]
	at software.amazon.awssdk.core.internal.handler.BaseSyncClientHandler.measureApiCallSuccess(BaseSyncClientHandler.java:175) ~[sdk-core-2.17.198.jar:?]
	at software.amazon.awssdk.core.internal.handler.BaseSyncClientHandler.execute(BaseSyncClientHandler.java:76) ~[sdk-core-2.17.198.jar:?]
	at software.amazon.awssdk.core.client.handler.SdkSyncClientHandler.execute(SdkSyncClientHandler.java:45) ~[sdk-core-2.17.198.jar:?]
	at software.amazon.awssdk.awscore.client.handler.AwsSyncClientHandler.execute(AwsSyncClientHandler.java:56) ~[aws-core-2.17.198.jar:?]
	at software.amazon.awssdk.services.secretsmanager.DefaultSecretsManagerClient.rotateSecret(DefaultSecretsManagerClient.java:1785) ~[secretsmanager-2.17.198.jar:?]
	at org.apache.camel.component.aws.secretsmanager.SecretsManagerProducer.rotateSecret(SecretsManagerProducer.java:297) ~[classes/:?]
	at org.apache.camel.component.aws.secretsmanager.SecretsManagerProducer.process(SecretsManagerProducer.java:87) ~[classes/:?]",
0,CAMEL-18144,Dependency upgrade,Minor,3.17.0,3.18.0,"
None
",Resolved,Fixed,3.18.0,Unassigned,Andreas Klug,0,1,2022-05-25 15:05:18+00:00,2022-05-26 10:17:50+00:00,"Update Eclipse Milo from 0.3.7 to 0.6.6.


Out of my perspective, there were significant changes, especially the timing of the notifications (client subscription) seems to behave slightly different using Eclipse Milo 0.6.6 (or is subject to a misunderstanding on my side), e.g. there is an additional, early notification with a node value ""null"" after route-startup, as at this time the node value hasn't been set yet. I saw these kind of timing issues with 0.3.7, too, but less often. In order to avoid changing the unit tests too much, I introduced a new omitNullValues parameter on the client endpoint, which defaults to ""true"" in order to avoid that notification and to avoid flaking unit tests, too.


Would be great if somebody out there with experience with Eclipse Milo could test that in specific scenarios, too.",
0,CAMEL-18143,Improvement,Minor,3.17.0,3.19.0,"
None
",Resolved,Fixed,3.19.0,Claus Ibsen,Joe Siponen,0,1,2022-05-25 06:24:14+00:00,2022-09-06 05:16:38+00:00,"I suggest that the scheduler option is autowired for the quartz component.


The instructions for the QUARKUS BASED configuration of the quartz-component seems to (implicitly) assume that it is:


https://camel.apache.org/camel-quarkus/2.7.x/reference/extensions/quartz.html


However, the documentation does not mark scheduler as being autowired so the quarkus based documentation is not correct as it leaves out the part required for wiring the quarkus provided scheduler with camel's quartz component.


However, one could argue that the sceduler should be autowired in order to reduce the necessity for boilerplate code when there is clear candidate for autowiring.",
0,CAMEL-18142,New Feature,Minor,3.17.0,,"
None
",Resolved,Invalid,None,Unassigned,Rafał Gała,0,2,2022-05-25 06:00:35+00:00,2022-05-25 07:28:17+00:00,"I have a question regarding changes in PollExceptionStrategy interface. Currently I have my own PollExceptionStrategy implementation that look like this:


 


 




    @Override
    public PollOnError handleException(Exception exception) {
      if (exception instanceof TopicAuthorizationException) {
        return PollOnError.STOP;
      } else {         
        return PollOnError.RETRY;
      }
    }



 


 


How can I achieve the same with the new interface version? The handle method now returns void and canContinue method is not aware of the exception so it is not possible to return false in case of TopicAuthorizationException and true in case of any others.","davsclaus:1653434897:2022-05-25T07:28:17.088+0000:1653434897:2022-05-25T07:28:17.088+0000:Please ask on user mailing list, or the zulip chat room"
0,CAMEL-18141,Improvement,Major,None,3.18.0,"
None
",Resolved,Fixed,3.18.0,Nicolas Filotto,Claus Ibsen,0,2,2022-05-24 12:11:39+00:00,2022-06-21 12:56:08+00:00,"Now that every component has marked up the headers it supports, we can use that to generate fluent builders in camel-endpointdsl.


This makes it easier to use from this, as you do not need to have the camel-xxx JAR on the classpath and setup in your editor. And you dont need to remember the class name of the class having the headers etc.


from xxx
   setHeader(file().fileName(), constant(""foo.txt""))
   setHeader(karaf().patititionKey(), constant(""3""))","davsclaus:1653365664:2022-05-24T12:14:24.904+0000:1653365664:2022-05-24T12:14:24.904+0000:[~essobedo] something to look at that can make endpoint-dsl more awesome.

This means that the endpoint-dsl adds some special methods in Java DSL where headers are in use, such as setHeader, because the methods today take a String as key.
But we need a special type so the endpoint-dsl and java compiler can show the list of possible headers. Like we do for endpoint options
nfilotto:1653366277:2022-05-24T12:24:37.058+0000:1653366277:2022-05-24T12:24:37.058+0000:I see that makes sense indeed, I can have look after the improvements in the plugins
nfilotto:1655776725:2022-06-21T09:58:45.191+0000:1655776725:2022-06-21T09:58:45.191+0000:The corresponding PR https://github.com/apache/camel/pull/7839"
0,CAMEL-18140,New Feature,Minor,None,3.x,"
None
",Resolved,Won't Fix,3.x,Unassigned,Claus Ibsen,0,1,2022-05-24 08:35:14+00:00,2023-01-04 11:56:19+00:00,"Lets see if we can resolve dependencies using jitpack style
https://camel.apache.org/camel-k/1.9.x/configuration/dependencies.html#dependencies-kind-jitpack",
0,CAMEL-18109,Improvement,Major,None,3.17.0,"
None
",Resolved,Fixed,3.17.0,Claus Ibsen,Claus Ibsen,0,1,2022-05-13 08:17:56+00:00,2022-05-13 09:50:56+00:00,"In Camel 3.15 we fixed the route model in yaml dsl to be aligned to the core model DSL.


However this meant that a route ""steps"" was moved into its correct place, as child to a from.


However Camel K users will struggle to migrate, so lets make the yaml-dsl parser able to detect the old style and auto-correct this and log a WARN about deprecated style in use.",
0,CAMEL-18108,New Feature,Minor,3.16.0,3.x,"
None
",Resolved,Abandoned,3.x,Unassigned,Roland Huss,0,1,2022-05-13 06:38:10+00:00,2023-08-09 09:09:37+00:00,"Since Twitter IDs as unsigned 64-bit integer values that cannot be handled fully by JavaScript, the exposed id field as an integer can not be sealed with JavaScript. Twitter has a id_str field in its REST API, however, Twitter4J does not add this field to its response.


Also, since Twitter4J seems to refuse to add this field, it would be great if Camel could re-add it to its Twitter-related components. 


For a quick fix, I also created https://github.com/apache/camel-kamelets/issues/925 so that this issue could be circumvented on the Camel-K level for Kamelet users.",
0,CAMEL-18107,Dependency upgrade,Minor,None,3.17.0,"
None
",Resolved,Fixed,3.17.0,Unassigned,Claus Ibsen,0,1,2022-05-13 05:31:57+00:00,2022-05-13 09:23:20+00:00,No Desc,
0,CAMEL-18106,Improvement,Major,None,3.17.0,"
None
",Resolved,Fixed,3.17.0,Claus Ibsen,Claus Ibsen,0,1,2022-05-12 20:19:33+00:00,2022-05-13 10:21:23+00:00,"We can optimize when the exchange has not custom charset name, then we can use Charset UTF8 as the default which is quicker than UTF-8 as string literal.


Because this would return a Charset vs String then the internals of camel-core need to be adjusted for this optimization.


Especially in type converters this can help.",
0,CAMEL-18105,Improvement,Minor,None,3.x,"
None
",Resolved,Won't Fix,3.x,Unassigned,Claus Ibsen,0,1,2022-05-12 15:43:42+00:00,2022-09-03 12:30:45+00:00,"You may mistakenly have spaces in a #bean reference in yaml-dsl where the value must be entered as string literal, with single or double quotes




    - key: prefetchPolicy
            value: '#bean:{{sourcePrefetchPolicyBean}}   '




There are spaces after the }} in the example above",
0,CAMEL-18104,Improvement,Minor,None,3.17.0,"
None
",Resolved,Fixed,3.17.0,Claus Ibsen,Andrea Tarocchi,0,2,2022-05-12 15:21:28+00:00,2022-05-20 14:20:08+00:00,"for all the types that have a from string converter would be nice to provide an alternative that from byte[] converts to string and from string to the type basically cascading byte[] to string converter and string to type converter.


It is useful for all the conversions in headers coming from kafka topics since they usually come as byte[]","davsclaus:1652907882:2022-05-19T05:04:42.178+0000:1652907882:2022-05-19T05:04:42.178+0000:There is a test failure in camel-kafka - that was impacted by this
davsclaus:1652919070:2022-05-19T08:11:10.632+0000:1652919070:2022-05-19T08:11:10.632+0000:Okay so the test failures in camel-kafka in KafkaProducerFullIT was in fact a test that assigned a partion key as byte array but that was not in use as it was not converter to Integer and as such kafka would not use a specific partition and so the test worked.
Fixing the test to use partition 0 like the other tests then works."
0,CAMEL-18103,Task,Minor,2.25.4,None,"
None
",Resolved,Won't Fix,None,Unassigned,Perennec,0,2,2022-05-12 13:46:28+00:00,2022-05-12 20:20:34+00:00,"It seems that the binary deliverables for the version 2.25.4 of apache-camel are missing on mvn central (and therefore prevents the integration in our products of this version).


The artefact org.apache.camel:apache-camel:tar.gz:2.25.4 was available for 2.25.3 but is missing in the expected location hereafter :


https://repo1.maven.org/maven2/org/apache/camel/apache-camel/2.25.4/",davsclaus:1652358034:2022-05-12T20:20:34.322+0000:1652358034:2022-05-12T20:20:34.322+0000:Camel 2.x is EOL
0,CAMEL-18102,Dependency upgrade,Major,None,3.17.0,"
None
",Resolved,Fixed,3.17.0,James Netherton,James Netherton,0,1,2022-05-12 10:15:15+00:00,2022-05-12 11:53:29+00:00,The project is currently aligned to a Google Cloud libraries-bom version (16.3.0) that is more than 12 months old. We should try to upgrade to the latest 25.2.0 release in the main project and in camel-karaf.,
0,CAMEL-18101,Bug,Major,"3.14.3, 3.16.0","3.14.4, 3.17.0","
None
",Resolved,Fixed,"3.14.4, 3.17.0",Claus Ibsen,Claus Ibsen,0,1,2022-05-12 08:35:37+00:00,2022-05-12 08:56:34+00:00,No Desc,
0,CAMEL-18100,Bug,Major,3.17.0,3.17.0,"
None
",Resolved,Fixed,3.17.0,Claus Ibsen,Claus Ibsen,0,1,2022-05-11 19:49:50+00:00,2022-05-20 11:40:50+00:00,"java.lang.NoClassDefFoundError: org/apache/camel/resume/ResumeStrategy
	at java.lang.Class.getDeclaredMethods0(Native Method) ~[?:?]
	at java.lang.Class.privateGetDeclaredMethods(Class.java:3166) ~[?:?]
	at java.lang.Class.getDeclaredMethod(Class.java:2473) ~[?:?]
	at com.sun.xml.bind.v2.model.nav.ReflectionNavigator$10.run(ReflectionNavigator.java:595) ~[jaxb-runtime-2.3.3.jar:2.3.3]
	at com.sun.xml.bind.v2.model.nav.ReflectionNavigator$10.run(ReflectionNavigator.java:588) ~[jaxb-runtime-2.3.3.jar:2.3.3]
	at java.security.AccessController.doPrivileged(Native Method) ~[?:?]
	at com.sun.xml.bind.v2.model.nav.ReflectionNavigator.isOverriding(ReflectionNavigator.java:587) ~[jaxb-runtime-2.3.3.jar:2.3.3]
	at com.sun.xml.bind.v2.model.nav.ReflectionNavigator.isOverriding(ReflectionNavigator.java:34) ~[jaxb-runtime-2.3.3.jar:2.3.3]
	at com.sun.xml.bind.v2.model.impl.ClassInfoImpl.findGetterSetterProperties(ClassInfoImpl.java:943) ~[jaxb-runtime-2.3.3.jar:2.3.3]
	at com.sun.xml.bind.v2.model.impl.ClassInfoImpl.getProperties(ClassInfoImpl.java:283) ~[jaxb-runtime-2.3.3.jar:2.3.3]
	at com.sun.xml.bind.v2.model.impl.RuntimeClassInfoImpl.getProperties(RuntimeClassInfoImpl.java:156) ~[jaxb-runtime-2.3.3.jar:2.3.3]
	at com.sun.xml.bind.v2.model.impl.ModelBuilder.getClassInfo(ModelBuilder.java:231) ~[jaxb-runtime-2.3.3.jar:2.3.3]
	at com.sun.xml.bind.v2.model.impl.RuntimeModelBuilder.getClassInfo(RuntimeModelBuilder.java:73) ~[jaxb-runtime-2.3.3.jar:2.3.3]
	at com.sun.xml.bind.v2.model.impl.RuntimeModelBuilder.getClassInfo(RuntimeModelBuilder.java:54) ~[jaxb-runtime-2.3.3.jar:2.3.3]
	at com.sun.xml.bind.v2.model.impl.ModelBuilder.getClassInfo(ModelBuilder.java:197) ~[jaxb-runtime-2.3.3.jar:2.3.3]
	at com.sun.xml.bind.v2.model.impl.RuntimeModelBuilder.getClassInfo(RuntimeModelBuilder.java:68) ~[jaxb-runtime-2.3.3.jar:2.3.3]
	at com.sun.xml.bind.v2.model.impl.RuntimeModelBuilder.getClassInfo(RuntimeModelBuilder.java:54) ~[jaxb-runtime-2.3.3.jar:2.3.3]
	at com.sun.xml.bind.v2.model.impl.ModelBuilder.getTypeInfo(ModelBuilder.java:345) ~[jaxb-runtime-2.3.3.jar:2.3.3]
	at com.sun.xml.bind.v2.model.impl.TypeRefImpl.calcRef(TypeRefImpl.java:66) ~[jaxb-runtime-2.3.3.jar:2.3.3]
	at com.sun.xml.bind.v2.model.impl.TypeRefImpl.getTarget(TypeRefImpl.java:43) ~[jaxb-runtime-2.3.3.jar:2.3.3]
	at com.sun.xml.bind.v2.model.impl.RuntimeTypeRefImpl.getTarget(RuntimeTypeRefImpl.java:32) ~[jaxb-runtime-2.3.3.jar:2.3.3]
	at com.sun.xml.bind.v2.model.impl.RuntimeTypeRefImpl.getTarget(RuntimeTypeRefImpl.java:25) ~[jaxb-runtime-2.3.3.jar:2.3.3]
	at com.sun.xml.bind.v2.model.impl.ElementPropertyInfoImpl$1.get(ElementPropertyInfoImpl.java:48) ~[jaxb-runtime-2.3.3.jar:2.3.3]
	at com.sun.xml.bind.v2.model.impl.ElementPropertyInfoImpl$1.get(ElementPropertyInfoImpl.java:46) ~[jaxb-runtime-2.3.3.jar:2.3.3]
	at java.util.AbstractList$Itr.next(AbstractList.java:371) ~[?:?]
	at com.sun.xml.bind.v2.model.impl.ModelBuilder.getClassInfo(ModelBuilder.java:245) ~[jaxb-runtime-2.3.3.jar:2.3.3]
	at com.sun.xml.bind.v2.model.impl.RuntimeModelBuilder.getClassInfo(RuntimeModelBuilder.java:73) ~[jaxb-runtime-2.3.3.jar:2.3.3]
	at com.sun.xml.bind.v2.model.impl.RuntimeModelBuilder.getClassInfo(RuntimeModelBuilder.java:54) ~[jaxb-runtime-2.3.3.jar:2.3.3]
	at com.sun.xml.bind.v2.model.impl.ModelBuilder.getClassInfo(ModelBuilder.java:197) ~[jaxb-runtime-2.3.3.jar:2.3.3]
	at com.sun.xml.bind.v2.model.impl.RuntimeModelBuilder.getClassInfo(RuntimeModelBuilder.java:68) ~[jaxb-runtime-2.3.3.jar:2.3.3]
	at com.sun.xml.bind.v2.model.impl.RuntimeModelBuilder.getClassInfo(RuntimeModelBuilder.java:54) ~[jaxb-runtime-2.3.3.jar:2.3.3]
	at com.sun.xml.bind.v2.model.impl.ModelBuilder.getTypeInfo(ModelBuilder.java:345) ~[jaxb-runtime-2.3.3.jar:2.3.3]
	at com.sun.xml.bind.v2.model.impl.ModelBuilder.getTypeInfo(ModelBuilder.java:360) ~[jaxb-runtime-2.3.3.jar:2.3.3]
	at com.sun.xml.bind.v2.runtime.JAXBContextImpl.getTypeInfoSet(JAXBContextImpl.java:444) ~[jaxb-runtime-2.3.3.jar:2.3.3]
	at com.sun.xml.bind.v2.runtime.JAXBContextImpl.<init>(JAXBContextImpl.java:282) ~[jaxb-runtime-2.3.3.jar:2.3.3]
	at com.sun.xml.bind.v2.runtime.JAXBContextImpl.<init>(JAXBContextImpl.java:109) ~[jaxb-runtime-2.3.3.jar:2.3.3]
	at com.sun.xml.bind.v2.runtime.JAXBContextImpl$JAXBContextBuilder.build(JAXBContextImpl.java:1142) ~[jaxb-runtime-2.3.3.jar:2.3.3]
	at com.sun.xml.bind.v2.ContextFactory.createContext(ContextFactory.java:141) ~[jaxb-runtime-2.3.3.jar:2.3.3]
	at com.sun.xml.bind.v2.ContextFactory.createContext(ContextFactory.java:265) ~[jaxb-runtime-2.3.3.jar:2.3.3]
	at com.sun.xml.bind.v2.JAXBContextFactory.createContext(JAXBContextFactory.java:48) ~[jaxb-runtime-2.3.3.jar:2.3.3]
	at javax.xml.bind.ContextFinder.find(ContextFinder.java:302) ~[jakarta.xml.bind-api-2.3.3.jar:2.3.3]
	at javax.xml.bind.JAXBContext.newInstance(JAXBContext.java:478) ~[jakarta.xml.bind-api-2.3.3.jar:2.3.3]
	at javax.xml.bind.JAXBContext.newInstance(JAXBContext.java:435) ~[jakarta.xml.bind-api-2.3.3.jar:2.3.3]
	at org.apache.camel.xml.jaxb.DefaultModelJAXBContextFactory.newJAXBContext(DefaultModelJAXBContextFactory.java:39) ~[?:?]
	at org.apache.camel.blueprint.handler.CamelNamespaceHandler.getJaxbContext(CamelNamespaceHandler.java:785) ~[?:?]
	at org.apache.camel.blueprint.handler.CamelNamespaceHandler.parseCamelContextNode(CamelNamespaceHandler.java:276) ~[?:?]
	at org.apache.camel.blueprint.handler.CamelNamespaceHandler.parse(CamelNamespaceHandler.java:224) ~[?:?]
	at org.apache.aries.blueprint.parser.Parser.parseCustomElement(Parser.java:1369) ~[!/:1.10.3]
	at org.apache.aries.blueprint.parser.Parser.loadComponents(Parser.java:427) ~[!/:1.10.3]
	at org.apache.aries.blueprint.parser.Parser.populate(Parser.java:331) ~[!/:1.10.3]
	at org.apache.aries.blueprint.container.BlueprintContainerImpl.doRun(BlueprintContainerImpl.java:371) [!/:1.10.3]
	at org.apache.aries.blueprint.container.BlueprintContainerImpl.run(BlueprintContainerImpl.java:298) [!/:1.10.3]
	at org.apache.aries.blueprint.container.BlueprintExtender.createContainer(BlueprintExtender.java:335) [!/:1.10.3]
	at org.apache.aries.blueprint.container.BlueprintExtender.createContainer(BlueprintExtender.java:288) [!/:1.10.3]
	at org.apache.aries.blueprint.container.BlueprintExtender.createContainer(BlueprintExtender.java:284) [!/:1.10.3]
	at org.apache.aries.blueprint.container.BlueprintExtender.modifiedBundle(BlueprintExtender.java:274) [!/:1.10.3]
	at org.apache.aries.util.tracker.hook.BundleHookBundleTracker$Tracked.customizerModified(BundleHookBundleTracker.java:500) [!/:1.10.3]
	at org.apache.aries.util.tracker.hook.BundleHookBundleTracker$Tracked.customizerModified(BundleHookBundleTracker.java:433) [!/:1.10.3]
	at org.apache.aries.util.tracker.hook.BundleHookBundleTracker$AbstractTracked.track(BundleHookBundleTracker.java:725) [!/:1.10.3]
	at org.apache.aries.util.tracker.hook.BundleHookBundleTracker$Tracked.bundleChanged(BundleHookBundleTracker.java:463) [!/:1.10.3]
	at org.apache.aries.util.tracker.hook.BundleHookBundleTracker$BundleEventHook.event(BundleHookBundleTracker.java:422) [!/:1.10.3]
	at org.apache.felix.framework.util.SecureAction.invokeBundleEventHook(SecureAction.java:1180) [org.apache.felix.framework-6.0.5.jar:?]
	at org.apache.felix.framework.EventDispatcher.createWhitelistFromHooks(EventDispatcher.java:730) [org.apache.felix.framework-6.0.5.jar:?]
	at org.apache.felix.framework.EventDispatcher.fireBundleEvent(EventDispatcher.java:485) [org.apache.felix.framework-6.0.5.jar:?]
	at org.apache.felix.framework.Felix.fireBundleEvent(Felix.java:4817) [org.apache.felix.framework-6.0.5.jar:?]
	at org.apache.felix.framework.Felix.startBundle(Felix.java:2336) [org.apache.felix.framework-6.0.5.jar:?]
	at org.apache.felix.framework.BundleImpl.start(BundleImpl.java:998) [org.apache.felix.framework-6.0.5.jar:?]
	at org.apache.felix.fileinstall.internal.DirectoryWatcher.startBundle(DirectoryWatcher.java:1260) [!/:3.7.4]
	at org.apache.felix.fileinstall.internal.DirectoryWatcher.startBundles(DirectoryWatcher.java:1233) [!/:3.7.4]
	at org.apache.felix.fileinstall.internal.DirectoryWatcher.doProcess(DirectoryWatcher.java:520) [!/:3.7.4]
	at org.apache.felix.fileinstall.internal.DirectoryWatcher.process(DirectoryWatcher.java:365) [!/:3.7.4]
	at org.apache.felix.fileinstall.internal.DirectoryWatcher.run(DirectoryWatcher.java:316) [!/:3.7.4]
Caused by: java.lang.ClassNotFoundException: org.apache.camel.resume.ResumeStrategy
	at java.net.URLClassLoader.findClass(URLClassLoader.java:476) ~[?:?]
	at java.lang.ClassLoader.loadClass(ClassLoader.java:589) ~[?:?]
	at java.lang.ClassLoader.loadClass(ClassLoader.java:522) ~[?:?]
	at org.apache.felix.framework.BundleWiringImpl.doImplicitBootDelegation(BundleWiringImpl.java:1785) ~[?:?]
	at org.apache.felix.framework.BundleWiringImpl.tryImplicitBootDelegation(BundleWiringImpl.java:1714) ~[?:?]
	at org.apache.felix.framework.BundleWiringImpl.searchDynamicImports(BundleWiringImpl.java:1667) ~[?:?]
	at org.apache.felix.framework.BundleWiringImpl.findClassOrResourceByDelegation(BundleWiringImpl.java:1543) ~[?:?]
	at org.apache.felix.framework.BundleWiringImpl.access$300(BundleWiringImpl.java:78) ~[?:?]
	at org.apache.felix.framework.BundleWiringImpl$BundleClassLoader.loadClass(BundleWiringImpl.java:1950) ~[?:?]
	at java.lang.ClassLoader.loadClass(ClassLoader.java:522) ~[?:?]
	at org.apache.felix.framework.BundleWiringImpl.getClassByDelegation(BundleWiringImpl.java:1343) ~[?:?]
	at org.apache.felix.framework.BundleWiringImpl.searchImports(BundleWiringImpl.java:1586) ~[?:?]
	at org.apache.felix.framework.BundleWiringImpl.findClassOrResourceByDelegation(BundleWiringImpl.java:1516) ~[?:?]
	at org.apache.felix.framework.BundleWiringImpl.access$300(BundleWiringImpl.java:78) ~[?:?]
	at org.apache.felix.framework.BundleWiringImpl$BundleClassLoader.loadClass(BundleWiringImpl.java:1950) ~[?:?]
	at java.lang.ClassLoader.loadClass(ClassLoader.java:522) ~[?:?]","davsclaus:1652270563:2022-05-11T20:02:43.488+0000:1652270563:2022-05-11T20:02:43.488+0000:Ah it looks like we have split/duplicate packages

org.apache.camel.resume                                │ 3.17.0          │ 59  │ org.apache.camel.camel-api
org.apache.camel.resume                                │ 3.17.0.SNAPSHOT │ 92  │ org.apache.camel.camel-support"
0,CAMEL-18099,New Feature,Major,3.16.0,3.18.0,"

enhancement

",Resolved,Fixed,3.18.0,Unassigned,Hugo Veillette,0,2,2022-05-11 16:59:36+00:00,2022-05-18 05:57:15+00:00,"The ""Azure storage blob service"" Camel component only supports access key as mean of access authorization. This strategy is discouraged according to MS. 


https://docs.microsoft.com/en-us/azure/storage/common/authorize-data-access?toc=%2Fazure%2Fstorage%2Fblobs%2Ftoc.json#understand-authorization-for-data-operations


Microsoft recommends that you disallow Shared Key authorization for your storage account.


The MS Azure blob library, in combination with Azure-Identity library, enable preferred means to authenticate to a blob storage.  Namely, SAS token and Azure Identity.


This issue is a feature request to add support for recommended options (SAS and Azure Identity)  to the Camel  ""Azure storage blob service"" component.


Suggestion is to default to the ""DefaultAzureCredentialBuilder"" when no specific authorization strategy is provided.


azure-sdk-for-java/README.md at main · Azure/azure-sdk-for-java (github.com)",davsclaus:1652824635:2022-05-18T05:57:15.701+0000:1652824635:2022-05-18T05:57:15.701+0000:Thanks for reporting and the PR
0,CAMEL-18098,Improvement,Major,None,3.17.0,"
None
",Resolved,Fixed,3.17.0,Claus Ibsen,Claus Ibsen,0,1,2022-05-11 13:24:02+00:00,2022-05-11 14:06:15+00:00,"Add new option to allow to spool to disk.


As spooling to disk requires that the volume have space and the user has permission to write to disk etc. For container workloads this is not always the case.


And stream caching is useable for ensuring that the message body can be re-read when camel components return data as InputStream that are only readable once.",davsclaus:1652247655:2022-05-11T13:40:55.908+0000:1652249175:2022-05-11T14:06:15.022+0000:TODO: spring boot option *DONE*
0,CAMEL-18097,Bug,Minor,3.14.2,3.x,"
None
",Resolved,Information Provided,3.x,Andrea Cosentino,Oreste Creolese,0,2,2022-05-11 09:56:43+00:00,2023-08-09 09:10:18+00:00,"Our goal is to no longer access AWS endpoints via a custom proxy but to access them via VPC endpoints from AWS. To make this work in our secured network we use our own VPC endpoints which we configure with the option: uri-endpoint-override (string) and override-endpoint (boolean). Now the problem is that the options are not used at all and the application always uses the default endpoints which have no access in our network. Because of this the STS component can't execute a HTTP request.


And in the console the following error message appears:




 
Unable to execute HTTP request: Connect to sts.eu-central-1.amazonaws.com:443 [sts.eu-central-1.amazonaws.com/54.239.54.207] failed: Connect timed out, ContainerCredentialsProvider(): Cannot fetch credentials from container - neither AWS_CONTAINER_CREDENTIALS_FULL_URI or AWS_CONTAINER_CREDENTIALS_RELATIVE_URI environment variables are set




As taken from the error message, the default endpoint sts.eu-central-1.amazonaws.com:443 is used.


This is how our application.properties looks in which the options are set:




camel.component.aws2-sts.override-endpoint=true camel.component.aws2-sts.uri-endpoint-override=https://vpce-???-???.sts.eu central1.vpce.amazonaws.com



We are using the following versions:



Apache Camel 3.14.2
Spring Boot 2.5.10



Dependencies




    <properties>
    <java.version>14</java.version>
    <camel.version>3.14.2</camel.version>
    <spring-boot.version>2.5.10</spring-boot.version>
</properties>

<dependencies>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-test</artifactId>
        <scope>test</scope>
        <exclusions>
            <exclusion>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-starter-logging</artifactId>
            </exclusion>
        </exclusions>
    </dependency>
    
    <dependency>
        <groupId>org.apache.camel.springboot</groupId>
        <artifactId>camel-aws2-s3-starter</artifactId>
        <exclusions>
            <exclusion>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-starter-logging</artifactId>
            </exclusion>
        </exclusions>
    </dependency>
    
    <dependency>
        <groupId>org.apache.camel.springboot</groupId>
        <artifactId>camel-aws2-sts-starter</artifactId>
        <exclusions>
            <exclusion>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-starter-logging</artifactId>
            </exclusion>
        </exclusions>
    </dependency>

    <dependency>
        <groupId>org.apache.camel</groupId>
        <artifactId>camel-jetty</artifactId>
        <version>${camel.version}</version>
    </dependency>

    <dependency>
        <groupId>org.apache.camel</groupId>
        <artifactId>camel-json-validator</artifactId>
        <version>${camel.version}</version>
    </dependency>

</dependencies>



Info With ticket CAMEL-16171 , Camel added the usage of uri-endpoint-override and override-endpoint options attributes for all AWS components among others for STS.


Do you have any idea why the options are not overwritten? Thanks a lot for your help!","acosentino:1652847879:2022-05-18T12:24:39.214+0000:1652847879:2022-05-18T12:24:39.214+0000:Can you please show the route and your full configuration? 
acosentino:1652848053:2022-05-18T12:27:33.200+0000:1652848053:2022-05-18T12:27:33.200+0000:Another important point. Camel 3.14.2 use Spring Boot 2.6.4 while you're pointing 2.5.10. Can you please test with the correct SB version?
acosentino:1652848620:2022-05-18T12:37:00.426+0000:1652848620:2022-05-18T12:37:00.426+0000:Also if your runtime is Spring boot you should use also camel-jetty-starter and json-validator-starter. Don't mix up plain components and Spring Boot components.
acosentino:1652848957:2022-05-18T12:42:37.260+0000:1652849021:2022-05-18T12:43:41.556+0000:With an xml like this:

{code:xml}
<?xml version=""1.0"" encoding=""UTF-8""?>
<!--

    Licensed to the Apache Software Foundation (ASF) under one or more
    contributor license agreements.  See the NOTICE file distributed with
    this work for additional information regarding copyright ownership.
    The ASF licenses this file to You under the Apache License, Version 2.0
    (the ""License""); you may not use this file except in compliance with
    the License.  You may obtain a copy of the License at

         http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an ""AS IS"" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.

-->
<project xmlns=""http://maven.apache.org/POM/4.0.0"" xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance"" xsi:schemaLocation=""http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"">
    <modelVersion>4.0.0</modelVersion>
    <parent>
        <groupId>org.apache.camel.springboot.example</groupId>
        <artifactId>examples</artifactId>
        <version>3.17.0-SNAPSHOT</version>
    </parent>

    <artifactId>camel-example-spring-boot-aws2-sts</artifactId>
    <name>Camel SB Examples :: AWS2 STS</name>
    <description>An example showing the Camel AWS2 STS component with Spring Boot</description>

    <properties>
        <category>Cloud</category>
    </properties>

    <!-- Spring-Boot and Camel BOM -->
    <dependencyManagement>
        <dependencies>
            <dependency>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-dependencies</artifactId>
                <version>2.6.4</version>
                <type>pom</type>
                <scope>import</scope>
            </dependency>
            <dependency>
                <groupId>org.apache.camel.springboot</groupId>
                <artifactId>camel-spring-boot-bom</artifactId>
                <version>3.14.2</version>
                <type>pom</type>
                <scope>import</scope>
            </dependency>
        </dependencies>
    </dependencyManagement>

    <dependencies>
        <!-- Camel -->
        <dependency>
            <groupId>org.apache.camel.springboot</groupId>
            <artifactId>camel-spring-boot-starter</artifactId>
        </dependency>
        <dependency>
            <groupId>org.apache.camel.springboot</groupId>
            <artifactId>camel-aws2-sts-starter</artifactId>
        </dependency>
        <dependency>
            <groupId>org.apache.camel.springboot</groupId>
            <artifactId>camel-timer-starter</artifactId>
        </dependency>
    </dependencies>

    <build>
        <plugins>
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
                <version>2.6.4</version>
                <executions>
                    <execution>
                        <goals>
                            <goal>repackage</goal>
                        </goals>
                    </execution>
                </executions>
            </plugin>
        </plugins>
    </build>


</project>
{code}

An application.properties like this:


{code:java}
camel.component.aws2-sts.accessKey=xxxx
camel.component.aws2-sts.secretKey=yyyyy
camel.component.aws2-sts.region=eu-central-1
camel.springboot.main-run-controller=true
logging.config=classpath:logback.xml
camel.component.aws2-sts.override-endpoint=true 
camel.component.aws2-sts.uri-endpoint-override=https://vpce-pippo-pluto.sts.eu.central1.vpce.amazonaws.com
{code}

and a route like:


{code:java}
/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.example.springboot.aws2sts;

import org.apache.camel.builder.RouteBuilder;
import org.springframework.stereotype.Component;

@Component
public class CamelRoute extends RouteBuilder {

    @Override
    public void configure() throws Exception {

      from(""timer://tick?period=1000"")
                .to(""aws2-sts://label?operation=getSessionToken"");
    }
}
{code}

I'm getting the following error:


{code:java}
[INFO] --- spring-boot-maven-plugin:2.6.4:run (default-cli) @ camel-example-spring-boot-aws2-sts ---
[INFO] Attaching agents: []

  .   ____          _            __ _ _
 /\\ / ___'_ __ _ _(_)_ __  __ _ \ \ \ \
( ( )\___ | '_ | '_| | '_ \/ _` | \ \ \ \
 \\/  ___)| |_)| | | | | || (_| |  ) ) ) )
  '  |____| .__|_| |_|_| |_\__, | / / / /
 =========|_|==============|___/=/_/_/_/
 :: Spring Boot ::                (v2.6.4)

14:38:40.132 [main           ] INFO  .springboot.aws2s3.Application - Starting Application using Java 11.0.15 on ghost with PID 31495 (/home/oscerd/workspace/apache-camel/camel-spring-boot-examples/aws2-sts/target/classes started by oscerd in /home/oscerd/workspace/apache-camel/camel-spring-boot-examples/aws2-sts)
14:38:40.133 [main           ] INFO  .springboot.aws2s3.Application - No active profile set, falling back to 1 default profile: ""default""
14:38:41.242 [main           ] INFO  lSpringBootApplicationListener - Starting CamelMainRunController to ensure the main thread keeps running
14:38:41.248 [main           ] INFO  pl.engine.AbstractCamelContext - Routes startup (total:1 started:1)
14:38:41.249 [main           ] INFO  pl.engine.AbstractCamelContext -     Started route1 (timer://tick)
14:38:41.249 [main           ] INFO  pl.engine.AbstractCamelContext - Apache Camel 3.14.2 (camel-1) started in 328ms (build:20ms init:75ms start:233ms)
14:38:41.252 [main           ] INFO  .springboot.aws2s3.Application - Started Application in 1.316 seconds (JVM running for 1.623)
14:38:52.603 [ - timer://tick] ERROR rorhandler.DefaultErrorHandler - Failed delivery for (MessageId: 8C5BB76A269F72A-0000000000000000 on ExchangeId: 8C5BB76A269F72A-0000000000000000). Exhausted after delivery attempt: 1 caught: software.amazon.awssdk.core.exception.SdkClientException: Received an UnknownHostException when attempting to interact with a service. See cause for the exact endpoint that is failing to resolve. If this is happening on an endpoint that previously worked, there may be a network connectivity issue or your DNS cache could be storing endpoints for too long.

Message History (complete message history is disabled)
---------------------------------------------------------------------------------------------------------------------------------------
RouteId              ProcessorId          Processor                                                                        Elapsed (ms)
[route1            ] [route1            ] [from[timer://tick?period=1000]                                                ] [     10353]
	...
[route1            ] [to1               ] [aws2-sts://peppe?operation=getSessionToken                                    ] [         0]

Stacktrace
---------------------------------------------------------------------------------------------------------------------------------------

software.amazon.awssdk.core.exception.SdkClientException: Received an UnknownHostException when attempting to interact with a service. See cause for the exact endpoint that is failing to resolve. If this is happening on an endpoint that previously worked, there may be a network connectivity issue or your DNS cache could be storing endpoints for too long.
	at software.amazon.awssdk.core.exception.SdkClientException$BuilderImpl.build(SdkClientException.java:98)
	at software.amazon.awssdk.awscore.interceptor.HelpfulUnknownHostExceptionInterceptor.modifyException(HelpfulUnknownHostExceptionInterceptor.java:59)
	at software.amazon.awssdk.core.interceptor.ExecutionInterceptorChain.modifyException(ExecutionInterceptorChain.java:199)
	at software.amazon.awssdk.core.internal.http.pipeline.stages.utils.ExceptionReportingUtils.runModifyException(ExceptionReportingUtils.java:54)
	at software.amazon.awssdk.core.internal.http.pipeline.stages.utils.ExceptionReportingUtils.reportFailureToInterceptors(ExceptionReportingUtils.java:38)
	at software.amazon.awssdk.core.internal.http.pipeline.stages.ExecutionFailureExceptionReportingStage.execute(ExecutionFailureExceptionReportingStage.java:39)
	at software.amazon.awssdk.core.internal.http.pipeline.stages.ExecutionFailureExceptionReportingStage.execute(ExecutionFailureExceptionReportingStage.java:26)
	at software.amazon.awssdk.core.internal.http.AmazonSyncHttpClient$RequestExecutionBuilderImpl.execute(AmazonSyncHttpClient.java:193)
	at software.amazon.awssdk.core.internal.handler.BaseSyncClientHandler.invoke(BaseSyncClientHandler.java:103)
	at software.amazon.awssdk.core.internal.handler.BaseSyncClientHandler.doExecute(BaseSyncClientHandler.java:167)
	at software.amazon.awssdk.core.internal.handler.BaseSyncClientHandler.lambda$execute$1(BaseSyncClientHandler.java:82)
	at software.amazon.awssdk.core.internal.handler.BaseSyncClientHandler.measureApiCallSuccess(BaseSyncClientHandler.java:175)
	at software.amazon.awssdk.core.internal.handler.BaseSyncClientHandler.execute(BaseSyncClientHandler.java:76)
	at software.amazon.awssdk.core.client.handler.SdkSyncClientHandler.execute(SdkSyncClientHandler.java:45)
	at software.amazon.awssdk.awscore.client.handler.AwsSyncClientHandler.execute(AwsSyncClientHandler.java:56)
	at software.amazon.awssdk.services.sts.DefaultStsClient.getSessionToken(DefaultStsClient.java:1271)
	at org.apache.camel.component.aws2.sts.STS2Producer.getSessionToken(STS2Producer.java:153)
	at org.apache.camel.component.aws2.sts.STS2Producer.process(STS2Producer.java:58)
	at org.apache.camel.support.AsyncProcessorConverterHelper$ProcessorToAsyncProcessorBridge.process(AsyncProcessorConverterHelper.java:66)
	at org.apache.camel.processor.SendProcessor.process(SendProcessor.java:172)
	at org.apache.camel.processor.errorhandler.RedeliveryErrorHandler$SimpleTask.run(RedeliveryErrorHandler.java:471)
	at org.apache.camel.impl.engine.DefaultReactiveExecutor$Worker.schedule(DefaultReactiveExecutor.java:193)
	at org.apache.camel.impl.engine.DefaultReactiveExecutor.scheduleMain(DefaultReactiveExecutor.java:64)
	at org.apache.camel.processor.Pipeline.process(Pipeline.java:184)
	at org.apache.camel.impl.engine.CamelInternalProcessor.process(CamelInternalProcessor.java:398)
	at org.apache.camel.component.timer.TimerConsumer.sendTimerExchange(TimerConsumer.java:210)
	at org.apache.camel.component.timer.TimerConsumer$1.run(TimerConsumer.java:76)
	at java.base/java.util.TimerThread.mainLoop(Timer.java:556)
	at java.base/java.util.TimerThread.run(Timer.java:506)
Caused by: software.amazon.awssdk.core.exception.SdkClientException: Unable to execute HTTP request: vpce-pippo-pluto.sts.eu.central1.vpce.amazonaws.com
	at software.amazon.awssdk.core.exception.SdkClientException$BuilderImpl.build(SdkClientException.java:98)
	at software.amazon.awssdk.core.exception.SdkClientException.create(SdkClientException.java:43)
	at software.amazon.awssdk.core.internal.http.pipeline.stages.utils.RetryableStageHelper.setLastException(RetryableStageHelper.java:204)
	at software.amazon.awssdk.core.internal.http.pipeline.stages.RetryableStage.execute(RetryableStage.java:83)
	at software.amazon.awssdk.core.internal.http.pipeline.stages.RetryableStage.execute(RetryableStage.java:36)
	at software.amazon.awssdk.core.internal.http.pipeline.RequestPipelineBuilder$ComposingRequestPipelineStage.execute(RequestPipelineBuilder.java:206)
	at software.amazon.awssdk.core.internal.http.StreamManagingStage.execute(StreamManagingStage.java:56)
	at software.amazon.awssdk.core.internal.http.StreamManagingStage.execute(StreamManagingStage.java:36)
	at software.amazon.awssdk.core.internal.http.pipeline.stages.ApiCallTimeoutTrackingStage.executeWithTimer(ApiCallTimeoutTrackingStage.java:80)
	at software.amazon.awssdk.core.internal.http.pipeline.stages.ApiCallTimeoutTrackingStage.execute(ApiCallTimeoutTrackingStage.java:60)
	at software.amazon.awssdk.core.internal.http.pipeline.stages.ApiCallTimeoutTrackingStage.execute(ApiCallTimeoutTrackingStage.java:42)
	at software.amazon.awssdk.core.internal.http.pipeline.stages.ApiCallMetricCollectionStage.execute(ApiCallMetricCollectionStage.java:48)
	at software.amazon.awssdk.core.internal.http.pipeline.stages.ApiCallMetricCollectionStage.execute(ApiCallMetricCollectionStage.java:31)
	at software.amazon.awssdk.core.internal.http.pipeline.RequestPipelineBuilder$ComposingRequestPipelineStage.execute(RequestPipelineBuilder.java:206)
	at software.amazon.awssdk.core.internal.http.pipeline.RequestPipelineBuilder$ComposingRequestPipelineStage.execute(RequestPipelineBuilder.java:206)
	at software.amazon.awssdk.core.internal.http.pipeline.stages.ExecutionFailureExceptionReportingStage.execute(ExecutionFailureExceptionReportingStage.java:37)
	... 23 common frames omitted
Caused by: java.net.UnknownHostException: vpce-pippo-pluto.sts.eu.central1.vpce.amazonaws.com
	at java.base/java.net.InetAddress$CachedAddresses.get(InetAddress.java:797)
	at java.base/java.net.InetAddress.getAllByName0(InetAddress.java:1509)
	at java.base/java.net.InetAddress.getAllByName(InetAddress.java:1368)
	at java.base/java.net.InetAddress.getAllByName(InetAddress.java:1302)
	at org.apache.http.impl.conn.SystemDefaultDnsResolver.resolve(SystemDefaultDnsResolver.java:45)
	at org.apache.http.impl.conn.DefaultHttpClientConnectionOperator.connect(DefaultHttpClientConnectionOperator.java:112)
	at org.apache.http.impl.conn.PoolingHttpClientConnectionManager.connect(PoolingHttpClientConnectionManager.java:376)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at software.amazon.awssdk.http.apache.internal.conn.ClientConnectionManagerFactory$Handler.invoke(ClientConnectionManagerFactory.java:80)
	at com.sun.proxy.$Proxy64.connect(Unknown Source)
	at org.apache.http.impl.execchain.MainClientExec.establishRoute(MainClientExec.java:393)
	at org.apache.http.impl.execchain.MainClientExec.execute(MainClientExec.java:236)
	at org.apache.http.impl.execchain.ProtocolExec.execute(ProtocolExec.java:186)
	at org.apache.http.impl.client.InternalHttpClient.doExecute(InternalHttpClient.java:185)
	at org.apache.http.impl.client.CloseableHttpClient.execute(CloseableHttpClient.java:83)
	at org.apache.http.impl.client.CloseableHttpClient.execute(CloseableHttpClient.java:56)
	at software.amazon.awssdk.http.apache.internal.impl.ApacheSdkHttpClient.execute(ApacheSdkHttpClient.java:72)
	at software.amazon.awssdk.http.apache.ApacheHttpClient.execute(ApacheHttpClient.java:254)
	at software.amazon.awssdk.http.apache.ApacheHttpClient.access$500(ApacheHttpClient.java:107)
	at software.amazon.awssdk.http.apache.ApacheHttpClient$1.call(ApacheHttpClient.java:233)
	at software.amazon.awssdk.http.apache.ApacheHttpClient$1.call(ApacheHttpClient.java:230)
	at software.amazon.awssdk.core.internal.util.MetricUtils.measureDurationUnsafe(MetricUtils.java:64)
	at software.amazon.awssdk.core.internal.http.pipeline.stages.MakeHttpRequestStage.executeHttpRequest(MakeHttpRequestStage.java:77)
	at software.amazon.awssdk.core.internal.http.pipeline.stages.MakeHttpRequestStage.execute(MakeHttpRequestStage.java:56)
	at software.amazon.awssdk.core.internal.http.pipeline.stages.MakeHttpRequestStage.execute(MakeHttpRequestStage.java:39)
	at software.amazon.awssdk.core.internal.http.pipeline.RequestPipelineBuilder$ComposingRequestPipelineStage.execute(RequestPipelineBuilder.java:206)
	at software.amazon.awssdk.core.internal.http.pipeline.RequestPipelineBuilder$ComposingRequestPipelineStage.execute(RequestPipelineBuilder.java:206)
	at software.amazon.awssdk.core.internal.http.pipeline.RequestPipelineBuilder$ComposingRequestPipelineStage.execute(RequestPipelineBuilder.java:206)
	at software.amazon.awssdk.core.internal.http.pipeline.RequestPipelineBuilder$ComposingRequestPipelineStage.execute(RequestPipelineBuilder.java:206)
	at software.amazon.awssdk.core.internal.http.pipeline.stages.ApiCallAttemptTimeoutTrackingStage.execute(ApiCallAttemptTimeoutTrackingStage.java:73)
	at software.amazon.awssdk.core.internal.http.pipeline.stages.ApiCallAttemptTimeoutTrackingStage.execute(ApiCallAttemptTimeoutTrackingStage.java:42)
	at software.amazon.awssdk.core.internal.http.pipeline.stages.TimeoutExceptionHandlingStage.execute(TimeoutExceptionHandlingStage.java:78)
	at software.amazon.awssdk.core.internal.http.pipeline.stages.TimeoutExceptionHandlingStage.execute(TimeoutExceptionHandlingStage.java:40)
	at software.amazon.awssdk.core.internal.http.pipeline.stages.ApiCallAttemptMetricCollectionStage.execute(ApiCallAttemptMetricCollectionStage.java:50)
	at software.amazon.awssdk.core.internal.http.pipeline.stages.ApiCallAttemptMetricCollectionStage.execute(ApiCallAttemptMetricCollectionStage.java:36)
	at software.amazon.awssdk.core.internal.http.pipeline.stages.RetryableStage.execute(RetryableStage.java:81)
	... 35 common frames omitted

{code}




acosentino:1652849047:2022-05-18T12:44:07.901+0000:1652849047:2022-05-18T12:44:07.901+0000:It is working as expected, so it seems to be something on your side.
Oreste:1653355142:2022-05-24T09:19:02.850+0000:1654744507:2022-06-09T11:15:07.398+0000:Hello Mr. [~acosentino],

thank you very much for your effort and help to solve our problem. It is now possible to start a getSessionToken call for the STS component. Originally the problem did not come from using the STS component but from the S3 component accessing the STS component. Unfortunately, the original problem was not solved by the S3 component. The error message appears again: 

 
{code:java}
FEHLER_DEFAULT[SdkClientException] Allgemeine Exception aufgetreten: software.amazon.awssdk.core.exception.SdkClientException: Unable to load credentials from any of the providers in the chain AwsCredentialsProviderChain(credentialsProviders=[SystemPropertyCredentialsProvider(), ... InstanceProfileCredentialsProvider()]) : [SystemPropertyCredentialsProvider(): Unable to load credentials from system settings. Access key must be specified either via environment variable (AWS_ACCESS_KEY_ID) or system property (aws.accessKeyId)., EnvironmentVariableCredentialsProvider(): Unable to load credentials from system settings. Access key must be specified either via environment variable (AWS_ACCESS_KEY_ID) or system property (aws.accessKeyId)., WebIdentityTokenCredentialsProvider(): Either the environment variable AWS_WEB_IDENTITY_TOKEN_FILE or the javaproperty aws.webIdentityTokenFile must be set., ProfileCredentialsProvider ... : 
Unable to execute HTTP request: Connect to sts.eu-central-1.amazonaws.com:443 [sts.eu-central-1.amazonaws.com/54.239.54.197] failed: Connect timed out, ContainerCredentialsProvider(): Cannot fetch credentials from container - neither AWS_CONTAINER_CREDENTIALS_FULL_URI or AWS_CONTAINER_CREDENTIALS_RELATIVE_URI environment variables are set., InstanceProfileCredentialsProvider(): Unable to load credentials from service endpoint.]{code}
 

Die Properties für die S3-Komponente sind ähnlich aus wie die der STS-Komponente:
{code:java}
camel.component.aws2-s3.override-endpoint=true
camel.component.aws2-s3.uri-endpoint-override=https://bucket.vpce-??-??.s3.eu-central-1.vpce.amazonaws.com
camel.component.aws2-s3.accessKey=????
camel.component.aws2-s3.secretKey==????
camel.component.aws2-s3.region=eu-central-1camel.component.aws2-sts.accessKey==????
camel.component.aws2-sts.secretKey==????
camel.component.aws2-sts.region=eu-central-1
camel.component.aws2-sts.override-endpoint=true
camel.component.aws2-sts.uri-endpoint-override=https://vpce-??-??.sts.eu-central-1.vpce.amazonaws.com
 {code}
As the error message ""Unable to execute HTTP request: Connect to sts.eu-central-1.amazonaws.com:443"" shows, the default endpoint is accessed again which does not work in our network.
acosentino:1653357192:2022-05-24T09:53:12.405+0000:1653357192:2022-05-24T09:53:12.405+0000:What you're trying to do is not possible with the options available in S3. If you set something on STS component it will only affect endpoint based on STS component, this means it has no effect on S3 endpoint. If you need to do something in the context of S3, through STS, you'll need to use a custom STS Client, do your operation, instantiate an S3 client and pass it as parameter to your endpoint. Essentially you're using a default STS client in the way you're providing the example.
Oreste:1653432523:2022-05-25T06:48:43.751+0000:1653432523:2022-05-25T06:48:43.751+0000:Thank you [~acosentino] for your help. Unfortunately I am not clear how to attach a custom STS client to the S3 component. I have built it so far: 
{code:java}
String awsBucketAccessKey = ""???"";
String awsBucketSecretKey = ""???"";

StsClient stsClient = StsClient.builder().credentialsProvider(StaticCredentialsProvider.create(AwsBasicCredentials.create(awsBucketAccessKey, awsBucketSecretKey)))
.region(Region.EU_CENTRAL_1)
.endpointOverride(URI.create(""https://vpce-???-???.sts.eu-central-1.vpce.amazonaws.com""))
.build();
STS2Configuration stsConfiguration = new STS2Configuration();
stsConfiguration.setStsClient(stsClient);

STS2Component sts2Component = new STS2Component(getContext());
sts2Component.setConfiguration(stsConfiguration);
sts2Component.setLazyStartProducer(true);
getCamelContext().addComponent(""aws2-sts"", sts2Component);{code}
acosentino:1653511854:2022-05-26T04:50:54.228+0000:1653511854:2022-05-26T04:50:54.228+0000:You need to get a token programmatically like here:
https://docs.aws.amazon.com/code-samples/latest/catalog/javav2-sts-src-main-java-com-example-sts-GetSessionToken.java.html

And then instantiante an S3 by using the credentials retrieve in the session token. Then reference the S3 client in the https://camel.apache.org/components/3.16.x/aws2-s3-component.html#_sb_option_camel_component_aws2-s3_amazon-s3-client"
0,CAMEL-18096,Improvement,Major,None,4.x,"
None
",Open,Unresolved,4.x,Zheng Feng,Zheng Feng,0,2,2022-05-11 02:40:13+00:00,2023-08-09 09:10:24+00:00,"Currently it needs to use addtional-properties to enable kafka transaction. It would be good if we could make configuring the TX options as new endpoint options so its easier and more tooling friendly. Additional properties is only intended for special and rare use-cases.


 



transactionalId -> addtional-properties[transactional.id]
idempotence -> additional-properties[enable.idempotence]
retries -> additional-properties[retries]","davsclaus:1652214319:2022-05-11T04:25:19.325+0000:1652214319:2022-05-11T04:25:19.325+0000:Would you use transaction with idempotence=false ? I just wonder if that option could automatic just be set if you have transaction enabled.
Also how unique should the transaction id be? Does it make sense to have a way for Camel to auto generate an unique id?
 
zhfeng:1652223740:2022-05-11T07:02:20.646+0000:1652223740:2022-05-11T07:02:20.646+0000:No, I think idempotence=true and retries are mandatory. In term of transaction id, I need to check with the kafka document."
0,CAMEL-18095,Improvement,Major,None,,"
None
",Resolved,Won't Fix,None,Unassigned,Claus Ibsen,0,1,2022-05-10 17:05:12+00:00,2022-05-13 10:39:27+00:00,"During development and whatnot, then you may want to be able to quicker terminate if the user presses ctrl +c multiple times.


If we can detect this ""stress"" and then trigger camel shutdown to go quicker - as today the graceful shutdown is waiting for inflight to complete, and this can sometimes get stuck and you have that ... 30 sec ... 29 sec ... 28 sec.",davsclaus:1652409567:2022-05-13T10:39:27.146+0000:1652409567:2022-05-13T10:39:27.146+0000:Its not possible in the JDK to capture a 2nd terminate signal while shutdown hooks are running. The JVM internally synchronize on its own shutdown class so new threads will block and wait while pending hooks are in progress
0,CAMEL-18094,Bug,Minor,3.16.0,3.x,"
None
",Resolved,Abandoned,3.x,Unassigned,Miroslav Borský,0,2,2022-05-10 15:56:57+00:00,2023-05-26 18:19:52+00:00,"karaf 4.4 and Java 11:


feature:repo-add camel 3.16.0
feature:install camel
feature:install camel-cxf


then created the following blueprint:




<?xml version=""1.0"" encoding=""utf-8""?>
<osgi:blueprint xmlns:xs=""http://www.w3.org/2001/XMLSchema""
                xmlns:camel=""http://camel.apache.org/schema/blueprint""
                xmlns:osgi=""http://www.osgi.org/xmlns/blueprint/v1.0.0""
                xmlns:cxf=""http://camel.apache.org/schema/blueprint/cxf"">
	<camel:camelContext id=""VerySimple-context"">
		<camel:route id=""VerySimple-route"">
			<camel:from uri=""VerySimple""/>
			<camel:to uri=""log:proxy.VerySimple""/>
		</camel:route>
	</camel:camelContext>
	<cxf:cxfEndpoint id=""VerySimple"" address=""http://localhost:8088/VerySimple"" serviceName=""tns:VerySimple"" endpointName=""tns:VerySimplePort"" wsdlURL=""file:deploy/VerySimple.wsdl"" xmlns:tns=""http://www.talend.org/service/"">
		<cxf:properties>
			<osgi:entry key=""dataFormat"" value=""PAYLOAD""/>
		</cxf:properties>
	</cxf:cxfEndpoint>
</osgi:blueprint>




received the following exception:



Exception: Failed to start route route1 because of null
org.apache.camel.FailedToStartRouteException: Failed to start route route1 because of null
        at org.apache.camel.impl.engine.RouteService.setUp(RouteService.java:132)
        at org.apache.camel.impl.engine.InternalRouteStartupManager.doInitRoutes(InternalRouteStartupManager.java:92)
        at org.apache.camel.impl.engine.AbstractCamelContext.doInit(AbstractCamelContext.java:2939)
        at org.apache.camel.support.service.BaseService.init(BaseService.java:83)
        at org.apache.camel.impl.engine.AbstractCamelContext.init(AbstractCamelContext.java:2620)
        at org.apache.camel.support.service.BaseService.start(BaseService.java:111)
        at org.apache.camel.impl.engine.AbstractCamelContext.start(AbstractCamelContext.java:2639)
        at org.apache.camel.impl.DefaultCamelContext.start(DefaultCamelContext.java:255)
        at org.apache.camel.blueprint.BlueprintCamelContext.start(BlueprintCamelContext.java:241)
        at org.apache.camel.blueprint.BlueprintCamelContext.maybeStart(BlueprintCamelContext.java:283)
        at org.apache.camel.blueprint.BlueprintCamelContext.blueprintEvent(BlueprintCamelContext.java:188)
        at org.apache.aries.blueprint.container.BlueprintEventDispatcher$3.call(BlueprintEventDispatcher.java:197)
        at org.apache.aries.blueprint.container.BlueprintEventDispatcher$3.call(BlueprintEventDispatcher.java:195)
        at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
        at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)
        at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
        at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)
        at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
        at java.base/java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:304)
        at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)
        at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)
        at java.base/java.lang.Thread.run(Thread.java:829)
Caused by: java.lang.IllegalArgumentException: camelContext must be specified
        at org.apache.camel.util.ObjectHelper.notNull(ObjectHelper.java:149)
        at org.apache.camel.support.DefaultEndpoint.doInit(DefaultEndpoint.java:488)
        at org.apache.camel.component.cxf.CxfEndpoint.doInit(CxfEndpoint.java:1071)
        at org.apache.camel.support.service.BaseService.init(BaseService.java:83)
        at org.apache.camel.support.service.ServiceHelper.initService(ServiceHelper.java:84)
        at org.apache.camel.impl.engine.RouteService.doSetup(RouteService.java:146)
        at org.apache.camel.impl.engine.RouteService.setUp(RouteService.java:130)
        ... 21 more




This worked in 2.x versions of Camel, but do not work in 3.x (tried several different versions). I am not sure if this is a bug or not, but at least in the migration notes from 2.x to 3.x there is nothing about this kind of no-java-class cxf endpoint definition being unsupported.","davsclaus:1652410684:2022-05-13T10:58:04.549+0000:1652410684:2022-05-13T10:58:04.549+0000:You can try to see if < cxf:cxfEndpoint> has a depends-on attribute (or some similar name) so you can refer to the id of the <camelContext> so its created later.
davsclaus:1652410733:2022-05-13T10:58:53.229+0000:1652410733:2022-05-13T10:58:53.229+0000:And does it work without that CXF thingy?
davsclaus:1652413355:2022-05-13T11:42:35.089+0000:1652413355:2022-05-13T11:42:35.089+0000:I have reproduced this, and have a fix. 

In Camel 3.17 onwards, you must use depends-on

<cxf:cxfEndpoint id=""VerySimple"" depends-on=""VerySimple-context""

bachabazi:1652414439:2022-05-13T12:00:39.619+0000:1652414439:2022-05-13T12:00:39.619+0000:Hi [~davsclaus],

thank you for the investigation. Any idea if there is a viable workaround for older versions? Some that will do without the serviceClass attribute and Java development?
davsclaus:1652415471:2022-05-13T12:17:51.781+0000:1652415471:2022-05-13T12:17:51.781+0000:There is no workaround as its in the namespace parser, but 3.17.0 will be released in about a week
bachabazi:1654153102:2022-06-02T14:58:22.709+0000:1654153102:2022-06-02T14:58:22.709+0000:Hi [~davsclaus] 

may I ask what is actually the content of your fix? We are on 3.11 and would rather try to manually hotfix our 3.11 installation than migrate to 3.17.

I have looked to the camel github, but found only the commit for the camel-3x-upgrade-guide-3_17.adoc file.
davsclaus:1654157285:2022-06-02T16:08:05.999+0000:1654157285:2022-06-02T16:08:05.999+0000:It is in camel-karaf so look in that git repo
bachabazi:1654172027:2022-06-02T20:13:47.712+0000:1654172027:2022-06-02T20:13:47.712+0000:The issue is solved for cxfEndpoint used as consumer, but it still fails with the same error message for cxfEndpoint used as producer.
To reproduce, follow the original description, but use the cxfEndpoint in camel:to as well:
{code:xml}
<?xml version=""1.0"" encoding=""utf-8""?>
<osgi:blueprint xmlns:xs=""http://www.w3.org/2001/XMLSchema""
                xmlns:camel=""http://camel.apache.org/schema/blueprint""
                xmlns:osgi=""http://www.osgi.org/xmlns/blueprint/v1.0.0""
                xmlns:cxf=""http://camel.apache.org/schema/blueprint/cxf"">
	<camel:camelContext id=""VerySimple-context"">
		<camel:route id=""VerySimple-route"">
			<camel:from uri=""VerySimple""/>
			<camel:to uri=""VerySimple""/>
		</camel:route>
	</camel:camelContext>
	<cxf:cxfEndpoint id=""VerySimple"" address=""http://localhost:8088/VerySimple"" serviceName=""tns:VerySimple"" endpointName=""tns:VerySimplePort"" wsdlURL=""file:deploy/VerySimple.wsdl"" xmlns:tns=""http://www.talend.org/service/"">
		<cxf:properties>
			<osgi:entry key=""dataFormat"" value=""PAYLOAD""/>
		</cxf:properties>
	</cxf:cxfEndpoint>
</osgi:blueprint>
{code}
davsclaus:1655714503:2022-06-20T16:41:43.121+0000:1655714503:2022-06-20T16:41:43.121+0000:You need to do as documented with the depends-on, your example below is wrong
bachabazi:1655716692:2022-06-20T17:18:12.818+0000:1655716863:2022-06-20T17:21:03.980+0000:Hi [~davsclaus] 

I apologize for that, it was a copy paste error. I have included the depends-on attribute and it worked for consumer, but it still fails for cxfEndpoint used as producer.

karaf 4.4 and Java 11:

feature:repo-add camel 3.17.0
feature:install camel
feature:install camel-cxf
{code:xml}
<?xml version=""1.0"" encoding=""utf-8""?>
<osgi:blueprint xmlns:xs=""http://www.w3.org/2001/XMLSchema""
                xmlns:camel=""http://camel.apache.org/schema/blueprint""
                xmlns:osgi=""http://www.osgi.org/xmlns/blueprint/v1.0.0""
                xmlns:cxf=""http://camel.apache.org/schema/blueprint/cxf"">
    <camel:camelContext id=""VerySimple-context"">
        <camel:route id=""VerySimple-route"">
            <camel:from uri=""VerySimple""/>
            <camel:to uri=""VerySimple""/>
        </camel:route>
    </camel:camelContext>
    <cxf:cxfEndpoint depends-on=""VerySimple-context"" id=""VerySimple"" address=""http://localhost:8088/VerySimple"" serviceName=""tns:VerySimple"" endpointName=""tns:VerySimplePort"" wsdlURL=""file:deploy/VerySimple.wsdl"" xmlns:tns=""http://www.talend.org/service/"">
        <cxf:properties>
            <osgi:entry key=""dataFormat"" value=""PAYLOAD""/>
        </cxf:properties>
    </cxf:cxfEndpoint>
</osgi:blueprint>
{code}

Error message:
{noformat}
Error occurred during starting CamelContext: VerySimple-context
org.apache.camel.FailedToCreateRouteException: Failed to create route VerySimple-route at: >>> To[VerySimple] <<< in route: Route(VerySimple-route)[From[VerySimple] -> [To[VerySimple]]... because of camelContext must be specified
        at org.apache.camel.reifier.RouteReifier.doCreateRoute(RouteReifier.java:240) ~[!/:3.17.0]
        at org.apache.camel.reifier.RouteReifier.createRoute(RouteReifier.java:74) ~[!/:3.17.0]
        at org.apache.camel.impl.DefaultModelReifierFactory.createRoute(DefaultModelReifierFactory.java:49) ~[!/:3.17.0]
        at org.apache.camel.impl.DefaultCamelContext.startRouteDefinitions(DefaultCamelContext.java:862) ~[!/:3.17.0]
        at org.apache.camel.impl.DefaultCamelContext.startRouteDefinitions(DefaultCamelContext.java:750) ~[!/:3.17.0]
        at org.apache.camel.impl.engine.AbstractCamelContext.doInit(AbstractCamelContext.java:2946) ~[!/:3.17.0]
        at org.apache.camel.support.service.BaseService.init(BaseService.java:83) ~[!/:3.17.0]
        at org.apache.camel.impl.engine.AbstractCamelContext.init(AbstractCamelContext.java:2629) ~[!/:3.17.0]
        at org.apache.camel.support.service.BaseService.start(BaseService.java:111) ~[!/:3.17.0]
        at org.apache.camel.impl.engine.AbstractCamelContext.start(AbstractCamelContext.java:2648) ~[!/:3.17.0]
        at org.apache.camel.impl.DefaultCamelContext.start(DefaultCamelContext.java:262) ~[!/:3.17.0]
        at org.apache.camel.blueprint.BlueprintCamelContext.start(BlueprintCamelContext.java:241) ~[!/:3.17.0]
        at org.apache.camel.blueprint.BlueprintCamelContext.maybeStart(BlueprintCamelContext.java:283) ~[!/:3.17.0]
        at org.apache.camel.blueprint.BlueprintCamelContext.blueprintEvent(BlueprintCamelContext.java:188) [!/:3.17.0]
        at org.apache.aries.blueprint.container.BlueprintEventDispatcher$3.call(BlueprintEventDispatcher.java:197) [!/:1.10.3]
        at org.apache.aries.blueprint.container.BlueprintEventDispatcher$3.call(BlueprintEventDispatcher.java:195) [!/:1.10.3]
        at java.util.concurrent.FutureTask.run(FutureTask.java:264) [?:?]
        at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515) [?:?]
        at java.util.concurrent.FutureTask.run(FutureTask.java:264) [?:?]
        at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515) [?:?]
        at java.util.concurrent.FutureTask.run(FutureTask.java:264) [?:?]
        at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:304) [?:?]
        at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128) [?:?]
        at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628) [?:?]
        at java.lang.Thread.run(Thread.java:829) [?:?]
Caused by: java.lang.IllegalArgumentException: camelContext must be specified
        at org.apache.camel.util.ObjectHelper.notNull(ObjectHelper.java:155) ~[!/:3.17.0]
        at org.apache.camel.processor.SendProcessor.<init>(SendProcessor.java:73) ~[!/:3.17.0]
        at org.apache.camel.reifier.SendReifier.createProcessor(SendReifier.java:38) ~[!/:3.17.0]
        at org.apache.camel.reifier.ProcessorReifier.makeProcessor(ProcessorReifier.java:847) ~[!/:3.17.0]
        at org.apache.camel.reifier.ProcessorReifier.addRoutes(ProcessorReifier.java:588) ~[!/:3.17.0]
        at org.apache.camel.reifier.RouteReifier.doCreateRoute(RouteReifier.java:236) ~[!/:3.17.0]
        ... 24 more
{noformat}"
0,CAMEL-18093,New Feature,Major,None,3.19.0,"
None
",Resolved,Fixed,3.19.0,Unassigned,Claus Ibsen,0,3,2022-05-10 15:48:50+00:00,2022-08-02 12:29:00+00:00,"With your hint, I have found the solution: httpClientConfigure


from(""direct:start"")
        .to(""rest:POST:users/

{id}

/basic?throwExceptionOnFailure=false&httpClientConfigurer=#customConfigurer"")
        .log(LoggingLevel.INFO, ""Received body : ${body}"")
        .to(""mock:result"");


@BindToRegistry(""customConfigurer"")
private TestClientConfigurer testConfigurer;


private static class TestClientConfigurer implements HttpClientConfigurer {


    @Override    public void configureHttpClient(HttpClientBuilder
clientBuilder) 

{
        clientBuilder.setRedirectStrategy(new LaxRedirectStrategy());    }

}","davsclaus:1652168970:2022-05-10T15:49:30.141+0000:1652168970:2022-05-10T15:49:30.141+0000:We need an option so you can do

followRedirects=true

on both component / endpoint

which then set that lax redirect strategy as the code above
rhuanrcoha:1656683446:2022-07-01T21:50:46.537+0000:1656683446:2022-07-01T21:50:46.537+0000:Hi [~davsclaus], 

I will get this issue to contribute, okay? 
davsclaus:1656710273:2022-07-02T05:17:53.534+0000:1656710273:2022-07-02T05:17:53.534+0000:Yes you are welcome
rhuanrcoha:1656868739:2022-07-04T01:18:59.999+0000:1656868739:2022-07-04T01:18:59.999+0000:Hi [~davsclaus],

I`m working on camel-http, but I have noted you provided an example using rest. I`ll apply to both components, okay? "
0,CAMEL-18092,Improvement,Minor,3.16.0,3.18.0,"
None
",Resolved,Fixed,3.18.0,Claus Ibsen,Aurélien Pupier,0,2,2022-05-10 15:23:25+00:00,2022-05-24 08:41:53+00:00,"Given this route in subfolder src/main/java/org/acme/timer/log :



package org.acme.timer.log;

import org.apache.camel.builder.RouteBuilder;

public class TimerRoute extends RouteBuilder {

    @Override
    public void configure() throws Exception {
        from(""timer:foo?period=1000"")
                .log(""Hello World a first time"")
                .log(""Helloss World a second time - modified "");
    }
}




when calling:



jbang -Dcamel.jbang.version=3.17.0-SNAPSHOT camel@apache/camel run src/main/java/org/acme/timer/log/TimerRoute.java --logging-level=info --reload --dep=org.apache.camel:camel-debug



when modifying the route and saving it, the route is not restarted.


Given that the file path has been provided, the reload shoudl be able to watch for it even if it is in a subfolder","davsclaus:1652168861:2022-05-10T15:47:41.318+0000:1652168861:2022-05-10T15:47:41.318+0000:This is not really the primary use-case for jbang, as its not for regular maven projects with source code in deep sub folders. At the moment its for source code in a flat folder (current dir)."
0,CAMEL-18091,Bug,Major,3.16.0,3.17.0,"
None
",Resolved,Fixed,3.17.0,Claus Ibsen,Claus Ibsen,0,1,2022-05-10 14:25:26+00:00,2022-05-10 16:30:58+00:00,The message body contains the json data as UP or DOWN but we forgot to change the HTTP status code accordingly. Those are what monitoring tools use to check,
0,CAMEL-18090,New Feature,Minor,None,,"
None
",Open,Unresolved,None,Unassigned,Claus Ibsen,0,2,2022-05-10 11:39:25+00:00,2023-07-17 11:06:45+00:00,"We may want to be able to have properties files that have property key=values that are specific to profiles, so you can have %dev %prod %qa etc


Quarkus has something similar.
And spring boot have some kind of profile mechanism too.


However from tooling point of view its a bit more difficult as then a properties file is not just plain key/value pairs.","davsclaus:1655108257:2022-06-13T16:17:37.387+0000:1655108257:2022-06-13T16:17:37.387+0000:MP Config which id what quarkus uses does not seem to have the concept of profiles.
klease78:1668039079:2022-11-10T08:11:19.663+0000:1668039079:2022-11-10T08:11:19.663+0000:{quote}However from tooling point of view its a bit more difficult as then a properties file is not just plain key/value pairs.
{quote}
In spring, there are different properties files such as application-dev.properties, application-prod.properties and the active profile specifies the one to use. But I haven't looked into the implementation details.
davsclaus:1668079983:2022-11-10T19:33:03.068+0000:1668079983:2022-11-10T19:33:03.068+0000:Yeah I think we may want to give this some more thought and not rush anything - the runtimes are different and this is not as needed today as it was when I created the ticket"
0,CAMEL-18089,Bug,Minor,"3.7.1, 3.16.0",3.17.0,"
None
",Resolved,Fixed,3.17.0,Claus Ibsen,Rebecca,0,2,2022-05-10 11:04:24+00:00,2022-05-11 13:04:25+00:00,"Resuming a suspended camel context results in an IllegalThreadStateException. 


When all routes and the context are started, calling camelContext.suspend(); or clicking 'Suspend' in hawtio will suspend the context and the routes, showing them as 'Suspended' in hawtio.


Then, calling camelContext.resume(); or clicking 'Start' on the Context in hawtio, will throw an IllegalThreadStateException and afterwards the context is in state 'stopped'. There seems to be no way to restart the context other than restarting the whole application. 


Tried this with our actual application:



Java 14.0.2
Camel 3.7.1
Spring Boot 2.4.2
Jolokia 1.6.2
hawtio 2.13.3



And also with a little test application with different dependency versions and only a simple test route, the result was the same.



Java 17.0.1 (also tried with 11.0.6 and 14.0.2, same result)
Camel 3.16.0
Spring Boot 2.6.6
Jolokia 1.7.1
hawtio 2.14.5



Stacktrace:


 




o.a.camel.support.service.BaseService    : Error while resuming service: SpringCamelContext(CamelTestContext) with spring id applicationjava.lang.IllegalThreadStateException: null
    at java.base/java.lang.Thread.start(Thread.java:793) ~[na:na]
    at org.apache.camel.spring.boot.CamelMainRunController.start(CamelMainRunController.java:40) ~[camel-spring-boot-3.16.0.jar:3.16.0]
    at org.apache.camel.spring.boot.CamelSpringBootApplicationListener$1.onCamelContextStarted(CamelSpringBootApplicationListener.java:148) ~[camel-spring-boot-3.16.0.jar:3.16.0]
    at org.apache.camel.impl.engine.InternalRouteStartupManager.safelyStartRouteServices(InternalRouteStartupManager.java:196) ~[camel-base-engine-3.16.0.jar:3.16.0]
    at org.apache.camel.impl.engine.InternalRouteStartupManager.doStartOrResumeRoutes(InternalRouteStartupManager.java:147) ~[camel-base-engine-3.16.0.jar:3.16.0]
    at org.apache.camel.impl.engine.AbstractCamelContext.doResume(AbstractCamelContext.java:2585) ~[camel-base-engine-3.16.0.jar:3.16.0]
    at org.apache.camel.support.service.BaseService.resume(BaseService.java:214) ~[camel-api-3.16.0.jar:3.16.0]
    at org.apache.camel.management.mbean.ManagedCamelContext.start(ManagedCamelContext.java:292) ~[camel-management-3.16.0.jar:3.16.0]
    at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method) ~[na:na]
    at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77) ~[na:na]
    at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) ~[na:na]
    at java.base/java.lang.reflect.Method.invoke(Method.java:568) ~[na:na]
    at sun.reflect.misc.Trampoline.invoke(MethodUtil.java:72) ~[na:na]
    at jdk.internal.reflect.GeneratedMethodAccessor43.invoke(Unknown Source) ~[na:na]
    at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) ~[na:na]
    at java.base/java.lang.reflect.Method.invoke(Method.java:568) ~[na:na]
    at java.base/sun.reflect.misc.MethodUtil.invoke(MethodUtil.java:262) ~[na:na]
    at java.management/javax.management.modelmbean.RequiredModelMBean$4.run(RequiredModelMBean.java:1178) ~[na:na]
    at java.base/java.security.AccessController.doPrivileged(AccessController.java:399) ~[na:na]
    at java.base/java.security.ProtectionDomain$JavaSecurityAccessImpl.doIntersectionPrivilege(ProtectionDomain.java:86) ~[na:na]
    at java.management/javax.management.modelmbean.RequiredModelMBean.invokeMethod(RequiredModelMBean.java:1172) ~[na:na]
    at java.management/javax.management.modelmbean.RequiredModelMBean.invoke(RequiredModelMBean.java:1016) ~[na:na]
    at org.apache.camel.support.management.MixinRequiredModelMBean.invoke(MixinRequiredModelMBean.java:72) ~[camel-support-3.16.0.jar:3.16.0]
    at java.management/com.sun.jmx.interceptor.DefaultMBeanServerInterceptor.invoke(DefaultMBeanServerInterceptor.java:814) ~[na:na]
    at java.management/com.sun.jmx.mbeanserver.JmxMBeanServer.invoke(JmxMBeanServer.java:802) ~[na:na]
    at org.jolokia.handler.ExecHandler.doHandleRequest(ExecHandler.java:98) ~[jolokia-core-1.7.1.jar:na]
    at org.jolokia.handler.ExecHandler.doHandleRequest(ExecHandler.java:40) ~[jolokia-core-1.7.1.jar:na]
    at org.jolokia.handler.JsonRequestHandler.handleRequest(JsonRequestHandler.java:89) ~[jolokia-core-1.7.1.jar:na]
    at org.jolokia.backend.MBeanServerExecutorLocal.handleRequest(MBeanServerExecutorLocal.java:109) ~[jolokia-core-1.7.1.jar:na]
    at org.jolokia.backend.MBeanServerHandler.dispatchRequest(MBeanServerHandler.java:161) ~[jolokia-core-1.7.1.jar:na]
    at org.jolokia.backend.LocalRequestDispatcher.dispatchRequest(LocalRequestDispatcher.java:99) ~[jolokia-core-1.7.1.jar:na]
    at org.jolokia.backend.BackendManager.callRequestDispatcher(BackendManager.java:429) ~[jolokia-core-1.7.1.jar:na]
    at org.jolokia.backend.BackendManager.handleRequest(BackendManager.java:158) ~[jolokia-core-1.7.1.jar:na]
    at org.jolokia.http.HttpRequestHandler.executeRequest(HttpRequestHandler.java:197) ~[jolokia-core-1.7.1.jar:na]
    at org.jolokia.http.HttpRequestHandler.handlePostRequest(HttpRequestHandler.java:131) ~[jolokia-core-1.7.1.jar:na]
    at org.jolokia.http.AgentServlet$3.handleRequest(AgentServlet.java:493) ~[jolokia-core-1.7.1.jar:na]
    at org.jolokia.http.AgentServlet.handleSecurely(AgentServlet.java:383) ~[jolokia-core-1.7.1.jar:na]
    at org.jolokia.http.AgentServlet.handle(AgentServlet.java:354) ~[jolokia-core-1.7.1.jar:na]
    at org.jolokia.http.AgentServlet.doPost(AgentServlet.java:317) ~[jolokia-core-1.7.1.jar:na]
    at javax.servlet.http.HttpServlet.service(HttpServlet.java:681) ~[tomcat-embed-core-9.0.60.jar:4.0.FR]
    at javax.servlet.http.HttpServlet.service(HttpServlet.java:764) ~[tomcat-embed-core-9.0.60.jar:4.0.FR]
    at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:227) ~[tomcat-embed-core-9.0.60.jar:9.0.60]
    at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:162) ~[tomcat-embed-core-9.0.60.jar:9.0.60]
    at org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:53) ~[tomcat-embed-websocket-9.0.60.jar:9.0.60]
    at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:189) ~[tomcat-embed-core-9.0.60.jar:9.0.60]
    at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:162) ~[tomcat-embed-core-9.0.60.jar:9.0.60]
    at org.springframework.web.filter.RequestContextFilter.doFilterInternal(RequestContextFilter.java:100) ~[spring-web-5.3.18.jar:5.3.18]
    at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:117) ~[spring-web-5.3.18.jar:5.3.18]
    at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:189) ~[tomcat-embed-core-9.0.60.jar:9.0.60]
    at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:162) ~[tomcat-embed-core-9.0.60.jar:9.0.60]
    at org.springframework.web.filter.FormContentFilter.doFilterInternal(FormContentFilter.java:93) ~[spring-web-5.3.18.jar:5.3.18]
    at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:117) ~[spring-web-5.3.18.jar:5.3.18]
    at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:189) ~[tomcat-embed-core-9.0.60.jar:9.0.60]
    at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:162) ~[tomcat-embed-core-9.0.60.jar:9.0.60]
    at org.springframework.boot.actuate.metrics.web.servlet.WebMvcMetricsFilter.doFilterInternal(WebMvcMetricsFilter.java:96) ~[spring-boot-actuator-2.6.6.jar:2.6.6]
    at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:117) ~[spring-web-5.3.18.jar:5.3.18]
    at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:189) ~[tomcat-embed-core-9.0.60.jar:9.0.60]
    at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:162) ~[tomcat-embed-core-9.0.60.jar:9.0.60]
    at org.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:201) ~[spring-web-5.3.18.jar:5.3.18]
    at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:117) ~[spring-web-5.3.18.jar:5.3.18]
    at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:189) ~[tomcat-embed-core-9.0.60.jar:9.0.60]
    at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:162) ~[tomcat-embed-core-9.0.60.jar:9.0.60]
    at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:197) ~[tomcat-embed-core-9.0.60.jar:9.0.60]
    at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:97) ~[tomcat-embed-core-9.0.60.jar:9.0.60]
    at org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:541) ~[tomcat-embed-core-9.0.60.jar:9.0.60]
    at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:135) ~[tomcat-embed-core-9.0.60.jar:9.0.60]
    at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:92) ~[tomcat-embed-core-9.0.60.jar:9.0.60]
    at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:78) ~[tomcat-embed-core-9.0.60.jar:9.0.60]
    at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:360) ~[tomcat-embed-core-9.0.60.jar:9.0.60]
    at org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:399) ~[tomcat-embed-core-9.0.60.jar:9.0.60]
    at org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:65) ~[tomcat-embed-core-9.0.60.jar:9.0.60]
    at org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:889) ~[tomcat-embed-core-9.0.60.jar:9.0.60]
    at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1743) ~[tomcat-embed-core-9.0.60.jar:9.0.60]
    at org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:49) ~[tomcat-embed-core-9.0.60.jar:9.0.60]
    at org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1191) ~[tomcat-embed-core-9.0.60.jar:9.0.60]
    at org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:659) ~[tomcat-embed-core-9.0.60.jar:9.0.60]
    at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61) ~[tomcat-embed-core-9.0.60.jar:9.0.60]
    at java.base/java.lang.Thread.run(Thread.java:833) ~[na:na] 



Dependencies:


 




<properties>
    <java.version>17</java.version>
    <jolokia-core.version>1.7.1</jolokia-core.version>
    <camel-version>3.16.0</camel-version>
</properties>
<dependencies>
    <dependency>
        <groupId>org.apache.camel.springboot</groupId>
        <artifactId>camel-spring-boot-starter</artifactId>
        <version>3.16.0</version>
    </dependency>    
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-test</artifactId>
        <scope>test</scope>
    </dependency>    
    <dependency>
        <groupId>org.apache.camel.springboot</groupId>
        <artifactId>camel-file-starter</artifactId>
        <version>${camel-version}</version>
    </dependency>
    <dependency>
        <groupId>org.apache.camel</groupId>
        <artifactId>camel-management</artifactId>
        <version>${camel-version}</version>
    </dependency>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-web</artifactId>
    </dependency>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-actuator</artifactId>
    </dependency>
    <dependency>
        <groupId>org.jolokia</groupId>
        <artifactId>jolokia-core</artifactId>
        <version>${jolokia-core.version}</version>
    </dependency>
</dependencies> 



The test route:


 




public class MyRouteBuilder extends RouteBuilder {    
    @Override
    public void configure() throws Exception {
        from(""file:src/data?noop=true"")
                .routeId(""ROUTE1"")
                .log(LoggingLevel.INFO, ""ROUTE1 entered"")
                .to(""file://target/test"");
    }
}","davsclaus:1652152089:2022-05-10T11:08:09.644+0000:1652152089:2022-05-10T11:08:09.644+0000:Can you try to reproduce this with the spring-boot example from
https://github.com/apache/camel-spring-boot-examples/tree/main/spring-boot

Then we can use that to reproduce more easily
cebra:1652223865:2022-05-11T07:04:25.012+0000:1652223865:2022-05-11T07:04:25.012+0000:Thanks for your reply. 

I could not reproduce it with the example, so I compared it with our code. 

Turns out, we still had the property 
{code:java}
camel.springboot.main-run-controller=true{code}
set from back when we started the project. It seems we don't need that property anymore as we now have included the spring-boot-starter-web. 

When I remove that property, resuming the context works. 
davsclaus:1652245345:2022-05-11T13:02:25.018+0000:1652245345:2022-05-11T13:02:25.018+0000:Thanks I have reproduced the little bug"
0,CAMEL-18088,Bug,Minor,3.16.0,3.17.0,"
None
",Resolved,Fixed,3.17.0,Claus Ibsen,Mikołaj Matejko,0,2,2022-05-10 10:12:18+00:00,2022-05-11 14:56:24+00:00,"Within CAMEL-17593 a new property `messageHeaderExceededLimit` was added for producer. By setting it we can either ignore too many headers (aws sqs can contain max 10 headers), warn or throw. However none of them is working as due to the code bug this new code is always ignored.


Please look at screenshot, taken in Sqs2Producer class",davsclaus:1652252184:2022-05-11T14:56:24.354+0000:1652252184:2022-05-11T14:56:24.354+0000:Thanks for reporting and showing where the bug is
0,CAMEL-18087,Improvement,Major,None,3.17.0,"
None
",Resolved,Fixed,3.17.0,Claus Ibsen,Claus Ibsen,0,1,2022-05-10 09:24:11+00:00,2022-06-23 05:00:37+00:00,"This is tripping users when they for example use camel routes that call HTTP services where the response is InputStream that is only often readable only once.


So if they do log and then continue processing the message body is null/empty, or if they use choice EIP with predicates etc.","davsclaus:1652160846:2022-05-10T13:34:06.524+0000:1652166147:2022-05-10T15:02:27.949+0000:TODO: spring boot auto configuration change default value *DONE*
TODO: upgrade guide *DONE*
davsclaus:1652166173:2022-05-10T15:02:53.991+0000:1652245869:2022-05-11T13:11:09.258+0000:TODO: Let CI server do full test over night to see if any regressions *DONE*"
0,CAMEL-18086,Improvement,Major,None,3.17.0,"
None
",Resolved,Fixed,3.17.0,Claus Ibsen,Claus Ibsen,0,1,2022-05-10 07:29:19+00:00,2022-05-10 08:56:19+00:00,"To be able to build uber-jar and have dependency resolution work without having camel triggering components init that may lead them to warmup remote connections.


For example the kafka component will validate brokerURLs for actual broker, which during package may not be running.",
0,CAMEL-18085,Improvement,Major,None,3.17.0,"
None
",Resolved,Fixed,3.17.0,Jiri Ondrusek,Jiri Ondrusek,0,2,2022-05-09 12:24:48+00:00,2022-05-11 12:53:59+00:00,"If ManagementStatisticsLevel.RoutesOnly is used to configure performance statistics, processors' statistics are created - the are not actualized.  Even their existence could cause performance issues. It would be better to do not register them at all (the same way as with onlyRegisterProcessorWithCustomId=true). See the documentation for more details.","davsclaus:1652075062:2022-05-09T13:44:22.445+0000:1652075062:2022-05-09T13:44:22.445+0000:This is not a bug, as that only controls if statistics is enabled or not.
Its is not about which mbeans to register by default.

Instead a new option should be added to control how many mbeans to install. Having the mbean for processors but without statistics can be of use if you need fine grained management of EIPs or custom processors which can have JMX attributes and operations.


jondruse:1652075812:2022-05-09T13:56:52.284+0000:1652075812:2022-05-09T13:56:52.284+0000:[~davsclaus]  Thanks for the explanation.
davsclaus:1652075907:2022-05-09T13:58:27.069+0000:1652075907:2022-05-09T13:58:27.069+0000:Jiri, so can we come up with a good name for a new option? It can be based on same set of levels

- context only
- routes only
- default (include processors)

Maybe the name can be 

managementMBeansLevel

And then have similar enums as the other. 

Can you try working on that, thanks




jondruse:1652076163:2022-05-09T14:02:43.463+0000:1652076163:2022-05-09T14:02:43.463+0000:I will work on it and I'll prepare a new config. option, which will allow to define a level of beans to install."
0,CAMEL-18084,Bug,Minor,3.17.0,3.17.0,"
None
",Resolved,Fixed,3.17.0,Claus Ibsen,Claus Ibsen,0,1,2022-05-09 11:54:56+00:00,2022-05-09 12:08:22+00:00,"The kamelet in this gist should be able to use with camel run
https://gist.github.com/davsclaus/a77f996ae186f349551eb545d04cef25",
0,CAMEL-18083,Bug,Minor,3.14.3,,"
None
",Resolved,Not A Bug,None,Unassigned,Martin Lichtin,0,2,2022-05-09 04:56:28+00:00,2022-05-10 09:06:07+00:00,"Infrequently seeing a ConcurrentModificationException 



2022-05-08T22:14:54,999 | ERROR | rint Event Dispatcher: 1 | BlueprintCamelContext            | .blueprint.BlueprintCamelContext  190 | 188 - org.apache.camel.karaf.camel-blueprint - 3.14.3 | Error occurred during starting CamelContext: my.test.CamelContext
java.util.ConcurrentModificationException: null
    at java.util.ArrayList$Itr.checkForComodification(ArrayList.java:911) ~[?:1.8.0_321]
    at java.util.ArrayList$Itr.next(ArrayList.java:861) ~[?:1.8.0_321]
    at org.apache.camel.impl.DefaultCamelContext.startRouteDefinitions(DefaultCamelContext.java:789) ~[!/:3.14.3]
    at org.apache.camel.impl.DefaultCamelContext.startRouteDefinitions(DefaultCamelContext.java:764) ~[!/:3.14.3]
    at org.apache.camel.impl.engine.AbstractCamelContext.doInit(AbstractCamelContext.java:2862) ~[!/:3.14.3]
    at org.apache.camel.support.service.BaseService.init(BaseService.java:83) ~[!/:3.14.3]
    at org.apache.camel.impl.engine.AbstractCamelContext.init(AbstractCamelContext.java:2568) ~[!/:3.14.3]
    at org.apache.camel.support.service.BaseService.start(BaseService.java:111) ~[!/:3.14.3]
    at org.apache.camel.impl.engine.AbstractCamelContext.start(AbstractCamelContext.java:2587) ~[!/:3.14.3]
    at org.apache.camel.impl.DefaultCamelContext.start(DefaultCamelContext.java:253) ~[!/:3.14.3]
    at org.apache.camel.blueprint.BlueprintCamelContext.start(BlueprintCamelContext.java:241) ~[!/:3.14.3]
    at org.apache.camel.blueprint.BlueprintCamelContext.maybeStart(BlueprintCamelContext.java:283) ~[!/:3.14.3]
    at org.apache.camel.blueprint.BlueprintCamelContext.blueprintEvent(BlueprintCamelContext.java:188) [!/:3.14.3]
    at org.apache.aries.blueprint.container.BlueprintEventDispatcher$3.call(BlueprintEventDispatcher.java:197) [!/:1.10.3]
    at org.apache.aries.blueprint.container.BlueprintEventDispatcher$3.call(BlueprintEventDispatcher.java:195) [!/:1.10.3]
    at java.util.concurrent.FutureTask.run(FutureTask.java:266) [?:1.8.0_321]
    at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511) [?:1.8.0_321]
    at java.util.concurrent.FutureTask.run(FutureTask.java:266) [?:1.8.0_321]
    at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511) [?:1.8.0_321]
    at java.util.concurrent.FutureTask.run(FutureTask.java:266) [?:1.8.0_321]
    at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(ScheduledThreadPoolExecutor.java:180) [?:1.8.0_321]
    at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:293) [?:1.8.0_321]
    at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149) [?:1.8.0_321]
    at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624) [?:1.8.0_321]
    at java.lang.Thread.run(Thread.java:750) [?:1.8.0_321]","davsclaus:1652144482:2022-05-10T09:01:22.026+0000:1652144482:2022-05-10T09:01:22.026+0000:This is because you do manual adding routes while camel is starting up - its out of the ordinary.
lichtin:1652144767:2022-05-10T09:06:07.207+0000:1652144767:2022-05-10T09:06:07.207+0000:But then the Karaf Blueprint integration is broken"
0,CAMEL-18082,New Feature,Minor,None,4.4.0,"
None
",Resolved,Fixed,4.4.0,Claus Ibsen,Claus Ibsen,0,1,2022-05-08 09:14:36+00:00,2023-12-16 08:12:11+00:00,"So you can run something where a set of required values have not been provided, such as username / passwords etc.


camel run foo.xml


And then camel-jbang will prompt for missing values


Enter value for s3-api-token: XXX
Enter value for s3-secret-token: XXX
...


Then you can copy/paste those in the prompt.",
0,CAMEL-18081,New Feature,Minor,None,3.x,"
None
",Resolved,Won't Fix,3.x,Unassigned,Claus Ibsen,0,1,2022-05-08 09:12:33+00:00,2023-01-04 11:57:14+00:00,"So you can quickly run something and provide a key=value where the value is taken from clipboard, such as an api token etc.


However this if limited to a single clipboard value, so when you have many its better to provide them as CLI args or properties files etc.


camel run foo.yaml --prop=secret-token=@clipboard@


What kind of syntax to use?",
0,CAMEL-18080,New Feature,Major,None,3.17.0,"
None
",Resolved,Fixed,3.17.0,Claus Ibsen,Claus Ibsen,0,1,2022-05-08 09:07:57+00:00,2022-05-08 09:08:25+00:00,No Desc,
0,CAMEL-18079,New Feature,Major,None,3.18.0,"
None
",Resolved,Won't Fix,3.18.0,Claus Ibsen,Claus Ibsen,0,1,2022-05-08 08:36:32+00:00,2022-06-01 06:44:56+00:00,"It would be good if you can more easily specific a specific Camel version from a CLI arg, instead of a -Dcamel.jbang.version JVM system property.


Something ala:


camel run --version=3.18.2 foo.xml
camel run --version=3.18.1 foo.xml


It can help trouble shoot where you investigate something and want to easily switch between Camel versions.","davsclaus:1653637393:2022-05-27T15:43:13.682+0000:1653637393:2022-05-27T15:43:13.682+0000:We should also have camel package uber-jar to support this, as the CLI may use a 3.18.0 released version, but you want to package for a camel 3.14.2 app etc
davsclaus:1654037096:2022-06-01T06:44:56.592+0000:1654037096:2022-06-01T06:44:56.592+0000:At the moment its a bit too complex - we can revist later if needed"
0,CAMEL-18078,Improvement,Minor,None,"4.0-RC1, 4.0.0","
None
",Resolved,Fixed,"4.0-RC1, 4.0.0",Unassigned,Peter Palaga,0,2,2022-05-08 07:52:24+00:00,2023-05-26 18:32:03+00:00,"Having a route like the following 




        from(""timer:tick?period=3s"").setBody().constant(""foobar"")
                .log(""${body}"")
                .process(exchange -> {
                    final Message m = exchange.getMessage();
                    //m.setHeader(""CamelGoogleSheets.valueInputOption"", ""RAW"");
                    m.setHeader(""CamelGoogleSheets.values"",
                            new ValueRange().setValues(
                                    Arrays.asList(
                                            Arrays.asList(
                                                    m.getBody(String.class)))));

                })
                .to(""google-sheets://data/append?spreadsheetId={{google-sheets.spreadsheet-id}}&range=Sheet1!A1:A1"");




results in the following exception unless one uncomments m.setHeader(""CamelGoogleSheets.valueInputOption"", ""RAW""):




org.apache.camel.RuntimeCamelException: com.google.api.client.googleapis.json.GoogleJsonResponseException: 400 Bad Request
POST https://sheets.googleapis.com/v4/spreadsheets/12dtOvsosJ4l1vIfLRqD8bZXyzLk0iGI4ENzN6qi_ys8/values/Sheet1!A1:A1:append
{
  ""code"" : 400,
  ""errors"" : [ {
    ""domain"" : ""global"",
    ""message"" : ""'valueInputOption' is required but not specified"",
    ""reason"" : ""badRequest""
  } ],
  ""message"" : ""'valueInputOption' is required but not specified"",
  ""status"" : ""INVALID_ARGUMENT""
}
        at org.apache.camel.component.google.sheets.GoogleSheetsProducer.doInvokeMethod(GoogleSheetsProducer.java:51)
        at org.apache.camel.support.component.AbstractApiProducer$1.run(AbstractApiProducer.java:89)
        at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)
        at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
        at java.base/java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:304)
        at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)
        at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)
        at java.base/java.lang.Thread.run(Thread.java:829)
Caused by: com.google.api.client.googleapis.json.GoogleJsonResponseException: 400 Bad Request
POST https://sheets.googleapis.com/v4/spreadsheets/12dtOvsosJ4l1vIfLRqD8bZXyzLk0iGI4ENzN6qi_ys8/values/Sheet1!A1:A1:append
{
  ""code"" : 400,
  ""errors"" : [ {
    ""domain"" : ""global"",
    ""message"" : ""'valueInputOption' is required but not specified"",
    ""reason"" : ""badRequest""
  } ],
  ""message"" : ""'valueInputOption' is required but not specified"",
  ""status"" : ""INVALID_ARGUMENT""
}
        at com.google.api.client.googleapis.json.GoogleJsonResponseException.from(GoogleJsonResponseException.java:146)
        at com.google.api.client.googleapis.services.json.AbstractGoogleJsonClientRequest.newExceptionOnError(AbstractGoogleJsonClientRequest.java:118)
        at com.google.api.client.googleapis.services.json.AbstractGoogleJsonClientRequest.newExceptionOnError(AbstractGoogleJsonClientRequest.java:37)
        at com.google.api.client.googleapis.services.AbstractGoogleClientRequest$1.interceptResponse(AbstractGoogleClientRequest.java:428)
        at com.google.api.client.http.HttpRequest.execute(HttpRequest.java:1111)
        at com.google.api.client.googleapis.services.AbstractGoogleClientRequest.executeUnparsed(AbstractGoogleClientRequest.java:514)
        at com.google.api.client.googleapis.services.AbstractGoogleClientRequest.executeUnparsed(AbstractGoogleClientRequest.java:455)
        at com.google.api.client.googleapis.services.AbstractGoogleClientRequest.execute(AbstractGoogleClientRequest.java:565)
        at org.apache.camel.component.google.sheets.GoogleSheetsProducer.doInvokeMethod(GoogleSheetsProducer.java:49)
        ... 7 more





It would be nice to document the header around here: https://camel.apache.org/components/latest/google-sheets-component.html#_api_data_method_append
Possible values are RAW and USER_ENTERED.


Also, I wonder whether the valueInputOption could be made an uri/component parameter, so that to(""google-sheets://data/append?valueInputOption=RAW in DSL and camel.component.google-sheets.value-input-option=RAW in application.properties become possible?","davsclaus:1685097088:2023-05-26T18:31:28.783+0000:1685097088:2023-05-26T18:31:28.783+0000:I am not sure if this option should be provided for all the apis, or only some of them.
I am adding a note in the docs about this header."
0,CAMEL-18077,New Feature,Major,None,3.17.0,"
None
",Resolved,Fixed,3.17.0,Claus Ibsen,Claus Ibsen,0,1,2022-05-07 08:15:27+00:00,2022-05-08 06:09:31+00:00,So we can load resources from gist,
0,CAMEL-18076,Improvement,Minor,None,3.17.0,"
None
",Resolved,Fixed,3.17.0,Claus Ibsen,Claus Ibsen,0,1,2022-05-07 05:54:33+00:00,2022-05-09 07:10:23+00:00,"It does a JVM system property lookup, we can do this once to speedup",
0,CAMEL-18075,Dependency upgrade,Major,3.16.0,3.17.0,"
None
",Resolved,Fixed,3.17.0,Unassigned,Herve Boutemy,0,2,2022-05-07 04:34:43+00:00,2022-05-07 05:54:51+00:00,"reproducibility issue found a long time ago https://github.com/jvm-repo-rebuild/reproducible-central/blob/master/content/org/apache/camel/camel/camel-3.13.0.diffoscope


requires maven-bundle-plugin 5.1.5 FELIX-6496 released recently",davsclaus:1651874082:2022-05-07T05:54:42.273+0000:1651874082:2022-05-07T05:54:42.273+0000:Thanks for the PR
0,CAMEL-18074,Improvement,Minor,None,3.17.0,"
None
",Resolved,Fixed,3.17.0,Claus Ibsen,Claus Ibsen,0,1,2022-05-06 14:42:16+00:00,2022-05-07 06:42:34+00:00,"~/workspace/deleteme ❯ camel
[jbang] Building jar...
Usage: CamelJBang [-hV] [COMMAND]
A JBang-based Camel app


It should say Camel instead of CamelJBang",
0,CAMEL-18073,Improvement,Major,None,3.18.0,"
None
",Resolved,Won't Fix,3.18.0,Unassigned,Claus Ibsen,0,1,2022-05-06 13:47:33+00:00,2022-05-23 14:45:08+00:00,"We have support for --open-api now, but we can also add this to camel-dsl-modeline
https://camel.apache.org/camel-k/1.9.x/cli/modeline.html",davsclaus:1653288305:2022-05-23T14:45:05.227+0000:1653288305:2022-05-23T14:45:05.227+0000:This is more difficult to do as the openapi currently is executed before camel main starts. 
0,CAMEL-18072,New Feature,Minor,None,3.17.0,"
None
",Resolved,Fixed,3.17.0,Luca Burgazzoli,Luca Burgazzoli,0,1,2022-05-06 12:37:08+00:00,2022-05-10 08:58:54+00:00,No Desc,
0,CAMEL-18071,Task,Major,None,3.17.0,"
None
",Resolved,Fixed,3.17.0,Jiri Ondrusek,Jiri Ondrusek,0,1,2022-05-06 11:32:08+00:00,2022-05-10 05:09:13+00:00,There is a chamnge of PlatformHttpComponent.getHttpEndpoints (see https://issues.apache.org/jira/browse/CAMEL-18062). Test from starter has to reflect it.,
0,CAMEL-18070,Improvement,Major,None,3.18.0,"
None
",Resolved,Fixed,3.18.0,Claus Ibsen,Claus Ibsen,1,2,2022-05-06 10:31:53+00:00,2022-05-23 15:22:17+00:00,"To make it easy to check that keyName exists or not.


Well its easy to check if it exists but not the opposite


<simple>?keyName</simple>


We need a not argument for this


<simple>?keyName == null</simple>


Or something ala


<simple>!keyName</simple>


<simple>${properties:!keyName}</simple>","davsclaus:1653290254:2022-05-23T15:17:34.622+0000:1653290254:2022-05-23T15:17:34.622+0000:There is a new propertiesExist function

<simple>${propertiesExist:keyName}</simple>

And to check for NOT exists you prefix with !

<simple>${propertiesExist:!keyName}</simple>
"
0,CAMEL-18069,Improvement,Minor,None,3.17.0,"
None
",Resolved,Fixed,3.17.0,James Netherton,James Netherton,0,1,2022-05-06 10:08:50+00:00,2022-05-06 12:16:23+00:00,"In AWS2S3Producer there's some logic for the createDownloadLink operation that sets up a presigner:


https://github.com/apache/camel/blob/c793c4531183fd54cd04bff0222a65d9c6562435/components/camel-aws/camel-aws2-s3/src/main/java/org/apache/camel/component/aws2/s3/AWS2S3Producer.java#L564-L567


If the uriEndpointOverride option is set, then we should configure it on the builder so that the generated download link is correct.",
0,CAMEL-18068,Task,Minor,None,3.17.0,"
None
",Resolved,Fixed,3.17.0,Babak Vahdat,Babak Vahdat,0,1,2022-05-06 08:08:43+00:00,2022-05-06 18:07:13+00:00,https://mvnrepository.com/artifact/com.azure/azure-sdk-bom/1.2.1,
0,CAMEL-18067,Improvement,Minor,None,3.17.0,"
None
",Resolved,Won't Do,3.17.0,Unassigned,Claus Ibsen,0,1,2022-05-06 06:53:08+00:00,2022-05-09 09:15:26+00:00,So users can provide their own logging configuration instead of the default,davsclaus:1652058926:2022-05-09T09:15:26.049+0000:1652058926:2022-05-09T09:15:26.049+0000:Its a bit difficult to include custom logging files due to classloading ordering.
0,CAMEL-18066,Improvement,Minor,3.14.2,3.17.0,"
None
",Resolved,Fixed,3.17.0,Unassigned,Johnathan Ingram,0,2,2022-05-05 23:40:03+00:00,2022-05-09 07:22:49+00:00,"Add support for the OpenApi spec 'discriminator' allowing for explicit selection of a schema type based on a property value.


https://redocly.com/docs/resources/discriminator/


 


This class 




@Schema(oneOf = { XOfFormA.class, XOfFormB.class },
        discriminatorProperty = ""code"",
        discriminatorMapping = {
                @DiscriminatorMapping(value = ""a-123"", schema = XOfFormA.class),
                @DiscriminatorMapping(value = ""b-456"", schema = XOfFormB.class) })
public interface OneOfForm {
    // The discriminator explicitly declares which property you can inspect to determine the object type.
    // The discriminator must apply to the same level of the schema it is declared in (common mistake when using nested objects).
} 



will generate




""components"" : {
    ""schemas"" : {
      ""OneOfForm"" : {
        ""oneOf"" : [ {
          ""$ref"" : ""#/components/schemas/XOfFormA""
        }, {
          ""$ref"" : ""#/components/schemas/XOfFormB""
        } ],
        ""discriminator"" : {
          ""propertyName"" : ""code"",
          ""mapping"" : {
            ""a-123"" : ""#/components/schemas/org.apache.camel.openapi.model.XOfFormA"",
            ""b-456"" : ""#/components/schemas/org.apache.camel.openapi.model.XOfFormB""
          }
        },

...","davsclaus:1651791209:2022-05-06T06:53:29.701+0000:1651791209:2022-05-06T06:53:29.701+0000:Thanks for reporting, you are welcome to work on a PR
johnathani:1652046735:2022-05-09T05:52:15.132+0000:1652046798:2022-05-09T05:53:18.586+0000:Hi

I have done a pull request #7568 for both 18065 and 18066

It keeps on failing on *main pr build / checkstyle*

I have run which {{mvn clean install -Psourcecheck}} passes on my local machine

Would you be able to have a look and see why this is failing.

 

Then do these commits get merged into the 3.14 LTS line, so will these commits be available in the 3.14.3?

 

 "
0,CAMEL-18065,Improvement,Minor,3.14.2,3.17.0,"
None
",Resolved,Fixed,3.17.0,Unassigned,Johnathan Ingram,0,2,2022-05-05 23:15:48+00:00,2022-05-09 07:22:58+00:00,"Hi


 


The OpenAPI specification supports multiple tags per operation allowing applications to use the tags for custom purposes. Camel only supports 1 tag per operation.


https://swagger.io/docs/specification/grouping-operations-with-tags/


 


Add support for , delimited values in the setTag() method.


 


The generator can will utilise this metadata with , delimiters to set multiple tags on the Oas object to represent multiple tags in the schema generated.


 


The following OpenApi metadata 




                rest(""/tag"")
                    .get(""single"")
                    .tag(""Organisation"")
                    .consumes(""application/json"")
                    .produces(""application/json"")
                    .to(""log:bye"")
                ;

                rest(""/tag"")
                    .get(""multiple/a"")
                    .tag(""Organisation,Group A"")
                    .consumes(""application/json"")
                    .produces(""application/json"")
                    .to(""log:bye"")
                ;

                rest(""/tag"")
                    .get(""multiple/b"")
                    .tag(""Organisation,Group B"")
                    .consumes(""application/json"")
                    .produces(""application/json"")
                    .to(""log:bye"")
                ; 



Will produce the following OpenAPI specification




...
    ""/tag/single"" : {
      ""get"" : {
        ""consumes"" : [ ""application/json"" ],
        ""produces"" : [ ""application/json"" ],
        ""tags"" : [ ""Organisation"" ],
...
    ""/tag/multiple/a"" : {
      ""get"" : {
        ""consumes"" : [ ""application/json"" ],
        ""produces"" : [ ""application/json"" ],
        ""tags"" : [ ""Organisation"", ""Group A"" ],
...
    ""/tag/multiple/b"" : {
      ""get"" : {
        ""consumes"" : [ ""application/json"" ],
        ""produces"" : [ ""application/json"" ],
        ""tags"" : [ ""Organisation"", ""Group B"" ],
...
  ""tags"" : [ {
    ""name"" : ""Group B""
  }, {
    ""name"" : ""Organisation""
  }, {
    ""name"" : ""Group A""
  }, {
    ""name"" : ""/hello""
  } ]
....","davsclaus:1651791253:2022-05-06T06:54:13.855+0000:1651791253:2022-05-06T06:54:13.855+0000:You can use comma to separate multiple tags, we use this idiom in other places in Camel DSL model.
johnathani:1652046764:2022-05-09T05:52:44.808+0000:1652046764:2022-05-09T05:52:44.808+0000:{color:#000000}Hi{color}

Pull request done, please see comment on 18066"
0,CAMEL-18064,Bug,Major,3.16.0,3.17.0,"
None
",Resolved,Fixed,3.17.0,Andrea Cosentino,Mark Geiger,0,1,2022-05-05 21:20:24+00:00,2022-05-10 10:06:19+00:00,"There's no working option to use Amazon S3 Managed Keys (SSE-S3).


From reading online, the http header x-amz-server-side-encription needs to be set.


Setting the header CamelAwsS3ServerSideEncryption to AES256 does not enable SSE and there doesn't appear to be an option to enable this type of encryption, even though the documentation states:
""Sets the server-side encryption algorithm when encrypting the object using AWS-managed keys. For example use AES256.""",
0,CAMEL-18063,Bug,Minor,None,3.17.0,"
None
",Resolved,Fixed,3.17.0,Claus Ibsen,Claus Ibsen,0,1,2022-05-05 14:31:20+00:00,2022-05-05 18:01:52+00:00,"If you use the route debugger in vscode, then it stores the camel-debug without a version


dependency=mvn:org.apache.camel:camel-debug:null",
0,CAMEL-18062,Test,Major,None,,"
None
",Resolved,Won't Fix,None,Jiri Ondrusek,Jiri Ondrusek,0,1,2022-05-05 13:45:07+00:00,2022-09-03 12:27:27+00:00,No Desc,
0,CAMEL-18061,Test,Minor,None,3.x,"
None
",Resolved,Won't Fix,3.x,Freeman Yue Fang,Freeman Yue Fang,0,1,2022-05-05 13:28:33+00:00,2022-09-03 12:27:21+00:00,No Desc,
0,CAMEL-18060,Improvement,Major,None,3.17.0,"
None
",Resolved,Fixed,3.17.0,Claus Ibsen,Claus Ibsen,0,1,2022-05-05 12:48:30+00:00,2022-05-06 05:20:03+00:00,"If you run on containers or minikube then they web app for showing container logs does not support ansi colours.


Lets make it possible to turn off logging colours",
0,CAMEL-18028,Improvement,Major,None,3.17.0,"
None
",Resolved,Fixed,3.17.0,Claus Ibsen,Claus Ibsen,1,1,2022-04-28 14:44:45+00:00,2022-04-28 18:03:12+00:00,"If no args provided, then read input from application.properties, where users can specify which files are routes, extra classpath etc.","davsclaus:1651139061:2022-04-28T17:44:21.554+0000:1651139061:2022-04-28T17:44:21.554+0000:You need to prefix the files with file:

camel.main.routesIncludePattern=file:foo.java

Lets see if we can support omitting this so you can do

camel.main.routesIncludePattern=foo.java,bar.java
"
0,CAMEL-18027,Bug,Minor,"3.14.2, 3.16.0","3.14.4, 3.18.0","
None
",Resolved,Fixed,"3.14.4, 3.18.0",Claus Ibsen,Vincenzo Galluccio,0,2,2022-04-28 08:52:57+00:00,2022-06-20 17:21:25+00:00,"The Camel Netty component (NettyProducer) is wrongly closing TCP/IP client channels when the requestTimeout option is configured.


See logs:


 




2022-04-21 15:21:46.410  INFO 18420 --- [           main] o.a.c.component.netty.NettyComponent     : Creating shared NettyConsumerExecutorGroup with 17 threads
2022-04-21 15:21:46.683 DEBUG 18420 --- [           main] o.a.camel.component.netty.NettyProducer  : Created NettyProducer pool[maxTotal=1, minIdle=100, maxIdle=100, minEvictableIdleDuration=PT-0.001S] -> GenericObjectPool [maxTotal=1, blockWhenExhausted=true, maxWaitDuration=PT-0.001S, lifo=true, fairness=false, testOnCreate=false, testOnBorrow=true, testOnReturn=false, testWhileIdle=true, durationBetweenEvictionRuns=PT30S, numTestsPerEvictionRun=3, minEvictableIdleTimeDuration=PT-0.001S, softMinEvictableIdleTimeDuration=PT-0.001S, evictionPolicy=org.apache.commons.pool2.impl.DefaultEvictionPolicy@580d3612, closeLock=java.lang.Object@5b0039aa, closed=false, evictionLock=java.lang.Object@52bf5065, evictor=org.apache.commons.pool2.impl.BaseGenericObjectPool$Evictor@263cece5, evictionIterator=null, factoryClassLoader=java.lang.ref.WeakReference@1730f396, oname=org.apache.commons.pool2:type=GenericObjectPool,name=pool, creationStackTrace=java.lang.Exception
[...]
, borrowedCount=0, returnedCount=0, createdCount=0, destroyedCount=0, destroyedByEvictorCount=0, destroyedByBorrowValidationCount=0, activeTimes=StatsStore [[]], size=100, index=0], idleTimes=StatsStore [[]], size=100, index=0], waitTimes=StatsStore [[]], size=100, index=0], maxBorrowWaitDuration=PT0S, swallowedExceptionListener=null, factoryType=null, maxIdle=100, minIdle=0, factory=org.apache.camel.component.netty.NettyProducer$NettyProducerPoolableObjectFactory@4d2745b3, allObjects={}, createCount=0, idleObjects=[], abandonedConfig=null]
2022-04-21 15:51:11.502 TRACE 18420 --- [roducerTemplate] o.a.camel.component.netty.NettyProducer  : Pool[active=0, idle=0]
2022-04-21 15:51:11.504 DEBUG 18420 --- [roducerTemplate] o.a.camel.component.netty.NettyProducer  : Created new TCP client bootstrap connecting to localhost:19001 with options: Bootstrap(BootstrapConfig(group: NioEventLoopGroup, channelFactory: ReflectiveChannelFactory(NioSocketChannel.class), options: {SO_KEEPALIVE=true, SO_REUSEADDR=true, TCP_NODELAY=true, CONNECT_TIMEOUT_MILLIS=2000}, handler: org.apache.camel.component.netty.DefaultClientInitializerFactory@624ce9ff, resolver: io.netty.resolver.DefaultAddressResolverGroup@6e4616a3))
2022-04-21 15:51:11.505 TRACE 18420 --- [roducerTemplate] o.a.camel.component.netty.NettyProducer  : Requested channel: AbstractBootstrap$PendingRegistrationPromise@270856c0(incomplete)
2022-04-21 15:51:11.505 TRACE 18420 --- [roducerTemplate] o.a.camel.component.netty.NettyProducer  : activateObject channel request: AbstractBootstrap$PendingRegistrationPromise@270856c0(incomplete)
2022-04-21 15:51:11.505 TRACE 18420 --- [roducerTemplate] o.a.camel.component.netty.NettyProducer  : Validating connecting channel request: AbstractBootstrap$PendingRegistrationPromise@270856c0(incomplete) -> true
2022-04-21 15:51:11.505 TRACE 18420 --- [roducerTemplate] o.a.camel.component.netty.NettyProducer  : Got channel request from pool AbstractBootstrap$PendingRegistrationPromise@270856c0(incomplete)
2022-04-21 15:51:11.509 DEBUG 18420 --- [ClientTCPWorker] .a.c.c.n.DefaultClientInitializerFactory : Client SSL handler configured and added to the ChannelPipeline: io.netty.handler.ssl.SslHandler@735dd507
2022-04-21 15:51:11.509 TRACE 18420 --- [ClientTCPWorker] .a.c.c.n.DefaultClientInitializerFactory : Using request timeout 5000 millis
2022-04-21 15:51:11.509 TRACE 18420 --- [ClientTCPWorker] .a.c.c.n.DefaultClientInitializerFactory : Created ChannelPipeline: DefaultChannelPipeline{(DefaultClientInitializerFactory#0 = org.apache.camel.component.netty.DefaultClientInitializerFactory), (ssl = io.netty.handler.ssl.SslHandler), (decoder-0 = io.netty.handler.codec.LengthFieldBasedFrameDecoder), (decoder-1 = util.SharableByteArrayDecoder), (encoder-0 = io.netty.handler.codec.LengthFieldPrepender), (encoder-1 = io.netty.handler.codec.bytes.ByteArrayEncoder), (timeout = io.netty.handler.timeout.ReadTimeoutHandler), (handler = org.apache.camel.component.netty.handlers.ClientChannelHandler)}
2022-04-21 15:51:11.511 TRACE 18420 --- [ClientTCPWorker] o.a.camel.component.netty.NettyProducer  : Channel open finished with AbstractBootstrap$PendingRegistrationPromise@270856c0(success)
2022-04-21 15:51:11.511 DEBUG 18420 --- [ClientTCPWorker] o.a.camel.component.netty.NettyProducer  : Creating connector to address: localhost:19001
2022-04-21 15:51:11.511 DEBUG 18420 --- [ClientTCPWorker] o.a.camel.component.netty.NettyProducer  : Channel: [id: 0x80278f7c, L:/127.0.0.1:61770 - R:localhost/127.0.0.1:19001] writing body: OMITTED
2022-04-21 15:51:11.517 TRACE 18420 --- [ClientTCPWorker] o.a.camel.component.netty.NettyProducer  : Channel open: [id: 0x80278f7c, L:/127.0.0.1:61770 - R:localhost/127.0.0.1:19001]
2022-04-21 15:51:11.637 TRACE 18420 --- [ClientTCPWorker] o.a.camel.component.netty.NettyProducer  : Operation complete DefaultChannelPromise@1835894c(success)
2022-04-21 15:51:11.642 TRACE 18420 --- [ClientTCPWorker] o.a.camel.component.netty.NettyProducer  : Message received: OMITTED
2022-04-21 15:51:11.642 TRACE 18420 --- [ClientTCPWorker] o.a.camel.component.netty.NettyProducer  : Removing timeout channel as we received message
2022-04-21 15:51:11.642 DEBUG 18420 --- [ClientTCPWorker] o.a.camel.component.netty.NettyProducer  : Channel: [id: 0x80278f7c, L:/127.0.0.1:61770 - R:localhost/127.0.0.1:19001] received body: OMITTED
2022-04-21 15:51:11.643 TRACE 18420 --- [ClientTCPWorker] o.a.camel.component.netty.NettyProducer  : Putting channel back to pool [id: 0x80278f7c, L:/127.0.0.1:61770 - R:localhost/127.0.0.1:19001]
2022-04-21 15:51:11.643 TRACE 18420 --- [ClientTCPWorker] o.a.camel.component.netty.NettyProducer  : passivateObject channel request: AbstractBootstrap$PendingRegistrationPromise@270856c0(success)
2022-04-21 15:51:11.645 DEBUG 18420 --- [nio-8087-exec-5] eHttpServletFilter$AsyncExceptionHandler : handling on complete for async event
2022-04-21 15:51:16.770 TRACE 18420 --- [ns-pool-evictor] o.a.camel.component.netty.NettyProducer  : activateObject channel request: AbstractBootstrap$PendingRegistrationPromise@270856c0(success)
2022-04-21 15:51:16.771 TRACE 18420 --- [ns-pool-evictor] o.a.camel.component.netty.NettyProducer  : reset the request timeout as we activate the channel
2022-04-21 15:51:16.771 TRACE 18420 --- [ns-pool-evictor] o.a.camel.component.netty.NettyProducer  : Validating channel: [id: 0x80278f7c, L:/127.0.0.1:61770 - R:localhost/127.0.0.1:19001] -> true
2022-04-21 15:51:16.771 TRACE 18420 --- [ns-pool-evictor] o.a.camel.component.netty.NettyProducer  : passivateObject channel request: AbstractBootstrap$PendingRegistrationPromise@270856c0(success)
2022-04-21 15:51:21.771 TRACE 18420 --- [ClientTCPWorker] o.a.camel.component.netty.NettyProducer  : Exception caught at Channel: [id: 0x80278f7c, L:/127.0.0.1:61770 - R:localhost/127.0.0.1:19001]
io.netty.handler.timeout.ReadTimeoutException: null
2022-04-21 15:51:21.772 DEBUG 18420 --- [ClientTCPWorker] o.a.camel.component.netty.NettyProducer  : Closing channel as an exception was thrown from Netty
io.netty.handler.timeout.ReadTimeoutException: null
2022-04-21 15:51:21.772 TRACE 18420 --- [ClientTCPWorker] o.a.camel.component.netty.NettyHelper    : Channel closed: [id: 0x80278f7c, L:/127.0.0.1:61770 ! R:localhost/127.0.0.1:19001]
2022-04-21 15:51:21.773 TRACE 18420 --- [ClientTCPWorker] o.a.camel.component.netty.NettyProducer  : Channel closed: [id: 0x80278f7c, L:/127.0.0.1:61770 ! R:localhost/127.0.0.1:19001]
2022-04-21 15:51:46.773 TRACE 18420 --- [ns-pool-evictor] o.a.camel.component.netty.NettyProducer  : activateObject channel request: AbstractBootstrap$PendingRegistrationPromise@270856c0(success)
2022-04-21 15:51:46.773 TRACE 18420 --- [ns-pool-evictor] o.a.camel.component.netty.NettyProducer  : reset the request timeout as we activate the channel
2022-04-21 15:51:46.773 TRACE 18420 --- [ns-pool-evictor] o.a.camel.component.netty.NettyProducer  : Destroying channel request: AbstractBootstrap$PendingRegistrationPromise@270856c0(success)




 


The offending code seems to be: https://github.com/apache/camel/blob/main/components/camel-netty/src/main/java/org/apache/camel/component/netty/NettyProducer.java


 




        @Override
        public void activateObject(PooledObject<ChannelFuture> p) throws Exception {
            ChannelFuture channelFuture = p.getObject();
            LOG.trace(""activateObject channel request: {}"", channelFuture);
            if (channelFuture.isSuccess() && producer.getConfiguration().getRequestTimeout() > 0) {
                LOG.trace(""reset the request timeout as we activate the channel"");
                Channel channel = channelFuture.channel();
                ChannelHandler handler = channel.pipeline().get(""timeout"");
                if (handler == null) {
                    ChannelHandler timeout
                            = new ReadTimeoutHandler(producer.getConfiguration().getRequestTimeout(), TimeUnit.MILLISECONDS);
                    channel.pipeline().addBefore(""handler"", ""timeout"", timeout);
                }
            }
        }","davsclaus:1652131967:2022-05-10T05:32:47.846+0000:1652131967:2022-05-10T05:32:47.846+0000:Why do you think its wrong - the timeout was hit and as such the channel can be regarded as invalid from the client point of view, and therefore is closed to avoid using a stale channel on next use.
vincenzo.galluccio:1652138520:2022-05-10T07:22:00.361+0000:1652138520:2022-05-10T07:22:00.361+0000:Good morning Claus,

It is wrong because, as you can see from the logs (at 2022-04-21 15:51:11.642), the response is received on time, therefore the request timeout should not be hit and channel should not be closed. 
davsclaus:1655716710:2022-06-20T17:18:30.591+0000:1655716710:2022-06-20T17:18:30.591+0000:Thanks for reporting I can see the problem and have a fix"
0,CAMEL-18026,Improvement,Major,None,3.17.0,"
None
",Resolved,Fixed,3.17.0,Claus Ibsen,Claus Ibsen,0,1,2022-04-28 08:28:08+00:00,2022-05-03 05:06:52+00:00,"If you use rest-dsl then http endpoints may be limited to POST, GET etc. 


It would be good to have a summary of these rest-dsl endpoints when you startup Camel (we could also have content-type consume/produces) listed.


And we can make this into a camel-console as well, so we in the future can have a nicer dashboard that lists the rest endpoints.


Today we have




2022-04-28 10:17:35.942  INFO 95702 --- [           main] org.apache.camel.main.VertxHttpServer    : HTTP endpoints summary
2022-04-28 10:17:35.944  INFO 95702 --- [           main] org.apache.camel.main.VertxHttpServer    :     http://0.0.0.0:8080/parcels",
0,CAMEL-18025,Improvement,Major,None,3.17.0,"
None
",Resolved,Fixed,3.17.0,Claus Ibsen,Claus Ibsen,0,1,2022-04-28 08:20:52+00:00,2022-04-29 14:46:18+00:00,"when terminating jbang with cltr + c then the logging output seems to stop to soon


I wonder if maybe log4j or something captures cltr + c and shutdown before we have camel shutdown so you are a bit ""in the dark""","davsclaus:1651214554:2022-04-29T14:42:34.547+0000:1651214554:2022-04-29T14:42:34.547+0000:Yes it was log4j, now it works by disabling its shutdown hook that gives camel time to complete"
0,CAMEL-18024,Task,Major,None,3.17.0,"
None
",Resolved,Fixed,3.17.0,Otavio Rodolfo Piske,Otavio Rodolfo Piske,0,1,2022-04-28 05:16:16+00:00,2022-05-21 08:01:20+00:00,"The record fetcher keeps track of the last processed offset via HashMap that associates the partition+key pair to an offset. This is primarily used for rollbacks and commits when doing manual commit management.


We should probably move this within the commit management code to further simplify the code.


 


Also, as pointed here, the data structure in use is not thread-safe.",orpiske:1651198851:2022-04-29T10:20:51.143+0000:1651198851:2022-04-29T10:20:51.143+0000:Fixed with the linked PR.
0,CAMEL-18023,Improvement,Major,None,3.17.0,"
None
",Resolved,Resolved,3.17.0,Marat Gubaidullin,Marat Gubaidullin,0,1,2022-04-28 02:52:34+00:00,2022-05-02 15:25:48+00:00,"Properties in application.properties file automagically mapped to command arguments(options)
ex: for command build subcommand image option openshift




camel.jbang.build.image.openshift=true




ex: for command deploy option image




camel.jbang.deploy.image=karavan/deploy-demo:1.0.0




 


 


Common reused options: namespace, name and version automagically mapped to all command/subcommand options with respective names




camel.jbang.project.namespace=development
camel.jbang.project.name=demo
camel.jbang.project.version=1.0.0",
0,CAMEL-18022,Bug,Minor,"3.15.0, 3.16.0",4.x,"
None
",Open,Unresolved,4.x,Andrea Cosentino,Jawad Ahmad,0,2,2022-04-27 18:10:54+00:00,2023-08-09 09:10:40+00:00,"I am trying to configure AWS2 S3 component. I have folders under a hierarchy where the bucket name is top of the hierarchy and then different subfolders which will have actual files.


But when I configure the route, it fails with 403 error on Head Bucket Request. I believe as my bucket name doesn't match the regex pattern (as it contains a subfolder name as well), this request gets failed.


We need to move away from HeadBucketRequests or provide a way to configure herirchical folders structure. 




 try {
            s3Client.headBucket(HeadBucketRequest.builder().bucket(bucketName).build());
            LOG.trace(""Bucket [{}] already exists"", bucketName);
            return;
        } catch (AwsServiceException ase) {
            /* 404 means the bucket doesn't exist */
            if (!(ase.awsErrorDetails().sdkHttpResponse().statusCode() == 404)) {
                throw ase;
            }
        }




E.g : If bucket name = Test and folder name = CSV then S3 path of folder would look like : s3://Test/CSV/ . Configuring this in AWS route fails on Bucket Head Request.","acosentino:1651061660:2022-04-27T20:14:20.871+0000:1651061660:2022-04-27T20:14:20.871+0000:Head bucket is a cheaper and faster invocation then listing all the buckets and check. This is the main reason for using it. Can you please show an example of your route and bucket name and structure?

It's really a corner case and moving away from this for a corner case needs a justification 
jawwad124:1651062007:2022-04-27T20:20:07.681+0000:1651062007:2022-04-27T20:20:07.681+0000:E.g : If bucket name = Test and folder name = CSV then S3 path of folder would look like : s3://Test/CSV/ . Configuring this in the AWS route fails on Bucket Head Request.

I don't think this is a corner case. It's very common to have sub folders in the main bucket.
acosentino:1651062970:2022-04-27T20:36:10.671+0000:1651062970:2022-04-27T20:36:10.671+0000:In that case the bucket name is only test and the check should be for test and not for subfolders
acosentino:1651064098:2022-04-27T20:54:58.058+0000:1651064098:2022-04-27T20:54:58.058+0000:I'll check, but bucket name is a thing, subfolders a different thing. The check is for the bucket name only, not for subfolders. Are you consuming or producing?
jawwad124:1651066206:2022-04-27T21:30:06.314+0000:1651066206:2022-04-27T21:30:06.314+0000:I am using it for both.
jawwad124:1651066723:2022-04-27T21:38:43.972+0000:1651066723:2022-04-27T21:38:43.972+0000:Maybe we can provide another header to set bucket name ? Or just split and use first name as bucket name. Will it be able to create sub folders ?
"
0,CAMEL-18021,Improvement,Major,None,3.17.0,"
None
",Resolved,Fixed,3.17.0,Nicolas Filotto,Nicolas Filotto,0,1,2022-04-27 16:42:10+00:00,2022-04-28 07:13:05+00:00,"For now it is not possible to upgrade Debezium to 1.9 because  PostgresConnectorConfig has a default value for a type list that is not properly supported by the maven plugin such that we end up with compilation error of the following type:



[ERROR] COMPILATION ERROR : 
[INFO] -------------------------------------------------------------
[ERROR] /camel/components/camel-debezium/camel-debezium-postgres/src/generated/java/org/apache/camel/component/debezium/configuration/PostgresConnectorEmbeddedDebeziumConfiguration.java:[97,39] error: illegal start of expression
[ERROR] /camel/camel/components/camel-debezium/camel-debezium-postgres/src/generated/java/org/apache/camel/component/debezium/configuration/PostgresConnectorEmbeddedDebeziumConfiguration.java:[97,41] error: <identifier> expected
[INFO] 2 errors",nfilotto:1651052545:2022-04-27T17:42:25.233+0000:1651052545:2022-04-27T17:42:25.233+0000:The related PR https://github.com/apache/camel/pull/7506
0,CAMEL-18020,Task,Major,None,3.17.0,"
None
",Resolved,Fixed,3.17.0,Otavio Rodolfo Piske,Nicolas Filotto,0,2,2022-04-27 15:25:24+00:00,2022-04-29 10:20:38+00:00,It looks the poll exception strategy is initialized too early as it is initialized with the consumer field that is always null at this stage. The code should be review to ensure that all its parameters are properly initialized first,orpiske:1651198838:2022-04-29T10:20:38.144+0000:1651198838:2022-04-29T10:20:38.144+0000:Fixed with the linked PR.
0,CAMEL-18019,Task,Major,None,3.17.0,"
None
",Resolved,Fixed,3.17.0,Otavio Rodolfo Piske,Otavio Rodolfo Piske,0,1,2022-04-27 13:21:53+00:00,2022-04-29 10:21:08+00:00,"Recent features such as the pausable API and the health checks may result in concurrent access to the Kafka fetch records task thread. This was not the case when the code was last refactored.


As such, this may require that some fields are properly guarded or marked as volatile [1].


 


This is a task to review that. (h/t: to essobedo who raised this warning) 


 


1. https://github.com/apache/camel/pull/7502#issuecomment-1110979435",orpiske:1651198868:2022-04-29T10:21:08.640+0000:1651198868:2022-04-29T10:21:08.640+0000:Fixed with the linked PR(s).
0,CAMEL-18018,New Feature,Major,None,3.17.0,"
None
",Resolved,Fixed,3.17.0,Claus Ibsen,Claus Ibsen,0,1,2022-04-27 09:29:49+00:00,2022-04-27 17:39:53+00:00,"Add option in camel-main to specify save to disk for java-dsl with joor and that it can load from disk on next run, instead of compiling again.","davsclaus:1651042098:2022-04-27T14:48:18.385+0000:1651052390:2022-04-27T17:39:50.811+0000:TODO: option to save to disk *DONE*
TODO: load from disk *DONE*"
0,CAMEL-18017,Bug,Minor,3.16.0,4.x,"
None
",Open,Unresolved,4.x,Unassigned,Ted Lundqvist,0,2,2022-04-27 06:56:03+00:00,2023-12-06 11:08:23+00:00,"When the http response with an MDN is received it is parsed to a MultipartSignedEntity-object. 
When the object is serialized back to an outputstream using the method AS2MessageDispositionNotificationEntity#writeTo the string is not guaranteed to be identical to the the string received in the original http-response.


This makes it impossible to calculate an correct message-digest and the method MultipartSignedEntity#isValid returns false because the following exception is thrown:
""org.bouncycastle.cms.CMSSignerDigestMismatchException: message-digest attribute value does not match calculated value""
when calling: 
signer.verify(new JcaSimpleSignerInfoVerifierBuilder().setProvider(""BC"").build(cert)


I tried to use the AS2-client to send messeages to both IBM Datapower and ArcESB and it was not possible to validate the MDN from neither of them.


A few examples of differences between the actual received string and the reconstructed string are (see the full examples further down):



The order of the fields in the disposition-notification was in the wrong order:
In the original string they where ordered as follows:
Reporting-UA
Original-Recipient
Final-Recipient
Original-Message-ID
Disposition
Received-content-MIC
But in the reconstructed string the field Original-Recipient had been moved down and was placed before Received-content-MIC.
Received-content-MIC returned from both Datapower and ArcESB had a space between the comma-sign and the algorithmId.
In the reconstructed string the space-character was removed.
According to the example in RFC4130 (https://datatracker.ietf.org/doc/html/rfc4130) is seems as if it should be ok to have a space-character.
In the MDN from ArcESB the field Received-content-MIC the word content was written with a capital 'C' i.e. Received-Content-MIC.
I'm not sure if that is valid according to the standard or not.



The actual string received in the http-response:




Content-Type: multipart/report; report-type=disposition-notification; boundary=8e7e662d-3449-4777-96dc-7a6ba5ddbfb3

--8e7e662d-3449-4777-96dc-7a6ba5ddbfb3
Content-Type: text/plain; charset=us-asciiThis MDN response message is for:Original-Message-ID: <52vncg5lq4.1sqyji9ko4yxk@camel.apache.org>
From: AMFAutoTest_AS2--8e7e662d-3449-4777-96dc-7a6ba5ddbfb3
Content-Type: message/disposition-notificationReporting-UA: DataPower
Original-Recipient: rfc822; ""TEST""
Final-Recipient: rfc822; ""TEST""
Original-Message-ID: <52vncg5lq4.1sqyji9ko4yxk@camel.apache.org>
Disposition: automatic-action/MDN-sent-automatically; processed
Received-content-MIC: vUE91/gKwRCPdosfVE3H/VQNy1xHgZ+YWoVgcM5mVBya/ggZb7KxjozNUk7ewsrHOxoI9BDY2uURCcxpKU9dYA==, sha-512

--8e7e662d-3449-4777-96dc-7a6ba5ddbfb3-- 



The String reconstructed from the MultipartSignedEntity:




Content-Type: multipart/report; report-type=disposition-notification; boundary=8e7e662d-3449-4777-96dc-7a6ba5ddbfb3

--8e7e662d-3449-4777-96dc-7a6ba5ddbfb3
Content-Type: text/plain; charset=us-asciiThis MDN response message is for:Original-Message-ID: <52vncg5lq4.1sqyji9ko4yxk@camel.apache.org>
From: AMFAutoTest_AS2--8e7e662d-3449-4777-96dc-7a6ba5ddbfb3
Content-Type: message/disposition-notificationReporting-UA: DataPower
Final-Recipient: rfc822;""TEST""
Original-Message-ID: <52vncg5lq4.1sqyji9ko4yxk@camel.apache.org>
Disposition: automatic-action/MDN-sent-automatically;processed
Original-Recipient: rfc822; ""TEST""
Received-content-MIC: vUE91/gKwRCPdosfVE3H/VQNy1xHgZ+YWoVgcM5mVBya/ggZb7KxjozNUk7ewsrHOxoI9BDY2uURCcxpKU9dYA==,sha-512

--8e7e662d-3449-4777-96dc-7a6ba5ddbfb3-- 



In order to always being able to calculate a correct digest the original string that was signed should be preserved as is.","davsclaus:1672795914:2023-01-04T09:31:54.800+0000:1672795914:2023-01-04T09:31:54.800+0000:Ah you mean the reconstructed string can reorder the ket/value lines ?
TedL:1672799261:2023-01-04T10:27:41.037+0000:1672799524:2023-01-04T10:32:04.694+0000:Yes! But also the format is changed as I mentioned regarding the field name Received-Content-MIC

One way to get around this problem would be to save an exact copy of the signed string instead of parsing it and then create a new string from the object.
davsclaus:1672802548:2023-01-04T11:22:28.385+0000:1672802548:2023-01-04T11:22:28.385+0000:Yes that sounds like a good plan, would you be able to try and implement this and send a PR or patch file.
TedL:1673506765:2023-01-12T14:59:25.929+0000:1673506795:2023-01-12T14:59:55.661+0000:Sorry for the late response.
Unfortunately we gave up our attempt to use Camel for AS2 communication and I have moved on to other things.

I created att workaround that solves this problem but I think that in order to make a proper fix a major rework is needed.
You can find my solution here if you would like to have look: [https://github.com/apache/camel/commit/810c7dea0758a049c06bc5927f18ca9d9938b9d4]"
0,CAMEL-18016,Improvement,Minor,3.16.0,3.17.0,"
None
",Resolved,Fixed,3.17.0,Unassigned,Benjamin Graf,0,2,2022-04-26 18:49:20+00:00,2022-04-27 05:04:03+00:00,"Latest added mojos are missing parameters not given



GenerateEndpointUriFactoryMojo.class
GenerateInvokeOnHeaderMojo.class",davsclaus:1651007043:2022-04-27T05:04:03.256+0000:1651007043:2022-04-27T05:04:03.256+0000:Thanks for reporting and the PR
0,CAMEL-18015,Bug,Minor,None,3.17.0,"
None
",Resolved,Fixed,3.17.0,Claus Ibsen,Claus Ibsen,0,2,2022-04-26 16:34:04+00:00,2022-04-28 03:58:30+00:00,"The syntax in the metadata is wrong, it should use that old as400 standard","ThePrez:1651089510:2022-04-28T03:58:30.994+0000:1651089510:2022-04-28T03:58:30.994+0000:Thanks!! 

[commit link for reference|https://github.com/apache/camel/commit/507017ec5b647ab57e3d6caa4972142eed70f17c]"
0,CAMEL-18014,New Feature,Major,None,3.17.0,"
None
",Resolved,Fixed,3.17.0,Claus Ibsen,Claus Ibsen,0,1,2022-04-26 14:04:15+00:00,2022-04-27 09:30:04+00:00,"When compiling with camel-java-dsl we can have it capture the compiled byte code, which allows us to write to disk, which we can make possible as a build step, that allows to load the routes from disk and avoid the compilation step at runtime.",
0,CAMEL-18013,Improvement,Major,None,Future,"
None
",Open,Unresolved,Future,Otavio Rodolfo Piske,Otavio Rodolfo Piske,0,1,2022-04-26 08:30:07+00:00,2022-04-26 08:38:47+00:00,"I think we should be able to allow finer control of which exceptions can trigger a pause and which doesn't. For instance, we should be able to do something like:


 


 




onException(SomeException.class)
       .pausable(consumerListener, o -> canContinue());
from(from).routeId(""pausable-it"")
     .process(exchange -> LOG.info(""Got record from Kafka: {}"", exchange.getMessage().getBody()))
     .to(intermediate);




So that if AnotherException is thrown, the consumer does not pause.


Note: those using the circuit breaker can already filter unwanted exceptions via the event publisher - although, it is not very elegant.",
0,CAMEL-18012,Improvement,Minor,"3.14.2, 3.16.0",3.17.0,"
None
",Resolved,Fixed,3.17.0,Claus Ibsen,Steffen Brauns,0,2,2022-04-26 08:12:56+00:00,2022-05-03 05:08:29+00:00,"Within method DefaultMainShutdownStrategy#handleHangup() there is a fixed additional 5 seconds timeout value to allow camel to shutdown gracefully (see attached screenshot). In my usage of camel this 5 seconds aren't enough (I need in some cases e.g. 30 seconds), otherwise my application cannot shutdown gracefully. This additional timeout value should be made in some way configurable (at least with a setter, constructor, better with a command line option for org.apache.camel.spring.Main)!","davsclaus:1650950044:2022-04-26T13:14:04.312+0000:1650950090:2022-04-26T13:14:50.131+0000:Just configure the shtudown timeout on camel to be higher, there are plenty of ways to configure that already
https://camel.apache.org/manual/graceful-shutdown.html
sbrauns:1651015585:2022-04-27T07:26:25.342+0000:1651015585:2022-04-27T07:26:25.342+0000:[~davsclaus]:
The problem unfortunately came up after I migrated from Camel 2 to 3: 
In my case there are hundreds of routes which need a quite short shutdowntimeout. I have configured this globally on context level. When shutting down the application, these hundreds of routes are not closed fast enough one after the other, so the new DefaultMainShutdownStrategy terminates the application hard, which I don't want. The behavior as it was in Camel 2 was exactly what I needed. 
davsclaus:1651103488:2022-04-28T07:51:28.804+0000:1651103488:2022-04-28T07:51:28.804+0000:the shutdown timeout is per camel context (not per route) - so if you have 1 or 100 routes they use the same timeout.

To better understand you problem, how exactly do you package and run your Camel ?
sbrauns:1651144855:2022-04-28T19:20:55.926+0000:1651144855:2022-04-28T19:20:55.926+0000:My Application is started as a simple java process on linux via camel.spring.Main class. Something like 
java ${jvm.arguments} -cp ./lib/* org.apache.camel.spring.Main -applicationContext classpath:my-camel-spring-context.xml &> consolelog.txt
davsclaus:1651177226:2022-04-29T04:20:26.927+0000:1651177226:2022-04-29T04:20:26.927+0000:And inside my-camel-spring-context.xml do you have only 1 <camelContext> or how many do you have?
sbrauns:1651224967:2022-04-29T17:36:07.261+0000:1651224967:2022-04-29T17:36:07.261+0000:Yes, I have exactly one CamelContext within the application in spring-context.xml. It is started when the process starts and is shutting down when the application receives the hang up signal.
davsclaus:1651268050:2022-04-30T05:34:10.717+0000:1651268050:2022-04-30T05:34:10.717+0000:How have you configure the shutdown timeout, and what value did you set it to?
sbrauns:1651462502:2022-05-02T11:35:02.770+0000:1651462540:2022-05-02T11:35:40.526+0000:<bean id=""myCamelShutdownStrategy"" class=""org.apache.camel.impl.engine.DefaultShutdownStrategy"">
    <property name=""timeout"" value=""2000"" />
    <property name=""timeUnit"" value=""MILLISECONDS"" />
</bean>

There is only one spring bean of type DefaultShutdownStrategy
davsclaus:1651462915:2022-05-02T11:41:55.118+0000:1651462915:2022-05-02T11:41:55.118+0000:That bean means that the entire camel context, only have 2 seconds to shutdown all of its routes (it is NOT per route).
The default value for this is 45 seconds.

You should set this to a higher value.

The extra 5 seconds are only for additional services to shutdown that are not essentiallt part of camel routes, but internal camel services. However 5 seconds could potentially be low in case there is a lot of extra services, and then it can make sense to have a higher value for that.

But in your use-case the 2 seconds should be much higher especially if you have 100s routes.
davsclaus:1651469834:2022-05-02T13:37:14.686+0000:1651469834:2022-05-02T13:37:14.686+0000:You can set extra timeout now, such as (44 seconds)

-Dcamel.main.extraShutdownTimeout=44
sbrauns:1651474444:2022-05-02T14:54:04.128+0000:1651474444:2022-05-02T14:54:04.128+0000:[~davsclaus] : ""You should set this to a higher value."" --> I'll have a look into that! For some reasons this was for our application not possible/useful a few years ago with Camel 2.X. 
Thanks for the fix/extension, and keep up the great work on this awesome framework! :)"
0,CAMEL-18011,Dependency upgrade,Major,None,"3.11.7, 3.14.3, 3.17.0","
None
",Resolved,Fixed,"3.11.7, 3.14.3, 3.17.0",Claus Ibsen,Claus Ibsen,0,1,2022-04-26 07:05:28+00:00,2022-04-28 20:18:36+00:00,No Desc,davsclaus:1650927976:2022-04-26T07:06:16.572+0000:1650927976:2022-04-26T07:06:16.572+0000:And for 3.11.x there is a 2.5.13 release
0,CAMEL-18010,Improvement,Major,None,3.17.0,"
None
",Resolved,Fixed,3.17.0,Claus Ibsen,Claus Ibsen,0,1,2022-04-25 19:30:46+00:00,2022-04-26 07:39:18+00:00,"When running from jbang then some JARs are pre-loaded on CP. We should deal with this to know that its a JAR that is needed at runtime (hence downloaded).


This makes it possible to better resolve the correct set of JARs for package fat-jar and other goals.",
0,CAMEL-18009,Test,Major,None,3.17.0,"
None
",Resolved,Fixed,3.17.0,Freeman Yue Fang,Freeman Yue Fang,0,1,2022-04-25 14:17:55+00:00,2022-04-29 20:27:25+00:00,No Desc,"ffang:1651231146:2022-04-29T19:19:06.240+0000:1651231146:2022-04-29T19:19:06.240+0000:PR is
https://github.com/apache/camel-spring-boot/pull/549"
0,CAMEL-18008,Improvement,Major,None,3.17.0,"
None
",Resolved,Resolved,3.17.0,Marat Gubaidullin,Marat Gubaidullin,0,1,2022-04-24 16:28:25+00:00,2022-05-02 15:25:37+00:00,"Deploy integration application to minikube




jbang camel@apache/camel deploy --namespace default --name demo --version 1.0 --image timer/jbang:latest --minikube --replicas 1 




Undeploy integration application to minikube




jbang camel@apache/camel undeploy --namespace default --name demo --minikube",
0,CAMEL-18007,New Feature,Minor,None,3.x,"
None
",Resolved,Auto Closed,3.x,Unassigned,Jesse Sightler,0,3,2022-04-23 01:19:57+00:00,2022-09-03 12:25:07+00:00,"Currently this can be done with composite, but it would be good to be able to do it with composite tree as well.","jeremyross:1650705550:2022-04-23T17:19:10.542+0000:1650705550:2022-04-23T17:19:10.542+0000:[~jsight] Have you tried the [raw operation|https://camel.apache.org/components/3.16.x/salesforce-component.html#raw]?
davsclaus:1662179107:2022-09-03T12:25:07.540+0000:1662179107:2022-09-03T12:25:07.540+0000:No response from user"
0,CAMEL-18006,Improvement,Major,None,3.17.0,"
None
",Resolved,Resolved,3.17.0,Marat Gubaidullin,Marat Gubaidullin,0,1,2022-04-22 16:44:41+00:00,2022-04-26 23:33:45+00:00,"Create image from jar with tag:




jbang camel@apache/camel build image --jar runner.jar --tag camel/demo




Create image from jar with tag from specified *base image *:




jbang camel@apache/camel build image --jar runner.jar --tag camel/demo --from registry.access.redhat.com/ubi8/openjdk-11-runtime:1.11




if you want to deploy later to minikube, execute the following command before build:




eval $(minikube -p minikube docker-env




Push image from jar with tag to registry:




jbang camel@apache/camel build image --jar runner.jar --tag camel/demo --registry registry.access.redhat.com/camel/jbang-demo --username demo --password demo




Build in OpenShift (BuildConfig + Build + ImageStream)




jbang camel@apache/camel build image --jar target/camel-timer-1.0.0-runner.jar  --version 1.0.0 --namespace demos --name demo --server https://xxx.opentlc.com:6443 --token=XXX --openshift",
0,CAMEL-18005,Test,Major,None,3.17.0,"
None
",Resolved,Fixed,3.17.0,Freeman Yue Fang,Freeman Yue Fang,0,1,2022-04-22 14:01:41+00:00,2022-04-28 14:12:09+00:00,No Desc,"ffang:1650888308:2022-04-25T20:05:08.392+0000:1650888308:2022-04-25T20:05:08.392+0000:PR is
https://github.com/apache/camel-spring-boot/pull/543"
0,CAMEL-18004,Improvement,Major,3.16.0,,"
None
",Closed,Not A Problem,None,Unassigned,Jawad Ahmad,0,1,2022-04-22 10:37:34+00:00,2022-04-22 14:22:23+00:00,"We are trying to integrate NHS FHIR API with our Salesforce instance. We are connecting with NHS using FHIR component. NHS Payloads are on FHIR R4 with UK Extensions.


The issue we are facing is that, apart from standard extra params, NHS API except for a few custom parameters in requests as well. There seems to be no way to add those in FHIR operations, I was able to add independent headers e.g Request ID using an HTTP interceptor but for parameters that are dependent on the current requests, I can't see any way to provide those in requests.


Look at this [NHS Summary Care Record FHIR API|
https://digital.nhs.uk/developer/api-catalogue/summary-care-record-fhir#:~:text=to%20follow%20later.-,Overview,in%20the%20patient's%20direct%20care.] it excepts a few extra parameters apart from ID.


It requires these extra parameters :


composition.identifier ( This is identifier of Bundle ID)
composition.subject:Patient.identifier (The patient's NHS number. Must be preceded with FHIR identifier (eg.""composition.subject:Patient.identifier=https://fhir.nhs.uk/Id/nhs-number|9000000009""))


I don't see a way to provide these in FHIR Read Operations.  Maybe an improvement can be done to extend ExtraParameters implementation to allow custom parameters as well.",
0,CAMEL-18003,Task,Major,None,,"
None
",Resolved,Fixed,None,Otavio Rodolfo Piske,Otavio Rodolfo Piske,0,1,2022-04-22 09:42:31+00:00,2022-04-29 10:21:22+00:00,"The Kafka consumer is not safe for concurrent access. We need to protect it from multiple different threads trying to access the instance on the component consumer. Otherwise:




java.util.ConcurrentModificationException: KafkaConsumer is not safe for multi-threaded access
        at org.apache.kafka.clients.consumer.KafkaConsumer.acquire(KafkaConsumer.java:2469) ~[kafka-clients-3.1.0.jar:?]
        at org.apache.kafka.clients.consumer.KafkaConsumer.acquireAndEnsureOpen(KafkaConsumer.java:2453) ~[kafka-clients-3.1.0.jar:?]
        at org.apache.kafka.clients.consumer.KafkaConsumer.assignment(KafkaConsumer.java:891) ~[kafka-clients-3.1.0.jar:?]
        at org.apache.camel.component.kafka.KafkaFetchRecords.pause(KafkaFetchRecords.java:519) ~[camel-kafka-3.17.0-SNAPSHOT.jar:3.17.0-SNAPSHOT]
        at org.apache.camel.component.kafka.KafkaConsumer.doSuspend(KafkaConsumer.java:221) ~[camel-kafka-3.17.0-SNAPSHOT.jar:3.17.0-SNAPSHOT]
        at org.apache.camel.support.service.BaseService.suspend(BaseService.java:189) ~[camel-api-3.17.0-SNAPSHOT.jar:3.17.0-SNAPSHOT]
        at org.apache.camel.support.service.ServiceHelper.suspendService(ServiceHelper.java:404) ~[camel-api-3.17.0-SNAPSHOT.jar:3.17.0-SNAPSHOT]
        at org.apache.camel.impl.engine.DefaultShutdownStrategy.suspendNow(DefaultShutdownStrategy.java:447) ~[camel-base-engine-3.17.0-SNAPSHOT.jar:3.17.0-SNAPSHOT]
        at org.apache.camel.impl.engine.DefaultShutdownStrategy$ShutdownTask.run(DefaultShutdownStrategy.java:620) ~[camel-base-engine-3.17.0-SNAPSHOT.jar:3.17.0-SNAPSHOT]
        at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539) ~[?:?]
        at java.util.concurrent.FutureTask.run(FutureTask.java:264) ~[?:?]
        at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136) ~[?:?]
        at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635) ~[?:?]
        at java.lang.Thread.run(Thread.java:833) ~[?:?]",orpiske:1651198882:2022-04-29T10:21:22.523+0000:1651198882:2022-04-29T10:21:22.523+0000:Fixed with the linked PR.
0,CAMEL-18002,Test,Major,None,3.17.0,"
None
",Resolved,Fixed,3.17.0,Jiri Ondrusek,Jiri Ondrusek,0,3,2022-04-22 07:53:57+00:00,2022-05-13 07:48:15+00:00,"Tested with OpenJDK Runtime Environment Temurin-11.0.14+9 (build 11.0.14+9).


Test NettyHttpSimpleUriParametersTest failed with:


[ERROR] Failures: 
[ERROR]   NettyHttpSimpleUriParametersTest>BaseNettyTest.verifyNoLeaks:65 Leaks detected while running tests: [Logger=io.netty.util.ResourceLeakDetector Level=ERROR Message=LEAK: ByteBuf.release() was not called before it's garbage-collected. See https://netty.io/wiki/reference-counted-objects.html for more information.
...","klease78:1652271538:2022-05-11T20:18:58.713+0000:1652271538:2022-05-11T20:18:58.713+0000:I believe I found the reason for this. In fact, the problem does not seem to be in the NettyHttpSimpleUriParametersTest but rather in NettyHttpSimplePooledExchangeTest.testTwo() which makes 2 requests. In the second one, the completion method which should release the allocated ByteBuffer is not called.

I found this is due to the Exchange from the first request being reused and the completion being put on it's UoW queue which is then overwritten.

I've proposed a PR which solves this in local testing.

For some reason, the leak does not appear in the test class where it actually occurs, even when setting  ResourceLeakDetector.Level.PARANOID on the test. I don't have an explanation for this.

 
davsclaus:1652314111:2022-05-12T08:08:31.012+0000:1652314111:2022-05-12T08:08:31.012+0000:Yeah thanks for spotting this Karen.

Its really weird as the pooled exchange when its released back, then its cleared its UoW so that if its reused later then its empty.
Also the pooled exchange are local for its own camel context only, so its weird that it has a knock-on effect on following tests.

If you make the test run last and isolated then it also works.

The trick to null the UoW is a clever hack.
davsclaus:1652315589:2022-05-12T08:33:09.563+0000:1652315589:2022-05-12T08:33:09.563+0000:Okay I found the real problem, so its due to netty/jetty/servlet components handles UoW in a special way, and so later in the code they re-create a new UoW which they override the existing when using pooled exchanges.

So these 3 components does not work well with exchange pooling. I have a fix for that now.
davsclaus:1652317006:2022-05-12T08:56:46.747+0000:1652317006:2022-05-12T08:56:46.747+0000:Thanks its fixed by the other linked ticket
klease78:1652399295:2022-05-13T07:48:15.093+0000:1652399295:2022-05-13T07:48:15.093+0000:[~davsclaus] Thanks for the better fix. I did consider that maybe it was better not to overwrite the existing UoW in the Exchange, and was also wondering why the Exchange we got from the pool already had a non-null UoW. But I now see it just calls a reset() on it and doesn't remove it."
0,CAMEL-18001,New Feature,Major,3.16.0,3.17.0,"
None
",Resolved,Fixed,3.17.0,Marat Gubaidullin,Marat Gubaidullin,0,1,2022-04-21 14:14:40+00:00,2022-04-28 20:24:13+00:00,https://issues.apache.org/jira/browse/CAMEL-17995,
0,CAMEL-18000,Dependency upgrade,Minor,None,None,"
None
",Resolved,Fixed,3.17.0,Unassigned,Claus Ibsen,0,1,2022-04-21 13:45:31+00:00,2022-04-28 11:16:21+00:00,osgi should work again with this release,
0,CAMEL-17999,Bug,Minor,3.14.2,"3.14.4, 3.18.0","
None
",Resolved,Fixed,"3.14.4, 3.18.0",Claus Ibsen,Steffen Brauns,0,2,2022-04-21 09:31:07+00:00,2022-06-04 13:28:13+00:00,"I am getting an exception if the clone method is invoked on an object (which has an implemented clone method) via simple language:
org.apache.camel.language.bean.RuntimeBeanExpressionException: Failed to invoke method: clone() on null due to:



org.apache.camel.component.bean.MethodNotFoundException: Method with name: clone() not found on bean ...



Example code:
...
.to(""language://simple:${body.clone()}"")
...
For full example see attachment:
InvokeCloneTest.java


Same code worked with Camel 2.X",davsclaus:1654320493:2022-06-04T13:28:13.036+0000:1654320493:2022-06-04T13:28:13.036+0000:Thanks for reporting and the unit test
0,CAMEL-17998,New Feature,Major,None,3.17.0,"
None
",Resolved,Fixed,3.17.0,Claus Ibsen,Claus Ibsen,0,1,2022-04-21 09:09:24+00:00,2022-04-27 09:14:45+00:00,A goal to build the app as a fat-jar,"davsclaus:1650539773:2022-04-21T19:16:13.430+0000:1650878739:2022-04-25T17:25:39.576+0000:TODO: fat-jar classloader to load inside the jar *DONE*
TODO: package target/camel-app as single .jar output *DONE*
TODO: MANIFEST.MF with main class entry so fat-jar can be run with java -jar *DONE*

davsclaus:1650878729:2022-04-25T17:25:29.405+0000:1651022081:2022-04-27T09:14:41.032+0000:TODO: fat-jar to work with java-joor-dsl that does runtime compilation *DONE*
TODO: fat-jar route sources as local files should be classpath resolved now *DONE*"
0,CAMEL-17997,Improvement,Major,None,3.17.0,"
None
",Resolved,Fixed,3.17.0,Claus Ibsen,Claus Ibsen,0,1,2022-04-21 08:40:22+00:00,2022-04-21 08:43:36+00:00,"We should let camel-jbang not include all of camel-core, but instead let it fine grained download what is needed.",
0,CAMEL-17996,Bug,Major,3.17.0,3.17.0,"
None
",Resolved,Fixed,3.17.0,James Netherton,James Netherton,0,1,2022-04-21 06:43:44+00:00,2022-04-21 08:39:43+00:00,"Since CAMEL-17831 any routes in Camel Quarkus that contain property placeholders have started to fail.


https://github.com/apache/camel-quarkus/issues/3739


It seems that CamelMicroProfilePropertiesSource.loadProperties cannot deal with empty String properties as it treats the property lookup as mandatory.",
0,CAMEL-17995,Improvement,Major,3.16.0,3.17.0,"
None
",Resolved,Fixed,3.17.0,Marat Gubaidullin,Marat Gubaidullin,0,1,2022-04-20 23:02:06+00:00,2022-04-21 14:15:29+00:00,"In addition to REST DSL, ex:




- rest:
    put:
      path: ""/pet""
      to: ""direct:rest1""




generator should optionally generate routes, ex:




- rest:
    put:
      path: ""/pet""
      to: ""direct:rest1""
- route:
    from:
      uri: ""direct:rest1""",
0,CAMEL-17994,Test,Major,None,3.17.0,"
None
",Resolved,Fixed,3.17.0,Jiri Ondrusek,Jiri Ondrusek,0,1,2022-04-20 13:29:34+00:00,2022-05-11 13:10:29+00:00,"There is a code in the test 


Record record = resultExchange.getIn().getBody(Record.class); assertEquals(data, new String(record.data().asByteArray()));


Body of the exchange is already converted in to InputStream in Kinesis2Consumer class.


Working code should be:


assertEquals(data,resultExchange.getIn().getBody(String.class));",
0,CAMEL-17993,Test,Major,None,3.17.0,"
None
",Resolved,Fixed,3.17.0,Jiri Ondrusek,Jiri Ondrusek,0,1,2022-04-20 12:12:58+00:00,2022-05-03 05:07:22+00:00,No Desc,
0,CAMEL-17992,Bug,Minor,"3.14.2, 3.16.0","3.14.3, 3.17.0","
None
",Resolved,Fixed,"3.14.3, 3.17.0",Karen Lease,Vincenzo Galluccio,0,3,2022-04-20 08:33:52+00:00,2022-04-27 14:57:51+00:00,"Setting the camel.component.netty.ssl-context-parameters (camel-netty-starter) does not work. 


The application starts but then when I produce a message (NettyProducer), it fails because from what I can see in the logs the Channel has not been configured with SSL (SSLEngine not configured, Client SSL handler not configured).


If I use the query parameter instead: `&ssl=true&sslContextParameters=#sslContextParameters` it works just fine.


For reference, this is how I set the springboot properties:




camel.component.netty.ssl=true
camel.component.netty.ssl-context-parameters=#sslContextParameters




This is an example of how the Spring bean looks like:




@Bean(name = ""sslContextParameters"")
public SSLContextParameters getSSLContextParameters() {
// code omitted to keep it short
SSLContextParameters scp = new SSLContextParameters();
scp.setSecureSocketProtocol(""TLSv1.2"");
scp.setSecureSocketProtocols(sspp);
scp.setServerParameters(scsp);
scp.setClientParameters(sccp);
scp.setKeyManagers(kmp);
scp.setTrustManagers(tmp);
return scp;","klease78:1650964185:2022-04-26T17:09:45.704+0000:1650964264:2022-04-26T17:11:04.813+0000:I analyzed this and found the cause. In fact the spring parameters are correctly set in the configuration on the NettyComponent. But then it calls NettyConfiguration.parseURI() and if this does not find ""ssl=true"" in the URI for the endpoint, it sets it to false, overriding the configuration. I'll push a fix.
davsclaus:1651007079:2022-04-27T05:04:39.513+0000:1651007079:2022-04-27T05:04:39.513+0000:Karen, if you have time you are welcome to cherry-pick this to 3.14.x branch
klease78:1651032522:2022-04-27T12:08:42.329+0000:1651032522:2022-04-27T12:08:42.329+0000:Sure, I'll do that."
0,CAMEL-17991,New Feature,Major,None,3.17.0,"
None
",Resolved,Fixed,3.17.0,Claus Ibsen,Claus Ibsen,0,1,2022-04-20 07:48:37+00:00,2022-04-20 09:46:59+00:00,"So you can download an existing example / source from github, and then have it saved local, so you can modify and prototype this.",
0,CAMEL-17990,Improvement,Minor,"3.14.0, 3.16.0","3.14.3, 3.17.0","
None
",Resolved,Fixed,"3.14.3, 3.17.0",Unassigned,Gianandrea Rigoni,0,2,2022-04-20 04:19:59+00:00,2022-04-20 05:47:11+00:00,"FileInputStreamCache extends InputStream but is missing a few delegates for its field ""private InputStream stream;"". 
this implies calling methods from the parent which are suboptimal on performance level, for example ""public int read(byte[] b, int off, int len)"" on InutStream is looping byte by byte while the instance in the class field might have a specific optimised implementation.","davsclaus:1650403925:2022-04-20T05:32:05.938+0000:1650403925:2022-04-20T05:32:05.938+0000:Thanks for reporting and the PR
grigoni:1650404831:2022-04-20T05:47:11.175+0000:1650404831:2022-04-20T05:47:11.175+0000:pleasure was mine!"
0,CAMEL-17989,Improvement,Major,"3.16.0, 3.17.0",3.17.0,"
None
",Resolved,Fixed,3.17.0,Marat Gubaidullin,Marat Gubaidullin,0,1,2022-04-19 22:14:52+00:00,2022-04-20 05:02:54+00:00,"starting from camel 3.16 REST DSL YAML looks like




rest:
  get:
    - path: ""/hello/{name}""
      to: ""direct:hello""




however camel-openapi-rest-dsl-generator generates 




rest:
  get:
    - path: ""/hello/{name}""
      to: 
        uri: ""direct:hello""




instead",
0,CAMEL-17988,Test,Major,None,3.17.0,"
None
",Resolved,Fixed,3.17.0,Freeman Yue Fang,Freeman Yue Fang,0,1,2022-04-19 17:38:43+00:00,2022-04-22 17:49:34+00:00,No Desc,"ffang:1650619832:2022-04-22T17:30:32.209+0000:1650619832:2022-04-22T17:30:32.209+0000:PR is 
https://github.com/apache/camel-spring-boot/pull/537"
0,CAMEL-17987,Test,Minor,3.17.0,3.17.0,"
None
",Resolved,Fixed,3.17.0,Unassigned,Thomas Cunningham,0,1,2022-04-19 17:10:03+00:00,2022-04-20 07:52:23+00:00,"[INFO] -------------------------------------------------------
[INFO]  T E S T S
[INFO] -------------------------------------------------------
[INFO] Running org.apache.camel.itest.springboot.CamelWebhookTest
[WARNING] Corrupted STDOUT by directly writing to native stream in forked JVM 1. See FAQ web page and the dump file /private/tmp/cunningt/camel-spring-boot/tests/camel-itest-spring-boot/target/surefire-reports/2022-04-19T13-07-44_460-jvmRun1.dumpstream
[ERROR] Tests run: 1, Failures: 0, Errors: 1, Skipped: 0, Time elapsed: 46.345 s <<< FAILURE! - in org.apache.camel.itest.springboot.CamelWebhookTest
[ERROR] org.apache.camel.itest.springboot.CamelWebhookTest.componentTests  Time elapsed: 1.848 s  <<< ERROR!
org.apache.logging.log4j.LoggingException: log4j-slf4j-impl cannot be present with log4j-to-slf4j
    at org.apache.logging.slf4j.Log4jLoggerFactory.validateContext(Log4jLoggerFactory.java:60)
    at org.apache.logging.slf4j.Log4jLoggerFactory.newLogger(Log4jLoggerFactory.java:44)
    at org.apache.logging.slf4j.Log4jLoggerFactory.newLogger(Log4jLoggerFactory.java:33)
    at org.apache.logging.log4j.spi.AbstractLoggerAdapter.getLogger(AbstractLoggerAdapter.java:53)
    at org.apache.logging.slf4j.Log4jLoggerFactory.getLogger(Log4jLoggerFactory.java:33)
    at org.slf4j.LoggerFactory.getLogger(LoggerFactory.java:363)
    at org.slf4j.LoggerFactory.getLogger(LoggerFactory.java:388)
    at org.apache.camel.itest.springboot.ITestApplication.main(ITestApplication.java:49)
    at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
    at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
    at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
    at java.base/java.lang.reflect.Method.invoke(Method.java:566)
    at org.springframework.boot.loader.MainMethodRunner.run(MainMethodRunner.java:49)
    at org.apache.camel.itest.springboot.arquillian.ArquillianSyncBootJarLauncher.launch(ArquillianSyncBootJarLauncher.java:54)
    at org.springframework.boot.loader.Launcher.launch(Launcher.java:58)
    at org.apache.camel.itest.springboot.arquillian.ArquillianSyncBootJarLauncher.run(ArquillianSyncBootJarLauncher.java:44)
    at org.apache.camel.itest.springboot.AbstractSpringBootTestSupport.startSpringBoot(AbstractSpringBootTestSupport.java:44)
    at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
    at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
    at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
    at java.base/java.lang.reflect.Method.invoke(Method.java:566)
    at org.junit.platform.commons.util.ReflectionUtils.invokeMethod(ReflectionUtils.java:725)
    at org.junit.jupiter.engine.execution.MethodInvocation.proceed(MethodInvocation.java:60)
    at org.junit.jupiter.engine.execution.InvocationInterceptorChain$ValidatingInvocation.proceed(InvocationInterceptorChain.java:131)
    at org.jboss.arquillian.junit5.ArquillianExtension.interceptBeforeEachMethod(ArquillianExtension.java:100)
    at org.junit.jupiter.engine.execution.ExecutableInvoker$ReflectiveInterceptorCall.lambda$ofVoidMethod$0(ExecutableInvoker.java:115)
    at org.junit.jupiter.engine.execution.ExecutableInvoker.lambda$invoke$0(ExecutableInvoker.java:105)
    at org.junit.jupiter.engine.execution.InvocationInterceptorChain$InterceptedInvocation.proceed(InvocationInterceptorChain.java:106)
    at org.junit.jupiter.engine.extension.TimeoutExtension.intercept(TimeoutExtension.java:149)
    at org.junit.jupiter.engine.extension.TimeoutExtension.interceptLifecycleMethod(TimeoutExtension.java:126)
    at org.junit.jupiter.engine.extension.TimeoutExtension.interceptBeforeEachMethod(TimeoutExtension.java:76)
    at org.junit.jupiter.engine.execution.ExecutableInvoker$ReflectiveInterceptorCall.lambda$ofVoidMethod$0(ExecutableInvoker.java:115)
    at org.junit.jupiter.engine.execution.ExecutableInvoker.lambda$invoke$0(ExecutableInvoker.java:105)
    at org.junit.jupiter.engine.execution.InvocationInterceptorChain$InterceptedInvocation.proceed(InvocationInterceptorChain.java:106)
    at org.junit.jupiter.engine.execution.InvocationInterceptorChain.proceed(InvocationInterceptorChain.java:64)
    at org.junit.jupiter.engine.execution.InvocationInterceptorChain.chainAndInvoke(InvocationInterceptorChain.java:45)
    at org.junit.jupiter.engine.execution.InvocationInterceptorChain.invoke(InvocationInterceptorChain.java:37)
    at org.junit.jupiter.engine.execution.ExecutableInvoker.invoke(ExecutableInvoker.java:104)
    at org.junit.jupiter.engine.execution.ExecutableInvoker.invoke(ExecutableInvoker.java:98)
    at org.junit.jupiter.engine.descriptor.ClassBasedTestDescriptor.invokeMethodInExtensionContext(ClassBasedTestDescriptor.java:506)
    at org.junit.jupiter.engine.descriptor.ClassBasedTestDescriptor.lambda$synthesizeBeforeEachMethodAdapter$21(ClassBasedTestDescriptor.java:491)
    at org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.lambda$invokeBeforeEachMethods$3(TestMethodTestDescriptor.java:171)
    at org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.lambda$invokeBeforeMethodsOrCallbacksUntilExceptionOccurs$6(TestMethodTestDescriptor.java:199)
    at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)
    at org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.invokeBeforeMethodsOrCallbacksUntilExceptionOccurs(TestMethodTestDescriptor.java:199)
    at org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.invokeBeforeEachMethods(TestMethodTestDescriptor.java:168)
    at org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.execute(TestMethodTestDescriptor.java:131)
    at org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.execute(TestMethodTestDescriptor.java:66)
    at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$6(NodeTestTask.java:151)
    at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)
    at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$8(NodeTestTask.java:141)
    at org.junit.platform.engine.support.hierarchical.Node.around(Node.java:137)
    at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$9(NodeTestTask.java:139)
    at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)
    at org.junit.platform.engine.support.hierarchical.NodeTestTask.executeRecursively(NodeTestTask.java:138)
    at org.junit.platform.engine.support.hierarchical.NodeTestTask.execute(NodeTestTask.java:95)
    at java.base/java.util.ArrayList.forEach(ArrayList.java:1541)
    at org.junit.platform.engine.support.hierarchical.SameThreadHierarchicalTestExecutorService.invokeAll(SameThreadHierarchicalTestExecutorService.java:41)
    at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$6(NodeTestTask.java:155)
    at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)
    at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$8(NodeTestTask.java:141)
    at org.junit.platform.engine.support.hierarchical.Node.around(Node.java:137)
    at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$9(NodeTestTask.java:139)
    at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)
    at org.junit.platform.engine.support.hierarchical.NodeTestTask.executeRecursively(NodeTestTask.java:138)
    at org.junit.platform.engine.support.hierarchical.NodeTestTask.execute(NodeTestTask.java:95)
    at java.base/java.util.ArrayList.forEach(ArrayList.java:1541)
    at org.junit.platform.engine.support.hierarchical.SameThreadHierarchicalTestExecutorService.invokeAll(SameThreadHierarchicalTestExecutorService.java:41)
    at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$6(NodeTestTask.java:155)
    at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)
    at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$8(NodeTestTask.java:141)
    at org.junit.platform.engine.support.hierarchical.Node.around(Node.java:137)
    at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$9(NodeTestTask.java:139)
    at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)
    at org.junit.platform.engine.support.hierarchical.NodeTestTask.executeRecursively(NodeTestTask.java:138)
    at org.junit.platform.engine.support.hierarchical.NodeTestTask.execute(NodeTestTask.java:95)
    at org.junit.platform.engine.support.hierarchical.SameThreadHierarchicalTestExecutorService.submit(SameThreadHierarchicalTestExecutorService.java:35)
    at org.junit.platform.engine.support.hierarchical.HierarchicalTestExecutor.execute(HierarchicalTestExecutor.java:57)
    at org.junit.platform.engine.support.hierarchical.HierarchicalTestEngine.execute(HierarchicalTestEngine.java:54)
    at org.junit.platform.launcher.core.EngineExecutionOrchestrator.execute(EngineExecutionOrchestrator.java:107)
    at org.junit.platform.launcher.core.EngineExecutionOrchestrator.execute(EngineExecutionOrchestrator.java:88)
    at org.junit.platform.launcher.core.EngineExecutionOrchestrator.lambda$execute$0(EngineExecutionOrchestrator.java:54)
    at org.junit.platform.launcher.core.EngineExecutionOrchestrator.withInterceptedStreams(EngineExecutionOrchestrator.java:67)
    at org.junit.platform.launcher.core.EngineExecutionOrchestrator.execute(EngineExecutionOrchestrator.java:52)
    at org.junit.platform.launcher.core.DefaultLauncher.execute(DefaultLauncher.java:114)
    at org.junit.platform.launcher.core.DefaultLauncher.execute(DefaultLauncher.java:86)
    at org.junit.platform.launcher.core.DefaultLauncherSession$DelegatingLauncher.execute(DefaultLauncherSession.java:86)
    at org.junit.platform.launcher.core.SessionPerRequestLauncher.execute(SessionPerRequestLauncher.java:53)
    at org.jboss.arquillian.junit5.container.JUnitJupiterTestRunner.execute(JUnitJupiterTestRunner.java:57)
    at org.jboss.arquillian.protocol.jmx.JMXTestRunner.doRunTestMethod(JMXTestRunner.java:153)
    at org.jboss.arquillian.protocol.jmx.JMXTestRunner.runTestMethodInternal(JMXTestRunner.java:137)
    at org.jboss.arquillian.protocol.jmx.JMXTestRunner.runTestMethod(JMXTestRunner.java:119)
    at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
    at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
    at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
    at java.base/java.lang.reflect.Method.invoke(Method.java:566)
    at sun.reflect.misc.Trampoline.invoke(MethodUtil.java:71)
    at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
    at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
    at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
    at java.base/java.lang.reflect.Method.invoke(Method.java:566)
    at java.base/sun.reflect.misc.MethodUtil.invoke(MethodUtil.java:260)
    at java.management/com.sun.jmx.mbeanserver.StandardMBeanIntrospector.invokeM2(StandardMBeanIntrospector.java:112)
    at java.management/com.sun.jmx.mbeanserver.StandardMBeanIntrospector.invokeM2(StandardMBeanIntrospector.java:46)
    at java.management/com.sun.jmx.mbeanserver.MBeanIntrospector.invokeM(MBeanIntrospector.java:237)
    at java.management/com.sun.jmx.mbeanserver.PerInterface.invoke(PerInterface.java:138)
    at java.management/com.sun.jmx.mbeanserver.MBeanSupport.invoke(MBeanSupport.java:252)
    at java.management/com.sun.jmx.interceptor.DefaultMBeanServerInterceptor.invoke(DefaultMBeanServerInterceptor.java:809)
    at java.management/com.sun.jmx.mbeanserver.JmxMBeanServer.invoke(JmxMBeanServer.java:801)
    at java.management.rmi/javax.management.remote.rmi.RMIConnectionImpl.doOperation(RMIConnectionImpl.java:1466)
    at java.management.rmi/javax.management.remote.rmi.RMIConnectionImpl$PrivilegedOperation.run(RMIConnectionImpl.java:1307)
    at java.management.rmi/javax.management.remote.rmi.RMIConnectionImpl.doPrivilegedOperation(RMIConnectionImpl.java:1399)
    at java.management.rmi/javax.management.remote.rmi.RMIConnectionImpl.invoke(RMIConnectionImpl.java:827)
    at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
    at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
    at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
    at java.base/java.lang.reflect.Method.invoke(Method.java:566)
    at java.rmi/sun.rmi.server.UnicastServerRef.dispatch(UnicastServerRef.java:359)
    at java.rmi/sun.rmi.transport.Transport$1.run(Transport.java:200)
    at java.rmi/sun.rmi.transport.Transport$1.run(Transport.java:197)
    at java.base/java.security.AccessController.doPrivileged(Native Method)
    at java.rmi/sun.rmi.transport.Transport.serviceCall(Transport.java:196)
    at java.rmi/sun.rmi.transport.tcp.TCPTransport.handleMessages(TCPTransport.java:562)
    at java.rmi/sun.rmi.transport.tcp.TCPTransport$ConnectionHandler.run0(TCPTransport.java:796)
    at java.rmi/sun.rmi.transport.tcp.TCPTransport$ConnectionHandler.lambda$run$0(TCPTransport.java:677)
    at java.base/java.security.AccessController.doPrivileged(Native Method)
    at java.rmi/sun.rmi.transport.tcp.TCPTransport$ConnectionHandler.run(TCPTransport.java:676)
    at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)
    at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)
    at java.base/java.lang.Thread.run(Thread.java:829)",
0,CAMEL-17986,New Feature,Minor,3.16.0,4.0.0,"
None
",Resolved,Fixed,4.0.0,Claus Ibsen,Kai Levy,0,2,2022-04-19 16:31:22+00:00,2023-07-25 06:53:59+00:00,"When using a key-shared subscription in pulsar, the consumer should be able to specify a KeySharedPolicy using camel's configuration options.","klevy-toast:1650623753:2022-04-22T18:35:53.209+0000:1650623753:2022-04-22T18:35:53.209+0000:Realized that converting from string URI to a KeySharedPolicy isn't at all trivial, so I put this down.
davsclaus:1690196439:2023-07-24T19:00:39.704+0000:1690196439:2023-07-24T19:00:39.704+0000:You can refer to beans with keySharedPolicy=#myPolicy"
0,CAMEL-17985,Improvement,Minor,None,3.17.0,"
None
",Resolved,Fixed,3.17.0,Unassigned,Bruno Mendola,0,2,2022-04-19 15:00:17+00:00,2022-04-20 12:11:54+00:00,"When trying to load a registry resource as XSLT source, XsltUriResolver uses ResourceHelper to check the scheme and then load the resource.


ResourceHelper.hasScheme(String) only supports ""file:"", ""classpath:"", ""http:"" and ""https:"" schemes, so the ""ref:"" uri fails to validate and is not correctly handled (the prefix ""classpath:"" is automatically appended).





The resulting exception when using a ""ref:"" uri is the following:




javax.xml.transform.TransformerException: java.io.FileNotFoundException: Cannot find resource: classpath:ref:camelResource-2 for URI: classpath:ref:camelResource-2
	at org.apache.camel.component.xslt.XsltUriResolver.resolve(XsltUriResolver.java:92)
	at org.apache.camel.component.xslt.XsltUriResolver.resolve(XsltUriResolver.java:100)
	at org.apache.camel.component.xslt.XsltEndpoint.loadResource(XsltEndpoint.java:322)
	at org.apache.camel.component.xslt.XsltEndpoint.doStart(XsltEndpoint.java:351)
	at org.apache.camel.support.service.BaseService.start(BaseService.java:119)
	... 49 common frames omitted
Caused by: java.io.FileNotFoundException: Cannot find resource: classpath:ref:camelResource-2 for URI: classpath:ref:camelResource-2
	at org.apache.camel.support.ResourceHelper.resolveMandatoryResourceAsInputStream(ResourceHelper.java:114)
	at org.apache.camel.component.xslt.XsltUriResolver.resolve(XsltUriResolver.java:90)
	... 53 common frames omitted","davsclaus:1650356370:2022-04-19T16:19:30.019+0000:1650356370:2022-04-19T16:19:30.019+0000:What camel version do you use, and can you show the camel route/endpoint you specify with ref.
Mendola:1650356651:2022-04-19T16:24:11.017+0000:1650356651:2022-04-19T16:24:11.017+0000:Camel 3.16.0 w/ Spring Boot integration.

This is the route YAML I'm trying to run:

 
{code:java}
- route:
    from:
      uri: kamelet:sftp-source
      steps:
        - to:
            uri: xslt:ref:camelResource-2
        - unmarshal:
            jacksonXml:
              unmarshalType: my.DomainObject
        - log:
            message: ${body}
            loggingLevel: INFO
      parameters:
        connectionHost: 127.0.0.1
        connectionPort: '2222'
        username: user
        password: password
        directoryName: import
 {code}
 

 
davsclaus:1650357260:2022-04-19T16:34:20.213+0000:1650357260:2022-04-19T16:34:20.213+0000:And `camelResource-2` is a bean id which has the resource data you want to use for xslt ?
Mendola:1650357607:2022-04-19T16:40:07.346+0000:1650357607:2022-04-19T16:40:07.346+0000:Exactly, I defined it like in this snippet:
{code:java}
camelContext.getRegistry().bind(""camelResource-2"", new String(xsltContent, StandardCharsets.UTF_8)); {code}
the data comes from the database and xsltContent is a byte array, but you get the point.

Looks like that XsltUriResolver doesn't get to call ResouceHelper.resolveMandatoryResourceAsInputStream because the ""ref:"" scheme is not recognized.
davsclaus:1650427914:2022-04-20T12:11:54.890+0000:1650427914:2022-04-20T12:11:54.890+0000:Thanks"
0,CAMEL-17984,Improvement,Major,None,3.17.0,"
None
",Resolved,Fixed,3.17.0,Marat Gubaidullin,Marat Gubaidullin,0,1,2022-04-19 14:25:40+00:00,2022-05-07 07:21:09+00:00,It would be great if camel-jbang could generate REST DSL from OpenAPI,
0,CAMEL-17983,Test,Major,None,3.17.0,"
None
",Resolved,Fixed,3.17.0,Freeman Yue Fang,Freeman Yue Fang,0,1,2022-04-19 13:38:22+00:00,2022-04-20 07:51:58+00:00,No Desc,"ffang:1650360964:2022-04-19T17:36:04.856+0000:1650360964:2022-04-19T17:36:04.856+0000:PR is
https://github.com/apache/camel-spring-boot/pull/532"
0,CAMEL-17982,Test,Major,None,,"
None
",Resolved,Won't Fix,None,Jiri Ondrusek,Jiri Ondrusek,0,1,2022-04-19 11:50:42+00:00,2022-09-03 12:24:08+00:00,No Desc,
0,CAMEL-17981,New Feature,Major,None,3.17.0,"
None
",Resolved,Fixed,3.17.0,Claus Ibsen,Aurélien Pupier,0,2,2022-04-19 07:32:00+00:00,2022-04-19 13:18:20+00:00,"Currently, jbanb binary supports `-deps` option and Camel Jabng, `-dep` option. I think the added dependencies end up to have the same behavior.


What about supporting --deps in Camel Jbang too? it would allow to to use the same syntax for the parameters when placing th parameter anywehere in teh command-line.


See also https://github.com/jbangdev/jbang/issues/1335#issuecomment-1100599695","davsclaus:1650336539:2022-04-19T10:48:59.496+0000:1650336539:2022-04-19T10:48:59.496+0000:jbang does not support carrying over its options from jbang run to camel run (app style).
So you cannot do

camel run foo.java --deps x

But we could maybe rename --dep to --deps in camel-jbang and make it similar to jbang --deps"
0,CAMEL-17980,Improvement,Major,None,3.17.0,"
None
",Resolved,Fixed,3.17.0,Claus Ibsen,Claus Ibsen,0,1,2022-04-18 12:02:43+00:00,2022-04-18 12:06:01+00:00,Other runtimes like spring-boot / quarkus etc dont create a lock file for auto terminate on delete.,
0,CAMEL-17979,Bug,Minor,3.16.0,3.17.0,"
None
",Resolved,Fixed,3.17.0,Unassigned,Jeremy Ross,0,1,2022-04-17 22:03:56+00:00,2022-04-17 22:05:30+00:00,"E.g., camel clears the value of an external Id field prior to sending to salesforce (per salesforce API requirements). The field values are being restored after the callback is invoked, however it should be done prior to invoking the callback.",
0,CAMEL-17948,Bug,Major,3.16.0,3.17.0,"
None
",Resolved,Fixed,3.17.0,Nicolas Filotto,Nicolas Filotto,0,2,2022-04-12 12:35:19+00:00,2022-04-14 09:39:55+00:00,"While working on CAMEL-17945, I realized that the tests with the scope PER_CLASS leveraging the MockEndpoint to define their assertions can fail randomly because of a race condition issue. Indeed, with the current code, a message of a previous test method can potentially call the method countDown on the latch of the following test method causing unexpected behavior.","essobedo:1649739201:2022-04-12T12:53:21.866+0000:1649739201:2022-04-12T12:53:21.866+0000:The related PR https://github.com/apache/camel/pull/7420
davsclaus:1649751329:2022-04-12T16:15:29.254+0000:1649751329:2022-04-12T16:15:29.254+0000:This test in camel-core ThrottlingExceptionRoutePolicyTest is now failing. It may be that the test source code can be updated after this PR, or that its a fringe error. Its something about expecting the mock to be slower.
essobedo:1649753300:2022-04-12T16:48:20.879+0000:1649753300:2022-04-12T16:48:20.879+0000:[~davsclaus] Are there other failing tests? Did you create a ticket for that? I will have a look to it
davsclaus:1649753446:2022-04-12T16:50:46.803+0000:1649753446:2022-04-12T16:50:46.803+0000:No its the only test failing. No ticket created.
essobedo:1649809522:2022-04-13T08:25:22.563+0000:1649810355:2022-04-13T08:39:15.218+0000:The PR of a second fix that limits the impact https://github.com/apache/camel/pull/7430
davsclaus:1649835411:2022-04-13T15:36:51.704+0000:1649836225:2022-04-13T15:50:25.632+0000:False alarm, its fast again

[INFO] Camel :: Core ...................................... SUCCESS [03:48 min]
essobedo:1649896544:2022-04-14T08:35:44.376+0000:1649896557:2022-04-14T08:35:57.300+0000:One test is failing due to this change which is {{org.apache.camel.component.ahc.ws.WsProducerConsumerTest.testRestartServer}} more details  here https://ci-builds.apache.org/job/Camel/job/Apache%20Camel/job/main/247/testReport/
essobedo:1649896983:2022-04-14T08:43:03.527+0000:1649896983:2022-04-14T08:43:03.527+0000:The fix for the regression https://github.com/apache/camel/pull/7448"
0,CAMEL-17947,Task,Major,3.17.0,"3.18.1, 3.19.0","
None
",Resolved,Fixed,"3.18.1, 3.19.0",Otavio Rodolfo Piske,Otavio Rodolfo Piske,0,1,2022-04-12 09:51:41+00:00,2022-12-07 09:17:37+00:00,"Investigate and fix the issue below: 




1496   │ java.util.ConcurrentModificationException: KafkaConsumer is not safe for multi-threaded access
1497   │     at org.apache.kafka.clients.consumer.KafkaConsumer.acquire(KafkaConsumer.java:2469) ~[kafka-clients-3.1.0.jar:?]
1498   │     at org.apache.kafka.clients.consumer.KafkaConsumer.acquireAndEnsureOpen(KafkaConsumer.java:2453) ~[kafka-clients-3.1.0.jar:?]
1499   │     at org.apache.kafka.clients.consumer.KafkaConsumer.assignment(KafkaConsumer.java:891) ~[kafka-clients-3.1.0.jar:?]
1500   │     at org.apache.camel.component.kafka.KafkaFetchRecords.pause(KafkaFetchRecords.java:518) ~[camel-kafka-3.17.0-SNAPSHOT.jar:3.17.0-SNAPSHOT]
1501   │     at org.apache.camel.component.kafka.KafkaConsumer.doSuspend(KafkaConsumer.java:221) ~[camel-kafka-3.17.0-SNAPSHOT.jar:3.17.0-SNAPSHOT]
1502   │     at org.apache.camel.support.service.BaseService.suspend(BaseService.java:189) ~[camel-api-3.17.0-SNAPSHOT.jar:3.17.0-SNAPSHOT]
1503   │     at org.apache.camel.support.service.ServiceHelper.suspendService(ServiceHelper.java:404) ~[camel-api-3.17.0-SNAPSHOT.jar:3.17.0-SNAPSHOT]
1504   │     at org.apache.camel.impl.engine.DefaultShutdownStrategy.suspendNow(DefaultShutdownStrategy.java:447) ~[camel-base-engine-3.17.0-SNAPSHOT.jar:3.17.0-SNAPSHOT]
1505   │     at org.apache.camel.impl.engine.DefaultShutdownStrategy$ShutdownTask.run(DefaultShutdownStrategy.java:620) ~[camel-base-engine-3.17.0-SNAPSHOT.jar:3.17.0-SNAPSHOT]
1506   │     at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539) ~[?:?]
1507   │     at java.util.concurrent.FutureTask.run(FutureTask.java:264) ~[?:?]
1508   │     at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136) ~[?:?]
1509   │     at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635) ~[?:?]
1510   │     at java.lang.Thread.run(Thread.java:833) ~[?:?]",orpiske:1649728344:2022-04-12T09:52:24.341+0000:1649728344:2022-04-12T09:52:24.341+0000:KafkaConsumer is not safe for multi-threaded access.
0,CAMEL-17946,New Feature,Minor,3.16.0,"3.21.0, 4.0-RC1, 4.0.0","
None
",Resolved,Fixed,"3.21.0, 4.0-RC1, 4.0.0",Dmitrii Kriukov,Ted Lundqvist,1,5,2022-04-12 08:40:07+00:00,2023-05-03 12:40:12+00:00,The AS2 component should have support for TLS for both server and client connections.,"davsclaus:1662178908:2022-09-03T12:21:48.270+0000:1662178908:2022-09-03T12:21:48.270+0000:Community users is welcome to help improve camel-as2
shikhar97gupta:1670021864:2022-12-03T06:57:44.439+0000:1670021864:2022-12-03T06:57:44.439+0000:Hi [~davsclaus], can I work on this?
davsclaus:1670027621:2022-12-03T08:33:41.665+0000:1670027621:2022-12-03T08:33:41.665+0000:Yes sure you are very welcome to work on this
shikhar97gupta:1670469404:2022-12-08T11:16:44.030+0000:1670631695:2022-12-10T08:21:35.902+0000:I added a new SSLContext field to AS2Configuration class and got ""Unable to create mojo: Empty doc for option: sc, parent options: <null>"" error while compiling. Following the contribution page, I have already added javadoc comment before the setter method (didn't see it before any getter method of other fields so skipped it for getter) and @UriParam for the field declaration. What am I missing? [~davsclaus] 
davsclaus:1670815558:2022-12-12T11:25:58.762+0000:1670815558:2022-12-12T11:25:58.762+0000:Not sure, maybe look at one of the existing options and see if you can copy what it does. If not then maybe put your code somewhere for us to take a look at
shikhar97gupta:1670929040:2022-12-13T18:57:20.711+0000:1670929040:2022-12-13T18:57:20.711+0000:Draft PR:

[https://github.com/apache/camel/pull/8896]
dkryukov:1682578539:2023-04-27T14:55:39.019+0000:1682578539:2023-04-27T14:55:39.019+0000:New draft PR [link|https://github.com/apache/camel/pull/9939]
dkryukov:1682671867:2023-04-28T16:51:07.549+0000:1682671867:2023-04-28T16:51:07.549+0000:[~davsclaus] The PR is about to be complete. It was for the main and 4.x branches. I assume it can be automatically integrated into 3.x - so the ticket needs to be Opened. Correct me if the changes can be merged into 3.x automatically. Otherwise I'm going to back port them
davsclaus:1683016904:2023-05-02T16:41:44.384+0000:1683016904:2023-05-02T16:41:44.384+0000:I think we need to backport this to camel-3.x branch so this can be in 3.21 release
dkryukov:1683077975:2023-05-03T09:39:35.752+0000:1683077975:2023-05-03T09:39:35.752+0000:PR for the branch camel-3.x [link|https://github.com/apache/camel/pull/9985]"
0,CAMEL-17945,Task,Major,None,3.17.0,"
None
",Resolved,Fixed,3.17.0,Nicolas Filotto,Nicolas Filotto,0,1,2022-04-12 08:39:35+00:00,2022-04-12 16:10:57+00:00,"While working on CAMEL-17921, I noticed that the test HazelcastSedaTransferExchangeTest was unstable and should be fixed.


 


It fails with the next errors:



[ERROR] Tests run: 2, Failures: 1, Errors: 0, Skipped: 0, Time elapsed: 2.473 s <<< FAILURE! - in org.apache.camel.component.hazelcast.HazelcastSedaTransferExchangeTest
[ERROR] org.apache.camel.component.hazelcast.HazelcastSedaTransferExchangeTest.testExchangeTransferDisabled  Time elapsed: 0.035 s  <<< FAILURE!
org.opentest4j.AssertionFailedError: Expected java.lang.AssertionError to be thrown, but nothing was thrown.
 at org.junit.jupiter.api.AssertThrows.assertThrows(AssertThrows.java:71)
 at org.junit.jupiter.api.AssertThrows.assertThrows(AssertThrows.java:37)
 at org.junit.jupiter.api.Assertions.assertThrows(Assertions.java:3082)
 at org.apache.camel.component.hazelcast.HazelcastSedaTransferExchangeTest.testExchangeTransferDisabled(HazelcastSedaTransferExchangeTest.java:92)
 at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
 at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
 at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
 at java.base/java.lang.reflect.Method.invoke(Method.java:566)
 at org.junit.platform.commons.util.ReflectionUtils.invokeMethod(ReflectionUtils.java:725)
 at org.junit.jupiter.engine.execution.MethodInvocation.proceed(MethodInvocation.java:60)
 at org.junit.jupiter.engine.execution.InvocationInterceptorChain$ValidatingInvocation.proceed(InvocationInterceptorChain.java:131)
 at org.junit.jupiter.engine.extension.TimeoutExtension.intercept(TimeoutExtension.java:149)
 at org.junit.jupiter.engine.extension.TimeoutExtension.interceptTestableMethod(TimeoutExtension.java:140)
 at org.junit.jupiter.engine.extension.TimeoutExtension.interceptTestMethod(TimeoutExtension.java:84)
 at org.junit.jupiter.engine.execution.ExecutableInvoker$ReflectiveInterceptorCall.lambda$ofVoidMethod$0(ExecutableInvoker.java:115)
 at org.junit.jupiter.engine.execution.ExecutableInvoker.lambda$invoke$0(ExecutableInvoker.java:105)
 at org.junit.jupiter.engine.execution.InvocationInterceptorChain$InterceptedInvocation.proceed(InvocationInterceptorChain.java:106)
 at org.junit.jupiter.engine.execution.InvocationInterceptorChain.proceed(InvocationInterceptorChain.java:64)
 at org.junit.jupiter.engine.execution.InvocationInterceptorChain.chainAndInvoke(InvocationInterceptorChain.java:45)
 at org.junit.jupiter.engine.execution.InvocationInterceptorChain.invoke(InvocationInterceptorChain.java:37)
 at org.junit.jupiter.engine.execution.ExecutableInvoker.invoke(ExecutableInvoker.java:104)
 at org.junit.jupiter.engine.execution.ExecutableInvoker.invoke(ExecutableInvoker.java:98)
 at org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.lambda$invokeTestMethod$7(TestMethodTestDescriptor.java:214)
 at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)
 at org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.invokeTestMethod(TestMethodTestDescriptor.java:210)
 at org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.execute(TestMethodTestDescriptor.java:135)
 at org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.execute(TestMethodTestDescriptor.java:66)
 at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$6(NodeTestTask.java:151)
 at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)
 at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$8(NodeTestTask.java:141)
 at org.junit.platform.engine.support.hierarchical.Node.around(Node.java:137)
 at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$9(NodeTestTask.java:139)
 at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)
 at org.junit.platform.engine.support.hierarchical.NodeTestTask.executeRecursively(NodeTestTask.java:138)
 at org.junit.platform.engine.support.hierarchical.NodeTestTask.execute(NodeTestTask.java:95)




Or



[ERROR] Tests run: 2, Failures: 1, Errors: 0, Skipped: 0, Time elapsed: 0.191 s <<< FAILURE! - in org.apache.camel.component.hazelcast.HazelcastSedaTransferExchangeTest
[ERROR] org.apache.camel.component.hazelcast.HazelcastSedaTransferExchangeTest.testExchangeTransferEnabled  Time elapsed: 0.009 s  <<< FAILURE!
java.lang.AssertionError: mock://result Received message count. Expected: <1> but was: <0>
	at org.apache.camel.component.mock.MockEndpoint.fail(MockEndpoint.java:1843)
	at org.apache.camel.component.mock.MockEndpoint.assertEquals(MockEndpoint.java:1800)
	at org.apache.camel.component.mock.MockEndpoint.doAssertIsSatisfied(MockEndpoint.java:449)
	at org.apache.camel.component.mock.MockEndpoint.assertIsSatisfied(MockEndpoint.java:427)
	at org.apache.camel.component.mock.MockEndpoint.assertIsSatisfied(MockEndpoint.java:417)
	at org.apache.camel.component.mock.MockEndpoint.assertIsSatisfied(MockEndpoint.java:239)
	at org.apache.camel.test.junit5.CamelTestSupport.assertMockEndpointsSatisfied(CamelTestSupport.java:990)
	at org.apache.camel.component.hazelcast.HazelcastSedaTransferExchangeTest.testExchangeTransferEnabled(HazelcastSedaTransferExchangeTest.java:76)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.junit.platform.commons.util.ReflectionUtils.invokeMethod(ReflectionUtils.java:725)
	at org.junit.jupiter.engine.execution.MethodInvocation.proceed(MethodInvocation.java:60)
	at org.junit.jupiter.engine.execution.InvocationInterceptorChain$ValidatingInvocation.proceed(InvocationInterceptorChain.java:131)
	at org.junit.jupiter.engine.extension.TimeoutExtension.intercept(TimeoutExtension.java:149)
	at org.junit.jupiter.engine.extension.TimeoutExtension.interceptTestableMethod(TimeoutExtension.java:140)
	at org.junit.jupiter.engine.extension.TimeoutExtension.interceptTestMethod(TimeoutExtension.java:84)
	at org.junit.jupiter.engine.execution.ExecutableInvoker$ReflectiveInterceptorCall.lambda$ofVoidMethod$0(ExecutableInvoker.java:115)
	at org.junit.jupiter.engine.execution.ExecutableInvoker.lambda$invoke$0(ExecutableInvoker.java:105)
	at org.junit.jupiter.engine.execution.InvocationInterceptorChain$InterceptedInvocation.proceed(InvocationInterceptorChain.java:106)
	at org.junit.jupiter.engine.execution.InvocationInterceptorChain.proceed(InvocationInterceptorChain.java:64)
	at org.junit.jupiter.engine.execution.InvocationInterceptorChain.chainAndInvoke(InvocationInterceptorChain.java:45)
	at org.junit.jupiter.engine.execution.InvocationInterceptorChain.invoke(InvocationInterceptorChain.java:37)
	at org.junit.jupiter.engine.execution.ExecutableInvoker.invoke(ExecutableInvoker.java:104)
	at org.junit.jupiter.engine.execution.ExecutableInvoker.invoke(ExecutableInvoker.java:98)
	at org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.lambda$invokeTestMethod$7(TestMethodTestDescriptor.java:214)
	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)
	at org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.invokeTestMethod(TestMethodTestDescriptor.java:210)
	at org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.execute(TestMethodTestDescriptor.java:135)
	at org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.execute(TestMethodTestDescriptor.java:66)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$6(NodeTestTask.java:151)
	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$8(NodeTestTask.java:141)
	at org.junit.platform.engine.support.hierarchical.Node.around(Node.java:137)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$9(NodeTestTask.java:139)
	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.executeRecursively(NodeTestTask.java:138)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.execute(NodeTestTask.java:95)
	at java.base/java.util.ArrayList.forEach(ArrayList.java:1541)",essobedo:1649745882:2022-04-12T14:44:42.113+0000:1649745882:2022-04-12T14:44:42.113+0000:The corresponding PR https://github.com/apache/camel/pull/7418
0,CAMEL-17944,Improvement,Major,None,3.17.0,"
None
",Resolved,Fixed,3.17.0,Claus Ibsen,Claus Ibsen,0,1,2022-04-12 08:37:11+00:00,2022-04-12 16:38:36+00:00,"We use embedded vertx http server as a light-weight HTTP server to service REST / HTTP services etc.


It enabled file upload to temp disk by default, but this does not work well in containerized apps where access to the local file system is restricted and also limited space.


For example reported by
https://github.com/apache/camel-k-runtime/issues/634


If users want a big HTTP server to deal with large file uploads, then they need to enable this and set a uploads-directory that is in a static well known location.",
0,CAMEL-17943,Improvement,Minor,None,3.17.0,"
None
",Resolved,Fixed,3.17.0,Claus Ibsen,Claus Ibsen,0,1,2022-04-12 06:37:06+00:00,2022-04-12 07:22:05+00:00,"You can do a method call expression without setting expression value, if you define the method using bean-type / method etc","davsclaus:1649719325:2022-04-12T07:22:05.749+0000:1649719325:2022-04-12T07:22:05.749+0000:It is method, tokenize, xtokenize languages that does not use expression, which should be removed from the yaml-dsl model."
0,CAMEL-17942,Bug,Minor,"3.15.0, 3.16.0",,"
None
",Resolved,Not A Problem,None,Unassigned,Dale Olzer,0,2,2022-04-11 19:24:08+00:00,2022-04-12 18:05:50+00:00,"This is issue appears in camel version 3.7 - 3.16  ,   camel 3.1 - 3.6 runs fine.


 


[DEBUG] Response abort HttpResponse[HTTP/1.1 200 OK]@6d2a2560 HttpExchange@1a47a1e8{req=SalesforceHttpRequest[GET /services/data/v53.0/sobjects/ HTTP/1.1]@6a916402[TERMINATED/null] res=HttpResponse[HTTP/1.1 200 OK]@6d2a2560[COMPLETED/java.lang.IllegalArgumentException: Buffering capacity 4194304 exceeded]} on HttpChannelOverHTTP@19c3c81d(exchange=HttpExchange@1a47a1e8{req=SalesforceHttpRequest[GET /services/data/v53.0/sobjects/ HTTP/1.1]@6a916402[TERMINATED/null] res=HttpResponse[HTTP/1.1 200 OK]@6d2a2560[COMPLETED/java.lang.IllegalArgumentException: Buffering capacity 4194304 exceeded]})[send=HttpSenderOverHTTP@20110a97(req=QUEUED,snd=COMPLETED,failure=null)[HttpGenerator@dafc37\{s=START}],recv=HttpReceiverOverHTTP@55a955d5(rsp=FAILURE,failure=java.lang.IllegalArgumentException: Buffering capacity 4194304 exceeded)[HttpParser\{s=CHUNK,171773 of -1}]]: {}
java.lang.IllegalArgumentException: Buffering capacity 4194304 exceeded
    at org.eclipse.jetty.client.util.BufferingResponseListener.onContent (BufferingResponseListener.java:124)
    at org.eclipse.jetty.client.api.Response$ContentListener.onContent (Response.java:158)
    at org.eclipse.jetty.client.api.Response$AsyncContentListener.onContent (Response.java:189)
    at org.eclipse.jetty.client.ResponseNotifier.notifyContent (ResponseNotifier.java:155)
    at org.eclipse.jetty.client.ResponseNotifier.notifyContent (ResponseNotifier.java:139)
    at org.eclipse.jetty.client.HttpReceiver$ContentListeners.notifyContent (HttpReceiver.java:693)","jeremyross:1649677818:2022-04-11T19:50:18.692+0000:1649677818:2022-04-11T19:50:18.692+0000:[~Olzer] Did you try setting the maxContentLength option? The default is 4MB. Maybe try 8MB, so 8 * 1024 * 1024.
Olzer:1649686613:2022-04-11T22:16:53.160+0000:1649686613:2022-04-11T22:16:53.160+0000:[~jeremyross] I added the following, in pom.xml file. Received the same error.

<maxContentLength>8388608</maxContentLength>
jeremyross:1649687437:2022-04-11T22:30:37.881+0000:1649687437:2022-04-11T22:30:37.881+0000:[~Olzer] Where in the pom.xml? I'm not sure that's something that is configured in the pom.
Olzer:1649735219:2022-04-12T11:46:59.290+0000:1649735219:2022-04-12T11:46:59.290+0000:Below is a snippet of the pom. Using camel 3.6.0, the DTO's that are produced come out to be about 21K. It doesn't seem like the max content length is being exceeded.

                        <plugin>
                               <groupId>org.apache.camel.maven</groupId>
                                <artifactId>camel-salesforce-maven-plugin</artifactId>
                                <version>3.16.0</version>
                                <configuration>
                                        <outputDirectory>./tmp2</outputDirectory>
                                        <packageName>com.redhat.sales.loader.generated.dto</packageName>
                                        <clientId>XXXXX</clientId>
                                        <clientSecret>XXXX</clientSecret>
                                        <userName>dolzer@redhat.com.XXX</userName>

                                        <password>XXXXX</password>
                                        <loginUrl>https://redhat--dev1.my.salesforce.com </loginUrl>
                                        <camel.component.salesforce.http-max-content-length>8388608</camel.component.salesforce.http-max-content-length>
                                        <maxContentLength>8388608</maxContentLength>
                                        <includes>
                                                <include>IE_Product_Transaction_Log__c</include>
                                        </includes>
                                </configuration>
                        </plugin>
jeremyross:1649743092:2022-04-12T13:58:12.696+0000:1649743139:2022-04-12T13:58:59.977+0000:[~Olzer] If you're getting this error using the maven plugin, add this to the configuration:

{code:xml}
<httpClientProperties>
    <maxContentLength>8388608</maxContentLength>
</httpClientProperties>
{code}

Olzer:1649755268:2022-04-12T17:21:08.758+0000:1649755268:2022-04-12T17:21:08.758+0000:Thank you [~jeremyross]     adding the httpClientProperties configuration to the pom worked.
jeremyross:1649755444:2022-04-12T17:24:04.274+0000:1649755444:2022-04-12T17:24:04.274+0000:[~Olzer] Did you figure out why the response was so gigantic?
Olzer:1649757587:2022-04-12T17:59:47.498+0000:1649757587:2022-04-12T17:59:47.498+0000:[~jeremyross] , I don't think the response is that big, it is only returning 6 java DTO files , the largest of which is about 16K. The total of 6 files is about 21K"
0,CAMEL-17941,Improvement,Major,3.16.0,"3.14.4, 3.18.0","
None
",Resolved,Fixed,"3.14.4, 3.18.0",Otavio Rodolfo Piske,Reto Peter,0,4,2022-04-11 16:19:17+00:00,2022-06-21 15:16:05+00:00,"The API used to access dropbox currently only supports the parameter ""accesstoken""
for ex. in the route:


.to(""dropbox://put?accessToken={{dropbox.accessToken}}""
                    + ""&clientIdentifier={{dropbox.clientIdentifier}}""
                    + ""&uploadMode=force""
                    + ""&remotePath=/to_cellular/"")


(by the way, the last '/' at remotePath is needed, otherwise the upload fails with 'KO')


After creating an access token inside the dropbox console and use it inside the route, the API works, but it will only work for 4 hours, after that, the following error message will be thrown:


InvalidAccessTokenException: {""error_summary"": ""expired_access_token/..."", ""error"": {"".tag"": ""expired_access_token""}}


Dropbox did change their strategy and not supporting long-lived access tokens anymore.


From the dropbox documentation: On September 30th, 2021, Dropbox will retire the creation of long-lived access tokens. Apps that require background (“offline”) access but have not yet implemented refresh tokens will be impacted.


Implement refresh tokens: For apps that want to interact with the Dropbox API when a user isn’t actively interacting with the app (“offline” access)"", we offer a long-lived refresh_token that can be used to request a new, short-lived access token.


see here: https://dropbox.tech/developers/migrating-app-permissions-and-access-tokens


Therefore I think there must be an adjustment in the API Camel is using.","rhuanrcoha:1654187321:2022-06-03T00:28:41.487+0000:1654187321:2022-06-03T00:28:41.487+0000:I`ll take a look at this issue :) 
rhuanrcoha:1654291044:2022-06-04T05:17:24.700+0000:1654291044:2022-06-04T05:17:24.700+0000:I sent a PR to solve that.
davsclaus:1654320610:2022-06-04T13:30:10.058+0000:1654320610:2022-06-04T13:30:10.058+0000:We may need to backport this to 3.14.x so users of this version can keep using dropbox
rhuanrcoha:1654358451:2022-06-05T00:00:51.072+0000:1654358451:2022-06-05T00:00:51.072+0000:[~davsclaus] to backport this to 3.14.x should I check out the 3.14.x branch build a PR to there or should I apply some additional action?
orpiske:1654385037:2022-06-05T07:23:57.783+0000:1654385093:2022-06-05T07:24:53.787+0000:[~rhuanrcoha] It's the same process as for the main one, except that the target branch is the one we use for 3.14.x development instead of main.

Thanks for contributing this fix!

Edit: more specifically, checkout the 3.14.x, cherry-pick/work on the change/etc, send a PR for that.
rhuanrcoha:1654604178:2022-06-07T20:16:18.135+0000:1654604178:2022-06-07T20:16:18.135+0000:PR backporting to 3.14.x 

https://github.com/apache/camel/pull/7736"
0,CAMEL-17940,Bug,Major,3.15.0,"3.11.7, 3.14.3, 3.17.0","
None
",Resolved,Fixed,"3.11.7, 3.14.3, 3.17.0",Claus Ibsen,Michele Blasi,0,2,2022-04-11 15:18:10+00:00,2022-04-12 07:53:53+00:00,"Hello everybody,


when we are in a clustered environment and we want use quartz scheduler to poll our directories, there is a wrong behaviour when a single node shutting down. In the class QuartzScheduledPollConsumerScheduler the method unscheduleTask does not perform the same checks that are done by the doStop method, causing the deletion of the triggers that should be used by the node still running.


 




@Override
public void unscheduleTask() {
    if (trigger != null) {
        LOG.debug(""Unscheduling trigger: {}"", trigger.getKey());
        try {
            quartzScheduler.unscheduleJob(trigger.getKey());
        } catch (SchedulerException e) {
            throw RuntimeCamelException.wrapRuntimeCamelException(e);
        }
    }
} 





@Override
protected void doStop() throws Exception {
    if (trigger != null && deleteJob) {
        boolean isClustered = quartzScheduler.getMetaData().isJobStoreClustered();
        if (!quartzScheduler.isShutdown() && !isClustered) {
            LOG.info(""Deleting job {}"", trigger.getKey());
            quartzScheduler.unscheduleJob(trigger.getKey());
        }
    }
} 



 


Thanks regards


Michele","davsclaus:1649664499:2022-04-11T16:08:19.182+0000:1649664499:2022-04-11T16:08:19.182+0000:Can you provide a github PR against main branch with a suggested fix, and it would be good if you had tested this fix in your clusterted environment.
3Rf0:1649670042:2022-04-11T17:40:42.083+0000:1649670042:2022-04-11T17:40:42.083+0000:Hi Claus, 

I have created a Github PR, I hope that can be useful for you.

 

Regards,

Michele
davsclaus:1649721233:2022-04-12T07:53:53.258+0000:1649721233:2022-04-12T07:53:53.258+0000:Thanks for reporting and the PR"
0,CAMEL-17939,Task,Major,None,3.17.0,"
None
",Resolved,Fixed,3.17.0,Claus Ibsen,Claus Ibsen,0,1,2022-04-11 13:32:30+00:00,2022-04-11 16:39:03+00:00,"https://camel.zulipchat.com/#narrow/stream/257298-camel/topic/How.20do.20I.20define.20Map.20property.3F


        // create by class
        main.addProperty(""camel.beans.foo"", ""#class:java.util.HashMap"");
        main.addProperty(""camel.beans.foo[database]"", ""mydb"");
        main.addProperty(""camel.beans.foo[username]"", ""scott"");
        main.addProperty(""camel.beans.foo[password]"", ""tiger"");


Using square brackets is not support for camel.beans, but is in other places such as camel.components","davsclaus:1649664571:2022-04-11T16:09:31.126+0000:1649664571:2022-04-11T16:09:31.126+0000:Its a little bit more difficult as we have dot style only now, and to have pure map support without the #class, then we need to auto-detect this too, so you can do

main.addProperty(""camel.beans.foo[database]"", ""mydb"");
main.addProperty(""camel.beans.foo[username]"", ""scott"");
main.addProperty(""camel.beans.foo[password]"", ""tiger"");

Then we would infer that foo is a map bean"
0,CAMEL-17938,Test,Major,None,,"
None
",Resolved,Won't Fix,None,Jiri Ondrusek,Jiri Ondrusek,0,1,2022-04-11 10:46:59+00:00,2022-09-03 12:21:12+00:00,No Desc,
0,CAMEL-17937,Task,Major,None,3.17.0,"
None
",Resolved,Fixed,3.17.0,Claus Ibsen,Claus Ibsen,0,1,2022-04-11 07:34:34+00:00,2022-04-11 07:46:20+00:00,"Some of the SSL option was marked as producer,secruity which should be common,security instead",
0,CAMEL-17936,Test,Major,None,3.17.0,"
None
",Resolved,Fixed,3.17.0,Freeman Yue Fang,Freeman Yue Fang,0,1,2022-04-08 14:28:41+00:00,2022-04-14 19:03:03+00:00,No Desc,"ffang:1649932801:2022-04-14T18:40:01.561+0000:1649932801:2022-04-14T18:40:01.561+0000:PR is
https://github.com/apache/camel-spring-boot/pull/528"
0,CAMEL-17935,Improvement,Minor,None,"3.14.3, 3.17.0","
None
",Resolved,Fixed,"3.14.3, 3.17.0",James Netherton,James Netherton,0,1,2022-04-08 11:54:51+00:00,2022-04-11 08:00:26+00:00,The object deserialization logic in CassandraCamelCodec could potentially not work in dynamic class loading environments with the plain ObjectInputStream. We could leverage something similar to that used in the JDBC & SQL components - ClassLoadingAwareObjectInputStream.,
0,CAMEL-17934,Improvement,Minor,None,"3.14.3, 3.17.0","
None
",Resolved,Fixed,"3.14.3, 3.17.0",James Netherton,James Netherton,0,1,2022-04-08 11:52:06+00:00,2022-04-11 08:00:18+00:00,"Since the Cassandra driver can dynamically load classes (like a custom load balancing policy), it makes sense to pass an appropriate ClassLoader instance to the CqlSessionBuilder if one is available. E.g the value of camelContext.getApplicationContextClassLoader().",
0,CAMEL-17933,Improvement,Minor,None,,"
None
",Resolved,Fixed,None,John Poth,John Poth,0,1,2022-04-08 11:35:34+00:00,2022-04-12 08:11:35+00:00,"It would be cool to add a section on the website describing the different ways to configure Components, Dataformats and languages in camel spring boot applications. Thanks !",
0,CAMEL-17932,Improvement,Minor,None,3.x,"
None
",Resolved,Won't Fix,3.x,Unassigned,John Poth,0,2,2022-04-08 11:03:26+00:00,2023-05-26 19:10:39+00:00,"Currently something like this fails in camel-spring-boot tests:




@EndpointInject(""mock:result"")
MockEndpoint mock;

@Test
public void testComponentConfigured() {
    // this fails
    assertTrue(mock.isLog());
}

@Bean
CamelContextConfiguration contextConfiguration() {
    return new CamelContextConfiguration() {
        @Override
        public void beforeApplicationStart(CamelContext context) {
            MockComponent mock = new MockComponent(context);
            mock.setLog(true);
            context.addComponent(""mock"", mock);
        }

        @Override
        public void afterApplicationStart(CamelContext camelContext) {
            //do nothing here
        }
    };
}




This is because the wiring for @EndpointInject happens before CamelContextConfiguration#beforeApplicationStart. Workaround is to configure the component via @Bean",davsclaus:1685099439:2023-05-26T19:10:39.779+0000:1685099439:2023-05-26T19:10:39.779+0000:That low level spring IoC stuff happens sooner and this is not the intention of that callback api to let end users do all sort of stuff there. Frankly end users should seldom use that listener api that is spring boot specific
0,CAMEL-17931,Task,Major,3.17.0,3.17.0,"
None
",Resolved,Fixed,3.17.0,Nicolas Filotto,Claus Ibsen,1,3,2022-04-08 09:18:45+00:00,2022-04-28 07:14:16+00:00,"public static final String MONGO_ID = ""_id""; // default id field


Causes this problem


[check:links    ] Found invalid urls in components/next/mongodb-component.html:
[check:links    ] 	Fragment #_endpoint_header%3C/em%3Eid at components/next/mongodb-component.html does not exist!","nfilotto:1650962390:2022-04-26T16:39:50.864+0000:1650962390:2022-04-26T16:39:50.864+0000:Depends on https://github.com/apache/camel-website/pull/833
nfilotto:1650963083:2022-04-26T16:51:23.732+0000:1650963083:2022-04-26T16:51:23.732+0000:Re-add _id as header https://github.com/apache/camel/pull/7498"
0,CAMEL-17930,Improvement,Major,None,3.17.0,"
None
",Resolved,Fixed,3.17.0,Claus Ibsen,Claus Ibsen,0,1,2022-04-08 08:22:20+00:00,2022-04-08 09:03:21+00:00,"The model exposes options as string types which allows property placeholders to be used by the end users.


However in the model we have details if its an enum and what values is possible and its java type


We can make the yaml schema generator aware of this
https://github.com/apache/camel/commit/55bc0f2430fa2df1569a8c70b853e0d9e2c5acd3","davsclaus:1649379797:2022-04-08T09:03:17.451+0000:1649379797:2022-04-08T09:03:17.451+0000:This commit shows the changes to the yaml schema with the new enums
https://github.com/apache/camel/commit/1a0c2b3078e7e16b2cb46e9901ea5b2aacaf3161"
0,CAMEL-17929,Improvement,Major,None,3.20.0,"
None
",Resolved,Fixed,3.20.0,Claus Ibsen,Claus Ibsen,0,1,2022-04-08 07:20:07+00:00,2023-01-04 09:34:45+00:00,"camel-yaml-dsl has support for error-handler with these 4 keys:




@YamlIn
@YamlType(
          nodes = { ""error-handler"", ""errorHandler"" },
          order = YamlDeserializerResolver.ORDER_DEFAULT,
          properties = {
                  @YamlProperty(name = ""ref"", type = ""string""),
                  @YamlProperty(name = ""none"", type = ""object:org.apache.camel.model.errorhandler.NoErrorHandlerDefinition""),
                  @YamlProperty(name = ""log"",
                                type = ""object:org.apache.camel.model.errorhandler.DefaultErrorHandlerDefinition""),
                  @YamlProperty(name = ""dead-letter-channel"",
                                type = ""object:org.apache.camel.model.errorhandler.DeadLetterChannelDefinition""),
          })




However that is not the standard naming we use in Camel. These are specific to KameletBinding and are for a special use-case only.


So we need to have standard Camel error-handler in camel-yaml-dsl that is universal.
And then the Camel K style error handler is only in Camel-K (or simulated specially for running KameletBinding with camel-jbang)",
0,CAMEL-17928,Test,Major,None,3.x,"
None
",Resolved,Won't Fix,3.x,Vaishnavi R,Vaishnavi R,0,1,2022-04-07 17:17:31+00:00,2022-09-03 12:19:06+00:00,No Desc,
0,CAMEL-17927,Bug,Major,3.16.0,3.17.0,"
None
",Resolved,Fixed,3.17.0,Claus Ibsen,Claus Ibsen,0,1,2022-04-07 16:15:40+00:00,2022-04-11 17:52:38+00:00,"~/Downloads ❯ jbang camel@apache/camel run https://github.com/apache/camel-kamelets-examples/tree/main/jbang/hello-java                                                                       ✘ INT
[jbang] Resolving dependencies...
[jbang] Artifacts used for dependency management:
         org.apache.camel:camel-bom:pom:3.17.0-SNAPSHOT
[jbang] org.apache.camel:camel-jbang-core:jar:3.17.0-SNAPSHOT
         org.apache.camel.kamelets:camel-kamelets:jar:0.7.1
         org.apache.camel.kamelets:camel-kamelets-utils:jar:0.7.1
Done
[jbang] Dependencies resolved
[jbang] Building jar...
A new lock file was created, delete the file to stop running:
/Users/davsclaus/Downloads/./.run13545688403169638587.camel.lock
2022-04-07 18:15:06.002  INFO 72320 — [           main] org.apache.camel.main.MainSupport        : Apache Camel (JBang) 3.17.0-SNAPSHOT is starting
2022-04-07 18:15:06.020  INFO 72320 — [           main] org.apache.camel.main.MainSupport        : Additional files added to classpath: https://github.com/apache/camel-kamelets-examples/tree/main/jbang/hello-java
2022-04-07 18:15:06.125  INFO 72320 — [           main] component.properties.PropertiesComponent : PropertiesComponent added custom PropertiesSource (factory): camel-dsl-modeline
java.lang.IllegalArgumentException: Unable to determine file extension for resource: classpath:
	at org.apache.camel.impl.engine.DefaultRoutesLoader.resolveRoutesBuilderLoader(DefaultRoutesLoader.java:200)
	at org.apache.camel.impl.engine.DefaultRoutesLoader.preParseRoute(DefaultRoutesLoader.java:137)
	at org.apache.camel.main.RoutesConfigurer.configureModeline(RoutesConfigurer.java:278)
	at org.apache.camel.main.BaseMainSupport.modelineRoutes(BaseMainSupport.java:510)
	at org.apache.camel.main.BaseMainSupport.autoconfigure(BaseMainSupport.java:390)
	at org.apache.camel.main.BaseMainSupport.postProcessCamelContext(BaseMainSupport.java:566)
	at org.apache.camel.main.MainSupport.initCamelContext(MainSupport.java:395)
	at org.apache.camel.main.KameletMain.doInit(KameletMain.java:121)
	at org.apache.camel.support.service.BaseService.init(BaseService.java:83)
	at org.apache.camel.support.service.BaseService.start(BaseService.java:111)
	at org.apache.camel.dsl.jbang.core.commands.Run.run(Run.java:348)
	at org.apache.camel.dsl.jbang.core.commands.Run.call(Run.java:134)
	at org.apache.camel.dsl.jbang.core.commands.Run.call(Run.java:47)
	at picocli.CommandLine.executeUserObject(CommandLine.java:1953)
	at picocli.CommandLine.access$1300(CommandLine.java:145)
	at picocli.CommandLine$RunLast.executeUserObjectOfLastSubcommandWithSameParent(CommandLine.java:2358)
	at picocli.CommandLine$RunLast.handle(CommandLine.java:2352)
	at picocli.CommandLine$RunLast.handle(CommandLine.java:2314)
	at picocli.CommandLine$AbstractParseResultHandler.execute(CommandLine.java:2179)
	at picocli.CommandLine$RunLast.execute(CommandLine.java:2316)
	at picocli.CommandLine.execute(CommandLine.java:2078)
	at org.apache.camel.dsl.jbang.core.commands.CamelJBangMain.run(CamelJBangMain.java:43)
	at main.CamelJBang.main(CamelJBang.java:37)",
0,CAMEL-17926,Task,Minor,3.17.0,4.x,"
None
",Open,Unresolved,4.x,Unassigned,Zoran Regvart,0,1,2022-04-07 15:07:03+00:00,2023-08-09 09:11:07+00:00,"During the recent troubleshooting of the differences between the documentation in Camel Spring Boot and Camel I've identified some long standing issues with the documentation.



To appease the referential integrity checks a placeholder springdoc component  documentation was created. This should be removed and the SpringDoc Starter documentation should remain only visible via the Camel Spring Boot documentation.
DSLs in Camel do not include the Camel Spring Boot configuration snippet like the component documentation has. It should be added to the DSLs as they have starters much like the component documentation it includes now.
DSLs in Camel do not have the camel-spring-boot-name attribute, it should be set for the referential integrity to notice issues other than the mismatch in component vs starter counts.
Camel metadata JSON (in src/main/docs) is missing for debug, cloudevents and DSLs. It was manually copied over from the Camel project in this commit. Automation should be done to make sure those are present and updated with changes in the Camel repository.
DSL documentation doesn't appear in the Camel Spring Boot starter list page. It should be added, most likely as a separate section.",
0,CAMEL-17925,Bug,Minor,"3.12.0, 3.14.2, 3.15.0, 3.16.0",3.18.0,"
None
",Resolved,Fixed,3.18.0,Karen Lease,Espen Andreassen,0,3,2022-04-07 12:11:30+00:00,2023-11-07 10:08:05+00:00,"Description:
Errors thrown in kafka-consumer routes with ""breakOnFirstError"" enabled does not trigger reprocessing in 3.12.0 and forward, as if option ""breakOnFirstError"" is not respected.


Reproduction:



Configure a route consuming from kafka with option ""breakOnFirstError"" enabled
Trigger an exception in route



Expected result:



Should break out, seek back to offset of the message that caused the failure and then reattempt to process the message (as per the [docs|https://camel.apache.org/components/3.14.x/kafka-component.html]: )



Actual result:



Consumer continuous to next message



GitHub project reproducing the issue


https://github.com/espeandr/camel-kafka-break-on-error-demo


Test-runs
3.16.0 (failing): https://github.com/espeandr/camel-kafka-break-on-error-demo/runs/5886049034?check_suite_focus=true
3.11.6 (succeeding): https://github.com/espeandr/camel-kafka-break-on-error-demo/runs/5886221956?check_suite_focus=true","davsclaus:1649312169:2022-04-07T14:16:09.701+0000:1649312169:2022-04-07T14:16:09.701+0000:I wonder if you could put this up as a ready to run spring boot project on github so its quick for us to try,
or build as an integration test for camel-kafka so we can have it as a test case for the future - see existing tests how they are done.
eandre:1649397826:2022-04-08T14:03:46.742+0000:1649397826:2022-04-08T14:03:46.742+0000:I've updated the description with a github spring boot project
davsclaus:1651879362:2022-05-07T07:22:42.428+0000:1651879362:2022-05-07T07:22:42.428+0000:Cn you try with latest SNAPSHOT code or with 3.17 when its released as we keep improving camel-kafka
eandre:1652221309:2022-05-11T06:21:49.287+0000:1652221309:2022-05-11T06:21:49.287+0000:I'm guessing 3.17.0-SNAPSHOT isn't released somewhere and readily available for testing? I will test when 3.17 is released, at least.
eandre:1652934654:2022-05-19T12:30:54.633+0000:1652934654:2022-05-19T12:30:54.633+0000:Issue is still present in 3.17.0.
klease78:1656321480:2022-06-27T17:18:00.694+0000:1656321480:2022-06-27T17:18:00.694+0000:A refactoring moved the handling of exceptions into the catch clause of the processor, but the error handler had already caught the exception. I have modified it to check if an exception is set on the Exchange which makes the test case contributed by [~eandre] work correctly.
davsclaus:1656323513:2022-06-27T17:51:53.346+0000:1656323513:2022-06-27T17:51:53.346+0000:Can this be backported to 3.14.x branch ?
klease78:1656325537:2022-06-27T18:25:37.890+0000:1656325537:2022-06-27T18:25:37.890+0000:Yes, it looks like the same code there.
davsclaus:1656329320:2022-06-27T19:28:40.950+0000:1656329320:2022-06-27T19:28:40.950+0000:Okay you are welcome to backport
klease78:1656372972:2022-06-28T07:36:12.167+0000:1656372972:2022-06-28T07:36:12.167+0000:For 3.14.x, modifying the exception handling code doesn't make test case work. It appears that the fetch position is not actually reset so the message isn't read again. I suspect it's related to the changes in the commit handling introduced in more recent versions but that is too complicated to backport, at least for me.
davsclaus:1656373383:2022-06-28T07:43:03.644+0000:1656373383:2022-06-28T07:43:03.644+0000:Thanks for looking, lets keep this for 3.18 onwards."
0,CAMEL-17924,Improvement,Minor,None,None,"
None
",Resolved,Fixed,3.17.0,Nicolas Filotto,Nicolas Filotto,0,1,2022-04-07 10:36:16+00:00,2022-04-07 13:56:57+00:00,Some static fields holding the name of an header that are not public are still exposed in the documentation of the component which is not expected as they should rather be seen as internal headers.,essobedo:1649307263:2022-04-07T12:54:23.309+0000:1649307263:2022-04-07T12:54:23.309+0000:The corresponding PR https://github.com/apache/camel/pull/7386
0,CAMEL-17923,Improvement,Major,None,None,"
None
",Resolved,Fixed,3.17.0,Nicolas Filotto,Nicolas Filotto,0,1,2022-04-07 10:11:28+00:00,2022-04-11 08:10:08+00:00,"In the documentation of an header only the name of the header is provided but the good practice is to use the related constant instead of using a string directly, so we should rather propose the name of the constant that holds the name of the header to avoid typos and to ease potential future renaming.","essobedo:1649394827:2022-04-08T13:13:47.552+0000:1649394827:2022-04-08T13:13:47.552+0000:The corresponding PR https://github.com/apache/camel/pull/7401
essobedo:1649635808:2022-04-11T08:10:08.997+0000:1649635808:2022-04-11T08:10:08.997+0000:The field {{constantName}} has been added to the model of the header that will contain the name of the header in the next formats:

* In case of an interface or a class: {{${declaring-class-name}#${constant-name}}}
* In case of an enum and `headersNameProvider` is set to a name of field: {{${declaring-class-name}#${enum-constant-name}@${field-name}}}
* In case of an enum and `headersNameProvider` is set to a name of method: {{${declaring-class-name}#${enum-constant-name}@${method-name}()}}
* In case of an enum by default: {{${declaring-class-name}#${enum-constant-name}}}"
0,CAMEL-17922,Bug,Minor,3.16.0,None,"
None
",Resolved,Fixed,3.17.0,Nicolas Filotto,Nicolas Filotto,0,1,2022-04-07 09:34:19+00:00,2022-04-07 12:44:26+00:00,The default value supplier of the header MIX_DIGEST is the value of the option headerPowHash while we would rather expect mixDigest,essobedo:1649295537:2022-04-07T09:38:57.755+0000:1649295537:2022-04-07T09:38:57.755+0000:The corresponding PR https://github.com/apache/camel/pull/7385
0,CAMEL-17921,Improvement,Trivial,3.16.0,3.17.0,"
None
",Resolved,Fixed,3.17.0,Nicolas Filotto,Nicolas Filotto,0,1,2022-04-07 09:07:06+00:00,2022-04-14 09:56:35+00:00,The name of some operations such as ADD_ALL and READ_ONCE_HEAD are misspelled,essobedo:1649294477:2022-04-07T09:21:17.981+0000:1649294477:2022-04-07T09:21:17.981+0000:The corresponding PR https://github.com/apache/camel/pull/7384
0,CAMEL-17920,Test,Major,None,,"
None
",Resolved,Won't Fix,None,Jiri Ondrusek,Jiri Ondrusek,0,1,2022-04-07 07:03:08+00:00,2022-09-03 12:18:24+00:00,No Desc,
0,CAMEL-17919,Test,Major,None,3.x,"
None
",Resolved,Won't Fix,3.x,Vaishnavi R,Vaishnavi R,0,1,2022-04-07 05:57:00+00:00,2022-09-03 12:18:17+00:00,No Desc,
0,CAMEL-17918,Improvement,Minor,None,None,"
None
",Resolved,Fixed,3.17.0,Nicolas Filotto,Nicolas Filotto,0,1,2022-04-06 16:10:34+00:00,2022-04-07 12:45:04+00:00,"When the headers class is an enum, so far the name of the headers can only be the name of the values of the enum which is not enough in some particular use cases. The idea of this improvement is to be able to provide the name of the field or method to invoke in order to get the name of the corresponding header.


In the next example, if the enum ""SomeEnum"" is declared as the headers class of a component, with the current code only ""FOO"" and ""BAR"" are possible values for the name of the headers while here we would rather expect ""fooKey"" and ""barKey"".


 



public enum SomeEnum {

    FOO(""fooKey""),
    BAR(""barKey"");

    public final String headerName;
 
    SomeEnum(final String str) {
        this.headerName = str;
    }
}",essobedo:1649290635:2022-04-07T08:17:15.193+0000:1649290635:2022-04-07T08:17:15.193+0000:The corresponding PR [https://github.com/apache/camel/pull/7382] which adds a new element called _{{headersNameProvider}}_ to the annotation _{{UriEndpoint}}_ in order to be able to provide the name of the field to get or the name of the method to invoke to get the name of the header
0,CAMEL-17917,Task,Minor,3.16.0,3.17.0,"
None
",Resolved,Fixed,3.17.0,Unassigned,Michael Prankl,0,2,2022-04-06 13:22:10+00:00,2022-04-07 14:16:57+00:00,"In multiple sections of camel-mail docs there are paragraphs which refer (e.g. ""The code below demonstrates this"") to example code, but the demonstration/example code is in fact missing.


Section ""Mail Message Content"":


https://github.com/apache/camel/blame/main/components/camel-mail/src/main/docs/mail-component.adoc#L210


https://github.com/apache/camel/blame/main/components/camel-mail/src/main/docs/mail-component.adoc#L213


Section ""Sending mail with attachment sample"":


https://github.com/apache/camel/blame/main/components/camel-mail/src/main/docs/mail-component.adoc#L330","eidottermihi:1649283771:2022-04-07T06:22:51.447+0000:1649283771:2022-04-07T06:22:51.447+0000:added one more missing example
davsclaus:1649312217:2022-04-07T14:16:57.889+0000:1649312217:2022-04-07T14:16:57.889+0000:Thanks for reporting and the PR."
0,CAMEL-17916,Improvement,Major,3.17.0,3.17.0,"
None
",Resolved,Fixed,3.17.0,James Netherton,James Netherton,0,1,2022-04-06 12:55:13+00:00,2022-04-07 06:17:45+00:00,"Since the implementation of CAMEL-17844, some of the camel-bean functionality in Camel Quarkus has stopped working. There's more information here:


https://github.com/apache/camel-quarkus/issues/3682","jamesnetherton:1649224679:2022-04-06T13:57:59.003+0000:1649224679:2022-04-06T13:57:59.003+0000:I'll leave this open until I can confirm everything is fixed via the CQ nightly build that runs with 3.17.0-SNAPSHOT. 
jamesnetherton:1649283465:2022-04-07T06:17:45.093+0000:1649283465:2022-04-07T06:17:45.093+0000:All of tests that use .bean(...) seem to have passed so I think this issue is now fixed"
0,CAMEL-17915,Test,Minor,None,,"
None
",Resolved,Won't Fix,None,Jiri Ondrusek,Jiri Ondrusek,0,1,2022-04-06 12:19:25+00:00,2022-09-03 12:18:11+00:00,"I noticed that topic message deduplication id strategy is not covered by componenet tests (or spring-boot-starter tests).


 


It would be nice to have it covered.",
0,CAMEL-17914,Test,Minor,None,4.x,"

help-wanted

",Open,Unresolved,4.x,Unassigned,James Netherton,0,1,2022-04-06 12:16:07+00:00,2023-11-14 13:35:27+00:00,"If camel-kafka enables users to configure SSL and the various Kafka security protocols, then we should have some basic tests for them. E.g the items listed in the SecurityProtocol enum:



SSL
SASL_PLAINTEXT
SASL_SSL",
0,CAMEL-17913,Improvement,Minor,3.14.2,3.17.0,"
None
",Resolved,Fixed,3.17.0,Claus Ibsen,itachi uchiha,0,2,2022-04-06 11:48:00+00:00,2022-05-11 19:18:15+00:00,"When we initialize a KafkaConsumer, we can set the property called isolation.level to control what transaction records are exposed to the consumer. Two values are then possible, read_uncommitted to retrieve all records, independently on the transaction outcome (if any), and read_committed to get only the records from committed transactions.
 
 in,
 org.apache.kafka.clients.consumer.ConsumerConfig
 DEFAULT_ISOLATION_LEVEL is IsolationLevel.READ_UNCOMMITTED.toString().toLowerCase(Locale.ROOT);
 
 and there is no way we can change ISOLATION_LEVEL to IsolationLevel.READ_COMMITTED by camel-kafka  


************************************************************************************************************************************************************


org.apache.kafka.clients.consumer.ConsumerConfig


----------------------------------------------------------------","davsclaus:1649223775:2022-04-06T13:42:55.556+0000:1649223775:2022-04-06T13:42:55.556+0000:Can you add more details as this ticket is empty
davsclaus:1649238048:2022-04-06T17:40:48.768+0000:1649238048:2022-04-06T17:40:48.768+0000:You can use additionalProperties to set options that camel does not have a direct option for, see the doc page
davsclaus:1649312261:2022-04-07T14:17:41.644+0000:1649312261:2022-04-07T14:17:41.644+0000:We may want to expose a special option for this for the consumers if its a common option to set."
0,CAMEL-17912,Bug,Minor,"3.11.6, 3.14.2",None,"
None
",Resolved,Fixed,"3.11.7, 3.14.3, 3.17.0",Claus Ibsen,Mikhail Lukyanov,0,2,2022-04-06 10:00:25+00:00,2022-04-12 17:32:21+00:00,"In SJMS2 producer parameter preserveMessageQos doesn't work. Message arrives with default durability and priority values, not from headers


If the parameter preserveMessageQos  value is true, the values from the headers JMSPriority, JMSDeliveryMode, and JMSExpiration are not set when the message is sent.


Steps



Install and run Apache Artemis (user/password root/root)
Create ANYCAST queue IN from console http://localhost:8161/console
Send nondurable message with 0 priority in queue IN
Run Sjms2MoveTest from sjms2Move maven project in attachment
Check message in OUT queue



Expected Behavior:


Message nondurable and has 0 priority


Received Behavior:


Message durable and has 4 priority (default values)","davsclaus:1649312334:2022-04-07T14:18:54.347+0000:1649312334:2022-04-07T14:18:54.347+0000:Thanks for reporting and the good guide on how to reproduce

You are welcome to dive into the code and see if you can find the bug / suggestion where it is / and if possible an attempted fix. Github PRs is welcome
lukymiv:1649755941:2022-04-12T17:32:21.433+0000:1649755941:2022-04-12T17:32:21.433+0000:Thanks for your reply, Сlaus. May I ask, how does this component camel-sjms2 differ from the usual camel-jms in the 3.x version, does it have any advantages over the camel-jms component? In the 2.x version, it had transaction batching, the producers count, its own thread pool, now it has been rewritten, this is not there."
0,CAMEL-17911,Bug,Major,3.16.0,"3.14.4, 3.18.0","
None
",Resolved,Fixed,"3.14.4, 3.18.0",Karen Lease,Twinkle Shah,0,3,2022-04-06 09:10:03+00:00,2022-06-23 07:28:11+00:00,"Discussion thread:


https://camel.zulipchat.com/#narrow/stream/257298-camel/topic/camel-olingo2.20.3A.20I.2FO.20Dispatcher.20threads.20leak


 


Details:


While using camel-onlingo2 to read from ODataV2 endpoint in Java, the ""I/O Dispatcher"" threads are left running even after closing the camel context.


Camel version: 3.15.0/3.16.0
With camel version 2.24.1, the issue was not reproducible.


Attaching a demo project to show the issue. Run ODataReaderTest.java to reproduce the issue


CamelOData.zip


-> With 3.15.0/3.16.0 version, there are 12 I/O Dispatcher threads which keeps running after every execution. So, every time the odata call is made the number of left over threads are piling up. This is eating up the resources on the server.
-> If camel version is changed to 2.24.1 ( build.gradle file, change value of camelVersion ), then with camel context stop, all the I/O Dispatcher threads are also closed. The same test case (ODataReaderTest) will pass with 2.24.1 version.


Analysis:
The below code is getting called twice for every execution and because of the IF condition multiple instances of Olingo2AppWrapper (apiProxy) are getting created.


https://github.com/apache/camel/blob/camel-3.15.0/components/camel-olingo2/camel-olingo2-component/src/main/java/org/apache/camel/component/olingo2/Olingo2Component.java#L121


And each of this instance creates 12 I/O Dispatcher threads. When camel context is closed only one of the instance of apiProxy ( the one which is created last) is closed, which leaves threads created by first instance as it is in RUNNING state.


With older version (2.24.1), only one instance of Olingo2AppWrapper (apiProxy) was getting created.


There is configuration variable defined in newer version which didn't exist in older version. This seems to be impacting the IF conditions and leading to multiple apiProxy instances.
Olingo2Configuration configuration;","davsclaus:1649312393:2022-04-07T14:19:53.921+0000:1649312393:2022-04-07T14:19:53.921+0000:Thanks for reporting and the reproducer. We are busy so it may take some time for us to take a look.

Community users is very welcome to take a look and help.
Also it would be good to know if there is a similar issues in olingo4 component.
davsclaus:1655803115:2022-06-21T17:18:35.921+0000:1655803115:2022-06-21T17:18:35.921+0000:Karen do you think that your PR fixes this?
klease78:1655804470:2022-06-21T17:41:10.785+0000:1655804470:2022-06-21T17:41:10.785+0000:Yes, I tried it with the example provided here. But I didn't convert that to a new test case.
davsclaus:1655807489:2022-06-21T18:31:29.907+0000:1655807489:2022-06-21T18:31:29.907+0000:Thanks for fixing this
twinkleshah:1655939167:2022-06-23T07:06:07.168+0000:1655939167:2022-06-23T07:06:07.168+0000:Hi [~davsclaus] ,

Any possibilities of putting this fix to 3.6.x  version?
davsclaus:1655940491:2022-06-23T07:28:11.175+0000:1655940491:2022-06-23T07:28:11.175+0000:No 3.6 is a non LTS version - we never patch these. And its also EOL."
0,CAMEL-17910,Bug,Major,"3.11.6, 3.14.2, 3.16.0","3.11.7, 3.14.3, 3.17.0","
None
",Resolved,Fixed,"3.11.7, 3.14.3, 3.17.0",Claus Ibsen,Claus Ibsen,1,1,2022-04-06 07:49:22+00:00,2022-04-08 08:08:29+00:00,"In org.apache.camel.component.jms.reply.MessageSelectorCreator we should use a local lock instance to ensure that get / timeout does not trigger concurrently that can render the dirty flag in wrong state, when under high load.


Also add fail-safe to the JMSCorrelationID returned so it cannot return an empty ID in the selector JMSCorrelationID=",davsclaus:1649203575:2022-04-06T08:06:15.920+0000:1649203575:2022-04-06T08:06:15.920+0000:In older Camel versions we use .size() > 0 which is not safe when using concurrency - but we changed to isEmpty that is safe.
0,CAMEL-17909,Test,Major,None,,"
None
",Resolved,Fixed,None,Jiri Ondrusek,Jiri Ondrusek,0,1,2022-04-06 07:12:14+00:00,2022-09-03 12:17:39+00:00,No Desc,
0,CAMEL-17908,Test,Major,None,3.17.0,"
None
",Resolved,Fixed,3.17.0,Freeman Yue Fang,Freeman Yue Fang,0,1,2022-04-05 15:41:58+00:00,2022-04-10 20:36:07+00:00,No Desc,"ffang:1649418129:2022-04-08T19:42:09.454+0000:1649418129:2022-04-08T19:42:09.454+0000:PR is
https://github.com/apache/camel-spring-boot/pull/511"
0,CAMEL-17907,Test,Minor,None,,"
None
",Resolved,Fixed,None,Federico Mariani,Federico Mariani,0,1,2022-04-05 15:26:57+00:00,2022-05-02 16:44:20+00:00,No Desc,
0,CAMEL-17906,Bug,Minor,"3.12.0, 3.14.2",,"
None
",Resolved,Workaround,None,Unassigned,Vincent Paturet,0,3,2022-04-05 14:06:24+00:00,2022-08-11 12:38:48+00:00,"After upgrading from Camel 3.11.5 to Camel 3.12.0, we experience a regression in a REST service that consumes multipart/form-data.
(Camel REST + Camel servlet + Tomcat + Spring Boot 2.6.4 + Spring Security + OAuth2)
When retrieving the binary attachment stored as an InputStream in the message body, the attachment is empty:
 




byte[] content = IOUtils.toByteArray(e.getIn().getBody(InputStream.class)) <-- empty byte array 




The only code change is the upgrade from Camel 3.11.5 to 3.12
When disabling the OAuth2 authentication/authorization layer, the REST service works as expected.
Tested with Camel 3.14.2 with the same outcome
possibly related to CAMEL-17004



stacktrace with OAuth2 enabled:




convertBodyToFileItems:97, FileUploadRouteBuilder (no.rutebanken.marduk.routes.file)
process:-1, 382032327 (no.rutebanken.marduk.routes.file.FileUploadRouteBuilder$$Lambda$1784)
process:66, DelegateSyncProcessor (org.apache.camel.support.processor)
doRun:810, RedeliveryErrorHandler$RedeliveryTask (org.apache.camel.processor.errorhandler)
run:718, RedeliveryErrorHandler$RedeliveryTask (org.apache.camel.processor.errorhandler)
schedule:179, DefaultReactiveExecutor$Worker (org.apache.camel.impl.engine)
scheduleSync:69, DefaultReactiveExecutor (org.apache.camel.impl.engine)
process:214, RedeliveryErrorHandler (org.apache.camel.processor.errorhandler)
access$201:45, TransactionErrorHandler (org.apache.camel.spring.spi)
process:247, TransactionErrorHandler$2 (org.apache.camel.spring.spi)
process:83, DefaultAsyncProcessorAwaitManager (org.apache.camel.impl.engine)
processByErrorHandler:244, TransactionErrorHandler (org.apache.camel.spring.spi)
doInTransactionWithoutResult:207, TransactionErrorHandler$1 (org.apache.camel.spring.spi)
doInTransaction:36, TransactionCallbackWithoutResult (org.springframework.transaction.support)
execute:140, TransactionTemplate (org.springframework.transaction.support)
doInTransactionTemplate:200, TransactionErrorHandler (org.apache.camel.spring.spi)
processInTransaction:155, TransactionErrorHandler (org.apache.camel.spring.spi)
process:123, TransactionErrorHandler (org.apache.camel.spring.spi)
process:132, TransactionErrorHandler (org.apache.camel.spring.spi)
process:399, CamelInternalProcessor (org.apache.camel.impl.engine)
run:109, Pipeline$PipelineTask (org.apache.camel.processor)
schedule:179, DefaultReactiveExecutor$Worker (org.apache.camel.impl.engine)
scheduleMain:64, DefaultReactiveExecutor (org.apache.camel.impl.engine)
process:184, Pipeline (org.apache.camel.processor)
process:399, CamelInternalProcessor (org.apache.camel.impl.engine)
process:83, DefaultAsyncProcessorAwaitManager (org.apache.camel.impl.engine)
process:41, AsyncProcessorSupport (org.apache.camel.support)
doExecute:319, CamelServlet (org.apache.camel.http.common)
doService:214, CamelServlet (org.apache.camel.http.common)
service:130, CamelServlet (org.apache.camel.http.common)
service:764, HttpServlet (javax.servlet.http)
internalDoFilter:227, ApplicationFilterChain (org.apache.catalina.core)
doFilter:162, ApplicationFilterChain (org.apache.catalina.core)
doFilter:53, WsFilter (org.apache.tomcat.websocket.server)
internalDoFilter:189, ApplicationFilterChain (org.apache.catalina.core)
doFilter:162, ApplicationFilterChain (org.apache.catalina.core)
doFilter:327, FilterChainProxy$VirtualFilterChain (org.springframework.security.web)
invoke:115, FilterSecurityInterceptor (org.springframework.security.web.access.intercept)
doFilter:81, FilterSecurityInterceptor (org.springframework.security.web.access.intercept)
doFilter:336, FilterChainProxy$VirtualFilterChain (org.springframework.security.web)
doFilter:122, ExceptionTranslationFilter (org.springframework.security.web.access)
doFilter:116, ExceptionTranslationFilter (org.springframework.security.web.access)
doFilter:336, FilterChainProxy$VirtualFilterChain (org.springframework.security.web)
doFilter:126, SessionManagementFilter (org.springframework.security.web.session)
doFilter:81, SessionManagementFilter (org.springframework.security.web.session)
doFilter:336, FilterChainProxy$VirtualFilterChain (org.springframework.security.web)
doFilterInternal:168, OAuth2AuthorizationCodeGrantFilter (org.springframework.security.oauth2.client.web)
doFilter:117, OncePerRequestFilter (org.springframework.web.filter)
doFilter:336, FilterChainProxy$VirtualFilterChain (org.springframework.security.web)
doFilter:109, AnonymousAuthenticationFilter (org.springframework.security.web.authentication)
doFilter:336, FilterChainProxy$VirtualFilterChain (org.springframework.security.web)
doFilter:149, SecurityContextHolderAwareRequestFilter (org.springframework.security.web.servletapi)
doFilter:336, FilterChainProxy$VirtualFilterChain (org.springframework.security.web)
doFilter:63, RequestCacheAwareFilter (org.springframework.security.web.savedrequest)
doFilter:336, FilterChainProxy$VirtualFilterChain (org.springframework.security.web)
doFilterInternal:137, BearerTokenAuthenticationFilter (org.springframework.security.oauth2.server.resource.web)
doFilter:117, OncePerRequestFilter (org.springframework.web.filter)
doFilter:336, FilterChainProxy$VirtualFilterChain (org.springframework.security.web)
doFilterInternal:178, OAuth2AuthorizationRequestRedirectFilter (org.springframework.security.oauth2.client.web)
doFilter:117, OncePerRequestFilter (org.springframework.web.filter)
doFilter:336, FilterChainProxy$VirtualFilterChain (org.springframework.security.web)
doFilter:103, LogoutFilter (org.springframework.security.web.authentication.logout)
doFilter:89, LogoutFilter (org.springframework.security.web.authentication.logout)
doFilter:336, FilterChainProxy$VirtualFilterChain (org.springframework.security.web)
doFilterInternal:91, CorsFilter (org.springframework.web.filter)
doFilter:117, OncePerRequestFilter (org.springframework.web.filter)
doFilter:336, FilterChainProxy$VirtualFilterChain (org.springframework.security.web)
doHeadersAfter:90, HeaderWriterFilter (org.springframework.security.web.header)
doFilterInternal:75, HeaderWriterFilter (org.springframework.security.web.header)
doFilter:117, OncePerRequestFilter (org.springframework.web.filter)
doFilter:336, FilterChainProxy$VirtualFilterChain (org.springframework.security.web)
doFilter:110, SecurityContextPersistenceFilter (org.springframework.security.web.context)
doFilter:80, SecurityContextPersistenceFilter (org.springframework.security.web.context)
doFilter:336, FilterChainProxy$VirtualFilterChain (org.springframework.security.web)
doFilterInternal:55, WebAsyncManagerIntegrationFilter (org.springframework.security.web.context.request.async)
doFilter:117, OncePerRequestFilter (org.springframework.web.filter)
doFilter:336, FilterChainProxy$VirtualFilterChain (org.springframework.security.web)
doFilterInternal:211, FilterChainProxy (org.springframework.security.web)
doFilter:183, FilterChainProxy (org.springframework.security.web)
invokeDelegate:354, DelegatingFilterProxy (org.springframework.web.filter)
doFilter:267, DelegatingFilterProxy (org.springframework.web.filter)
internalDoFilter:189, ApplicationFilterChain (org.apache.catalina.core)
doFilter:162, ApplicationFilterChain (org.apache.catalina.core)
doFilterInternal:100, RequestContextFilter (org.springframework.web.filter)
doFilter:117, OncePerRequestFilter (org.springframework.web.filter)
internalDoFilter:189, ApplicationFilterChain (org.apache.catalina.core)
doFilter:162, ApplicationFilterChain (org.apache.catalina.core)
doFilterInternal:93, FormContentFilter (org.springframework.web.filter)
doFilter:117, OncePerRequestFilter (org.springframework.web.filter)
internalDoFilter:189, ApplicationFilterChain (org.apache.catalina.core)
doFilter:162, ApplicationFilterChain (org.apache.catalina.core)
doFilterInternal:96, WebMvcMetricsFilter (org.springframework.boot.actuate.metrics.web.servlet)
doFilter:117, OncePerRequestFilter (org.springframework.web.filter)
internalDoFilter:189, ApplicationFilterChain (org.apache.catalina.core)
doFilter:162, ApplicationFilterChain (org.apache.catalina.core)
doFilterInternal:201, CharacterEncodingFilter (org.springframework.web.filter)
doFilter:117, OncePerRequestFilter (org.springframework.web.filter)
internalDoFilter:189, ApplicationFilterChain (org.apache.catalina.core)
doFilter:162, ApplicationFilterChain (org.apache.catalina.core)
invoke:197, StandardWrapperValve (org.apache.catalina.core)
invoke:97, StandardContextValve (org.apache.catalina.core)
invoke:540, AuthenticatorBase (org.apache.catalina.authenticator)
invoke:135, StandardHostValve (org.apache.catalina.core)
invoke:92, ErrorReportValve (org.apache.catalina.valves)
invoke:78, StandardEngineValve (org.apache.catalina.core)
service:359, CoyoteAdapter (org.apache.catalina.connector)
service:399, Http11Processor (org.apache.coyote.http11)
process:65, AbstractProcessorLight (org.apache.coyote)
process:889, AbstractProtocol$ConnectionHandler (org.apache.coyote)
doRun:1735, NioEndpoint$SocketProcessor (org.apache.tomcat.util.net)
run:49, SocketProcessorBase (org.apache.tomcat.util.net)
runWorker:1191, ThreadPoolExecutor (org.apache.tomcat.util.threads)
run:659, ThreadPoolExecutor$Worker (org.apache.tomcat.util.threads)
run:61, TaskThread$WrappingRunnable (org.apache.tomcat.util.threads)
run:829, Thread (java.lang)



stacktrace without OAuth2:




convertBodyToFileItems:96, FileUploadRouteBuilder (no.rutebanken.marduk.routes.file)
process:-1, 902585205 (no.rutebanken.marduk.routes.file.FileUploadRouteBuilder$$Lambda$1780)
process:66, DelegateSyncProcessor (org.apache.camel.support.processor)
doRun:810, RedeliveryErrorHandler$RedeliveryTask (org.apache.camel.processor.errorhandler)
run:718, RedeliveryErrorHandler$RedeliveryTask (org.apache.camel.processor.errorhandler)
schedule:179, DefaultReactiveExecutor$Worker (org.apache.camel.impl.engine)
scheduleSync:69, DefaultReactiveExecutor (org.apache.camel.impl.engine)
process:214, RedeliveryErrorHandler (org.apache.camel.processor.errorhandler)
access$201:45, TransactionErrorHandler (org.apache.camel.spring.spi)
process:247, TransactionErrorHandler$2 (org.apache.camel.spring.spi)
process:83, DefaultAsyncProcessorAwaitManager (org.apache.camel.impl.engine)
processByErrorHandler:244, TransactionErrorHandler (org.apache.camel.spring.spi)
doInTransactionWithoutResult:207, TransactionErrorHandler$1 (org.apache.camel.spring.spi)
doInTransaction:36, TransactionCallbackWithoutResult (org.springframework.transaction.support)
execute:140, TransactionTemplate (org.springframework.transaction.support)
doInTransactionTemplate:200, TransactionErrorHandler (org.apache.camel.spring.spi)
processInTransaction:155, TransactionErrorHandler (org.apache.camel.spring.spi)
process:123, TransactionErrorHandler (org.apache.camel.spring.spi)
process:132, TransactionErrorHandler (org.apache.camel.spring.spi)
process:399, CamelInternalProcessor (org.apache.camel.impl.engine)
run:109, Pipeline$PipelineTask (org.apache.camel.processor)
schedule:179, DefaultReactiveExecutor$Worker (org.apache.camel.impl.engine)
scheduleMain:64, DefaultReactiveExecutor (org.apache.camel.impl.engine)
process:184, Pipeline (org.apache.camel.processor)
process:399, CamelInternalProcessor (org.apache.camel.impl.engine)
process:83, DefaultAsyncProcessorAwaitManager (org.apache.camel.impl.engine)
process:41, AsyncProcessorSupport (org.apache.camel.support)
doExecute:319, CamelServlet (org.apache.camel.http.common)
doService:214, CamelServlet (org.apache.camel.http.common)
service:130, CamelServlet (org.apache.camel.http.common)
service:764, HttpServlet (javax.servlet.http)
internalDoFilter:227, ApplicationFilterChain (org.apache.catalina.core)
doFilter:162, ApplicationFilterChain (org.apache.catalina.core)
doFilter:53, WsFilter (org.apache.tomcat.websocket.server)
internalDoFilter:189, ApplicationFilterChain (org.apache.catalina.core)
doFilter:162, ApplicationFilterChain (org.apache.catalina.core)
doFilter:327, FilterChainProxy$VirtualFilterChain (org.springframework.security.web)
invoke:115, FilterSecurityInterceptor (org.springframework.security.web.access.intercept)
doFilter:81, FilterSecurityInterceptor (org.springframework.security.web.access.intercept)
doFilter:336, FilterChainProxy$VirtualFilterChain (org.springframework.security.web)
doFilter:122, ExceptionTranslationFilter (org.springframework.security.web.access)
doFilter:116, ExceptionTranslationFilter (org.springframework.security.web.access)
doFilter:336, FilterChainProxy$VirtualFilterChain (org.springframework.security.web)
doFilter:126, SessionManagementFilter (org.springframework.security.web.session)
doFilter:81, SessionManagementFilter (org.springframework.security.web.session)
doFilter:336, FilterChainProxy$VirtualFilterChain (org.springframework.security.web)
doFilter:109, AnonymousAuthenticationFilter (org.springframework.security.web.authentication)
doFilter:336, FilterChainProxy$VirtualFilterChain (org.springframework.security.web)
doFilter:149, SecurityContextHolderAwareRequestFilter (org.springframework.security.web.servletapi)
doFilter:336, FilterChainProxy$VirtualFilterChain (org.springframework.security.web)
doFilter:63, RequestCacheAwareFilter (org.springframework.security.web.savedrequest)
doFilter:336, FilterChainProxy$VirtualFilterChain (org.springframework.security.web)
doFilter:103, LogoutFilter (org.springframework.security.web.authentication.logout)
doFilter:89, LogoutFilter (org.springframework.security.web.authentication.logout)
doFilter:336, FilterChainProxy$VirtualFilterChain (org.springframework.security.web)
doHeadersAfter:90, HeaderWriterFilter (org.springframework.security.web.header)
doFilterInternal:75, HeaderWriterFilter (org.springframework.security.web.header)
doFilter:117, OncePerRequestFilter (org.springframework.web.filter)
doFilter:336, FilterChainProxy$VirtualFilterChain (org.springframework.security.web)
doFilter:110, SecurityContextPersistenceFilter (org.springframework.security.web.context)
doFilter:80, SecurityContextPersistenceFilter (org.springframework.security.web.context)
doFilter:336, FilterChainProxy$VirtualFilterChain (org.springframework.security.web)
doFilterInternal:55, WebAsyncManagerIntegrationFilter (org.springframework.security.web.context.request.async)
doFilter:117, OncePerRequestFilter (org.springframework.web.filter)
doFilter:336, FilterChainProxy$VirtualFilterChain (org.springframework.security.web)
doFilterInternal:211, FilterChainProxy (org.springframework.security.web)
doFilter:183, FilterChainProxy (org.springframework.security.web)
invokeDelegate:354, DelegatingFilterProxy (org.springframework.web.filter)
doFilter:267, DelegatingFilterProxy (org.springframework.web.filter)
internalDoFilter:189, ApplicationFilterChain (org.apache.catalina.core)
doFilter:162, ApplicationFilterChain (org.apache.catalina.core)
doFilterInternal:100, RequestContextFilter (org.springframework.web.filter)
doFilter:117, OncePerRequestFilter (org.springframework.web.filter)
internalDoFilter:189, ApplicationFilterChain (org.apache.catalina.core)
doFilter:162, ApplicationFilterChain (org.apache.catalina.core)
doFilterInternal:93, FormContentFilter (org.springframework.web.filter)
doFilter:117, OncePerRequestFilter (org.springframework.web.filter)
internalDoFilter:189, ApplicationFilterChain (org.apache.catalina.core)
doFilter:162, ApplicationFilterChain (org.apache.catalina.core)
doFilterInternal:96, WebMvcMetricsFilter (org.springframework.boot.actuate.metrics.web.servlet)
doFilter:117, OncePerRequestFilter (org.springframework.web.filter)
internalDoFilter:189, ApplicationFilterChain (org.apache.catalina.core)
doFilter:162, ApplicationFilterChain (org.apache.catalina.core)
doFilterInternal:201, CharacterEncodingFilter (org.springframework.web.filter)
doFilter:117, OncePerRequestFilter (org.springframework.web.filter)
internalDoFilter:189, ApplicationFilterChain (org.apache.catalina.core)
doFilter:162, ApplicationFilterChain (org.apache.catalina.core)
invoke:197, StandardWrapperValve (org.apache.catalina.core)
invoke:97, StandardContextValve (org.apache.catalina.core)
invoke:540, AuthenticatorBase (org.apache.catalina.authenticator)
invoke:135, StandardHostValve (org.apache.catalina.core)
invoke:92, ErrorReportValve (org.apache.catalina.valves)
invoke:78, StandardEngineValve (org.apache.catalina.core)
service:359, CoyoteAdapter (org.apache.catalina.connector)
service:399, Http11Processor (org.apache.coyote.http11)
process:65, AbstractProcessorLight (org.apache.coyote)
process:889, AbstractProtocol$ConnectionHandler (org.apache.coyote)
doRun:1735, NioEndpoint$SocketProcessor (org.apache.tomcat.util.net)
run:49, SocketProcessorBase (org.apache.tomcat.util.net)
runWorker:1191, ThreadPoolExecutor (org.apache.tomcat.util.threads)
run:659, ThreadPoolExecutor$Worker (org.apache.tomcat.util.threads)
run:61, TaskThread$WrappingRunnable (org.apache.tomcat.util.threads)
run:829, Thread (java.lang)","vpaturet:1651647796:2022-05-04T15:03:16.125+0000:1651647796:2022-05-04T15:03:16.125+0000:Test case: [https://github.com/vpaturet/camel-test-rest-upload]
The unit test passes with Camel 3.11.4 and fails with 3.12.0
davsclaus:1659600607:2022-08-04T16:10:07.497+0000:1659600607:2022-08-04T16:10:07.497+0000:Can you update to 3.18.x or 3.19.0-SNAPSHOT and add information how to turn off oauth.
vpaturet:1659930792:2022-08-08T11:53:12.633+0000:1659930928:2022-08-08T11:55:28.552+0000:The test project is updated to Camel 3.18.0
I added also a comment for disabling OAuth2 client ([https://github.com/vpaturet/camel-test-rest-upload/blob/ee26a56df5fcd79d6aafc623cef8a5246168d0bb/src/test/java/org/test/rest/RestRouteTest.java#L71])

When debugging the test application, it appears that there is a behavior change in org.springframework.security.oauth2.client.web.OAuth2AuthorizationCodeGrantFilter when upgrading between Camel 3.11 and 3.12.
On line [https://github.com/spring-projects/spring-security/blob/ed58ac7d7813cca2dd327bddabbd381be163fe97/oauth2/oauth2-client/src/main/java/org/springframework/security/oauth2/client/web/OAuth2AuthorizationCodeGrantFilter.java#L168:]
 - with Camel 3.11:
 - org.apache.catalina.connector.Request.getInputStream() contains the multipart attachment
 - org.apache.catalina.connector.Request.getParts() is empty
 - with Camel 3.12/3.18: 
 - org.apache.catalina.connector.Request.getInputStream() is empty
 - org.apache.catalina.connector.Request.getParts() contains the multipart attachment
 
 With Camel 3.12+ I changed the logic in my application to use the request parts instead of the inputStream:
 .setBody(simple(""${exchange.getIn().getRequest().getParts()}""))
 and I ended up with the same behavior as with Camel 3.11 (this fixes the issue for my use case)
davsclaus:1660192728:2022-08-11T12:38:48.997+0000:1660192728:2022-08-11T12:38:48.997+0000:Thanks for sharing the solution and that its likely a change in spring framework"
0,CAMEL-17905,Test,Minor,None,3.x,"
None
",Resolved,Abandoned,3.x,Jiri Ondrusek,Jiri Ondrusek,0,1,2022-04-05 13:26:36+00:00,2023-05-26 19:13:19+00:00,"Once https://issues.apache.org/jira/browse/CAMEL-17904 is fixed, extend coverage to spring-boot starter (follow-up for https://issues.apache.org/jira/browse/CAMEL-17860)",
0,CAMEL-17904,Test,Minor,None,4.x,"
None
",Open,Unresolved,4.x,Jiri Ondrusek,Jiri Ondrusek,0,1,2022-04-05 13:22:40+00:00,2023-08-09 09:11:26+00:00,"During development of https://issues.apache.org/jira/browse/CAMEL-17860, i found that there are 2 use cases in documentation which are not covered (server side encryption)  or not working correctly (deduplication strategy) in component tests.


 


It would be nice to cover/fix them.",
0,CAMEL-17903,Improvement,Major,None,3.17.0,"
None
",Resolved,Fixed,3.17.0,Claus Ibsen,Claus Ibsen,0,1,2022-04-05 12:29:29+00:00,2022-05-07 07:30:32+00:00,"We need to add




        <plugin>
            <artifactId>maven-compiler-plugin</artifactId>
            <executions>
                <execution>
                    <id>recompile</id>
                    <goals>
                        <goal>compile</goal>
                    </goals>
                    <phase>process-classes</phase>
                </execution>
            </executions>
        </plugin>




to the docs so users can generate and re-compile with latest changes. Otherwise its a 2-step process.",
0,CAMEL-17902,Improvement,Minor,"3.11.6, 3.16.0",3.17.0,"

mdc

",Resolved,Fixed,3.17.0,Claus Ibsen,Hugo Veillette,1,3,2022-04-04 23:47:51+00:00,2022-05-11 20:41:02+00:00,"The native OTEL MDC keys are not the same as the ones used by Camel OTEL component.


For instance:


`trace_id` vs `traceId`
`span_id` vs `spanId`


This is causing issue to log the MDC values in a consisting way that affects ability to correlate logs together.


Could we consider aligning with the OTEL spec for MDC keys?


Reference:
https://github.com/open-telemetry/opentelemetry-java-instrumentation/blob/main/docs/logger-mdc-instrumentation.md
https://camel.apache.org/components/3.16.x/others/opentelemetry.html#_mdc_logging","davsclaus:1649106434:2022-04-05T05:07:14.374+0000:1649106434:2022-04-05T05:07:14.374+0000:You are welcome to send a PR against the main branch (see camel-tracing where the MDC keys are defined)
hugov:1652272862:2022-05-11T20:41:02.615+0000:1652272862:2022-05-11T20:41:02.615+0000:Thank you [~davsclaus] ! "
0,CAMEL-17901,Bug,Minor,3.14.1,"3.14.3, 3.17.0","
None
",Resolved,Fixed,"3.14.3, 3.17.0",Unassigned,Vincent Paturet,0,2,2022-04-04 12:51:03+00:00,2022-04-05 09:53:24+00:00,"We experience random errors when stopping a Camel application (Camel 3.14.1) that cause the application to hang forever and not release the Camel Master leadership:


 




Error stopping consumer while loosing leadership. This exception is ignored.. Caused by: [java.lang.NullPointerException - null] java.lang.NullPointerException: null
at java.base/java.util.LinkedList$ListItr.next(Unknown Source)
at java.base/java.lang.Iterable.forEach(Unknown Source)
at org.apache.camel.component.google.pubsub.GooglePubsubConsumer.doStop(GooglePubsubConsumer.java:85)","davsclaus:1649059758:2022-04-04T16:09:18.087+0000:1649059758:2022-04-04T16:09:18.087+0000:Can you send a PR for 3.14.x branch
vpaturet:1649123152:2022-04-05T09:45:52.574+0000:1649123152:2022-04-05T09:45:52.574+0000:PR created: https://github.com/apache/camel/pull/7365
davsclaus:1649123604:2022-04-05T09:53:24.947+0000:1649123604:2022-04-05T09:53:24.947+0000:Thanks"
0,CAMEL-17900,Test,Major,None,3.17.0,"
None
",Resolved,Fixed,3.17.0,Vaishnavi R,Vaishnavi R,0,1,2022-04-04 09:36:24+00:00,2022-04-07 17:16:33+00:00,No Desc,var:1649138138:2022-04-05T13:55:38.820+0000:1649138138:2022-04-05T13:55:38.820+0000:PR - https://github.com/apache/camel-spring-boot/pull/504
0,CAMEL-17899,Dependency upgrade,Major,None,None,"
None
",Resolved,Fixed,"3.11.7, 3.14.3, 3.17.0",Unassigned,PJ Fanning,0,2,2022-04-01 23:56:11+00:00,2022-04-04 08:14:14+00:00,https://www.helpnetsecurity.com/2022/04/01/cve-2022-22965/,"davsclaus:1649020175:2022-04-04T05:09:35.664+0000:1649020175:2022-04-04T05:09:35.664+0000:Users can always upgrade and declare their own spring versions - if you use spring boot then just upgrade to their new spring boot versions.
pj.fanning:1649031254:2022-04-04T08:14:14.301+0000:1649031254:2022-04-04T08:14:14.301+0000:thanks - looks like [https://github.com/apache/camel/commit/ff54ec6fc5b272985c27dee43a0cb5af745ca0b7] sorted this out"
0,CAMEL-17867,Bug,Minor,3.16.0,3.17.0,"
None
",Resolved,Fixed,3.17.0,Claus Ibsen,Claus Ibsen,0,1,2022-03-29 05:22:57+00:00,2022-03-29 08:01:02+00:00,"2022-03-29 07:22:00.018  WARN 24335 — [ownCamelContext] .apache.camel.main.MainLifecycleStrategy : Error during stopping all routes. This exception is ignored.
java.lang.NullPointerException: null
        at org.apache.camel.impl.engine.AbstractCamelContext.stopAllRoutes(AbstractCamelContext.java:1229) ~[camel-base-engine-3.16.0.jar:3.16.0]
        at org.apache.camel.impl.engine.InternalRouteController.stopAllRoutes(InternalRouteController.java:78) ~[camel-base-engine-3.16.0.jar:3.16.0]
        at org.apache.camel.impl.engine.DefaultRouteController.stopAllRoutes(DefaultRouteController.java:99) ~[camel-base-engine-3.16.0.jar:3.16.0]
        at org.apache.camel.main.MainDurationEventNotifier.stopTask(MainDurationEventNotifier.java:164) ~[camel-main-3.16.0.jar:3.16.0]
        at java.lang.Thread.run(Thread.java:829) ~[?:?]",
0,CAMEL-17866,Bug,Minor,3.16.0,3.17.0,"
None
",Resolved,Fixed,3.17.0,Karen Lease,Jeremy Ross,0,1,2022-03-28 17:03:56+00:00,2022-03-30 20:19:31+00:00,"If the CamelSqlGeneratedKeyRows header already exists, subsequent operations will not overwrite with new values.",
0,CAMEL-17865,Bug,Major,3.16.0,"3.14.3, 3.17.0","
None
",Resolved,Fixed,"3.14.3, 3.17.0",Zheng Feng,Zheng Feng,0,1,2022-03-28 14:34:22+00:00,2022-03-29 00:48:21+00:00,"It response 400 when the rest define with consumes and CORS enabled.


 




restConfiguration().component(""platform-http"").enableCORS(true);

rest(""/rest"")
        .post()
        .consumes(""application/json"")
        .to(""direct:rest"");

from(""direct:rest"")
        .setBody(simple(""Hello ${body}""));",
0,CAMEL-17864,Task,Minor,None,3.17.0,"
None
",Resolved,Fixed,3.17.0,Nicolas Filotto,Claus Ibsen,0,2,2022-03-28 12:31:08+00:00,2022-04-26 14:29:12+00:00,"[INFO] — maven-plugin-plugin:3.6.4:descriptor (default-descriptor) @ camel-bundle-plugin —
[ERROR]


Some dependencies of Maven Plugins are expected to be in provided scope.
Please make sure that dependencies listed below declared in POM
have set '<scope>provided</scope>' as well.


The following dependencies are in wrong scope:



org.apache.maven:maven-core:jar:3.3.9:compile
org.apache.maven:maven-model:jar:3.3.9:compile
org.apache.maven:maven-settings:jar:3.3.9:compile
org.apache.maven:maven-settings-builder:jar:3.3.9:compile
org.apache.maven:maven-builder-support:jar:3.3.9:compile
org.apache.maven:maven-repository-metadata:jar:3.3.9:compile
org.apache.maven:maven-plugin-api:jar:3.3.9:compile
org.apache.maven:maven-model-builder:jar:3.3.9:compile
org.apache.maven:maven-aether-provider:jar:3.3.9:compile
org.apache.maven:maven-compat:jar:3.3.9:compile
org.apache.maven:maven-artifact:jar:3.0:compile",nfilotto:1650950257:2022-04-26T13:17:37.999+0000:1650950257:2022-04-26T13:17:37.999+0000:The corresponding fix https://github.com/apache/camel/pull/7496
0,CAMEL-17863,Improvement,Major,3.16.0,3.17.0,"
None
",Resolved,Fixed,3.17.0,Claus Ibsen,Claus Ibsen,0,1,2022-03-28 10:30:39+00:00,2022-03-30 07:40:27+00:00,"We should optimize to only load routes once, so when we find routes eager due to modeline, then we keep them loaded, and then reuse them when later loading routes.","davsclaus:1648595694:2022-03-30T07:14:54.475+0000:1648597224:2022-03-30T07:40:24.155+0000:modeline
TODO: RoutesCollector -> collectResourcesFromDirectory *DONE*
TODO: preParseRoute -> (yaml) but not for others *DONE*"
0,CAMEL-17862,Task,Major,3.17.0,3.17.0,"
None
",Resolved,Fixed,3.17.0,Claus Ibsen,Claus Ibsen,0,1,2022-03-28 09:49:10+00:00,2022-03-28 13:54:38+00:00,"camel-spring-boot


tooling/camel-spring-boot-dependencies/pom.xml


         <groupId>org.apache.avro</groupId>
         <artifactId>avro-mapred</artifactId>
         <version>1.11.0</version>
+        <classifier>hadoop2</classifier>
       </dependency>",davsclaus:1648432162:2022-03-28T09:49:22.446+0000:1648432162:2022-03-28T09:49:22.446+0000:This is wrong such a JAR does not exists
0,CAMEL-17861,Bug,Major,3.14.1,3.17.0,"
None
",Resolved,Fixed,3.17.0,Unassigned,Christian Müller,0,3,2022-03-28 09:43:52+00:00,2022-05-06 13:12:35+00:00,"As described in the email conversation below we are having memory problems with the current implementation of the azure (blob storage component). 
Concretely the component does not stream properly!


But looking at this stacktrace and the corresponding sourcecode it’s obvious that the whole stream is read to memory to check the total payload size (seems necessary for the azure client)
As we transfer mass data with the azure component we consider this a major bug as we cannot use the azure-component as long as it does not stream properly. 


Thx and Regards Christian


Email History (camel user mailing list): 
Response from Claus Ibsen: 
What are the sources of those streams?
I wonder if we could enrich from the message some sort of total size header
into the camel blob producer, so it can tell the blob client the expected
length, so it does not read the stream itself to find out.
Also if you have the opportunity you are welcome to test with latest Camel
3.9.0 release, if its still a problem.
 
And you are welcome to create a JIRA as it would be great to have streaming
work well with azure, especially for blob as its supposed to be also big
blobs of data 


initial question from Lukas Angerer: 
We are transferring lots of data to the azure-storage with the azure-storage-blob component (version 3.7.0)
The Route itself is only working with streams to keep the memory overhead low, streamcaching is enabled.


But looking at this stacktrace and the corresponding sourcecode it’s obvious that the whole stream is read to memory to check the total payload size (seems necessary for the azure client)


 


Caused by: java.lang.OutOfMemoryError: Java heap space


            at org.apache.commons.io.output.AbstractByteArrayOutputStream.toByteArrayImpl(AbstractByteArrayOutputStream.java:366)


            at org.apache.commons.io.output.ByteArrayOutputStream.toByteArray(ByteArrayOutputStream.java:163)


            at org.apache.commons.io.IOUtils.toByteArray(IOUtils.java:2241)


            at org.apache.camel.component.azure.storage.blob.BlobUtils.getInputStreamLength(BlobUtils.java:37)


            at org.apache.camel.component.azure.storage.blob.BlobStreamAndLength.createBlobStreamAndLengthFromExchangeBody(BlobStreamAndLength.java:50)


            at org.apache.camel.component.azure.storage.blob.operations.BlobOperations.uploadBlockBlob(BlobOperations.java:181)


            at org.apache.camel.component.azure.storage.blob.BlobProducer.process(BlobProducer.java:86)


            at org.apache.camel.support.AsyncProcessorConverterHelper$ProcessorToAsyncProcessorBridge.process(AsyncProcessorConverterHelper.java:66)


            at org.apache.camel.processor.SendDynamicProcessor.lambda$process$0(SendDynamicProcessor.java:195)


I was wondering if there is a better way to do this. Maybe a shortcut for the cached stream that just checks the size of the cache?","davsclaus:1648441285:2022-03-28T12:21:25.605+0000:1648441285:2022-03-28T12:21:25.605+0000:Can you take a look at the aws components for its blob storage component (such as s3) - i think we have done some better streamining support there that can be good to compare with
mueller110:1650615927:2022-04-22T16:25:27.617+0000:1650615927:2022-04-22T16:25:27.617+0000:Hi [~davsclaus], sry for my late response. 
Following your suggestion i checked the aws storage component! My suggestion is to determine the length of the stream like it is done in: 
[https://github.com/apache/camel/blob/abb1ad84fac520b00339533a2eafdeb901e22d87/components/camel-aws/camel-aws2-s3/src/main/java/org/apache/camel/component/aws2/s3/utils/AWS2S3Utils.java#L83]

is it ok if i create a pull request for that?
davsclaus:1650849416:2022-04-25T09:16:56.078+0000:1650849416:2022-04-25T09:16:56.078+0000:Yes a PR is much welcome
mueller110:1650877073:2022-04-25T16:57:53.134+0000:1650877073:2022-04-25T16:57:53.134+0000:[~davsclaus] fyi https://github.com/apache/camel/pull/7493
mueller110:1651811401:2022-05-06T12:30:01.204+0000:1651811401:2022-05-06T12:30:01.204+0000:Hi [~davsclaus], i tested the solution and found out that it does not work for FileInputStreamCache
i created a new pullrequest that properly handels FileInputStreamCache as well 
[https://github.com/apache/camel/pull/7561/]
regards christian
mueller110:1651811599:2022-05-06T12:33:19.415+0000:1651811599:2022-05-06T12:33:19.415+0000:ah sry. just saw that you already fixed that :)
i will close my pull request"
0,CAMEL-17860,Test,Major,None,3.17.0,"
None
",Resolved,Fixed,3.17.0,Jiri Ondrusek,Jiri Ondrusek,0,1,2022-03-28 07:04:33+00:00,2022-05-11 14:45:16+00:00,No Desc,
0,CAMEL-17859,Bug,Minor,3.15.0,"3.18.3, 3.19.0","
None
",Resolved,Fixed,"3.18.3, 3.19.0",Otavio Rodolfo Piske,Pascal Schumacher,0,2,2022-03-27 17:50:01+00:00,2022-12-01 07:23:56+00:00,"We have been running multiple applications using Camel SMPP with a consumer with lazy session creation for years without any problems.


Recently we observed that sometimes Camel 3.15.0 only tries to reconnect once.


Log:




Time - thread_name - logger_name - message
Mar 22, 2022 @ 01:16:59.798 - PDUReaderWorker-b333f18a - org.jsmpp.session.SMPPSession - Reading PDU session b333f18a in state BOUND_TX: Connection reset
Mar 22, 2022 @ 01:16:59.801 - EnquireLinkSender-b333f18a - org.jsmpp.session.AbstractSession - Response timeout on enquireLink
Mar 22, 2022 @ 01:16:59.801 - EnquireLinkSender-b333f18a - org.apache.camel.component.smpp.SmppProducer - Lost connection to: smpp://USER@HOST:PORT - trying to reconnect...
Mar 22, 2022 @ 01:16:59.824 - EnquireLinkSender-b333f18a - org.apache.camel.support.task.BackgroundTask - Interrupted while waiting for the repeatable task to execute: null
java.lang.InterruptedException: null
               at java.base/java.util.concurrent.locks.AbstractQueuedSynchronizer.acquireSharedInterruptibly(Unknown Source)
               at java.base/java.util.concurrent.CountDownLatch.await(Unknown Source)
               at org.apache.camel.support.task.BackgroundTask.waitForTaskCompletion(BackgroundTask.java:153)
               at org.apache.camel.support.task.BackgroundTask.run(BackgroundTask.java:144)
               at org.apache.camel.component.smpp.SmppProducer.reconnect(SmppProducer.java:197)
               at org.apache.camel.component.smpp.SmppProducer.lambda$new$0(SmppProducer.java:76)
               at org.apache.camel.component.smpp.SmppProducer$$Lambda$1087/0x000000002b4df3c8.onStateChange(Unknown Source)
               at org.jsmpp.session.AbstractSessionContext.fireStateChanged(AbstractSessionContext.java:85)
               at org.jsmpp.session.SMPPSessionContext.changeState(SMPPSessionContext.java:61)
               at org.jsmpp.session.AbstractSessionContext.close(AbstractSessionContext.java:66)
               at org.jsmpp.session.AbstractSession.close(AbstractSession.java:257)
               at org.jsmpp.session.AbstractSession$EnquireLinkSender.run(AbstractSession.java:503)
Mar 22, 2022 @ 01:17:04.824 - Camel (camel-1) thread #3797 - smpp-producer-reconnect - org.apache.camel.component.smpp.SmppProducer - Trying to reconnect to smpp://USER@HOST:PORT
Mar 22, 2022 @ 01:17:04.833 - Camel (camel-1) thread #3797 - smpp-producer-reconnect - org.jsmpp.session.SMPPSession - Connected from port 59810 to /PORT:PORT
Mar 22, 2022 @ 01:17:04.834 - PDUReaderWorker-d0566380 - org.jsmpp.session.SMPPSession - Starting PDUReaderWorker
Mar 22, 2022 @ 01:17:04.844 - PDUReaderWorker-d0566380 - org.jsmpp.session.SMPPSession - Reading PDU session d0566380 in state OPEN: null
Mar 22, 2022 @ 01:17:04.845 - pool-58909-thread-1 - org.jsmpp.session.SMPPSession - Failed setting so_timeout for session timer
java.net.SocketException: Socket is closed
               at java.base/java.net.Socket.setSoTimeout(Unknown Source)
               at org.jsmpp.session.connection.socket.SocketConnection.setSoTimeout(SocketConnection.java:60)
               at org.jsmpp.session.SMPPSession$BoundSessionStateListener.onStateChange(SMPPSession.java:721)
               at org.jsmpp.session.AbstractSessionContext.fireStateChanged(AbstractSessionContext.java:85)
               at org.jsmpp.session.SMPPSessionContext.changeState(SMPPSessionContext.java:61)
               at org.jsmpp.session.AbstractSessionContext.bound(AbstractSessionContext.java:49)
               at org.jsmpp.session.state.SMPPSessionOpen.processBindResp(SMPPSessionOpen.java:73)
               at org.jsmpp.session.PDUProcessTask.run(PDUProcessTask.java:62)
               at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(Unknown Source)
               at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(Unknown Source)
               at java.base/java.lang.Thread.run(Unknown Source)
Mar 22, 2022 @ 01:17:04.845 - pool-58909-thread-1 - org.jsmpp.session.SMPPSession - Changing processor degree to 1
Mar 22, 2022 @ 01:17:04.847 - Camel (camel-1) thread #3797 - smpp-producer-reconnect - org.jsmpp.session.SMPPSession - Receive negative bind response
Mar 22, 2022 @ 01:17:04.847 - PDUReaderWorker-d0566380 - org.apache.camel.component.smpp.SmppProducer - Lost connection to: smpp://USER@HOST:PORT - trying to reconnect...

[no further reconnects or anything related to smpp producing]

[almost seven hours later the application tries to produce the first sms (this and all further tries to produce fail):] 
org.apache.camel.processor.errorhandler.DefaultErrorHandler - Failed delivery for (MessageId: XZY on ExchangeId: XZY). Exhausted after delivery attempt: 1 caught: java.io.IOException: Lost connection to smpp://USER@HOST:PORT and yet not reconnected




The log of another instance showed the same behavior.


orpiske I am not sure, but I think this may be another regression caused by CAMEL-17121 It would be great if you could have a look at this. Thank you very much!","orpiske:1648416605:2022-03-28T05:30:05.131+0000:1648416605:2022-03-28T05:30:05.131+0000:Thanks for the heads up. I'll take a look.
orpiske:1648423441:2022-03-28T07:24:01.309+0000:1648423441:2022-03-28T07:24:01.309+0000:I haven't been able to reproduce this one yet. If you have any additional details about your scenario (or maybe a reproducer?), that would be very helpful. 

 

I have been using the producer [reconnect test|https://github.com/apache/camel/blob/main/components/camel-smpp/src/test/java/org/apache/camel/component/smpp/integration/SmppProducerReconnectManualIT.java] along with the options ""&lazySessionCreation=true&lazyStartProducer=true""  to do so.

 

Maybe something's missing on the test?

 
pascalschumacher:1648461036:2022-03-28T17:50:36.001+0000:1648461036:2022-03-28T17:50:36.001+0000:Thank you very much for locking into this! :)

I should have mentioned that we are only using {{lazySessionCreation}} (not {{{}lazyStartProducer{}}}).

I fear that the problem is more complex than the scenario tested by the reconnect test.

Sadly I do not have I reproducer.

In the logs I see multiple threads accessing {{{}SmppProducer{}}}. My best guess is that another thread must still hold the {{{}connectLock{}}}. Therefore {{connectLock.tryLock()}} in [https://github.com/apache/camel/blob/bc487f3f1645702e0ac9329bdb30b380a0380f7d/components/camel-smpp/src/main/java/org/apache/camel/component/smpp/SmppProducer.java#L192] returns {{false}} for the {{PDUReaderWorker-d0566380}} thread and no {{reconnectTask}} is started.
orpiske:1648512021:2022-03-29T08:00:21.681+0000:1648512021:2022-03-29T08:00:21.681+0000:[~pascalschumacher] that helps a lot, actually. I think your assessment could be correct.

 

If you are OK with it, I'd like to propose a two-step approach as I am unable to reproduce it: let me create a PR with some additional logs around that part (and others), and then I can create a fix for it. I'll do that later today and if you are able to test it, it would be awesome.
pascalschumacher:1648548326:2022-03-29T18:05:26.942+0000:1648548326:2022-03-29T18:05:26.942+0000:[~orpiske] Thank you very much!

I do not know if I will be able to reproduce the problem in a test environment, but I will give it a try.
orpiske:1664931771:2022-10-05T09:02:51.488+0000:1664931771:2022-10-05T09:02:51.488+0000:[~pascalschumacher] is this still an issue? I am wondering if the recent versions gave you more information about this?
pascalschumacher:1669789262:2022-11-30T14:21:02.968+0000:1669789276:2022-11-30T14:21:16.759+0000:[~orpiske]  Sorry for the late reply. The issue did not reoccur. My guess it that it is still present, but a very a rare race condition (or did you or anybody else fix something I am not aware of?). As there has been no new information for a long time it is o.k. to close it. We can always reopen or create a new issue.
orpiske:1669850548:2022-12-01T07:22:28.208+0000:1669850548:2022-12-01T07:22:28.208+0000:[~pascalschumacher] there were no other fixes I am aware of, so I guess it's a rare condition. I agree with closing the ticket for now ... In case it happens, we can reopen. 

Thanks for the update!
orpiske:1669850636:2022-12-01T07:23:56.158+0000:1669850636:2022-12-01T07:23:56.158+0000:It may have been fixed as part of 3.18.x, so closing it for now."
0,CAMEL-17858,New Feature,Major,None,Future,"
None
",Open,Unresolved,Future,Unassigned,Claus Ibsen,0,1,2022-03-26 10:11:36+00:00,2023-07-24 18:59:12+00:00,"For low-code users that get started with Camel would not as easily not how to use the Log EIP to output common use-cases such as



${body}
${header.xxx}
${exception.message}



etc


So we should find a way to have such patterns in the metadata that we can present in the documentation and for tooling.


It could be examples like we have for kamelets.


@Metadata(examples = ""${body}"", ""${header.myHeaderName}"", ...)


We should possible have both the value and a description for each example so we can have help test that go with that.


The openapi spec also have examples so we can be inspired there too.",
0,CAMEL-17857,Bug,Minor,3.16.0,3.17.0,"
None
",Resolved,Fixed,3.17.0,Federico Mariani,Federico Mariani,0,2,2022-03-25 14:25:50+00:00,2022-03-28 08:09:43+00:00,"camel-validator concat imports from xsd to the base endpoint, ex.




<xs:schema xmlns:xs=""http://www.w3.org/2001/XMLSchema""
            targetNamespace=""http://example.org/ord""
            xmlns=""http://example.org/ord""
            xmlns:prod=""http://example.org/prod"">
  <xs:include schemaLocation=""https://raw.githubusercontent.com/Croway/test-xsd/main/chapter04ord2.xsd""/>
  <xs:include schemaLocation=""https://raw.githubusercontent.com/Croway/test-xsd/main/chapter04cust.xsd""/>
  <xs:import namespace=""http://example.org/prod""
                 schemaLocation=""https://raw.githubusercontent.com/Croway/test-xsd/main/chapter04prod.xsd""/>
...




with a route like 




...
.toD(""validator:https://raw.githubusercontent.com/Croway/test-xsd/main/chapter04ord1.xsd"")
...




the validator component concat the base endpoint with the import one, for example: _https://raw.githubusercontent.com/Croway/test-xsd/main/https://raw.githubusercontent.com/Croway/test-xsd/main/chapter04prod.xsd _ and the following exception is thrown




Caused by: java.io.FileNotFoundException: https://raw.githubusercontent.com/Croway/test-xsd/main/https:/raw.githubusercontent.com/Croway/test-xsd/main/chapter04ord2.xsd
	at java.base/sun.net.www.protocol.http.HttpURLConnection.getInputStream0(HttpURLConnection.java:1993)
	at java.base/sun.net.www.protocol.http.HttpURLConnection.getInputStream(HttpURLConnection.java:1589)
	at java.base/sun.net.www.protocol.https.HttpsURLConnectionImpl.getInputStream(HttpsURLConnectionImpl.java:224)
	at org.apache.camel.impl.engine.DefaultResourceResolvers$HttpsResolver$1.getInputStream(DefaultResourceResolvers.java:202)
...","davsclaus:1648261924:2022-03-26T10:32:04.572+0000:1648261924:2022-03-26T10:32:04.572+0000:Its bad practice IMHO to have remote XSD imports as that makes your app depedent on that remote service being online.
Federico Mariani:1648426183:2022-03-28T08:09:43.925+0000:1648426183:2022-03-28T08:09:43.925+0000:I'm sorry I lost your comment, I agree with you, remote XSD import is not a good practice, but XSDs like [https://www.w3.org/2012/04/XMLSchema.xsd] use this feature, therefore I opened the PR."
0,CAMEL-17856,Dependency upgrade,Major,None,3.20.0,"
None
",Resolved,Fixed,3.20.0,Unassigned,Claus Ibsen,0,1,2022-03-25 11:52:52+00:00,2022-11-07 10:27:14+00:00,"We should upgrade, but would be good to have it aligned with SB and Quarkus as well with the version they use.",davsclaus:1662183256:2022-09-03T13:34:16.403+0000:1662183256:2022-09-03T13:34:16.403+0000:quarkus is still on 2.13.x
0,CAMEL-17855,Test,Major,None,4.x,"

help-wanted

",Open,Unresolved,4.x,Unassigned,Otavio Rodolfo Piske,0,2,2022-03-25 11:16:03+00:00,2023-08-09 09:20:53+00:00,Implement the same changes on https://github.com/apache/camel/pull/7254 to the other test infra services.,"davsclaus:1691543518:2023-08-09T09:11:58.188+0000:1691543518:2023-08-09T09:11:58.188+0000:We are focusing effort on 4.x onwards so we should IMHO schedule this for 4.x and not 3.x
orpiske:1691544028:2023-08-09T09:20:28.285+0000:1691544028:2023-08-09T09:20:28.285+0000:Yeah, this is an older ticket. I think what's missing is a review of the services that we can migrate and then include them here. Let me adjust this ticket a bit. "
0,CAMEL-17854,Improvement,Major,None,None,"
None
",Resolved,Fixed,3.17.0,Andrea Cosentino,Andrea Cosentino,0,1,2022-03-25 06:55:58+00:00,2022-03-28 09:36:51+00:00,Same as CAMEL-17816 but for SNS,
0,CAMEL-17853,Test,Trivial,None,3.17.0,"
None
",Resolved,Fixed,3.17.0,Alex Dettinger,Alex Dettinger,0,1,2022-03-24 15:54:11+00:00,2022-05-09 11:10:11+00:00,No Desc,"aldettinger:1648108692:2022-03-24T15:58:12.364+0000:1648108692:2022-03-24T15:58:12.364+0000:[~jirisimek98] Would you like to have a try ?
aldettinger:1652065811:2022-05-09T11:10:11.533+0000:1652065811:2022-05-09T11:10:11.533+0000:Actually, this case is already tested in AggregationStrategyWithFilenameHeaderTest.testSplitter()."
0,CAMEL-17852,New Feature,Major,None,3.x,"
None
",Resolved,Duplicate,3.x,Unassigned,Claus Ibsen,0,1,2022-03-24 14:14:05+00:00,2022-09-03 12:13:11+00:00,"We need to look again if we can provide a platform-http-starter for spring boot. And we can maybe just tie it to servlet so it can run on any of the actual http servers you may use, or we tie it to the default which is tomcat.


Then you can do 


from(""platform-http:foo"") ...",
0,CAMEL-17851,New Feature,Major,None,4.x,"
None
",Resolved,Fixed,4.x,Federico Mariani,Claus Ibsen,0,2,2022-03-24 14:12:32+00:00,2023-11-20 09:17:33+00:00,"When you run camel on spring boot in kubernetes, then their health-check system works differently.


So we need to find out if we need to integrate specially for this, or there is some other solution.


The health-checks in camel are separated into readiness/liveness or both. And as such we can do checks where ready = DOWN and live = UP. But if you run that as a single combined result then it could be DOWN.


But in fact the app is still booting up and are not ready to handle traffic.",Federico Mariani:1700443048:2023-11-20T09:17:28.854+0000:1700443048:2023-11-20T09:17:28.854+0000:https://github.com/apache/camel-spring-boot/pull/1010
0,CAMEL-17850,Bug,Major,None,3.17.0,"
None
",Resolved,Fixed,3.17.0,Otavio Rodolfo Piske,Otavio Rodolfo Piske,0,1,2022-03-24 13:17:53+00:00,2022-03-25 11:14:42+00:00,During stop the code tries to unlock the lock even if trying to lock it previously has failed (ie.: by failling a call to tryLock). This can cause the code to throw a IllegalMonitorStateException.,orpiske:1648178082:2022-03-25T11:14:42.595+0000:1648178082:2022-03-25T11:14:42.595+0000:Fixed with https://github.com/apache/camel/pull/7264
0,CAMEL-17849,Improvement,Major,None,3.17.0,"
None
",Resolved,Fixed,3.17.0,Otavio Rodolfo Piske,Otavio Rodolfo Piske,0,1,2022-03-24 13:14:05+00:00,2022-03-25 11:14:50+00:00,"During shutdown the consumer logs: ""Stopping Kafka consumer on topic: {}"". This is confusing when using topic patterns",orpiske:1648178047:2022-03-25T11:14:07.407+0000:1648178090:2022-03-25T11:14:50.339+0000:Fixed with https://github.com/apache/camel/pull/7264.
0,CAMEL-17848,Improvement,Major,None,3.18.0,"
None
",Resolved,Fixed,3.18.0,James Netherton,Claus Ibsen,0,2,2022-03-24 09:03:47+00:00,2022-06-28 17:06:45+00:00,"DOWN tends to convey the system is not working at all, and should fail the liveness check, so /q/health/live should return outside [200, 400[ when there is at least one DOWN, otherwise it should return inside [200, 400[.


for the readiness check, /q/health/ready should return inside [200, 400[ when all checks are UP","davsclaus:1648083874:2022-03-24T09:04:34.796+0000:1648096580:2022-03-24T12:36:20.916+0000:Currently CamelMicroProfileRepositoryHealthCheck doe the same for readiness or liveness. But we should not do that, instead do as ^^^^
davsclaus:1648091483:2022-03-24T11:11:23.494+0000:1648091483:2022-03-24T11:11:23.494+0000:TODO: camel-jbang now reports accordingly to this rule *DONE*
davsclaus:1656370813:2022-06-28T07:00:13.519+0000:1656370813:2022-06-28T07:00:13.519+0000:[~jamesnetherton] maybe you can take a look at this?

You can find the camel jbang health check reporter here
https://github.com/apache/camel/blob/main/dsl/camel-kamelet-main/src/main/java/org/apache/camel/main/http/VertxHttpServer.java
jamesnetherton:1656391513:2022-06-28T12:45:13.038+0000:1656391513:2022-06-28T12:45:13.038+0000:[~davsclaus] unless I misunderstand your comments above, I think I already see the desired behavior.

I hacked up an app that contains a Camel readiness check that is UP and a liveness check that is DOWN. Here's the results of the health check endpoint (in Quarkus). The status codes are reported correctly based on the check results.

*Readiness checks*
{code:java}
> GET /q/health/ready HTTP/1.1
> Host: localhost:8080
> User-Agent: curl/7.68.0
> Accept: */*
> 

< HTTP/1.1 200 OK
< content-type: application/json; charset=UTF-8
< content-length: 672
< 

{
    ""status"": ""UP"",
    ""checks"": [
        {
            ""name"": ""camel-routes"",
            ""status"": ""UP""
        },
        {
            ""name"": ""up-ready-check"",
            ""status"": ""UP"",
            ""data"": {
                ""check.kind"": ""READINESS""
            }
        },
        {
            ""name"": ""context"",
            ""status"": ""UP"",
            ""data"": {
                ""context.name"": ""camel-1"",
                ""context.version"": ""3.17.0"",
                ""context.status"": ""Started"",
                ""check.kind"": ""READINESS""
            }
        },
        {
            ""name"": ""camel-consumers"",
            ""status"": ""UP""
        }
    ]
}
{code}

*Liveness checks*
{code:java}
> GET /q/health/live HTTP/1.1
> Host: localhost:8080
> User-Agent: curl/7.68.0
> Accept: */*
> 

* < HTTP/1.1 503 Service Unavailable
< content-type: application/json; charset=UTF-8
< content-length: 214
< 

{
    ""status"": ""DOWN"",
    ""checks"": [
        {
            ""name"": ""down-live-check"",
            ""status"": ""DOWN"",
            ""data"": {
                ""check.kind"": ""LIVENESS""
            }
        }
    ]
}
{code}

*Combined checks*
{code:java}
> GET /q/health HTTP/1.1
> Host: localhost:8080
> User-Agent: curl/7.68.0
> Accept: */*
> 
 
< HTTP/1.1 503 Service Unavailable
< content-type: application/json; charset=UTF-8
< content-length: 841
< 

{
    ""status"": ""DOWN"",
    ""checks"": [
        {
            ""name"": ""down-live-check"",
            ""status"": ""DOWN"",
            ""data"": {
                ""check.kind"": ""LIVENESS""
            }
        },
        {
            ""name"": ""camel-routes"",
            ""status"": ""UP""
        },
        {
            ""name"": ""up-ready-check"",
            ""status"": ""UP"",
            ""data"": {
                ""check.kind"": ""READINESS""
            }
        },
        {
            ""name"": ""context"",
            ""status"": ""UP"",
            ""data"": {
                ""context.name"": ""camel-1"",
                ""context.version"": ""3.17.0"",
                ""context.status"": ""Started"",
                ""check.kind"": ""READINESS""
            }
        },
        {
            ""name"": ""camel-consumers"",
            ""status"": ""UP""
        }
    ]
}
{code}
davsclaus:1656400200:2022-06-28T15:10:00.975+0000:1656400200:2022-06-28T15:10:00.975+0000:Okay so this looks correct - I think it was for readiness checks especially that during startup they may report DOWN while booting up, but that DOWN should not affect liveness check. As the app is alive but just starting up and not yet ready.

So the separation of them is important.

"
0,CAMEL-17847,Task,Major,None,3.17.0,"
None
",Resolved,Fixed,3.17.0,Karen Lease,Claus Ibsen,0,2,2022-03-24 06:05:10+00:00,2022-05-09 19:44:54+00:00,"from camel-examples



camel-example-aggregate-dist: this module test fixture succeeds sometimes when exceeding the timeout within the test assertion
camel-example-endpointdsl-aws2-s3-kafka: this module succeeds when forcing a Thread.sleep(1000) before sending the first message triggering the routes template.send(""direct:putObject"", exchange -> 
{ //...}
);. Otherwise it succeeds when run separately (not as part of all the project test run).
camel-example-debezium: this module test fixture succeeds as well only when ran separately
camel-example-jooq: this module test fixture succeeds as well only when ran separately","klease78:1648718885:2022-03-31T17:28:05.646+0000:1648820909:2022-04-01T21:48:29.103+0000:These tests *usually* work for me locally when run together. KameletMainTest was failing due to unresolved https URL. I fixed this.

Also on my system, the camel-example-widget-gadget-java java test fails with ""Failed to connect to [tcp://localhost:61616]"" but the camel-widget-gadget-xml test suceeds to connect on this port.

The problem for widget-gadget-java is that the bindToRegistry() method which creates the activemq bean (with the Broker) is called *after* the Camel context initializes the routes using activemq.  A camel-activemq component is created but this doesn't initialize the embedded ActiveMQ broker.

 
klease78:1652096694:2022-05-09T19:44:54.901+0000:1652096694:2022-05-09T19:44:54.901+0000:Fixed the widget-gadget-java test and a few others which failed due to changes made in core camel."
0,CAMEL-17846,Test,Major,None,3.17.0,"
None
",Resolved,Fixed,3.17.0,Jiri Ondrusek,Jiri Ondrusek,0,1,2022-03-23 12:04:34+00:00,2022-05-11 14:45:22+00:00,No Desc,jondruse:1649140660:2022-04-05T14:37:40.809+0000:1649140660:2022-04-05T14:37:40.809+0000:R [https://github.com/apache/camel-spring-boot/pull/481] 
0,CAMEL-17845,Test,Minor,None,3.17.0,"
None
",Resolved,Fixed,3.17.0,John Poth,John Poth,0,3,2022-03-23 12:04:24+00:00,2022-03-29 14:04:09+00:00,It would be cool to create a singleton Kafka server when running integration tests and not recreate a Kafka instance for each test class,"orpiske:1648416558:2022-03-28T05:29:18.130+0000:1648416558:2022-03-28T05:29:18.130+0000:Hey [~jpoth], it looks like some of the tests are still flaky due to the changes: [https://ci-builds.apache.org/job/Camel/job/Apache%20Camel/job/main/211/testReport/. |https://ci-builds.apache.org/job/Camel/job/Apache%20Camel/job/main/211/testReport/]

 

If you have a chance, is it possible to take a look, please?
jpoth:1648432065:2022-03-28T09:47:45.811+0000:1648432065:2022-03-28T09:47:45.811+0000:Hi [~orpiske]! Looks like they were failing before too? https://ci-builds.apache.org/job/Camel/job/Apache%20Camel/job/main/203/

There's definitely a problem though. I'll try to take a look!
orpiske:1648434225:2022-03-28T10:23:45.461+0000:1648434225:2022-03-28T10:23:45.461+0000:Hi!

 

[~jpoth] I think the problematic ones are just the health check and the topic pattern ones. I fixed the idempotent tests. The manual one looks like an environment issue and not related to your change - at least I can't reproduce it here.
orpiske:1648434242:2022-03-28T10:24:02.378+0000:1648434242:2022-03-28T10:24:02.378+0000:And thanks for looking at those!
davsclaus:1648526292:2022-03-29T11:58:12.554+0000:1648526292:2022-03-29T11:58:12.554+0000:Is all of this done now?
jpoth:1648533844:2022-03-29T14:04:04.864+0000:1648533844:2022-03-29T14:04:04.864+0000:Yep, closing ..."
0,CAMEL-17844,Improvement,Minor,3.4.1,3.17.0,"
None
",Resolved,Fixed,3.17.0,Unassigned,Bjørn Ole Myrold,0,1,2022-03-23 11:09:46+00:00,2022-03-25 09:05:32+00:00,"Version 3.4.1 introduced fixes in regards to how BeanInfo gets built, this seems to break beans which are @FunctionalInterfaces.
I believe it was introduced with https://issues.apache.org/jira/browse/CAMEL-15278


The fix created in the above case only handles super classes, and does not look at interfaces. A lambda cast to a FunctionalInterface will only provide Object as super class, and BeanInfo will then not find any methods marked with @Handler in the interface.


 


This works in 3.4.0, but not in 3.4.1 or higher




public class TestRoute extends RouteBuilder {


    @Override public void configure() throws Exception {
        from(""direct:testRoute"").id(""TestRoute"")
            .bean((Formatter) a -> String.format(""%s %s"", a.getName(), a.getOtherName()))
            .to(""direct:testEndpoint"");
    }

    @FunctionalInterface
    public interface Formatter {
        @Handler String test(@Body RandomPojo t);
    }
}",
0,CAMEL-17843,Improvement,Major,3.16.0,3.17.0,"
None
",Resolved,Fixed,3.17.0,Otavio Rodolfo Piske,Otavio Rodolfo Piske,0,1,2022-03-23 10:37:32+00:00,2022-03-24 09:22:43+00:00,The default image does not have ARM based images. This can prevent the container from running and cause the tests to fail or skip.,orpiske:1648084963:2022-03-24T09:22:43.382+0000:1648084963:2022-03-24T09:22:43.382+0000:Fixed with the linked PR.
0,CAMEL-17842,Task,Minor,None,3.19.0,"
None
",Resolved,Fixed,3.19.0,Unassigned,Raymond,0,2,2022-03-22 15:20:39+00:00,2022-09-03 12:12:01+00:00,"In the manual there is an entry about DSL support by Camel:


https://camel.apache.org/manual/dsl.html


When you choose the Java DSL:


https://camel.apache.org/manual/java-dsl.html


Then there is a short explanation and example about what this DSL do. However when choosing for example XML then the user is direct to:


https://camel.apache.org/components/3.15.x/others/java-xml-io-dsl.html


This contains no information only a redirect back to manual.",pchasan:1649021505:2022-04-04T05:31:45.177+0000:1649021505:2022-04-04T05:31:45.177+0000:I am willing to work on this issue
0,CAMEL-17841,New Feature,Minor,None,3.19.0,"
None
",Resolved,Fixed,3.19.0,Andrea Cosentino,Kévin LACIRE,0,1,2022-03-22 14:35:15+00:00,2022-07-25 12:48:02+00:00,Currently the Azure Eventhub consumer is checkpoint it's offset on every processed exchange a quick upgrade would be to expose a batchSize parameter to execute this checkpoint less frequently (this dramatically alter consumption performances) a time interval could also be complementary to avoid potentially unlimited pending checkpoint of the last batch,"KevinLACIRE:1647932143:2022-03-22T14:55:43.860+0000:1647932143:2022-03-22T14:55:43.860+0000:[https://docs.microsoft.com/en-us/azure/event-hubs/event-hubs-java-get-started-send#add-event-hubs-libraries-to-your-java-project]

A modulo is presented as an example to lower the update frequency in the Azure Eventhub official documentation"
0,CAMEL-17840,New Feature,Minor,3.15.0,4.0.0,"

feature-request

",Resolved,Fixed,4.0.0,Claus Ibsen,Nathaniel Lombardi,0,2,2022-03-22 13:41:04+00:00,2023-07-25 07:13:41+00:00,"Recent versions of pulsar introduced the retry letter topic feature. This feature allows pulsar consumers to mark messages to be resent at a later time. This would be a nice feature to have in camel. 


https://pulsar.apache.org/docs/en/concepts-messaging/#retry-letter-topic","davsclaus:1690196230:2023-07-24T18:57:10.804+0000:1690196230:2023-07-24T18:57:10.804+0000:Here is a PR
https://github.com/apache/camel/pull/10812"
0,CAMEL-17839,Improvement,Major,None,3.17.0,"
None
",Resolved,Fixed,3.17.0,Claus Ibsen,Claus Ibsen,2,3,2022-03-22 12:16:33+00:00,2022-03-28 12:57:43+00:00,"Some users may have monitoring systems that rely on camel-health report UP on initial startup - as they may not differentiate between a readiness vs liveness check.


See comments on CAMEL-17168","rphgoossens:1647924101:2022-03-22T12:41:41.215+0000:1647924101:2022-03-22T12:41:41.215+0000:In the particular case my colleague [~Edwardkuenen] mentioned, the actuator health endpoint showed an overall status of ""DOWN"" due to the fact that nothing had been polled yet by the route, but the *readinessState* and *livenessState* both show an ""UP"" status in the json returned. I would have expected the readinessState to be DOWN as well, if I understood your comments correctly?! 
davsclaus:1647928171:2022-03-22T13:49:31.989+0000:1647928171:2022-03-22T13:49:31.989+0000:Ah yeah it could be that we dont differentiate correctly before the 1st poll to have ready=DOWN and live=UP. If ready=UNKNOWN then its in fact skipped and would be considered UP which we don't really know.

Ideally the camel components that are scheduled should have special health checks to do readiness check before 1st poll. But often a component would combine this and do lazy connection until 1st poll, so we are back to ""start"".


davsclaus:1648022309:2022-03-23T15:58:29.031+0000:1648022309:2022-03-23T15:58:29.031+0000:Are you using spring boot? If so it seems they have a different way of doing cloud liveness and readiness check, so that a spring boot HealthCheck implementation would not know what check it is currently performing.
davsclaus:1648022379:2022-03-23T15:59:39.774+0000:1648022379:2022-03-23T15:59:39.774+0000:Can you put together a spring boot example that can do liveness and readiness checks and with a readme how to run this. This helps us to quicker help you.
rphgoossens:1648023021:2022-03-23T16:10:21.803+0000:1648023021:2022-03-23T16:10:21.803+0000:Hey [~davsclaus] , yeah we are using Spring Boot and we are using implementations of Spring's HealthIndicator for our custom checks, not Camel HealthChecks, so I can imagine that Spring's liveness and readiness could be out of sync with the subset of HealthChecks Camel performs in our applications. At this moment our biggest issue is that scheduled polling consumers used to have a Status of UP after the application starts and now they are DOWN until something actually gets polled. So for now we've excluded those health checks (via the camel.health.config property) from participating in the overall status. But we like to put them back in, and an initial status of UNKNOW instead of DOWN would fix that imho.

I'll see if I can put together a small service that combines all. Give me a day or two.

Cheers, Roger.
davsclaus:1648024335:2022-03-23T16:32:15.491+0000:1648024335:2022-03-23T16:32:15.491+0000:Okay I found out you can turn on livess/readiness with

# expose liveness/readiness probes
management.health.probes.enabled=true


davsclaus:1648085677:2022-03-24T09:34:37.748+0000:1648085677:2022-03-24T09:34:37.748+0000:You can now configure the initial state - also for spring boot actuator

For example to set it as unknown
camel.health.initialState=UNKNOWN


rphgoossens:1648429946:2022-03-28T09:12:26.955+0000:1648429946:2022-03-28T09:12:26.955+0000:Hey [~davsclaus] , I've used the properties management.health.probes.enabled=true combined with management.health.livenessState.enabled=true and management.health.readinessState.enabled=true to expose the live- and readiness properties in json returned by the actuator health endpoint.

Your suggested solution sounds feasible and should solve our health check issue. Do you still require an example project or do you have all the information you need to resolve this issue?!
davsclaus:1648431694:2022-03-28T09:41:34.749+0000:1648431694:2022-03-28T09:41:34.749+0000:Roger, thanks for the details. No I think we are good."
0,CAMEL-17838,Test,Minor,None,3.17.0,"
None
",Resolved,Fixed,3.17.0,John Poth,John Poth,0,1,2022-03-22 10:38:04+00:00,2022-04-06 14:45:23+00:00,It would be cool to create a singleton FHIR server when running tests and not recreate the server for each test class,
0,CAMEL-17837,Improvement,Major,None,3.17.0,"
None
",Resolved,Fixed,3.17.0,Claus Ibsen,Claus Ibsen,0,1,2022-03-22 08:49:18+00:00,2022-03-22 12:57:34+00:00,"camel.main.shutdown-timeout=444
camel.main.shutdownTimeout=222


We should regard this as same key when configuring on camel-main and properties are loaded form different sources, where the end user can use different styles.",
0,CAMEL-17836,Improvement,Major,None,3.16.0,"
None
",Resolved,Implemented,3.16.0,Claus Ibsen,Claus Ibsen,0,1,2022-03-21 17:40:32+00:00,2022-03-22 10:30:32+00:00,"When you have multiple properties sources (we have camel-dsl-modeline) and others then you want to prioritize ordering among them, so let them be ordered.",davsclaus:1647916232:2022-03-22T10:30:32.554+0000:1647916232:2022-03-22T10:30:32.554+0000:This was already implemented
0,CAMEL-17835,Improvement,Major,None,3.17.0,"
None
",Resolved,Fixed,3.17.0,Grzegorz Grzybek,Grzegorz Grzybek,0,1,2022-03-21 08:58:57+00:00,2022-05-04 09:01:40+00:00,com.github.mwiede:jsch fork offers support for more algorithms and is more transparent (GitHub repo) as of 2022-03.,"ggrzybek:1647839797:2022-03-21T13:16:37.854+0000:1647839797:2022-03-21T13:16:37.854+0000:https://github.com/apache/camel/pull/7241
ggrzybek:1647841890:2022-03-21T13:51:30.950+0000:1647841890:2022-03-21T13:51:30.950+0000:Changes required in camel-karaf (I'm working on it).
ggrzybek:1647910776:2022-03-22T08:59:36.116+0000:1647910776:2022-03-22T08:59:36.116+0000:Fixed [here|https://github.com/apache/camel/commit/7b419e3bfc0755b610b6609af2a8ba2e24c6e191].
ggrzybek:1647930326:2022-03-22T14:25:26.072+0000:1647930326:2022-03-22T14:25:26.072+0000:https://github.com/apache/camel-karaf/pull/128
ggrzybek:1647930789:2022-03-22T14:33:09.242+0000:1647930789:2022-03-22T14:33:09.242+0000:Fixed [here|https://github.com/apache/camel-karaf/commit/f3ea14b3526e954e6f11951865aac4d6acdfb93c] in https://github.com/apache/camel-karaf/commits/main"
0,CAMEL-17834,Test,Minor,3.16.0,3.16.0,"
None
",Resolved,Fixed,3.16.0,Claus Ibsen,Claus Ibsen,0,1,2022-03-20 11:45:03+00:00,2022-03-21 09:02:30+00:00,"[ERROR] Errors:
[ERROR] org.apache.camel.itest.springboot.CamelJiraTest.componentTests
[ERROR]   Run 1: CamelJiraTest.componentTests:45->AbstractSpringBootTestSupport.runModuleUnitTestsIfEnabled:93->AbstractSpringBootTestSupport.runModuleUnitTests:98 »
[ERROR]   Run 2: CamelJiraTest.componentTests:45->AbstractSpringBootTestSupport.runModuleUnitTestsIfEnabled:93->AbstractSpringBootTestSupport.runModuleUnitTests:98 »
[INFO]
[ERROR] org.apache.camel.itest.springboot.CamelOpenapiJavaTest.componentTests
[ERROR]   Run 1: CamelOpenapiJavaTest>AbstractSpringBootTestSupport.startSpringBoot:44 » Logging
[ERROR]   Run 2: CamelOpenapiJavaTest>AbstractSpringBootTestSupport.startSpringBoot:44 » Logging
[INFO]
[ERROR] org.apache.camel.itest.springboot.CamelSlackTest.componentTests
[ERROR]   Run 1: CamelSlackTest.componentTests:46->AbstractSpringBootTestSupport.runModuleUnitTestsIfEnabled:93->AbstractSpringBootTestSupport.runModuleUnitTests:98 »
[ERROR]   Run 2: CamelSlackTest.componentTests:46->AbstractSpringBootTestSupport.runModuleUnitTestsIfEnabled:93->AbstractSpringBootTestSupport.runModuleUnitTests:98 »
[INFO]
[ERROR] org.apache.camel.itest.springboot.CamelSoapTest.componentTests
[ERROR]   Run 1: CamelSoapTest>AbstractSpringBootTestSupport.startSpringBoot:44 » Logging log4j...
[ERROR]   Run 2: CamelSoapTest>AbstractSpringBootTestSupport.startSpringBoot:44 » Logging log4j...
[INFO]
[INFO]
[ERROR] Tests run: 220, Failures: 0, Errors: 4, Skipped: 6","davsclaus:1647823851:2022-03-21T08:50:51.202+0000:1647823851:2022-03-21T08:50:51.202+0000:jira and slack *DONE*
davsclaus:1647824544:2022-03-21T09:02:24.211+0000:1647824544:2022-03-21T09:02:24.211+0000:openapi and soap *DONE*"
0,CAMEL-17833,Test,Major,3.16.0,3.17.0,"
None
",Resolved,Abandoned,3.17.0,Unassigned,Claus Ibsen,0,1,2022-03-20 08:55:31+00:00,2022-05-07 07:32:41+00:00,"The test SecretsManagerUpdateSecretProducerLocalstackIT is failing when running with 


""localstack/localstack:0.14.1"";


But downgrading to


""localstack/localstack:0.14.0"";


works","davsclaus:1647737948:2022-03-20T08:59:08.150+0000:1647737948:2022-03-20T08:59:08.150+0000:<Binary Body> but was: <QmluYXJ5IEJvZHk=>

I am not sure if we are supposed in camel-aws to encode/decode the binary data to base64 ourselves."
0,CAMEL-17832,Dependency upgrade,Major,3.16.0,3.17.0,"
None
",Resolved,Fixed,3.17.0,Nicolas Filotto,Claus Ibsen,0,2,2022-03-20 08:26:38+00:00,2022-04-27 08:53:16+00:00,"https://github.com/grpc/grpc-java/issues/8981


2022-03-20 09:20:48,851 [ult-executor-20] INFO  GrpcConsumerConcurrentTest     - Exception
io.grpc.StatusRuntimeException: INTERNAL: Connection closed after GOAWAY. HTTP/2 error code: COMPRESSION_ERROR, debug data: Use direct accessor methods for pseudo headers.",nfilotto:1651018078:2022-04-27T08:07:58.396+0000:1651018078:2022-04-27T08:07:58.396+0000:The related PR https://github.com/apache/camel/pull/7501
0,CAMEL-17831,New Feature,Major,None,3.17.0,"
None
",Resolved,Fixed,3.17.0,Claus Ibsen,Claus Ibsen,0,1,2022-03-19 14:17:19+00:00,2022-03-22 12:57:25+00:00,"When using camel-main based apps, it may be good if we can know from where a given option configuration comes from



properties file
ENV variable
JVM system property
camel-k modeline
camel-k spec/configuration spec/trait
etc



When using sprint boot or quarkus then we may not know all of this but can say 



spring boot
quarkus","davsclaus:1647849147:2022-03-21T15:52:27.165+0000:1647852456:2022-03-21T16:47:36.251+0000:{code}
PropertiesComponent added custom PropertiesSource (factory): camel-dsl-modeline                                               
Auto-configuration summary                                                                                                    
    [camel-main]                   camel.component.properties.location=file:myapp.properties,                                 
    [camel-main]                   camel.main.routes-include-pattern=file:chuck-out.yaml                                      
    [JVM System Property]          camel.main.name=Killroy                                                                    
    [chuck-out.yaml]               camel.main.shutdownTimeout=444                                                             
    [camel-main]                   camel.main.routesReloadEnabled=false                                                       
    [camel-main]                   camel.main.sourceLocationEnabled=true                                                      
    [chuck-out.yaml]               camel.main.tracing=false                                                                   
    [camel-main]                   camel.main.modeline=true                                                                   
    [camel-main]                   camel.main.routesIncludePattern=file:chuck-out.yaml                                        
    [OS Environment Variable]      camel.main.logmask=true                                                                    
    [myapp.properties]             camel.dev-console.event.capacity=20                                                        
    [camel-main]                   camel.component.kamelet.location=classpath:/kamelets,github:apache:camel-kamelets/kamelets 
    [camel-main]                   camel.component.rest.consumerComponentName=platform-http                                   
    [camel-main]                   camel.component.rest.producerComponentName=vertx-http                                      
    [myapp.properties]             camel.component.log.sourceLocationLoggerName=true                                          
{code}
davsclaus:1647849226:2022-03-21T15:53:46.616+0000:1647850709:2022-03-21T16:18:29.624+0000:SYS = JVM system property
ENV = OS Environment
initial = initial properties from java (we can say camel-main)
chuck-out.yaml = from this yaml route that has camel-k modeline
myapp.properties = from this properties file
davsclaus:1647851886:2022-03-21T16:38:06.059+0000:1647851886:2022-03-21T16:38:06.059+0000:For runtimes with spring-boot then its more limited what we know and we do not do summary logging on these."
0,CAMEL-17830,New Feature,Minor,None,None,"
None
",Resolved,Duplicate,None,Unassigned,Luca Burgazzoli,0,1,2022-03-18 22:00:23+00:00,2022-03-18 22:21:29+00:00,"There  is a library [1] that implements JQ expressions in java  
A related quarkus extension is also provided [2]


[1] https://github.com/eiiches/jackson-jq/. 
[2] https://github.com/quarkiverse/quarkus-jackson-jq",
0,CAMEL-17829,Bug,Minor,None,Future,"
None
",Open,Unresolved,Future,Unassigned,João Miranda,0,2,2022-03-18 18:21:38+00:00,2022-09-06 05:26:55+00:00,"The MDN implementation has a field status that can be used to tell the requester if the message was processed with success or if any error occurred.


The default template has that field in $dispositionType.


 



private static final String DEFAULT_MDN_MESSAGE_TEMPLATE = ""MDN for -\n""
                                                           + "" Message ID: $requestHeaders[\""Message-Id\""]\n""
                                                           + ""  Subject: $requestHeaders[\""Subject\""]\n""
                                                           + ""  Date: $requestHeaders[\""Date\""]\n""
                                                           + ""  From: $requestHeaders[\""AS2-From\""]\n""
                                                           + ""  To: $requestHeaders[\""AS2-To\""]\n""
                                                           + ""  Received on: $responseHeaders[\""Date\""]\n""
                                                           + "" Status: $dispositionType \n"";



 


 


The issue is in the condition that determines if the MDN should be returned with success status or error status:


 



ResponseMDN.java

if (AS2DispositionType.FAILED.getType()
        .equals(HttpMessageUtils.getHeaderValue(request, AS2Header.DISPOSITION_TYPE))) {...}



This condition is looking at the request header Disposition-Type which is not correct. If the requester sends this header with failed the MDN will be returned with failed status regardless of the execution status of the receiver.","davsclaus:1647603429:2022-03-18T19:37:09.170+0000:1647603429:2022-03-18T19:37:09.170+0000:Can you send a PR to implement this fix?
joao.r.miranda:1648094546:2022-03-24T12:02:26.853+0000:1648094546:2022-03-24T12:02:26.853+0000:Hi [~davsclaus] ! 

I took a look at the MDN implementation and at the [AS2 RFC|https://datatracker.ietf.org/doc/html/rfc4130]. The issue seems to be bigger if my interpretation of the RFC is correct. 

[Section 7.6|https://datatracker.ietf.org/doc/html/rfc4130#section-7.6] says:
(...)
Status codes in the 200 range SHOULD also be used when an entity is returned (a signed receipt in a multipart/signed content type or an unsigned receipt in a multipart/report).  Even when the disposition of the data was an error condition at the authentication, decryption or other higher level, the HTTP status code SHOULD indicate success at the HTTP level.
Currently this is not happening. If an authentication, decryption or other error occurs during AS2 processing, an HttpException is raised and the component responds with status 500. 
The ResponseMDN class is an HTTP interceptor that runs right before the response is sent back to the requester... I see 2 problems:
 * I'm not sure if changing the HttpResponse (including the http status code) at this stage would be appropriate.
 * Since the AS2 processing finished with error, the context does not have the HttpCoreContext.HTTP_REQUEST in the MDNResponse class. The request is necessary to obtain the AS2 headers sent by the requester.

 "
0,CAMEL-17828,Task,Major,None,3.16.0,"
None
",Resolved,Fixed,3.16.0,Andrea Cosentino,Andrea Cosentino,0,1,2022-03-18 18:04:53+00:00,2022-12-01 10:10:32+00:00,No Desc,
0,CAMEL-17827,Dependency upgrade,Major,None,3.16.0,"
None
",Resolved,Fixed,3.16.0,Andrea Cosentino,Andrea Cosentino,0,1,2022-03-18 17:24:08+00:00,2022-03-18 18:17:22+00:00,So we could support Mongo 5.x too.,
0,CAMEL-17826,New Feature,Major,None,3.16.0,"
None
",Resolved,Fixed,3.16.0,Claus Ibsen,Claus Ibsen,0,1,2022-03-18 11:34:34+00:00,2022-03-18 11:36:46+00:00,"We should have option to control if exceptions should be written in http responses when there are failures.


The vertx platform does not do this, and with this option we can control it.",
0,CAMEL-17825,New Feature,Minor,None,4.4.0,"

easy
help-wanted

",Resolved,Fixed,4.4.0,Claus Ibsen,Raymond,0,2,2022-03-18 11:16:38+00:00,2023-12-13 15:21:33+00:00,"Another use case which often used in common with Camel is using hashes. This is similar to the following request:


https://issues.apache.org/jira/browse/CAMEL-17823


There are various ways to use a bean or processor to use a Hash in Java:


https://www.baeldung.com/sha-256-hashing-java


 


Would be nice to generate a hash directly with the simple language:


generate-hash(value, algorithm)


Where value is the original text/string/data/file
Where algorithm is for example SHA-256 or SHA3-256.","davsclaus:1690195312:2023-07-24T18:41:52.858+0000:1690195312:2023-07-24T18:41:52.858+0000:[~orpiske] here is also a ticket that is a bit easy 
davsclaus:1702450370:2023-12-13T14:52:50.953+0000:1702450370:2023-12-13T14:52:50.953+0000:okay it was not super easy
skin27:1702452093:2023-12-13T15:21:33.361+0000:1702452093:2023-12-13T15:21:33.361+0000:Easy in engineering is mostly a bit harder than expected :) . I do think this function will be valued by a lot of users (as with the UUID)."
0,CAMEL-17824,Improvement,Major,None,3.16.0,"
None
",Resolved,Fixed,3.16.0,Claus Ibsen,Claus Ibsen,0,1,2022-03-18 11:06:18+00:00,2022-03-18 11:36:46+00:00,"The other HTTP components has logic that deals with exchange exception and writes a custom response code, and allow end users to control the http status code etc.


Because vertx uses a ctx.fail(throwable) then it returns a canned 500 response to http client and does a stacktrace logging.


We should use the existing response code that already deals with errors.",
0,CAMEL-17823,New Feature,Minor,3.15.0,3.19.0,"
None
",Resolved,Fixed,3.19.0,Claus Ibsen,Raymond,0,2,2022-03-18 09:20:33+00:00,2022-09-04 12:15:20+00:00,"One common use case I see a lot is to set a unique ID (UUID). There are several ways to do this. For example:


1) Reuse a Camel generated id (exchangeid, breadcrumbid, messageid). For example: ${exchangeId}


2) Use 'generate-id' function in XSLT on a node-set (https://www.w3schools.com/xml/func_generateid.asp)


3) Create bean (and create UUID directly in Java) or with help of the UUIDGenerator (https://camel.apache.org/manual/uuidgenerator.html).


4) Create a Groovy expression


I think, however, it would be more convenient and easier for users to have a function directly within the Simple language. Something like:   


generate-id(type)


Where type is one of ""Classic, Default, Short, Simple"". When none is used, the default should be used.


Source: 
        
https://camel.apache.org/manual/uuidgenerator.html
https://www.designingbuildings.co.uk/wiki/Global_Unique_IDs_(GUIDs)","davsclaus:1648102879:2022-03-24T14:21:19.342+0000:1648102879:2022-03-24T14:21:19.342+0000:Are you able to work on this and send a PR ?
skin27:1648167083:2022-03-25T08:11:23.232+0000:1648167083:2022-03-25T08:11:23.232+0000:I like to give it a try. Note that I haven't worked on such a large code base/large OSS projects (outside very small fixes/documentation). So I first need to read a bit about the contribution guidelines, investigate the code base and the problem...
davsclaus:1648167971:2022-03-25T08:26:11.833+0000:1648167971:2022-03-25T08:26:11.833+0000:Sure that is a good and fun issue to try to implement.

To add custom functions to simple language it is around here
org.apache.camel.language.simple.ast.SimpleFunctionExpression#createSimpleExpressionMisc

And you can add unit tests to 
org.apache.camel.language.simple.SimpleTest

See for example how the random function is implemented

And for docs then add it to simple-language.adoc file


davsclaus:1662184705:2022-09-03T13:58:25.244+0000:1662184705:2022-09-03T13:58:25.244+0000:There is a new uuid function now
skin27:1662264920:2022-09-04T12:15:20.239+0000:1662264920:2022-09-04T12:15:20.239+0000:Nice!

Has this already documented?

https://camel.apache.org/components/next/languages/simple-language.html"
0,CAMEL-17822,Dependency upgrade,Major,None,3.16.0,"
None
",Resolved,Fixed,3.16.0,Unassigned,Claus Ibsen,0,1,2022-03-18 09:09:59+00:00,2022-03-18 09:15:19+00:00,No Desc,
0,CAMEL-17821,Improvement,Minor,3.15.0,3.17.0,"
None
",Resolved,Fixed,3.17.0,Aurélien Pupier,Aurélien Pupier,0,2,2022-03-18 08:48:25+00:00,2022-05-11 14:45:42+00:00,"Currently, Camel textual debugging requires having camel-debug in dependencies. This is an extra dependency that we do not want at runtime. 



main java example is configured having it at runtime.
main xml and yaml doesn't have it



I think a possible good practice is to add the dependency in a profile, for instance named `camel.debug` which can be activated with the property camel.debug set to true.


This would be nice to be done for all examples but maybe best to start with the 3 more simple/important main (java), main-xml and main-yaml to help starting discussion and see the feedback on it.


I think this is even more important fo r3.16 as JMX is exposed by default when the dependency is available.","apupier:1647564532:2022-03-18T08:48:52.003+0000:1647564532:2022-03-18T08:48:52.003+0000:preparing a PR (I cannot assign the issue)
apupier:1647565304:2022-03-18T09:01:44.399+0000:1647565304:2022-03-18T09:01:44.399+0000:PR provided https://github.com/apache/camel-examples/pull/84
davsclaus:1647565570:2022-03-18T09:06:10.016+0000:1647565570:2022-03-18T09:06:10.016+0000:I granted your user karma to assign tickets"
0,CAMEL-17820,New Feature,Major,None,3.17.0,"
None
",Resolved,Fixed,3.17.0,Claus Ibsen,Claus Ibsen,0,1,2022-03-18 08:36:31+00:00,2022-03-24 15:40:59+00:00,"If you use


jbang run foo.java openapi.json then those are used for camel DLS and properties. So the openapi.json file is not really in use.


We should make it easy to include all these extra files on the classpath then.


And maybe also have a CLI option to specify classpath resources


camel run foo.java --resource myjson.json --resource data.bin","davsclaus:1648107659:2022-03-24T15:40:59.688+0000:1648107659:2022-03-24T15:40:59.688+0000:Extra files on CLI is added to classpath

We can look at later if we need --resource option to mimic camel-k more in the future."
0,CAMEL-17819,New Feature,Major,None,3.17.0,"
None
",Resolved,Fixed,3.17.0,Claus Ibsen,Claus Ibsen,0,1,2022-03-18 08:33:28+00:00,2022-05-04 10:56:19+00:00,https://github.com/apache/camel-k/tree/main/examples/openapi,davsclaus:1651559214:2022-05-03T14:26:54.562+0000:1651559214:2022-05-03T14:26:54.562+0000:There is a bug in the openapi yaml generator that we need to fix as well. When fixed then we can have this feature
0,CAMEL-17818,New Feature,Major,3.15.0,3.17.0,"
None
",Resolved,Fixed,3.17.0,Jeremy Ross,Jeremy Ross,0,1,2022-03-18 03:14:52+00:00,2022-03-24 17:18:41+00:00,"For large query results that require paging, add the option to transparently retrieve subsequent pages similar to the StreamList option of the SQL and JDBC components.",
0,CAMEL-17787,Improvement,Minor,None,3.16.0,"
None
",Resolved,Fixed,3.16.0,James Netherton,James Netherton,0,1,2022-03-14 08:20:01+00:00,2022-03-18 15:07:43+00:00,There's some logic in the MicroProfile Health component that pre-dates the introduction of the exposure-level feature from camel-health. So it should be reworked so that exposure-level is properly taken into consideration in the MP health check output.,
0,CAMEL-17786,Task,Major,None,None,"
None
",Closed,Fixed,None,Andrea Cosentino,Sebb,0,1,2022-03-12 12:25:59+00:00,2022-03-14 11:28:53+00:00,"As the subject says.


There don't appear to be any sources for those two versions.","acosentino:1647059730:2022-03-12T12:35:30.891+0000:1647059730:2022-03-12T12:35:30.891+0000:Forgot to upload. I'll do
sebb:1647060669:2022-03-12T12:51:09.494+0000:1647060669:2022-03-12T12:51:09.494+0000:They don't appear under dist/dev either, so it's not clear how the VOTE succeeded.

Reviewers are supposed to check that the released source can be used to build the artifacts, and that it corresponds with the repo (so provenance can be checked).
acosentino:1647060912:2022-03-12T12:55:12.374+0000:1647060912:2022-03-12T12:55:12.374+0000:The source is available in GitHub too.
sebb:1647190056:2022-03-14T00:47:36.425+0000:1647190056:2022-03-14T00:47:36.425+0000:They seem to have disappeared again.

Also there are no files for the following

camel-kamelets-sources-0.7.1.tar.gz
apache-camel-k-runtime-1.12.0-source-release.zip

Please fix these urgently
acosentino:1647206034:2022-03-14T05:13:54.244+0000:1647206034:2022-03-14T05:13:54.244+0000:The sources for this ticket have been uploaded on fist releases. I'll check when I have time. 
acosentino:1647207566:2022-03-14T05:39:26.541+0000:1647207566:2022-03-14T05:39:26.541+0000:https://dist.apache.org/repos/dist/release/camel/camel-k/1.8.2/
https://dist.apache.org/repos/dist/release/camel/camel-k/1.8.1/
https://dist.apache.org/repos/dist/release/camel/camel-k-runtime/1.12.0/
https://dist.apache.org/repos/dist/release/camel/camel-kamelets/0.7.1/

The source are all available in dist release. There is something to do on the website side I think."
0,CAMEL-17785,Improvement,Major,None,3.x,"
None
",Resolved,Won't Fix,3.x,Unassigned,Claus Ibsen,1,2,2022-03-12 07:34:07+00:00,2022-09-03 12:07:58+00:00,Instead of using thread local for a worker pool where the worker is affiniated to a thread. Then lets use a different pool based on a LRUCache.,
0,CAMEL-17784,Improvement,Major,None,3.17.0,"
None
",Resolved,Fixed,3.17.0,Claus Ibsen,Claus Ibsen,0,1,2022-03-11 21:43:26+00:00,2022-03-29 08:03:05+00:00,"joor (java-joor-dsl) can only compile a single .java file at a time. This means that if you have multiple files and they have dependency on each other, then joor will fail compiling.


It would be good to have them compile as a single unit together. This allows camel-jbang to have better hot-reload with java beans.


It also allows camel-k to use local beans instead of pre-compiled JARs","davsclaus:1648358315:2022-03-27T13:18:35.036+0000:1648358315:2022-03-27T13:18:35.036+0000:There is a PR in the works for jOOR
https://github.com/jOOQ/jOOR/pull/119
davsclaus:1648424444:2022-03-28T07:40:44.232+0000:1648435148:2022-03-28T10:39:08.109+0000:This also requires RoutesBuilderLoader to support loading multiple resources in one go. Then we can collect all .java resources and have them compiled once. *DONE*
davsclaus:1648428467:2022-03-28T08:47:47.981+0000:1648461697:2022-03-28T18:01:37.140+0000:Also the reload need to handle that multiple java source files needs to be aggregated and compiled in one go. *DONE*
davsclaus:1648512185:2022-03-29T08:03:05.965+0000:1648512185:2022-03-29T08:03:05.965+0000:This can also allow camel-k to have pojo support again
https://github.com/apache/camel-k/issues/1821"
0,CAMEL-17783,Wish,Major,None,None,"
None
",Resolved,Information Provided,None,Unassigned,Joseph Earl,0,2,2022-03-11 18:15:46+00:00,2022-03-12 09:06:30+00:00,"Using Jira requires creating a separate account so is not very user friendly and reduces the number of users reporting issues. Issues should be in the same place that people interact with the open source code, on GitHub.","davsclaus:1647047190:2022-03-12T09:06:30.992+0000:1647047190:2022-03-12T09:06:30.992+0000:The other sub projects like camel-k / camel-quarkus uses github issues. But the core project is a JIRA based project on ASF infrastructure which is mandatory.

For example Apache Kafka (one of the most popular ASF projects) also uses JIRA"
0,CAMEL-17782,Wish,Minor,None,None,"
None
",Resolved,Won't Fix,None,Unassigned,Joseph Earl,0,2,2022-03-11 18:11:33+00:00,2022-09-03 12:07:32+00:00,"EndpointInject should work on constructor parameters so that developers can use constructor based injection for dependencies.


Constructor injection encourages good, testable class design. Camel should support this.","davsclaus:1647003900:2022-03-11T21:05:00.448+0000:1647046997:2022-03-12T09:03:17.076+0000:What runtime do you use? such as spring boot, quarkus or what?

Also mind that spring or quarkus etc don't easily allow Camel to take part of constructor dependency injection as this requires support for plugging in 3rd party annotation injectors.

However this is possible at a later stage with bean post processors where Camel can do dependency injection on fields/methods after the object is created.
josephearl:1647219471:2022-03-14T08:57:51.888+0000:1647219471:2022-03-14T08:57:51.888+0000:[~davsclaus] Quarkus"
0,CAMEL-17781,Improvement,Major,None,3.16.0,"
None
",Resolved,Fixed,3.16.0,Claus Ibsen,Claus Ibsen,0,1,2022-03-11 08:17:57+00:00,2022-03-11 08:24:27+00:00,"So you can use


camel run *


and it will only load known DSLs and skip files such as readme, IDEA/Eclipse files etc


java.lang.IllegalArgumentException: Cannot find RoutesBuilderLoader in classpath supporting file extension: iml
	at org.apache.camel.impl.engine.DefaultRoutesLoader.findRoutesBuilders(DefaultRoutesLoader.java:100)",
0,CAMEL-17780,New Feature,Major,None,3.19.0,"
None
",Resolved,Fixed,3.19.0,Nicolas Filotto,Claus Ibsen,3,4,2022-03-11 07:04:47+00:00,2022-09-21 16:20:42+00:00,"See CAMEL-17779.


 


Due to a license change in the high-level client, we need to propose a new component based on a client that is compatible with an Apache license","lboutros:1660700613:2022-08-17T09:43:33.881+0000:1660700613:2022-08-17T09:43:33.881+0000:Hello, perhaps could we use this client https://github.com/elastic/elasticsearch-java in the new component, only compliant with ES 8+ ? Instead of the low level one.
The old one is already deprecated and the new one is licensed under Apache Licence 2.0.
nfilotto:1663219015:2022-09-15T13:16:55.296+0000:1663219066:2022-09-15T13:17:46.731+0000:I will try to propose a new component based on the [Java Api Client|https://www.elastic.co/guide/en/elasticsearch/client/java-api-client/8.4/index.html] My question is what could be the best name for this new component?
acosentino:1663220028:2022-09-15T13:33:48.154+0000:1663220028:2022-09-15T13:33:48.154+0000:Since we deprecated and removed camel-elasticsearch I would probably rename this new component just camel-elasticsearch and add a clear release note about the fact it's new and based on a different client and it's for a new ES version and bla bla
nfilotto:1663221915:2022-09-15T14:05:15.409+0000:1663221915:2022-09-15T14:05:15.409+0000:It is what I had in mind too, so let's go for camel-elasticsearch, thx
nfilotto:1663635557:2022-09-20T08:59:17.991+0000:1663635557:2022-09-20T08:59:17.991+0000:Should be fixed by https://github.com/apache/camel/pull/8395
nfilotto:1663722594:2022-09-21T09:09:54.941+0000:1663722594:2022-09-21T09:09:54.941+0000:The corresponding PR for camel-spring-boot https://github.com/apache/camel-spring-boot/pull/630
nfilotto:1663748442:2022-09-21T16:20:42.598+0000:1663748442:2022-09-21T16:20:42.598+0000:The PR to update the doc [https://github.com/apache/camel/pull/8402] in order to include the doc about the SB component"
0,CAMEL-17779,Task,Major,None,3.16.0,"
None
",Resolved,Fixed,3.16.0,Claus Ibsen,Claus Ibsen,0,1,2022-03-11 07:00:41+00:00,2022-03-11 07:04:53+00:00,"org.elasticsearch.client:elasticsearch-rest-high-level-client:jar:7.10.2:compile


The high level client 7.10.2 is the last released under ASF2 license.
They change the license forward to a license that is x-category for ASF.


We should deprecate this component, and create a new component using the lower level java api which is still released under ASF2 license.",
0,CAMEL-17778,Test,Major,None,3.16.0,"
None
",Resolved,Fixed,3.16.0,Freeman Yue Fang,Freeman Yue Fang,0,1,2022-03-10 22:03:58+00:00,2022-03-11 22:57:42+00:00,No Desc,"ffang:1647006685:2022-03-11T21:51:25.372+0000:1647006685:2022-03-11T21:51:25.372+0000:PR is
https://github.com/apache/camel-spring-boot/pull/462"
0,CAMEL-17777,Test,Major,None,3.16.0,"
None
",Resolved,Fixed,3.16.0,Freeman Yue Fang,Freeman Yue Fang,0,1,2022-03-10 19:58:57+00:00,2022-03-11 22:57:07+00:00,No Desc,"ffang:1647007108:2022-03-11T21:58:28.967+0000:1647007108:2022-03-11T21:58:28.967+0000:PR is
https://github.com/apache/camel-spring-boot/pull/463"
0,CAMEL-17776,New Feature,Minor,None,,"
None
",Open,Unresolved,None,Unassigned,Jawad Ahmad,0,1,2022-03-10 15:20:49+00:00,2022-09-03 12:06:19+00:00,"It would be great to support Health Cloud Connect API using Camel Salesforce Component. 


I am not sure if this can be achieved with current implementations.


https://developer.salesforce.com/docs/atlas.en-us.234.0.health_cloud_object_reference.meta/health_cloud_object_reference/hc_business_apis.htm",
0,CAMEL-17775,New Feature,Major,None,None,"
None
",Open,Unresolved,4.x,Andrea Cosentino,Claus Ibsen,0,1,2022-03-10 15:03:36+00:00,2023-08-09 09:12:07+00:00,"Like we did for camel-kafka, where we have a readiness health check that tracks if there is a live connection to kafka or not, and can then mark whether we are ready or not.


Other components can benefit from similar idea.",
0,CAMEL-17774,Improvement,Minor,3.14.2,3.16.0,"
None
",Resolved,Fixed,3.16.0,Unassigned,Manos Tsantakis,0,2,2022-03-10 14:15:55+00:00,2022-03-14 14:59:49+00:00,"The constructor of ZipIterator sets zipInputStream  to null in case of inputStream being null as well. {{}}


Here


A null check here would prevent that.","davsclaus:1646894281:2022-03-10T14:38:01.087+0000:1646894281:2022-03-10T14:38:01.087+0000:What is the use-case? When do you have a null input stream as input, what do you do?
mtsantakis:1646894652:2022-03-10T14:44:12.684+0000:1646894784:2022-03-10T14:46:24.388+0000:I've used ZipSplitter which does the following:

 

{color:#cc7832}public {color}Object {color:#ffc66d}evaluate{color}(Exchange exchange) {
  Message inputMessage = exchange.getIn(){color:#cc7832};{color}{color:#cc7832}  {color}

InputStream inputStream = inputMessage.getBody(InputStream.{color:#cc7832}class{color}){color:#cc7832};{color}{color:#cc7832}  {color}

{color:#cc7832}return new {color}ZipIterator(exchange{color:#cc7832}, {color}inputStream);
}

 

inputSteam here can be null (eg: The required TypeConverter cannot be matched)
davsclaus:1646894884:2022-03-10T14:48:04.669+0000:1646894884:2022-03-10T14:48:04.669+0000:Yes you are welcome to send a PR.
davsclaus:1647126295:2022-03-13T07:04:55.735+0000:1647126295:2022-03-13T07:04:55.735+0000:btw you can also use getMandatoryBody"
0,CAMEL-17773,Bug,Major,3.14.0,"3.14.3, 3.16.0","
None
",Resolved,Fixed,"3.14.3, 3.16.0",Claus Ibsen,Artem St,0,2,2022-03-10 12:56:31+00:00,2022-03-10 14:37:01+00:00,"There is a simple example from the http component documentation, but configured to use HttpSendDynamicAware:




from(""direct:start"")
   .toD(""http://oldhost?order=123&detail=short"");



Sending exchange to a direct:start will return an exception:




Failed to resolve endpoint: http://http://oldhost due to: Failed to resolve endpoint: http://http://oldhost due to: The uri part is not configured correctly. You have duplicated the http(s) protocol.



 


I belive, the core of the problem is how HttpSendDynamicAware parses uri. it's keeps scheme of uri if there is empty path. For example this test will not return the expected result:




@Test
public void testHttpsUndefinedPortParseUri() {
   this.httpSendDynamicAware.setScheme(""https"");
   DynamicAwareEntry entry = new DynamicAwareEntry(""https://localhost:80/"", null, null, null);
   String[] result = httpSendDynamicAware.parseUri(entry);
   assertEquals(""localhost"", result[0], ""Parse should not add port if https and not specified"");
}





org.opentest4j.AssertionFailedError: Parse should not add port if https and not specified ==> 
Expected :localhost
Actual   :https://localhost:80/



Both test classes are attached.",davsclaus:1646893287:2022-03-10T14:21:27.818+0000:1646893287:2022-03-10T14:21:27.818+0000:Thanks for reporting and providing unit tests.
0,CAMEL-17771,Test,Minor,3.16.0,3.17.0,"
None
",Resolved,Fixed,3.17.0,Unassigned,Claus Ibsen,0,1,2022-03-10 06:21:23+00:00,2022-05-07 07:33:44+00:00,No Desc,
0,CAMEL-17770,Test,Major,None,3.16.0,"
None
",Resolved,Fixed,3.16.0,Freeman Yue Fang,Freeman Yue Fang,0,1,2022-03-09 22:37:31+00:00,2022-03-10 19:41:35+00:00,No Desc,"ffang:1646910220:2022-03-10T19:03:40.212+0000:1646910220:2022-03-10T19:03:40.212+0000:PR is 
https://github.com/apache/camel-spring-boot/pull/460"
0,CAMEL-17769,Improvement,Major,None,3.16.0,"
None
",Resolved,Fixed,3.16.0,Andrea Cosentino,Andrea Cosentino,0,1,2022-03-09 10:03:42+00:00,2022-03-11 17:47:08+00:00,No Desc,
0,CAMEL-17768,Bug,Minor,3.16.0,"3.14.3, 3.16.0","
None
",Resolved,Fixed,"3.14.3, 3.16.0",Jiri Ondrusek,Jiri Ondrusek,0,1,2022-03-09 08:52:34+00:00,2022-03-09 15:21:35+00:00,"Error message was changed in cm-sms. It can return an error message  ERROR No or incorrect User node found, which is ""translated"" as UnknownErrorException. It should be ""translated"" as NoAccountFound...Exception",
0,CAMEL-17767,Bug,Minor,3.14.2,"3.14.3, 3.16.0","
None
",Resolved,Fixed,"3.14.3, 3.16.0",Unassigned,Benjamin Graf,0,2,2022-03-09 07:29:38+00:00,2022-03-09 15:21:24+00:00,"Since the last ""big"" change to camel-csv in Camel 3.12.0 an empty header in uri like




<to uri=""dataformat:name:marshal?header=&delimiter=;""/>




is interpreted as fixed column empty String.


Maybe do empty String check while creating marshaler in (Link)","davsclaus:1646785396:2022-03-09T08:23:16.429+0000:1646785396:2022-03-09T08:23:16.429+0000:What is the use case for setting header = blank
graben:1646788650:2022-03-09T09:17:30.235+0000:1646788650:2022-03-09T09:17:30.235+0000:We use the marshaler in a dynamic endpoint (tod) where the fixed headers are calculated at runtime. In some cases, they are null to use dynamic columns.
davsclaus:1646789936:2022-03-09T09:38:56.052+0000:1646789936:2022-03-09T09:38:56.052+0000:Ah okay, you are welcome to send a PR where we check for isNotEmpty instead of null check
graben:1646791442:2022-03-09T10:04:02.217+0000:1646791442:2022-03-09T10:04:02.217+0000:PR is ready. I first thought about reuse method from ObjectHelper, but this class exists twice in package org.apache.camel.support and org.apache.camel.util. One was already in use! So did it manually. :)"
0,CAMEL-17766,Test,Major,None,3.16.0,"
None
",Resolved,Fixed,3.16.0,Freeman Yue Fang,Freeman Yue Fang,0,1,2022-03-08 21:37:25+00:00,2022-03-10 19:50:46+00:00,No Desc,"ffang:1646912627:2022-03-10T19:43:47.967+0000:1646912627:2022-03-10T19:43:47.967+0000:PR is
https://github.com/apache/camel-spring-boot/pull/461"
0,CAMEL-17765,Bug,Minor,3.14.1,,"
None
",Resolved,Information Provided,None,Claus Ibsen,M. Bergin,0,3,2022-03-08 17:16:23+00:00,2022-03-10 09:54:34+00:00,"Boolean properties are not marked as required in the openapi document if the respective member variable name is prefixed with is.  The Fruit class in the attached project contains two boolean properties described below which are treated differently if the member variable name is prefixed.


The property definition below doesn't appear as required in the openapi document although it's marked as required.  The expectation is that it would appear in the list of required properties.


@NotBlank
private boolean isNotWorking;


public boolean isNotWorking() 

{
return isNotWorking;
}


public void setNotWorking(boolean isNotWorking) 

{
this.isNotWorking = isNotWorking;
}


 


The property definition below does appear as required in the openapi document as expected.


@NotBlank
private boolean working;


public boolean isWorking() 

{
return working;
}


public void setWorking(boolean working) 

{
this.working = working;
}


 


Additionally, the text below is printed when viewing the openapi document.


2022-03-08 11:38:20,704 WARN  [org.apa.cam.ope.RestModelConverters] (vert.x-worker-thread-0) Encountered unexpected type boolean in processing schema.","acosentino:1646731679:2022-03-08T17:27:59.129+0000:1646731679:2022-03-08T17:27:59.129+0000:If it is a camel-quarkus bug, please open it here:
https://github.com/apache/camel-quarkus/issues
mbchangellc:1646732080:2022-03-08T17:34:40.922+0000:1646732080:2022-03-08T17:34:40.922+0000:I believe the bug resides in the camel-openapi-java codebase.  The camel-quarkus-openapi-java project is just a wrapper around camel-openapi-java project that registers it as a Quarkus feature without introspection code of its own.
acosentino:1646732164:2022-03-08T17:36:04.794+0000:1646732183:2022-03-08T17:36:23.379+0000:Yes, but if you notice that using camel-quarkus it should be tracked there first, to avoid confusion. 
acosentino:1646732632:2022-03-08T17:43:52.566+0000:1646732632:2022-03-08T17:43:52.566+0000:https://github.com/apache/camel-quarkus/issues/3605
davsclaus:1646733380:2022-03-08T17:56:20.976+0000:1646733380:2022-03-08T17:56:20.976+0000:This is bad practice for getter/setter to name a boolean variable isXXX - it should just be XXX

There is a ""standard"" for naming getter/setters
https://stackoverflow.com/questions/5322648/for-a-boolean-field-what-is-the-naming-convention-for-its-getter-setter

mbchangellc:1646740708:2022-03-08T19:58:28.035+0000:1646740708:2022-03-08T19:58:28.035+0000:Link to the relevant section of the JavaBeans standard below.  The getters/setters in the example fully comply with the standard, both getters for booleans are prefixed with is.  The standard doesn't require getter/setter names match variable names, or that there's a correlation to a single variable at all.  As you can see in the sample, the member variable accessed by getMouthWidth() is mMouthWidth.  This is a stylistic point and claiming either is bad practice is a reach.  The code should either be driven by member variable or method declarations, trying to guess a member variable name based on the name of the getter/setter is bound to cause problems.

[https://docs.oracle.com/javase/tutorial/javabeans/writing/properties.html]

 
davsclaus:1646877224:2022-03-10T09:53:44.015+0000:1646877274:2022-03-10T09:54:34.368+0000:             * 1. Regular getters (""getX"")
             * 2. Is-getters (""isX"")
             * 3. Implicit, possible getters (""x"")
             */


Its jackson-databind that reads the pojo model, and they use this standard, meaning that your isXXX boolean is detected as number 2 as an isX type (see above)


    protected int _getterPriority(AnnotatedMethod m)
    {
        final String name = m.getName();
        // [databind#238]: Also, regular getters have precedence over ""is-getters""
        if (name.startsWith(""get"") && name.length() > 3) {
            // should we check capitalization?
            return 1;
        }
        if (name.startsWith(""is"") && name.length() > 2) {
            return 2;
        }
        return 3;
    }
"
0,CAMEL-17764,Bug,Major,3.16.0,"3.14.3, 3.16.0","
None
",Resolved,Fixed,"3.14.3, 3.16.0",Jiri Ondrusek,Jiri Ondrusek,0,1,2022-03-08 11:46:56+00:00,2022-03-08 14:31:15+00:00,"During implementation of tests for camel-quarkus's quartz extension (issue) I hit an issue.


There is a code in QuartzEndpoint, which enriches `jobDetrail` , see code. Unfortunatelly Quartz allows only `String` in this map - see code. Otherwise exception is thrown:




Caused by: java.io.IOException: JobDataMap values must be Strings when the 'useProperties' property is set.  Key of offending value: CamelQuartzTriggerSimpleRepeatInterval




Conversion of the values into String types solves the issue.",
0,CAMEL-17763,Task,Major,None,None,"
None
",Resolved,Fixed,3.17.0,Otavio Rodolfo Piske,Otavio Rodolfo Piske,0,1,2022-03-08 10:51:31+00:00,2022-04-14 15:44:20+00:00,"There are a lot of code in the tests that contains unused throws exceptions. This makes the test code harder to read, maintain and improve (since it makes it harder to figure out if can be replaced with an assertThrows). We should cleanup those.",orpiske:1649922260:2022-04-14T15:44:20.100+0000:1649922260:2022-04-14T15:44:20.100+0000:All of the components that could that could have their methods cleaned up without problems were cleaned up. Closing.
0,CAMEL-17762,New Feature,Major,None,None,"
None
",Resolved,Fixed,3.17.0,Otavio Rodolfo Piske,Otavio Rodolfo Piske,0,2,2022-03-08 10:15:02+00:00,2022-05-18 15:02:42+00:00,This is a tracking ticket for subsequent improvements for the Resume API v2 work.,davsclaus:1652303300:2022-05-12T05:08:20.062+0000:1652303300:2022-05-12T05:08:20.062+0000:Closing as there is another ticket for more components
0,CAMEL-17761,Bug,Major,None,"3.14.3, 3.16.0","
None
",Resolved,Fixed,"3.14.3, 3.16.0",Otavio Rodolfo Piske,Otavio Rodolfo Piske,0,1,2022-03-08 10:09:58+00:00,2022-03-08 16:05:40+00:00,"The Cassandra container is using a fixed value for the container: https://github.com/apache/camel/blob/bbbaaf39687fa4ee4556b3e1dd42ad51a86570f1/test-infra/camel-test-infra-cassandra/src/test/java/org/apache/camel/test/infra/cassandra/services/CassandraLocalContainerService.java#L39


 


This prevents users from defining a custom container.",
0,CAMEL-17760,Task,Major,3.15.0,3.x,"
None
",Resolved,Fixed,3.x,Otavio Rodolfo Piske,Otavio Rodolfo Piske,0,1,2022-03-08 09:59:45+00:00,2022-07-25 11:54:20+00:00,"We have lots of code doing this:


 




if (exchange.getPattern().isOutCapable()) {
    exchange.getOut().copyFrom(exchange.getIn());
    exchange.getOut().setBody(body);
} else {
    exchange.getIn().setBody(body);
}



 


Because getOut is deprecated, this generates a lot of warnings. We can consolidate this logic in the ExchangeHelper class to simplify cleaning it up in the future.",orpiske:1658721260:2022-07-25T11:54:20.342+0000:1658721260:2022-07-25T11:54:20.342+0000:Resolved with the linked PR.
0,CAMEL-17759,Task,Major,None,3.16.0,"
None
",Resolved,Fixed,3.16.0,Nicolas Filotto,Nicolas Filotto,0,2,2022-03-08 08:54:56+00:00,2022-03-10 18:41:03+00:00,"Since the parallel build has been enabled, we sometimes end up with an inconsistent  content of the catalog, indeed sometimes the console is included, sometimes is not, indicating a race condition issue in the build.


 


Example of inconsistency https://github.com/apache/camel/commit/8fcb3dfbbe7647417b82c9993ec744544e39dcae","essobedo:1646703666:2022-03-08T09:41:06.165+0000:1646703666:2022-03-08T09:41:06.165+0000:The related PR https://github.com/apache/camel/pull/7147
essobedo:1646716337:2022-03-08T13:12:17.244+0000:1646716337:2022-03-08T13:12:17.244+0000:It did not fix the problem, so let me find something better
essobedo:1646718530:2022-03-08T13:48:50.221+0000:1646718530:2022-03-08T13:48:50.221+0000:I double checked, the fix seems to be correct. In the _regen_bot_ branches that contain the fix, we can see that the console is included as expected.
essobedo:1646718648:2022-03-08T13:50:48.123+0000:1646718648:2022-03-08T13:50:48.123+0000:I keep it open for at least a day to see if the problem appears again.
klease78:1646815454:2022-03-09T16:44:14.682+0000:1646815454:2022-03-09T16:44:14.682+0000:[~essobedo] Thanks for fixing this annoying issue. It seems the console was the only component which wasn't indirectly required by one of the dependencies in camel-allcomponents so it wasn't guaranteed to be built before the catalog."
0,CAMEL-17758,Test,Major,None,3.16.0,"
None
",Resolved,Fixed,3.16.0,Freeman Yue Fang,Freeman Yue Fang,0,1,2022-03-07 17:03:59+00:00,2022-03-08 22:39:19+00:00,No Desc,"ffang:1646746975:2022-03-08T21:42:55.964+0000:1646746975:2022-03-08T21:42:55.964+0000:PR is
https://github.com/apache/camel-spring-boot/pull/458"
0,CAMEL-17757,Dependency upgrade,Major,None,3.16.0,"
None
",Resolved,Fixed,3.16.0,Claus Ibsen,Claus Ibsen,0,1,2022-03-07 14:33:32+00:00,2022-03-07 14:39:36+00:00,No Desc,
0,CAMEL-17756,Dependency upgrade,Major,None,3.16.0,"
None
",Resolved,Fixed,3.16.0,Claus Ibsen,Claus Ibsen,0,1,2022-03-07 13:57:10+00:00,2022-03-07 13:58:05+00:00,No Desc,
0,CAMEL-17755,Improvement,Major,None,3.16.0,"
None
",Resolved,Fixed,3.16.0,Nicolas Filotto,Claus Ibsen,0,2,2022-03-07 12:19:15+00:00,2022-03-09 06:04:43+00:00,"With CAMEL-17555 we use the term ""precondition"" to filter whether the route/EIP should be included or not (eager).


To standardize on precondition then we can remove DoSwitch and use Choice instead and add precondition to choice.","davsclaus:1646690856:2022-03-08T06:07:36.281+0000:1646690856:2022-03-08T06:07:36.281+0000:[~essobedo] this ticket you are welcome to look at too
essobedo:1646704425:2022-03-08T09:53:45.614+0000:1646704425:2022-03-08T09:53:45.614+0000:[~davsclaus] Of course, with pleasure. Feel free to assign me any tickets that you would like me to look at. I'm always happy to help if I can.
essobedo:1646710639:2022-03-08T11:37:19.939+0000:1646710639:2022-03-08T11:37:19.939+0000:[~davsclaus] Just to make sure that I get it right, could you please provide an example?
davsclaus:1646713990:2022-03-08T12:33:10.992+0000:1646713990:2022-03-08T12:33:10.992+0000:https://camel.apache.org/components/3.15.x/eips/switch-eip.html
davsclaus:1646714078:2022-03-08T12:34:38.696+0000:1646714078:2022-03-08T12:34:38.696+0000:https://github.com/apache/camel/commit/31a3f6ddb62898cd29264281fdc835fb29d6ed12
essobedo:1646722471:2022-03-08T14:54:31.317+0000:1646722471:2022-03-08T14:54:31.317+0000:Yes I'm aware of the switch EIP, I mean how would you rewrite the next example?
{code:java}
.doSwitch()
.when(simple(""{{?red}}"")).to(""mock:red"")
.when(simple(""{{?blue}}"")).to(""mock:blue"")
.end(){code}
I don't really get where the precondition should be set in the choice EIP? Maybe the right approach could be to add a boolean ""eager"" on the choice node to do the equivalent of doSwitch when it is set to true (false by default)?
essobedo:1646722529:2022-03-08T14:55:29.797+0000:1646722529:2022-03-08T14:55:29.797+0000:Please also note that for now, preconditions are expressed in simple language while doSwitch supports all the existing languages. 
davsclaus:1646726679:2022-03-08T16:04:39.741+0000:1646726679:2022-03-08T16:04:39.741+0000:Yeah the pro with doSwitch is that it seperates it from choice. But we may in the future find a few other EIPs where precondition makes sense.

So it can be something like (precondition should just be turned on, and then use the when predicates as today)

{code}
.choice().precondition()
.when(simple(""{{?red}}"")).to(""mock:red"")
.when(simple(""{{?blue}}"")).to(""mock:blue"")
.end()
{code}

And in XML
{code}
<choice precondition=""true"">
 ...
{code}

Then precondition is a boolean type on this EIP to enable this mode.
Then the choice reifier can check which mode it uses, and then do as DoSwitchReifier does when its true.

And then move the docs from DoSwitch to Choice EIP in a new section about the precondition mode
essobedo:1646727986:2022-03-08T16:26:26.455+0000:1646727986:2022-03-08T16:26:26.455+0000:It is very clear now, thank you
essobedo:1646745629:2022-03-08T21:20:29.077+0000:1646745629:2022-03-08T21:20:29.077+0000:The corresponding PR [https://github.com/apache/camel/pull/7166] assuming that it is still ok for 3.16
davsclaus:1646777083:2022-03-09T06:04:43.072+0000:1646777083:2022-03-09T06:04:43.072+0000:Thanks for the help"
0,CAMEL-17754,New Feature,Major,None,3.16.0,"
None
",Resolved,Fixed,3.16.0,Nicolas Filotto,Claus Ibsen,0,2,2022-03-07 12:16:05+00:00,2022-03-08 06:22:41+00:00,"The same as CAMEL-17555 but for route configurations (RouteConfigurationDefinition).


With this you could potentially have shared/nested JARs with a common set of route configurations that have pre-conditions so they will only be included if the precondition is true.","davsclaus:1646626645:2022-03-07T12:17:25.354+0000:1646626645:2022-03-07T12:17:25.354+0000:[~essobedo] here is another ticket that is related to what you did in CAMEL-17555. This one may also be tricky as route configurations are in the core and for all DSLs
essobedo:1646648915:2022-03-07T18:28:35.934+0000:1646648915:2022-03-07T18:28:35.934+0000:The corresponding PR https://github.com/apache/camel/pull/7142
davsclaus:1646691761:2022-03-08T06:22:41.213+0000:1646691761:2022-03-08T06:22:41.213+0000:Thanks that was really fast and great work"
0,CAMEL-17753,Improvement,Minor,3.14.1,,"
None
",Open,Unresolved,None,Unassigned,Vincenzo Galluccio,0,1,2022-03-07 09:51:48+00:00,2022-03-07 09:51:48+00:00,No Desc,
0,CAMEL-17752,Task,Major,3.15.0,None,"
None
",Resolved,Fixed,3.16.0,Claus Ibsen,Claus Ibsen,0,1,2022-03-06 08:54:51+00:00,2022-03-06 08:58:55+00:00,https://github.com/camel-tooling/camel-idea-plugin/issues/666,
0,CAMEL-17751,Bug,Major,3.14.1,None,"
None
",Resolved,Fixed,"3.14.3, 3.16.0",Unassigned,Vangelis Papanastasatos,0,2,2022-03-05 15:45:40+00:00,2022-03-06 18:14:35+00:00,"When using LRASagaService for a saga, neither the completion or compensation routes are being triggered correctly.


 


The last version that the behaviour was correct seems to be v3.7.2


 


A project replicating the error can be found in GitHub


The same project, with working v3.7.2, is located in branch 


camel-3.7.2.


 


Narayana v5.12.x was used as the transaction manager in both versions.","vagpap:1646466982:2022-03-05T15:56:22.779+0000:1646466982:2022-03-05T15:56:22.779+0000:When setting logging level to DEBUG, the following log entries were observed:

*v3.7.2*

{{2022-03-05 17:21:13.429 DEBUG 37992 --- [nio-8080-exec-3] o.a.coyote.http11.Http11InputBuffer      : Received [PUT /api/lra-participant/complete?Camel-Saga-Compensate=direct://sagaCompensated&Camel-Saga-Complete=direct://sagaCompleted HTTP/1.1}}
{{Content-Type: text/plain}}
{{Long-Running-Action: http://localhost:50000/lra-coordinator/0_ffffc0a80165_caf4_62236d7c_191}}
{{Long-Running-Action-Recovery: http://localhost:50000/lra-coordinator/recoveryhttp%3A%2F%2Flocalhost%3A50000%2Flra-coordinator%2F0_ffffc0a80165_caf4_62236d7c_191/0_ffffc0a80165_caf4_62236d7c_193}}
{{Content-Length: 0}}
{{Host: localhost:8080}}
{{Connection: Keep-Alive}}
{{{}User-Agent: Apache-HttpClient/4.5.12 (Java/11.0.7){}}}{{{}]{}}}
{{2022-03-05 17:21:13.430 DEBUG 37992 --- [nio-8080-exec-3] org.apache.tomcat.util.http.Parameters   : Set query string encoding to UTF-8}}
{{2022-03-05 17:21:13.431 DEBUG 37992 --- [nio-8080-exec-3] o.a.c.authenticator.AuthenticatorBase    : Security checking request PUT /api/lra-participant/complete}}
{{2022-03-05 17:21:13.431 DEBUG 37992 --- [nio-8080-exec-3] org.apache.catalina.realm.RealmBase      :   No applicable constraints defined}}
{{2022-03-05 17:21:13.431 DEBUG 37992 --- [nio-8080-exec-3] o.a.c.authenticator.AuthenticatorBase    : Not subject to any constraint}}
{{2022-03-05 17:21:13.432 DEBUG 37992 --- [nio-8080-exec-3] org.apache.tomcat.util.http.Parameters   : Set encoding to UTF-8}}
{{2022-03-05 17:21:13.433 DEBUG 37992 --- [nio-8080-exec-3] org.apache.tomcat.util.http.Parameters   : Decoding query null UTF-8}}
{{2022-03-05 17:21:13.433 DEBUG 37992 --- [nio-8080-exec-3] org.apache.tomcat.util.http.Parameters   : Start processing with input [Camel-Saga-Compensate=direct://sagaCompensated&Camel-Saga-Complete=direct://sagaCompleted]}}
{{2022-03-05 17:21:13.434 DEBUG 37992 --- [nio-8080-exec-3] o.a.camel.processor.FilterProcessor      : *Filter matches: true for exchange: Exchange[]*}}

 

{{*v3.14.2*}}

{{2022-03-05 17:50:41.563 DEBUG 43808 --- [nio-8080-exec-3] o.a.coyote.http11.Http11InputBuffer      : Received [PUT /api/lra-participant/complete?Camel-Saga-Compensate=direct://sagaCompensated&Camel-Saga-Complete=direct://sagaCompleted HTTP/1.1}}
{{Content-Type: text/plain}}
{{Long-Running-Action: http://localhost:50000/lra-coordinator/0_ffffc0a80165_caf4_62236d7c_1a7}}
{{Long-Running-Action-Recovery: http://localhost:50000/lra-coordinator/recoveryhttp%3A%2F%2Flocalhost%3A50000%2Flra-coordinator%2F0_ffffc0a80165_caf4_62236d7c_1a7/0_ffffc0a80165_caf4_62236d7c_1a9}}
{{Content-Length: 0}}
{{Host: localhost:8080}}
{{Connection: Keep-Alive}}
{{{}User-Agent: Apache-HttpClient/4.5.12 (Java/11.0.7){}}}{{{}]{}}}
{{2022-03-05 17:50:41.564 DEBUG 43808 --- [nio-8080-exec-3] org.apache.tomcat.util.http.Parameters   : Set query string encoding to UTF-8}}
{{2022-03-05 17:50:41.564 DEBUG 43808 --- [nio-8080-exec-3] o.a.c.authenticator.AuthenticatorBase    : Security checking request PUT /api/lra-participant/complete}}
{{2022-03-05 17:50:41.565 DEBUG 43808 --- [nio-8080-exec-3] org.apache.catalina.realm.RealmBase      :   No applicable constraints defined}}
{{2022-03-05 17:50:41.566 DEBUG 43808 --- [nio-8080-exec-3] o.a.c.authenticator.AuthenticatorBase    : Not subject to any constraint}}
{{2022-03-05 17:50:41.567 DEBUG 43808 --- [nio-8080-exec-3] org.apache.tomcat.util.http.Parameters   : Set encoding to UTF-8}}
{{2022-03-05 17:50:41.568 DEBUG 43808 --- [nio-8080-exec-3] org.apache.tomcat.util.http.Parameters   : Decoding query null UTF-8}}
{{2022-03-05 17:50:41.568 DEBUG 43808 --- [nio-8080-exec-3] org.apache.tomcat.util.http.Parameters   : Start processing with input [Camel-Saga-Compensate=direct://sagaCompensated&Camel-Saga-Complete=direct://sagaCompleted]}}
{{2022-03-05 17:50:41.568 DEBUG 43808 --- [nio-8080-exec-3] o.a.camel.processor.FilterProcessor      : *Filter matches: false for exchange: Exchange[]*}}

 

In both of the cases, the predicate that the filter tried to match is

{{header(Camel-Saga-Complete) is not null}}

 

Narayana in both cases sends the following request:

{{PUT /api/lra-participant/complete?Camel-Saga-Compensate=direct://sagaCompensated&Camel-Saga-Complete=direct://sagaCompleted}}

 

It seems that the query parameters are not correctly parsed and added as headers in the exchange, thus the filter is failing to match. Header CamelHttpQuery contains correctly the values."
0,CAMEL-17750,Improvement,Major,None,None,"
None
",Resolved,Fixed,3.16.0,Unassigned,Hokutor,0,1,2022-03-05 11:04:35+00:00,2022-03-06 08:27:03+00:00,Optimize implementation of HuaweiCloud FaceRecognition Service(FRS) component,
0,CAMEL-17749,Improvement,Minor,None,3.16.0,"
None
",Resolved,Delivered,3.16.0,Claus Ibsen,Claus Ibsen,0,1,2022-03-04 19:34:22+00:00,2022-03-06 08:37:00+00:00,TODO: be able to enable|disable camel.health.camel-kafka.enabled=false via camel-main configuration,"davsclaus:1646393761:2022-03-04T19:36:01.578+0000:1646393761:2022-03-04T19:36:01.578+0000:So you can configure this per custom health-check

camel.health.camel-kafka.enabled = false

For spring boot we may need a custom auto configuration that can be used. Otherwise we need to fiddle with the map config ala thread-pools, to make it generic and use the key as health check name

camel.health.config[camel-kafka].enabled = false

davsclaus:1646526707:2022-03-06T08:31:47.210+0000:1646527020:2022-03-06T08:37:00.080+0000:You can use the exclude-pattern

camel.health.exclude-pattern=kafka*

"
0,CAMEL-17748,Dependency upgrade,Minor,None,None,"
None
",Resolved,Fixed,3.16.0,Claus Ibsen,Claus Ibsen,0,1,2022-03-04 16:42:07+00:00,2022-09-26 11:58:47+00:00,No Desc,
0,CAMEL-17747,Test,Major,None,3.16.0,"
None
",Resolved,Fixed,3.16.0,Freeman Yue Fang,Freeman Yue Fang,0,1,2022-03-04 14:51:05+00:00,2022-03-08 21:43:24+00:00,No Desc,"ffang:1646746761:2022-03-08T21:39:21.543+0000:1646746761:2022-03-08T21:39:21.543+0000:PR is
https://github.com/apache/camel-spring-boot/pull/456"
0,CAMEL-17746,Test,Major,None,3.16.0,"
None
",Resolved,Fixed,3.16.0,Freeman Yue Fang,Freeman Yue Fang,0,1,2022-03-04 14:45:51+00:00,2022-03-05 02:20:38+00:00,No Desc,"ffang:1646400505:2022-03-04T21:28:25.257+0000:1646400505:2022-03-04T21:28:25.257+0000:PR is
https://github.com/apache/camel-spring-boot/pull/455"
0,CAMEL-17745,Task,Minor,3.16.0,3.16.0,"
None
",Resolved,Fixed,3.16.0,John Poth,John Poth,0,1,2022-03-04 11:46:57+00:00,2022-03-07 12:36:31+00:00,"I think this relates to CAMEL-16192. It may be worth creating a ""real"" camel-core-starter and a new camel-core-engine-starter.


Thanks !",jpoth:1646365721:2022-03-04T11:48:41.035+0000:1646365721:2022-03-04T11:48:41.035+0000:https://github.com/apache/camel-spring-boot/pull/454
0,CAMEL-17744,Bug,Major,None,,"
None
",Resolved,Fixed,None,John Poth,John Poth,0,1,2022-03-04 11:22:41+00:00,2022-03-04 11:34:11+00:00,"Running the example from scratch gives:




Caused by: java.lang.IllegalArgumentException: Cannot configure option [apiContextListing] with value [false] as the bean class [org.apache.camel.spi.RestConfiguration] has no suitable setter method, or not possible to lookup a bean with the id [false] in Spring Boot registry
        at org.apache.camel.spring.boot.util.CamelPropertiesHelper.setCamelProperties(CamelPropertiesHelper.java:125) ~[camel-spring-boot-3.16.0-SNAPSHOT.jar:3.16.0-SNAPSHOT]
        at org.apache.camel.model.rest.springboot.RestConfigurationDefinitionAutoConfiguration.configureRestConfigurationDefinition(RestConfigurationDefinitionAutoConfiguration.java:72) ~[camel-core-starter-3.16.0-SNAPSHOT.jar:3.16.0-SNAPSHOT]
        at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method) ~[na:na]
        at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) ~[na:na]
        at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) ~[na:na]
        at java.base/java.lang.reflect.Method.invoke(Method.java:566) ~[na:na]
        at org.springframework.beans.factory.support.SimpleInstantiationStrategy.instantiate(SimpleInstantiationStrategy.java:154) ~[spring-beans-5.3.16.jar:5.3.16]
        ... 37 common frames omitted",jpoth:1646364846:2022-03-04T11:34:06.344+0000:1646364846:2022-03-04T11:34:06.344+0000:Resolved with https://github.com/apache/camel-spring-boot/commit/07b410a73855b4ecced4de2bb675466bd53ec5d2
0,CAMEL-17743,Task,Minor,3.16.0,3.16.0,"
None
",Resolved,Fixed,3.16.0,John Poth,John Poth,0,1,2022-03-04 11:05:52+00:00,2022-03-07 10:20:36+00:00,SB2 schema generation fails for Resilience4jConfigurationDefinition because the javaType is set to io.github.resilience4j.circuitbreaker.CircuitBreaker when generating the schema while a String is expected. This also gives a ClassNotFoundException as the type isn't present on the classpath in SB2 starters. Removing the problematic javaTypes for now. Thanks !,jpoth:1646365737:2022-03-04T11:48:57.133+0000:1646365737:2022-03-04T11:48:57.133+0000:https://github.com/apache/camel/pull/7107
0,CAMEL-17742,Test,Minor,3.16.0,3.16.0,"
None
",Resolved,Fixed,3.16.0,Jiri Ondrusek,Jiri Ondrusek,0,1,2022-03-04 10:52:10+00:00,2022-03-04 14:40:37+00:00,Test _SpringQuartzPersistentStoreRestartAppChangeOptionsTest was disabled with update of spring 5.3.12 to 5.3.13. Test should be fixed and enabled,
0,CAMEL-17741,Task,Minor,None,3.16.0,"
None
",Resolved,Fixed,3.16.0,Nicolas Filotto,Nicolas Filotto,0,1,2022-03-04 08:18:55+00:00,2022-03-04 11:37:56+00:00,"It appears that the plugin camel-yaml-dsl-maven-plugin doesn't retrieve the default name of a property as the JAXB specification states.


Indeed, I have the next mapping:




@XmlElement
@Metadata(label = ""security"")
private List<SecurityDefinition> securityRequirements = new ArrayList<>();



According the JAXB specification, if a field is annotated with the annotation XmlElement, its name should be retrieved from the attribute ""name"" if set otherwise it should use the field name.


With the current code, I end up with ""security"" corresponding to the value of the attribute ""name"" of the annotation XmlRootElement on the class SecurityDefinition as you can see below:




@Metadata(label = ""rest,security,configuration"", title = ""Rest Security"")
@XmlRootElement(name = ""security"")
@XmlAccessorType(XmlAccessType.FIELD)
public class SecurityDefinition {



According to the specification, this behavior is actually only expected with a field annotated with XmlElementRef.",essobedo:1646354643:2022-03-04T08:44:03.214+0000:1646354643:2022-03-04T08:44:03.214+0000:The corresponding PR https://github.com/apache/camel/pull/7104
0,CAMEL-17740,Test,Major,None,3.16.0,"
None
",Resolved,Fixed,3.16.0,Freeman Yue Fang,Freeman Yue Fang,0,1,2022-03-03 19:25:10+00:00,2022-03-03 19:51:57+00:00,No Desc,"ffang:1646306776:2022-03-03T19:26:16.126+0000:1646306776:2022-03-03T19:26:16.126+0000:PR is
https://github.com/apache/camel-spring-boot/pull/452"
0,CAMEL-17739,Improvement,Major,None,None,"
None
",Resolved,Fixed,3.16.0,Andrea Cosentino,Andrea Cosentino,0,1,2022-03-03 14:13:28+00:00,2022-03-04 12:23:48+00:00,"Like use default credentials providers for AWS, but in this case we'll leverage the GOOGLE_APPLICATION_CREDENTIALS env variable, which is ugly as hell, but it's the default.",acosentino:1646351279:2022-03-04T07:47:59.510+0000:1646351279:2022-03-04T07:47:59.510+0000:Done. Need to add documentation.
0,CAMEL-17738,Bug,Minor,3.14.1,"3.14.3, 3.16.0","
None
",Resolved,Fixed,"3.14.3, 3.16.0",Claus Ibsen,Brad Harvey,0,2,2022-03-02 23:00:44+00:00,2022-03-06 08:24:26+00:00,"In camel 3.14.1 / spring boot 2.6.3 XML routes cannot be loaded from a nested jar.  I suspect earlier versions of both are also affected, but Camel 3.4.x + Spring Boot 2.3.x did load them ok.  


In this code from FatJarPackageScanResourceResolver, ""name"" is the nested jar name - it will end in .jar.  To traverse into the spring boot jar it would need to go into the second branch - the  ""else if""  - but it will always go into the first branch because it is a not a directory and the name does not end in .class.  


 




                String name = entry.getName();

                name = name.trim();
                if (!entry.isDirectory() && !name.endsWith("".class"")) {
                    name = cleanupSpringBootClassName(name);
                    // name is FQN so it must start with package name
                    if (name.startsWith(packageName)) {
                        entries.add(name);
                    }
                } else if (inspectNestedJars && !entry.isDirectory() && isSpringBootNestedJar(name)) {
                    String nestedUrl = urlPath + ""!/"" + name;
                    log.trace(""Inspecting nested jar: {}"", nestedUrl);

                    List<String> nestedEntries = doLoadImplementationsInJar(packageName, jarStream, nestedUrl, false, false);
                    entries.addAll(nestedEntries);
                }




 


I think this code was copied from the class resolver and name.endsWith("".class"") changed to !name.endswith("".class"") but it doesn't do what is needed.


 


Solution may be to swap the order of the if checks so that nested jars are found & traversed first.","davsclaus:1646258641:2022-03-03T06:04:01.601+0000:1646258641:2022-03-03T06:04:01.601+0000:Do you have a reproducer example you can attach here or put on github somewhere
bradhgbst:1646505592:2022-03-06T02:39:52.731+0000:1646505592:2022-03-06T02:39:52.731+0000:Please try  [https://github.com/bradhgbst/camel-spring-boot-examples/tree/CAMEL-17738]

Changes were:
 * Change routes-configuration/pom.xml to create the spring boot fat jar with a different name (""exec"" classifier) and leave the original plain jar so it can be used as a library.
 * Add a new example subproject routes-configuration-nested.  It nests the plain jar created by routes-configuration.
 * Remove unrelated modules from the parent pom - I was having trouble getting it all to install.

 

From the parent project run ""mvn install"".  

The following things work fine - all routes are loaded and run:
 * Running ""mvn spring-boot:run"" from either of the subprojects (routes-configuration & routes-configuration-nested)
 * java -jar routes-configuration/target/camel-example-spring-boot-routes-configuration-3.16.0-SNAPSHOT-exec.jar

 
{code:java}
2022-03-06 12:22:10.925  INFO 14492 --- [           main] o.a.c.impl.engine.AbstractCamelContext   : Routes startup (total:3 started:3)
{code}
 

But what does not work is:
 * java -jar routes-configuration-nested/target/camel-example-spring-boot-routes-nested-3.16.0-SNAPSHOT.jar

For that one, the java route & error handler are loaded but nothing else.

 
{code:java}
2022-03-06 12:34:05.286  INFO 12568 --- [           main] o.a.c.impl.engine.AbstractCamelContext   : Routes startup (total:1 started:1)
{code}
 

Quite tricky to test when it is only when run from the jar that it fails.  Hope that helps!
davsclaus:1646526025:2022-03-06T08:20:25.672+0000:1646526025:2022-03-06T08:20:25.672+0000:Thanks Brad for the reproducer, and the analysis and hint on checking nested first as that helps fix this bug"
0,CAMEL-17737,Bug,Major,3.11.1,,"
None
",Resolved,Invalid,None,Unassigned,Zia,0,2,2022-03-02 20:07:34+00:00,2022-03-02 20:30:59+00:00,"Hi All,


while observing consumed messages in Camel salesforce consumer, i see message id in consumed message are not in sequence and have some jumps in between the message ID sequences. there are no errors as well in the logs. does it means camel salesforce consumer missing some platform event messages? Kindly help


 


 


2022-03-03 01:24:52,664] INFO Received Exchange BBE93EB9D4320D3-0000000000003AFE with Message BBE93EB9D4320D3-0000000000003AFE from Endpoint salesforce:///event/LoginEventStream?backoffIncrement=1000&replayId=-2 (org.apache.camel.kafkaconnector.CamelSourceTask:233)
[2022-03-03 01:24:52,664] INFO Received Exchange BBE93EB9D4320D3-0000000000003AFF with Message BBE93EB9D4320D3-0000000000003AFF from Endpoint salesforce:///event/LoginEventStream?backoffIncrement=1000&replayId=-2 (org.apache.camel.kafkaconnector.CamelSourceTask:233)
[2022-03-03 01:24:52,664] INFO Received Exchange BBE93EB9D4320D3-0000000000003B00 with Message BBE93EB9D4320D3-0000000000003B00 from Endpoint salesforce:///event/LoginEventStream?backoffIncrement=1000&replayId=-2 (org.apache.camel.kafkaconnector.CamelSourceTask:233)
[2022-03-03 01:24:52,953] INFO Received Exchange BBE93EB9D4320D3-0000000000003C19 with Message BBE93EB9D4320D3-0000000000003C19 from Endpoint salesforce:///event/LoginEventStream?backoffIncrement=1000&replayId=-2 (org.apache.camel.kafkaconnector.CamelSourceTask:233)
[2022-03-03 01:24:52,954] INFO Received Exchange BBE93EB9D4320D3-0000000000003C23 with Message BBE93EB9D4320D3-0000000000003C23 from Endpoint salesforce:///event/LoginEventStream?backoffIncrement=1000&replayId=-2 (org.apache.camel.kafkaconnector.CamelSourceTask:233)
[2022-03-03 01:24:52,954] INFO Received Exchange BBE93EB9D4320D3-0000000000003C2C with Message BBE93EB9D4320D3-0000000000003C2C from Endpoint salesforce:///event/LoginEventStream?backoffIncrement=1000&replayId=-2 (org.apache.camel.kafkaconnector.CamelSourceTask:233)
[2022-03-03 01:24:52,954] INFO Received Exchange BBE93EB9D4320D3-0000000000003C32 with Message BBE93EB9D4320D3-0000000000003C32 from Endpoint salesforce:///event/LoginEventStream?backoffIncrement=1000&replayId=-2 (org.apache.camel.kafkaconnector.CamelSourceTask:233)
[2022-03-03 01:24:52,954] INFO Received Exchange BBE93EB9D4320D3-0000000000003C37 with Message BBE93EB9D4320D3-0000000000003C37 from Endpoint salesforce:///event/LoginEventStream?backoffIncrement=1000&replayId=-2 (org.apache.camel.kafkaconnector.CamelSourceTask:233)
[2022-03-03 01:24:52,955] INFO Received Exchange BBE93EB9D4320D3-0000000000003C3D with Message BBE93EB9D4320D3-0000000000003C3D from Endpoint salesforce:///event/LoginEventStream?backoffIncrement=1000&replayId=-2 (org.apache.camel.kafkaconnector.CamelSourceTask:233)
[2022-03-03 01:24:52,955] INFO Received Exchange BBE93EB9D4320D3-0000000000003C42 with Message BBE93EB9D4320D3-0000000000003C42 from Endpoint salesforce:///event/LoginEventStream?backoffIncrement=1000&replayId=-2 (org.apache.camel.kafkaconnector.CamelSourceTask:233)
[2022-03-03 01:24:52,955] INFO Received Exchange BBE93EB9D4320D3-0000000000003C47 with Message BBE93EB9D4320D3-0000000000003C47 from Endpoint salesforce:///event/LoginEventStream?backoffIncrement=1000&replayId=-2 (org.apache.camel.kafkaconnector.CamelSourceTask:233)
[2022-03-03 01:24:52,955] INFO Received Exchange BBE93EB9D4320D3-0000000000003C4E with Message BBE93EB9D4320D3-0000000000003C4E from Endpoint salesforce:///event/LoginEventStream?backoffIncrement=1000&replayId=-2 (org.apache.camel.kafkaconnector.CamelSourceTask:233)","acosentino:1646223211:2022-03-02T20:13:31.080+0000:1646223211:2022-03-02T20:13:31.080+0000:Please open the issue only on camel-kafka-connector issues for camel-kafka-connector project.

You already opened the same issue there
ziauddin135:1646224259:2022-03-02T20:30:59.910+0000:1646224259:2022-03-02T20:30:59.910+0000:sure Thank you!"
0,CAMEL-17706,New Feature,Minor,None,3.16.0,"

azure
servicebus

",Resolved,Fixed,3.16.0,Unassigned,MattV,0,2,2022-02-24 01:53:47+00:00,2022-02-26 07:51:45+00:00,"Add the option to pass a fully qualified namespace and token credential parameter to the azure-servicebus component as uri parameters. The use case would be to use AzureAD authentication rather than using a connection string, and allow for configuration for more than one service bus namespace and better security. Currently that configuration is cumbersome, needed to instantiate an async client for each queue to be sent to/received from. Passing those configuration options to the endpoint would greatly simplify that configuration.","acosentino:1645657341:2022-02-24T07:02:21.033+0000:1645657341:2022-02-24T07:02:21.033+0000:It's not really standard to have a clientBuilder as endpoint option. You have already the ability to inject a client in the camel registry and passing it in the route. We could probably relax the requirements for connection string, but having a clientBuilder as endpoint option is not a best practice. If you want to use AzureAD authentication, you could do that by injecting an instance of the client in the registry. There is still the problem of connection string requirement and this is something we should look at. 

If you have time to improve the component, we love contributions.
vachillo:1645681611:2022-02-24T13:46:51.213+0000:1645681680:2022-02-24T13:48:00.707+0000:makes sense. like i said, the configuration for multiple queues in 2+ namespaces is cumbersome, having to create a client per queue. I'd like to delegate most of that to the component. another option is to pass the fully qualified namespace and an instance of an azure identity credential, falling back to a DefaultCredential() if none is provided. this seems to be in line with the best practice for Azure AD auth with any Azure SDK. What do you think?

Link for reference: [Azure Service Bus client library for Java | https://docs.microsoft.com/en-us/java/api/overview/azure/messaging-servicebus-readme?view=azure-java-stable#create-a-service-bus-client-using-microsoft-identity-platform-formerly-azure-active-directory]
acosentino:1645696998:2022-02-24T18:03:18.420+0000:1645696998:2022-02-24T18:03:18.420+0000:I think there is space for improvements. There wasn't so much activity around this component, so I'd like to see more PRs. For example there were other issues regarding service bus sessions.
vachillo:1645715514:2022-02-24T23:11:54.767+0000:1645715514:2022-02-24T23:11:54.767+0000:I've updated the title and description to reflect the intended changes"
0,CAMEL-17705,Improvement,Major,"3.14.0, 3.15.0",3.17.0,"
None
",Resolved,Fixed,3.17.0,Jeremy Ross,Jawad Ahmad,0,4,2022-02-23 17:15:39+00:00,2022-04-01 02:03:00+00:00,"I am using Bulk V2 API to upload large files to Salesforce. I have noticed that on creating the job from Producer it times out with Timeout exception. I tried to change the timeout configuration but noticed its always gets set to a hardcoded one.


Class : SalesforceComponent




static SalesforceHttpClient createHttpClient(
            Object source, final SslContextFactory sslContextFactory, final CamelContext context, int workerPoolSize,
            int workerPoolMaxSize) {
        SecurityUtils.adaptToIBMCipherNames(sslContextFactory);

        final SalesforceHttpClient httpClient = new SalesforceHttpClient(
                context, context.getExecutorServiceManager().newThreadPool(source, ""SalesforceHttpClient"", workerPoolSize,
                        workerPoolMaxSize),
                sslContextFactory);
        // default settings, use httpClientProperties to set other
        // properties
        httpClient.setConnectTimeout(CONNECTION_TIMEOUT);
        httpClient.setIdleTimeout(IDLE_TIMEOUT);

        return httpClient;
    }




As suggested by Claus to use httpClientProperties. In that case, HTTP client does set the connection timeout of the configured value. But it passes timeout value to SalesforceSession instead of ConnectionTimeout value. So it still gets failed with a Timeout error.


Class : SalesforceComponent
Method: doStart




 setupHttpClient(httpClient, getCamelContext(), httpClientProperties);
// support restarts
if (session == null) {
session = new SalesforceSession(getCamelContext(), httpClient, httpClient.getTimeout(), loginConfig);
        }","davsclaus:1645608476:2022-02-23T17:27:56.739+0000:1645608476:2022-02-23T17:27:56.739+0000:Can you try as the comment says to use httpClientProperties to override and use your own timeout settings
jawwad124:1645611993:2022-02-23T18:26:33.910+0000:1645611993:2022-02-23T18:26:33.910+0000:[~davsclaus] I have updated the description with details. httpClientProperties does set client timeout value but timeout value still defaults. Which gets passed to the constructor of SalesforceSession. This timeout value is used to create requests and hence it get failed.

Caused by: java.util.concurrent.TimeoutException: Total timeout 60000 ms elapsed
ramu11:1646158758:2022-03-02T02:19:18.348+0000:1648749780:2022-04-01T02:03:00.512+0000:static final int CONNECTION_TIMEOUT = 60000; //hardcoded
@Metadata(description = ""Connection timeout used by the HttpClient when connecting to the Salesforce server."",
              label = ""common"", defaultValue = """" + CONNECTION_TIMEOUT)
    private long httpClientConnectionTimeout = CONNECTION_TIMEOUT;

 putValueIfGivenTo(httpClientProperties, HTTP_CONNECTION_TIMEOUT, salesforce::getHttpClientConnectionTimeout);

[~jawwad124] how you are passing httpClient values could you please share your configuration?
jawwad124:1646183557:2022-03-02T09:12:37.987+0000:1646183557:2022-03-02T09:12:37.987+0000:[~ramu11]

Here is the configuration I used to directly set properties on the HTTP client itself.

camel.component.salesforce.httpClientProperties.httpConnectionTimeout=360000
camel.component.salesforce.httpClientProperties.httpClientProperties=10000

Tried the configuration from Docs as well as :

camel.component.salesforce.http-client-connection-timeout= 360000
jeremyross:1647088266:2022-03-12T20:31:06.231+0000:1647095874:2022-03-12T22:37:54.724+0000:[~jawwad124] The timeout values do get [set in the client|https://github.com/apache/camel/blob/fd35990ed5e2d5d743e4a9c2137b86f5cc170961/components/camel-salesforce/camel-salesforce-component/src/main/java/org/apache/camel/component/salesforce/SalesforceComponent.java#L933-L934].  

You probably need to set idle timeout. Try this:

{{camel.component.salesforce.http-client-idle-timeout=360000}}
jeremyross:1648129462:2022-03-24T21:44:22.830+0000:1648129462:2022-03-24T21:44:22.830+0000:[~jawwad124] did this work for you?
jawwad124:1648180123:2022-03-25T11:48:43.790+0000:1648180123:2022-03-25T11:48:43.790+0000:[~jeremyross] You can see from the description code it's hardcoding both idle timeout and connection time out. I have tried both properties using httpClientProperties and setting directly on the component level. None of it works.
jeremyross:1648192866:2022-03-25T15:21:06.373+0000:1648192866:2022-03-25T15:21:06.373+0000:[~jawwad124] ok I see the problem. There is not currently an option to set the request timeout. I pushed a commit that adds this option [1]. 

[1] https://github.com/apache/camel/commit/91848c1114f60e2242b356805439bcf9ff5903c8"
0,CAMEL-17704,Bug,Minor,3.14.1,"3.14.3, 3.16.0","
None
",Resolved,Fixed,"3.14.3, 3.16.0",Claus Ibsen,Vincenzo Galluccio,0,2,2022-02-23 15:48:30+00:00,2022-04-28 19:21:47+00:00,"When using camel-netty-starter, and I'm having issues with camel.component.netty.decoders property. I get the following error:




Failed to bind properties under 'camel.component.netty.decoders' to java.util.List<io.netty.channel.ChannelHandler>: No converter found capable of converting from type [java.lang.String] to type [java.util.List<io.netty.channel.ChannelHandler>]



This is how I set the property:




camel.component.netty.decoders=#myDecoder



When I use the decoders query parameter it works fine:




netty:tcp://localhost:9999?decoders=#myDecoder



 


PS: I assume the issue also affects camel.component.netty.encoders property","davsclaus:1645688491:2022-02-24T15:41:31.673+0000:1645688491:2022-02-24T15:41:31.673+0000:Ah yeah its a limitation when using spring boot auto-configuration - standalone Camel can do this
davsclaus:1645689110:2022-02-24T15:51:50.666+0000:1645689110:2022-02-24T15:51:50.666+0000:We can potentially change the type in camel-netty to String instead of List to make it easier configurable 
vincenzo.galluccio:1651106895:2022-04-28T08:48:15.881+0000:1651106895:2022-04-28T08:48:15.881+0000:Hello,
Can this be fixed also on LTS 3.14.x ?
davsclaus:1651143629:2022-04-28T19:00:29.308+0000:1651143629:2022-04-28T19:00:29.308+0000:Okay let me try that"
0,CAMEL-17703,Test,Major,None,3.16.0,"
None
",Resolved,Fixed,3.16.0,Freeman Yue Fang,Freeman Yue Fang,0,1,2022-02-23 15:48:18+00:00,2022-02-25 12:42:03+00:00,No Desc,"ffang:1645704480:2022-02-24T20:08:00.285+0000:1645704480:2022-02-24T20:08:00.285+0000:PR is 
https://github.com/apache/camel-spring-boot/pull/442"
0,CAMEL-17702,Bug,Minor,3.11.0,"3.11.6, 3.14.2, 3.16.0","
None
",Resolved,Fixed,"3.11.6, 3.14.2, 3.16.0",Karen Lease,Radovan Bičiště,0,2,2022-02-23 14:41:33+00:00,2022-02-25 06:04:52+00:00,"When sending a file payload to google-storage consumer it causes Null Pointer Exception in GoogleCloudStorageProducer.processFile method.  
        if (obj instanceof File) 

{
            filePayload = (File) obj;
            is = new FileInputStream(filePayload);
        }

 else {
            is = exchange.getIn().getMandatoryBody(InputStream.class);
            baos = determineLengthInputStream(is);


 


baos is not initialized and causing NPE later on.


Test Case:




<route id=""CopyToGoogleCloudStorage"" streamCache=""true"">
  <from uri=""{{file-fromUri}}""/>
  <log message=""Found file: '${header[CamelFileNameOnly]}'""/>
      <log message=""Uploading to GCS file ${header.CamelFileNameOnly}""/>
      <!-- google-storage does not know File payload type and throws NPE -->
      <convertBodyTo type=""String""/> <-- comment this out to create NPE
      <toD uri=""google-storage://test?objectName=test.txt&amp;serviceAccountKey=classpath:keys/test.json""/>
  <log message=""Moved file: '${header.CamelFileNameOnly}'""/>
</route>",klease78:1645628438:2022-02-23T23:00:38.331+0000:1645628438:2022-02-23T23:00:38.331+0000:[~Bican] Thanks for reporting this bug.
0,CAMEL-17701,Improvement,Major,None,3.16.0,"
None
",Resolved,Fixed,3.16.0,Claus Ibsen,Claus Ibsen,0,1,2022-02-23 13:48:20+00:00,2022-03-01 13:03:42+00:00,"We should add labels to the options so we can group them, such as in advanced and other groups that we have for components","davsclaus:1645948887:2022-02-27T16:01:27.947+0000:1646025376:2022-02-28T13:16:16.194+0000:A..Z *DONE*
davsclaus:1646025387:2022-02-28T13:16:27.728+0000:1646107996:2022-03-01T12:13:16.120+0000:data-formats A..Z *DONE*"
0,CAMEL-17700,Improvement,Major,None,None,"
None
",Resolved,Fixed,3.16.0,Andrea Cosentino,Andrea Cosentino,0,1,2022-02-23 09:02:03+00:00,2022-02-23 13:39:12+00:00,"We should do something like aws:username:admin


where admin will be the default value for username, in case the value returned from the secrets manager is empty or null.


This means we should also change the way we are dealing with sub properties.


so something like aws:database/username will get the value of username field from database secret",
0,CAMEL-17699,Task,Major,3.15.0,,"
None
",Closed,Invalid,None,Otavio Rodolfo Piske,Otavio Rodolfo Piske,0,1,2022-02-23 06:08:29+00:00,2022-02-23 06:15:27+00:00,"I was searching for a good candidate to serve as a cache for the Kafka resume strategy implementation and I noticed that some of the LRU cache classes (DefaultLRUCacheFactory, SimpleLRUCache) seem to be unused.


This is a task for myself to remember investigating this more closely.",orpiske:1645568127:2022-02-23T06:15:27.136+0000:1645568127:2022-02-23T06:15:27.136+0000:Nevermind. They are used. I was looking for the wrong interface.
0,CAMEL-17698,Task,Major,3.16.0,None,"
None
",Resolved,Fixed,3.16.0,Andrea Cosentino,David Jencks,0,1,2022-02-23 02:08:24+00:00,2022-02-23 06:31:33+00:00,"There's a lot of inconsistency about whether it's google-secret-manager or google-secrets-manager.  Right now this has broken the website build because the spring-boot json file is google-secrets-manager.json but the camel components adoc has


:camel-spring-boot-name: google-secret-manager


Before this gets released I suggest that EVERYTHING be named consistently, either singular or plural but NOT a mixture.  


From e.g. 
```
import com.google.cloud.secretmanager.v1.SecretManagerServiceClient;
```
it looks like google prefers a singular form, so I'd guess it would be less confusing for camel to adopt the same.


I don't have a great deal of time right now but if there's agreement on what to do I can try to come up with a PR.",
0,CAMEL-17697,New Feature,Minor,None,None,"
None
",Resolved,Won't Fix,None,Unassigned,Neo Xu,0,2,2022-02-22 23:44:23+00:00,2023-11-14 13:15:43+00:00,"Quantitative trading is a very interesting space for developers. But the process is very complex, data collection, trading simulating, placing orders and so on.


Currently, we only have camel-quickfix for the FIX API. But it is for lower level APIs.


I thought we can integrate with large vendors for trading brokers. 
For example:
Dukascopy Bank SA, https://www.dukascopy.com/wiki/en/development/get-started-api/use-jforex-sdk/sdk-client
Interactive Brokers , https://interactivebrokers.github.io/tws-api/","orpiske:1699938943:2023-11-14T13:15:43.097+0000:1699938943:2023-11-14T13:15:43.097+0000:Closing because:

* Interactive Brokers API is incompatible with Apache License 2.0: https://interactivebrokers.github.io/. 
* DukasCopy API: doesn't seem to be available publicly, provide a clear definition of the license. 



"
0,CAMEL-17696,Test,Major,None,3.16.0,"
None
",Resolved,Fixed,3.16.0,Freeman Yue Fang,Freeman Yue Fang,0,1,2022-02-22 16:23:00+00:00,2022-02-24 12:43:12+00:00,No Desc,"ffang:1645602356:2022-02-23T15:45:56.471+0000:1645602356:2022-02-23T15:45:56.471+0000:PR is
https://github.com/apache/camel-spring-boot/pull/440"
0,CAMEL-17695,Improvement,Major,None,None,"
None
",Resolved,Fixed,3.16.0,Andrea Cosentino,Andrea Cosentino,0,1,2022-02-22 14:25:58+00:00,2022-02-24 09:51:47+00:00,No Desc,
0,CAMEL-17694,Improvement,Major,"3.11.5, 3.14.1","3.11.6, 3.14.2, 3.16.0","
None
",Resolved,Fixed,"3.11.6, 3.14.2, 3.16.0",James Netherton,James Netherton,0,1,2022-02-22 08:30:53+00:00,2022-02-23 13:17:36+00:00,"See issues reported in Zulip chat:


https://camel.zulipchat.com/#narrow/stream/257298-camel/topic/Vert.2Ex.20WebSocket.20sendToAll.20header",
0,CAMEL-17693,New Feature,Major,None,None,"
None
",Resolved,Fixed,3.16.0,Andrea Cosentino,Andrea Cosentino,0,1,2022-02-22 05:51:45+00:00,2022-02-22 11:06:33+00:00,No Desc,
0,CAMEL-17692,Task,Major,None,3.16.0,"
None
",Resolved,Fixed,3.16.0,Otavio Rodolfo Piske,Otavio Rodolfo Piske,0,1,2022-02-21 17:16:33+00:00,2022-03-02 18:53:53+00:00,This component is depending on camel-testcontainers which was deprecated. It must be cleaned up.,"orpiske:1646218433:2022-03-02T18:53:53.410+0000:1646218433:2022-03-02T18:53:53.410+0000:This was done on this PR, but it was not linked here for some reason.

 

https://github.com/apache/camel/pull/7009/commits/521389c1eb4ed00455b2ecf0a93d9da3f6ccb477"
0,CAMEL-17691,New Feature,Major,None,None,"
None
",Resolved,Fixed,3.16.0,Andrea Cosentino,Andrea Cosentino,0,1,2022-02-21 14:04:57+00:00,2022-02-22 10:56:44+00:00,"In the first iteration, we added only the createSecret operation.


Now we should support more operation, like:



GetSecret
DeleteSecret
GetSecretVersion



etc.",
0,CAMEL-17690,New Feature,Major,None,3.16.0,"
None
",Resolved,Fixed,3.16.0,Nicolas Filotto,Claus Ibsen,0,2,2022-02-21 11:54:33+00:00,2022-03-01 10:39:27+00:00,"Historically testing with camel is based on extending CamelTestSupport which gives you all the testing features from the base class.


When using spring boot, you can use spring boot style testing with annotations, or extend CamelSpringTestSupport.


For camel-main-test then we can also have a set of annotations as I think users will relate to this coming from spring boot world.


 




@CamelMainTest(MyApp.class)
public class MyAppTest {
    @BeanInject
    CamelContext camelContext;
    @Test
    public void testFoo() throws Exception {
      // my test content here
    }
}





 


And also a variation where you can refer to classes and properties to set as initial properties on the properties component


 




@CamelMainTest(class = MyApp.class, properties = {""camel.component.xxx=123"", ""period=1000"", ""hi=World""})
public class MyAppTest {
    @BeanInject
    CamelContext camelContext;
    @Test
    public void testFoo() throws Exception {
       // my test content here
    }
}





Take a look at the @SpringBootTest annotation and its features as inspiration.


And you can also extend the base class but use the annotations to make it stand out and also configure the main class etc


 




@CamelMainTest(class = MyApp.class, properties = {""camel.component.xxx=123"", ""period=1000"", ""hi=World""})
public class MyAppTest extends CamelMainTest {
    @Test
    public void testFoo() throws Exception {
        // camelContext is avail from the base class so no need for @BeanInject
    }
}","davsclaus:1645415748:2022-02-21T11:55:48.565+0000:1645415748:2022-02-21T11:55:48.565+0000:[~essobedo] wonder if you would like to take a stab at this also, now that you have done the great work on the main test module already.
essobedo:1645415852:2022-02-21T11:57:32.739+0000:1645415852:2022-02-21T11:57:32.739+0000:[~davsclaus] yes of course, with pleasure. 
essobedo:1645609969:2022-02-23T17:52:49.335+0000:1645609969:2022-02-23T17:52:49.335+0000:[~davsclaus] 

Are you sure about the hybrid mode? I mean the use case where the test class extends `CamelMainTestSupport` and is also annotated, IMHO it bings some complexity and confusion for the end user and the code itself. For example, let's say that you override a property using both the annotation and the method to override, which value will win?

Do you have a use case where it could make sense to use this hybrid mode?

FYI,  I'm trying to support all the existing features that we have in CamelMainTestSupport / CamelTestSupport that make sense for a Camel Main application like:

* Configure the main from a method (done)
* Allow to advice rules easily (done)
* Add support of mockEndpointsAndSkip and mockEndpoints (done)
* Allow to override properties (done)
* Allow to replace an existing bean (done)
* Add support of replaceRouteFromWith (done)
* Allow to configure easily the property placeholder locations with a file name or all the locations (done)
* Allow to provide a main class (done)
* Allow to add configuration classes (done)
* Add support of dumpRouteCoverage (in progress)
* Add support of the debug mode (TODO)

Do you see something that I could have missed?
davsclaus:1645682588:2022-02-24T14:03:08.022+0000:1645682588:2022-02-24T14:03:08.022+0000:Yeah lets wait with the hybrid mode, and focus on the annotation based first - that mirrors also practice from spring boot
essobedo:1645787270:2022-02-25T19:07:50.992+0000:1645787270:2022-02-25T19:07:50.992+0000:Here a PR proposal [https://github.com/apache/camel/pull/7041]

Please note that it doesn't support Nested test class, let me know if it is needed, I can eventually add  it 
essobedo:1646043808:2022-02-28T18:23:28.965+0000:1646043808:2022-02-28T18:23:28.965+0000:The nested test class support https://github.com/apache/camel/pull/7063
essobedo:1646044697:2022-02-28T18:38:17.261+0000:1646044697:2022-02-28T18:38:17.261+0000:Hum, I've just realized that I misunderstood how properties are configured, I thought that we expected an array of type [key1, value1, key2, value2...](like the utility method Map.of) while we expected more [key1=value1, key2=value2...]. My bad, I'll fix that tomorrow"
0,CAMEL-17689,New Feature,Major,None,None,"
None
",Resolved,Fixed,3.18.0,Andrea Cosentino,Andrea Cosentino,0,2,2022-02-21 05:37:09+00:00,2022-07-13 13:11:51+00:00,https://github.com/spring-projects/spring-vault,"acosentino:1654664196:2022-06-08T12:56:36.259+0000:1654664196:2022-06-08T12:56:36.259+0000:TODO:
- Support reading secrets as operation
- Improving docs with examples
- Create Spring Boot starter

davsclaus:1656375224:2022-06-28T08:13:44.156+0000:1656375224:2022-06-28T08:13:44.156+0000:Is there more work needed for this?"
0,CAMEL-17688,Sub-task,Major,None,None,"
None
",Resolved,Fixed,3.19.0,Andrea Cosentino,Andrea Cosentino,1,2,2022-02-21 05:36:17+00:00,2022-07-14 13:00:50+00:00,"We need an Hashicorp Vault component, based on spring vault library.",
0,CAMEL-17687,New Feature,Major,None,None,"
None
",Resolved,Fixed,3.17.0,Andrea Cosentino,Andrea Cosentino,0,1,2022-02-20 20:30:04+00:00,2022-04-01 09:48:47+00:00,No Desc,"acosentino:1648616250:2022-03-30T12:57:30.354+0000:1648616250:2022-03-30T12:57:30.354+0000:First iteration done.
acosentino:1648626422:2022-03-30T15:47:02.025+0000:1648626422:2022-03-30T15:47:02.025+0000:Following operations are supported for the moment:

- Create 
- Delete
- Get
- Purge
acosentino:1648626438:2022-03-30T15:47:18.949+0000:1648626438:2022-03-30T15:47:18.949+0000:Need to update the documentation"
0,CAMEL-17686,Sub-task,Major,None,None,"
None
",Resolved,Fixed,3.17.0,Andrea Cosentino,Andrea Cosentino,0,1,2022-02-20 20:29:37+00:00,2022-04-04 12:21:43+00:00,We need an Azure Key Vault component too,"acosentino:1648787169:2022-04-01T12:26:09.331+0000:1648787169:2022-04-01T12:26:09.331+0000:Done for Plain camel.
Missing Camel-Spring-boot"
0,CAMEL-17685,New Feature,Major,None,None,"
None
",Resolved,Fixed,3.16.0,Andrea Cosentino,Andrea Cosentino,0,1,2022-02-20 20:26:40+00:00,2022-02-21 13:57:43+00:00,No Desc,
0,CAMEL-17684,Sub-task,Major,None,None,"
None
",Resolved,Fixed,3.16.0,Andrea Cosentino,Andrea Cosentino,0,1,2022-02-20 20:26:00+00:00,2022-03-01 17:48:33+00:00,We need a GCP Secrets Manager component too.,"acosentino:1646115051:2022-03-01T14:10:51.241+0000:1646115051:2022-03-01T14:10:51.241+0000:This is done, need to add documentation.
acosentino:1646126064:2022-03-01T17:14:24.654+0000:1646126064:2022-03-01T17:14:24.654+0000:Only Spring Boot support is missing.
acosentino:1646128107:2022-03-01T17:48:27.224+0000:1646128107:2022-03-01T17:48:27.224+0000:Spring Boot support done."
0,CAMEL-17683,Improvement,Major,None,None,"
None
",Resolved,Fixed,3.16.0,Unassigned,Hokutor,0,1,2022-02-20 06:59:21+00:00,2022-02-20 09:28:18+00:00,Modify document of HuaweiCloud Face Recognition Service (FRS)  Component and add some test cases,
0,CAMEL-17682,Improvement,Major,None,3.16.0,"
None
",Resolved,Fixed,3.16.0,Nicolas Filotto,Claus Ibsen,0,2,2022-02-19 07:47:46+00:00,2022-02-21 17:52:43+00:00,"Nicolas, it would be good to make the main archetype use your new test module, see
https://github.com/apache/camel/tree/main/archetypes/camel-archetype-main","essobedo:1645237672:2022-02-19T10:27:52.642+0000:1645237672:2022-02-19T10:27:52.642+0000:[~davsclaus] of course, no problem, with pleasure. I just need first to improve a little bit more what I have done. Hopefully, I will be able to do both and the corresponding changes on the examples on Monday.

FYI (not related), while updating the test of the examples, I realized that the examples spring-spark and main-health are broken, I will check what's wrong with them just after
essobedo:1645427400:2022-02-21T15:10:00.267+0000:1645437163:2022-02-21T17:52:43.381+0000:The corresponding PR https://github.com/apache/camel/pull/7008

[~davsclaus] The example of test is really basic, please let me know if you want something more complex.
davsclaus:1645436966:2022-02-21T17:49:26.701+0000:1645436966:2022-02-21T17:49:26.701+0000:This is fine, users can read the main-test module documentation for more details."
0,CAMEL-17681,Improvement,Major,None,3.16.0,"
None
",Resolved,Fixed,3.16.0,Claus Ibsen,Claus Ibsen,0,1,2022-02-18 15:04:20+00:00,2022-02-18 16:11:57+00:00,Added option so you can turn this off if you want,
0,CAMEL-17680,Task,Major,"3.14.0, 3.15.0, 3.16.0","3.14.2, 3.16.0","
None
",Resolved,Fixed,"3.14.2, 3.16.0",Otavio Rodolfo Piske,Otavio Rodolfo Piske,0,1,2022-02-18 12:23:28+00:00,2022-02-24 14:14:55+00:00,In the meter registry part of the documentation we refer to the metrics registry instead of the micrometer one: https://camel.apache.org/components/3.14.x/micrometer-component.html#MicrometerComponent-registry,
0,CAMEL-17679,Task,Major,None,"3.14.1, 3.16.0","
None
",Resolved,Fixed,"3.14.1, 3.16.0",Otavio Rodolfo Piske,Otavio Rodolfo Piske,0,1,2022-02-18 12:21:34+00:00,2022-03-01 15:16:32+00:00,"Our documentation says gauge is supported by trying to use it leads to an error. We probably need to clarify this.


 


How to reproduce: try using:




micrometer:gauge:<opts>","orpiske:1645158513:2022-02-18T12:28:33.191+0000:1645158513:2022-02-18T12:28:33.191+0000:Exception in thread ""main"" org.apache.camel.FailedToCreateRouteException: Failed to create route route1 at: >>> To[micrometer:gauge:messages.count] <<< in route: Route(route1)[From[kafka:test?autoOffsetReset=earliest] -> [... because of Failed to resolve endpoint: micrometer://gauge:messages.count due to: Unsupported meter type gauge"
0,CAMEL-17678,New Feature,Major,None,3.16.0,"
None
",Resolved,Fixed,3.16.0,Claus Ibsen,Claus Ibsen,0,1,2022-02-18 11:21:53+00:00,2022-02-19 07:48:11+00:00,"You may want to run Camel in quiet mode where nothing is logged to the console, in the sense where you for example want to consume messages from X and write to console out. 


Then jbang can be a part where you can from a CLI pipe to other commands.
https://twitter.com/maxandersen/status/1494600204590501889?s=20&t=2BbbOdSYCj498qV1wwEkYw


Maybe something a long those lines with jbang -c where the code script is using camel instead.",
0,CAMEL-17677,Test,Major,None,3.16.0,"
None
",Resolved,Fixed,3.16.0,Freeman Yue Fang,Freeman Yue Fang,0,1,2022-02-17 23:06:06+00:00,2022-02-27 12:03:36+00:00,No Desc,
0,CAMEL-17676,Bug,Minor,"3.12.0, 3.14.2, 3.15.0",,"
None
",Resolved,Information Provided,None,Unassigned,Erwin Oldenkamp,2,4,2022-02-17 16:23:53+00:00,2023-12-20 15:57:41+00:00,"In version 3.12.0 the RedeliveryErrorHandler doesn't log the BreadcrumbId and RouteId anymore. 


In version 3.12.0 I would see:




2022-02-17 16:47:31,701 INFO  o.a.c.p.e.DeadLetterChannel - [BC ] - [RI ] - Failed delivery for (MessageId: ID:activemq-6bbb4dbb68-cr62z-39269-1645104552893-5:2:1:1:8 on ExchangeId: 92F0FAC801928B8-0000000000000000). On delivery attempt: 0 caught: java.lang.Exception: Some Bug 



Where as on version 3.11.4 the following is being displayed 




2022-02-17 17:20:24,820 INFO  o.a.c.p.e.DeadLetterChannel - [BC 331601E40883DAE-0000000000000000] - [RI CamelMDCTest1] - Failed delivery for (MessageId: ID:activemq-6bbb4dbb68-cr62z-39269-1645104552893-5:3:1:1:1 on ExchangeId: 331601E40883DAE-0000000000000000). On delivery attempt: 0 caught: java.lang.Exception: Some Bug 



The following is my logging formatting: 




<pattern>%d %-5level %logger{36} - [BC %X{camel.breadcrumbId}] - [RI %X{camel.routeId}] - %msg%n</pattern> 



I think this has to do with CAMEL-17009 for cleaning the MDC out more often now.","davsclaus:1703059061:2023-12-20T15:57:41.091+0000:1703059061:2023-12-20T15:57:41.091+0000:We have done some fixes for Camel 4.4. 

Try with that release onwards."
0,CAMEL-17675,Improvement,Major,None,3.16.0,"
None
",Resolved,Fixed,3.16.0,Claus Ibsen,Claus Ibsen,1,6,2022-02-17 14:38:08+00:00,2022-10-26 08:39:18+00:00,"In the Rest DSL you can inline a route but that was a mistake.


I made a mistake when rest-dsl was created that you could embed a route inside it
that is bad, instead its better as it was a facade to a route which you link via direct.","marat.gubaidullin@gmail.com:1645457675:2022-02-21T23:34:35.706+0000:1645502342:2022-02-22T11:59:02.425+0000:Could we also remove *steps* attribute from GetDefinition, PostDefinition, PatchDefinition, DeleteDefinition, HeadDefinition? *DONE*
davsclaus:1645491083:2022-02-22T08:51:23.090+0000:1645491094:2022-02-22T08:51:34.810+0000:Yeah ideally the yaml-dsl would just be a something along:

{code}
-rest
    get: /foo
       to: direct:foo
{code}
marat.gubaidullin@gmail.com:1645512981:2022-02-22T14:56:21.560+0000:1645513006:2022-02-22T14:56:46.164+0000:Looks like not correct YAML ;)

And we might have multiple rest and its methods.

So the shortest way is:
{code:java}
     - rest:
        path: ""/demo""
        post:
          - path: ""/foo""
            to: ""direct:foo""
          - path: ""/bar""
            to: ""direct:bar""
        get:
          - path: ""/getFoo""
            to: ""direct:foo""
          - path: ""/getBar""
            to: ""direct:foo""
{code}
 

 
coelhro:1651552971:2022-05-03T12:42:51.743+0000:1651552971:2022-05-03T12:42:51.743+0000:Hello all,

Any reason for the RestDefinition.to() not allowing String... ?

Before this change i was getting my routeDefinition from the restDefinition.route() and later on adding the to(), now i'm forced to set to() on restDefinition?

Can you explain me why?

 

Thanks.

Best,

Rodrigo
rmc:1651708060:2022-05-05T07:47:40.603+0000:1651708060:2022-05-05T07:47:40.603+0000:Hi Claus,
{quote}I made a mistake when rest-dsl was created that you could embed a route inside it
{quote}
What a pitty this code was removed. We used this ""feature"" to easy create a {{rulebased forwarding/blocking route}} for rest calls, like:
{code:java}
restDefinition.route().streamCaching()
  .doTry()
    .choice()
    .when(ex -> securityCheckService
            .checkForwardingAllowed(ex.getIn().getHeader(""xyz"", String.class), ref))
      .log(LoggingLevel.INFO, ref, ""message id '${id}' forwarded to "" + toRoute)
      .to(""destination..."")
    .otherwise()
      .log(LoggingLevel.DEBUG, ref, ""Forwarding interrupted: ${body}"")
      ...
  .endDoTry()
  .doCatch(HttpOperationFailedException.class)
  ...
  .end(); {code}
This was quite convenient.
coelhro:1651708543:2022-05-05T07:55:43.855+0000:1651708543:2022-05-05T07:55:43.855+0000:Hello Remo, i agree with you, i had a chat with Claus yesterday, check it here:
[https://camel.zulipchat.com/#narrow/stream/257301-camel-spring-boot/topic/RestDefinition]

And the following issue here:
https://issues.apache.org/jira/browse/CAMEL-18057



 
rmc:1651721221:2022-05-05T11:27:01.700+0000:1651721221:2022-05-05T11:27:01.700+0000:Hi Rodrigo,

Great.

I would prefer not to be forced to duplicate my routes to the following:

{{rest --> direct (Route1) : direct --> rest (Route2) }}... 

As I understood this would be the ""workaround"" for this change.
coelhro:1651731107:2022-05-05T14:11:47.966+0000:1651731107:2022-05-05T14:11:47.966+0000:Thats exactly what we need to do, to keep up to dated with Camel.
jsiponen:1666653644:2022-10-25T07:20:44.181+0000:1666653644:2022-10-25T07:20:44.181+0000:The documentation for REST DSL led me to believe there was a way to embed routes in the code example here:

[https://camel.apache.org/manual/rest-dsl.html#_defining_a_custom_error_message_as_is]

Try as I might I was not able to get that to work but it seems that the documentation has to be fixed there as this capability does not exist anymore.
davsclaus:1666654479:2022-10-25T07:34:39.177+0000:1666654479:2022-10-25T07:34:39.177+0000:Thanks updating the docs
jsiponen:1666742768:2022-10-26T08:06:08.412+0000:1666742768:2022-10-26T08:06:08.412+0000:This section of the REST DSL documentation should be erased altogether because {{toD}} was also erased from {{{}RestDefinition{}}}:

https://camel.apache.org/manual/rest-dsl.html#_using_dynamic_to_in_rest_dsl
davsclaus:1666744758:2022-10-26T08:39:18.292+0000:1666744758:2022-10-26T08:39:18.292+0000:Thanks removing"
0,CAMEL-17674,Improvement,Major,None,3.19.0,"
None
",Resolved,Duplicate,3.19.0,Claus Ibsen,Claus Ibsen,0,1,2022-02-17 14:30:24+00:00,2022-09-05 05:39:51+00:00,This EIP is problematic to maintain and it had some complications in its model.,
0,CAMEL-17673,Improvement,Major,None,3.16.0,"
None
",Resolved,Fixed,3.16.0,Claus Ibsen,Claus Ibsen,1,2,2022-02-17 14:16:32+00:00,2022-11-07 08:19:33+00:00,Some cleanups that Karavan have help identify,"marat.gubaidullin@gmail.com:1645081721:2022-02-17T15:08:41.562+0000:1645087644:2022-02-17T16:47:24.674+0000:enableCORS, skipBindingOnErrorCode, clientRequestValidation,  apiDocs should have ""type"": ""boolean"", ""javaType"": ""java.lang.Boolean"" *DONE*
marat.gubaidullin@gmail.com:1645081798:2022-02-17T15:09:58.149+0000:1645156874:2022-02-18T12:01:14.805+0000: Idea: Rename uri parameter to path to make similar to rest definition *DONE*

marat.gubaidullin@gmail.com:1645081964:2022-02-17T15:12:44.990+0000:1645087652:2022-02-17T16:47:32.140+0000:List of values  for bindingMode *DONE*
marat.gubaidullin@gmail.com:1645082454:2022-02-17T15:20:54.481+0000:1645087665:2022-02-17T16:47:45.347+0000:https://issues.apache.org/jira/browse/CAMEL-17664 *DONE*
marat.gubaidullin@gmail.com:1645082674:2022-02-17T15:24:34.259+0000:1645082674:2022-02-17T15:24:34.259+0000:List of values of mediaTypes for consumes and produces properties
marat.gubaidullin@gmail.com:1645083216:2022-02-17T15:33:36.291+0000:1645083216:2022-02-17T15:33:36.291+0000:There is no metadata for some properties defined in camelYamlDsl.json. Should they be in REST DSL?

[https://github.com/apache/camel/blob/c4bf1b9ef521285dd3bc34cabf08022dc9600c5a/dsl/camel-yaml-dsl/camel-yaml-dsl/src/generated/resources/camelYamlDsl.json#L6540]

 
{code:java}
         ""param"" : {
            ""type"" : ""array"",
            ""items"" : {
              ""$ref"" : ""#/items/definitions/org.apache.camel.model.rest.RestOperationParamDefinition""
            }
          }
{code}

{code:java}
""responseMessage"" : {
            ""type"" : ""array"",
            ""items"" : {
              ""$ref"" : ""#/items/definitions/org.apache.camel.model.rest.RestOperationResponseMsgDefinition""
            }
          }
{code}

{code:java}
""security"" : {
            ""type"" : ""array"",
            ""items"" : {
              ""$ref"" : ""#/items/definitions/org.apache.camel.model.rest.SecurityDefinition""
            }
          }
{code}
davsclaus:1645087732:2022-02-17T16:48:52.910+0000:1645087732:2022-02-17T16:48:52.910+0000:> List of values of mediaTypes for consumes and produces properties

That can be a lot as you can define any kind of media-types you like, but the most common is maybe ""application/json"" / ""application/xml"" - but you can also have types that are kafka/avro based and so on.

We can maybe have a suggestion list with the common ones, that Karvan can show in a dropdown.
davsclaus:1645152609:2022-02-18T10:50:09.509+0000:1645583240:2022-02-23T10:27:20.436+0000:Sort the options so they are listed better in karavan *DONE*
marat.gubaidullin@gmail.com:1645513244:2022-02-22T15:00:44.043+0000:1645583147:2022-02-23T10:25:47.402+0000:in camelYamlDsl.json we have the following properties that are not in camel-catalog/model/*.json

*param*
*responseMessage*
*security*
*to*

I think we need to sync them.

And it would be nice to have '{*}to'{*} somewhere upper in property list (impact the place in Karavan UI) *DONE*
davsclaus:1645583226:2022-02-23T10:27:06.850+0000:1645583226:2022-02-23T10:27:06.850+0000:> param
> responseMessage
> security
> to

Can you take a look at latest code - I can see these files in the camel-core-model
https://github.com/apache/camel/tree/main/core/camel-core-model/src/generated/resources/org/apache/camel/model/rest

And `to` is a general to, so its in the parent folder

marat.gubaidullin@gmail.com:1645597799:2022-02-23T14:29:59.394+0000:1645597799:2022-02-23T14:29:59.394+0000:!Screen Shot 2022-02-23 at 9.27.40 AM.png!!Screen Shot 2022-02-23 at 9.28.10 AM.png!
marat.gubaidullin@gmail.com:1645801865:2022-02-25T23:11:05.557+0000:1645923141:2022-02-27T08:52:21.681+0000:In most cases model json file has name depends on definition name (without Definition suffix), ex:

RestDefinition -> rest.json

LogDefinition -> log.json

However Definitions starts with RestOperation*** and RestSecurity*** has different logic, ex:

RestOperationResponseMsgDefinition -> responseMessage.json

 

Could we sync them?

*DONE*"
0,CAMEL-17672,Improvement,Minor,3.15.0,3.16.0,"
None
",Resolved,Fixed,3.16.0,Claus Ibsen,James Netherton,0,1,2022-02-17 13:52:36+00:00,2022-02-20 10:02:49+00:00,"Something I noticed since Camel 3.15.0 is that Camel Main will always log a warning if camel-health is not present:


BaseMainSupport - Cannot find HealthCheckRegistry from classpath. Add camel-health to classpath.


AFAIK health is not mandatory. And I guess we only want to log a warning if some health config has been set but camel-health is not present.",
0,CAMEL-17671,New Feature,Major,None,4.x,"
None
",Open,Unresolved,4.x,Unassigned,Tom Cassimon,0,3,2022-02-17 13:46:41+00:00,2023-08-09 09:12:24+00:00,"I would like to see the feature of transactions in the azure servicebus when using queues.


The use case I would like to have is that when a message is processed in a route with an azure servicebus consumer and an error occurs during processing, that the message is not aknowledged to the azure servicebus broker, resulting in the message to re-appear on the queue and can be processed by the same or another listener instance on the queue.


If i scroll to the configuration in Azure of the service bus I see a max delivery count setting, so i presume the feature is possible in the service bus component but not used in the camel service bus component.


An simple example of a route that should not aknowledge the message on the ServiceBus component, and should lead to the message to re-appear on the queue for a redelivery attempt.




from(""azure-servicebus://<redacted>"")
    .autoStartup(true)
    .transacted()
    .throwException(new RuntimeException())
.end();","davsclaus:1645078012:2022-02-17T14:06:52.736+0000:1645078012:2022-02-17T14:06:52.736+0000:Tom, can you add that example from the chat with JMS that better explain what you wanted, about redelivery and dequeue the same message again from the broker if faiing.
TCke83:1645145330:2022-02-18T08:48:50.509+0000:1645145330:2022-02-18T08:48:50.509+0000:It looks like the component could support transactionality, while debugging the code and looking for the best solution I noticed if i kill my test jvm the message stays on the queue in azure. I took a brief look at the azure component code but didn't directly found a pointer of where the transactionality could or should be implemented.
vachillo:1647009819:2022-03-11T22:43:39.012+0000:1647009819:2022-03-11T22:43:39.012+0000:I'd also like to see this. Taking a look in the code a bit, it looks like the camel component is not properly calling the ""ServiceBusReceiverAsyncClient.abandon"" when there is an exception on the route. The ""complete"" method is always getting called, causing the client to remove the message from the queue in peek lock mode. 
davsclaus:1647042037:2022-03-12T07:40:37.100+0000:1647042037:2022-03-12T07:40:37.100+0000:Matt, you are welcome to work on a potential implementation of this. The consumer on completion currently only logs the exception. You can check if the exchange is transacted and then do the abandon instead.
vachillo:1647069317:2022-03-12T15:15:17.172+0000:1647070081:2022-03-12T15:28:01.635+0000:i had started to take a look at how to do it, it's been slow as I'm not that familiar with reactive programming. It's worth noting though, in the documentation it states that the default behavior is exactly what is expected here but not happening: [Azure ServiceBus :: Apache Camel|https://camel.apache.org/components/3.15.x/azure-servicebus-component.html#_component_option_disableAutoComplete]

""By default, a successfully processed message is \{completed}. If an error happens when the message is processed, it is \{abandoned}""
vachillo:1647329060:2022-03-15T15:24:20.362+0000:1647329060:2022-03-15T15:24:20.362+0000:looked some more into this, looks like its an issue with the azure library. [the autoComplete option is being deprecated|https://github.com/Azure/azure-sdk-for-java/issues/26084] so it looks like itll be up to the component to implement this complete/abandon pattern."
0,CAMEL-17668,Improvement,Major,None,3.16.0,"
None
",Resolved,Fixed,3.16.0,Claus Ibsen,Claus Ibsen,0,1,2022-02-17 08:17:11+00:00,2022-02-17 09:22:21+00:00,"The wiretap should be for tapping the message as-is, and not to create new messages. 


Otherwise the onPrepare processor can be used to customize a new message with copy option enabled.",
0,CAMEL-17667,Task,Major,None,3.16.0,"
None
",Resolved,Fixed,3.16.0,Unassigned,Claus Ibsen,0,1,2022-02-17 08:11:23+00:00,2022-09-14 13:21:22+00:00,"We have many HTTP components already, and we should not have so many to maintain. camel-ahc is not a good component.


Use camel-http or camel-vertx-http instead.


We should also deprecate camel-ahc-ws",
0,CAMEL-17666,Task,Major,3.16.0,3.16.0,"
None
",Resolved,Fixed,3.16.0,Claus Ibsen,Claus Ibsen,0,1,2022-02-17 06:34:02+00:00,2022-02-18 14:08:49+00:00,"— a/components-starter/camel-activemq-starter/src/main/java/org/apache/camel/component/activemq/springboot/ActiveMQComponentConfiguration.java
+++ b/components-starter/camel-activemq-starter/src/main/java/org/apache/camel/component/activemq/springboot/ActiveMQComponentConfiguration.java
@@ -13,8 +13,7 @@



WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.




*/
-package org.apache.camel.component.activemq.springboot;
+ */package org.apache.camel.component.activemq.springboot;","davsclaus:1645050874:2022-02-17T06:34:34.468+0000:1645050874:2022-02-17T06:34:34.468+0000:It seems a new line is missing so the end of the license header does not have a new line before package
davsclaus:1645050896:2022-02-17T06:34:56.236+0000:1645050896:2022-02-17T06:34:56.236+0000:So when you build camel-spring-boot then you have 1000+ changed files.
davsclaus:1645050929:2022-02-17T06:35:29.709+0000:1645050929:2022-02-17T06:35:29.709+0000:Also this test seems to be affected
https://ci-builds.apache.org/job/Camel/job/Apache%20Camel/job/main/lastCompletedBuild/testReport/org.apache.camel.tooling.util/PackageHelperTest/testFileToString/"
0,CAMEL-17665,Task,Minor,3.16.0,3.16.0,"
None
",Resolved,Fixed,3.16.0,Claus Ibsen,Claus Ibsen,0,1,2022-02-17 06:08:08+00:00,2022-02-20 09:36:56+00:00,"[INFO] — camel-package-maven-plugin:3.16.0-SNAPSHOT:generate (generate) @ camel-any23 —
[INFO] Stale files detected, re-generating.
[INFO] Stale files detected, re-generating index.
[INFO] Building index...
[INFO] Generated dataformat.properties containing 1 Camel dataformat: any23
[INFO] Validation complete
[WARNING] No dataformat doc file: /Users/davsclaus/workspace/camel/components/camel-any23/src/main/docs/any23-dataformat.adoc","davsclaus:1645049305:2022-02-17T06:08:25.475+0000:1645049305:2022-02-17T06:08:25.475+0000:All the WARN about missing docs are almost false, most of the files are there."
0,CAMEL-17664,Improvement,Major,3.15.0,None,"
None
",Resolved,Fixed,3.16.0,Claus Ibsen,Marat Gubaidullin,0,1,2022-02-17 01:21:38+00:00,2022-02-17 14:08:26+00:00,"Could we align models json filenames in camel-catalog for REST DSL same way as EIP DSL?
ex. in EIP we have




definition name without word 'Definition'




WireTapDefinition -> wireTap.json
ChoiceDefinition -> choice.json
RestDefinition -> rest.json


however for REST DSL we have




definition name without word 'VerbDefinition'




PostVerbDefinition -> post.json
GetVerbDefinition -> get.json
HeadVerbDefinition -> head.json
DeleteVerbDefinition -> delete.json
PatchVerbDefinition -> patch.json",
0,CAMEL-17663,New Feature,Major,None,3.16.0,"
None
",Resolved,Not A Problem,3.16.0,Unassigned,Claus Ibsen,0,2,2022-02-16 20:11:03+00:00,2022-02-21 11:33:08+00:00,It would be good to have this implemented so we can use the excellent vert.x as rest producer also,"klease78:1645411306:2022-02-21T10:41:46.697+0000:1645411306:2022-02-21T10:41:46.697+0000:[~davsclaus] VertxHttpComponent already implements RestProducerFactory. Do you mean to make it also usable as a RestConsumer?
davsclaus:1645414383:2022-02-21T11:33:03.025+0000:1645414383:2022-02-21T11:33:03.025+0000:Argh yeah it does my bad"
0,CAMEL-17662,Improvement,Major,3.15.0,3.16.0,"
None
",Resolved,Fixed,3.16.0,Claus Ibsen,Marat Gubaidullin,0,2,2022-02-16 19:46:23+00:00,2022-02-16 20:32:05+00:00,"Running following yaml 




apiVersion: camel.apache.org/v1
kind: Integration
metadata:
  name: rest-dsl-example.yaml
spec:
  flows:
    - rest:
        get:
          - uri: ""/foo""
            to: ""direct:foo""
    - from:
        uri: 'direct:foo'
        steps:
          - log: '${body}'




with command 




jbang -Dcamel.jbang.version=3.15.0 camel@apache/camel run rest-dsl-example.yaml




have following error




2022-02-16 14:43:28.860  INFO 18536 --- [           main] e.camel.impl.engine.AbstractCamelContext : Detected: camel-debug JAR (enabling Camel Debugging)
2022-02-16 14:43:28.982  INFO 18536 --- [           main] org.apache.camel.main.BaseMainSupport    : Auto-configuration summary
2022-02-16 14:43:28.982  INFO 18536 --- [           main] org.apache.camel.main.BaseMainSupport    :     camel.main.name=CamelJBang
2022-02-16 14:43:28.982  INFO 18536 --- [           main] org.apache.camel.main.BaseMainSupport    :     camel.main.shutdownTimeout=5
2022-02-16 14:43:28.982  INFO 18536 --- [           main] org.apache.camel.main.BaseMainSupport    :     camel.main.routesReloadEnabled=false
2022-02-16 14:43:28.982  INFO 18536 --- [           main] org.apache.camel.main.BaseMainSupport    :     camel.main.sourceLocationEnabled=true
2022-02-16 14:43:28.983  INFO 18536 --- [           main] org.apache.camel.main.BaseMainSupport    :     camel.main.tracing=false
2022-02-16 14:43:28.983  INFO 18536 --- [           main] org.apache.camel.main.BaseMainSupport    :     camel.main.routesIncludePattern=file:rest-dsl-example.yaml
2022-02-16 14:43:28.983  INFO 18536 --- [           main] org.apache.camel.main.BaseMainSupport    :     camel.component.kamelet.location=classpath:/kamelets,github:apache:camel-kamelets/kamelets
2022-02-16 14:43:29.074  INFO 18536 --- [           main] e.camel.management.JmxManagementStrategy : JMX is enabled
2022-02-16 14:43:29.795  INFO 18536 --- [           main] org.apache.camel.main.DownloaderHelper   : Downloaded dependency: org.apache.camel:camel-coap:3.15.0 took: 626ms
Exception in thread ""main"" java.lang.NoClassDefFoundError: org/eclipse/californium/elements/Connector
        at java.base/java.lang.Class.getDeclaredConstructors0(Native Method)
        at java.base/java.lang.Class.privateGetDeclaredConstructors(Class.java:3137)
        at java.base/java.lang.Class.getConstructor0(Class.java:3342)
        at java.base/java.lang.Class.getDeclaredConstructor(Class.java:2553)
        at org.apache.camel.support.ObjectHelper.newInstance(ObjectHelper.java:393)
        at org.apache.camel.impl.engine.DefaultInjector.newInstance(DefaultInjector.java:65)
        at org.apache.camel.impl.engine.DefaultComponentResolver.resolveComponent(DefaultComponentResolver.java:66)
        at org.apache.camel.main.DependencyDownloaderComponentResolver.resolveComponent(DependencyDownloaderComponentResolver.java:56)
        at org.apache.camel.impl.engine.AbstractCamelContext.initComponent(AbstractCamelContext.java:692)
        at org.apache.camel.impl.engine.AbstractCamelContext$3.apply(AbstractCamelContext.java:620)
        at org.apache.camel.impl.engine.AbstractCamelContext$3.apply(AbstractCamelContext.java:616)
        at java.base/java.util.concurrent.ConcurrentHashMap.computeIfAbsent(ConcurrentHashMap.java:1705)
        at org.apache.camel.impl.engine.AbstractCamelContext.getComponent(AbstractCamelContext.java:616)
        at org.apache.camel.impl.engine.AbstractCamelContext.getComponent(AbstractCamelContext.java:596)
        at org.apache.camel.component.rest.RestEndpoint.createConsumer(RestEndpoint.java:515)
        at org.apache.camel.impl.engine.DefaultRoute.gatherRootServices(DefaultRoute.java:620)
        at org.apache.camel.impl.engine.DefaultRoute.gatherServices(DefaultRoute.java:604)
        at org.apache.camel.impl.engine.DefaultRoute.initializeServices(DefaultRoute.java:189)
        at org.apache.camel.impl.engine.RouteService.doSetup(RouteService.java:151)
        at org.apache.camel.impl.engine.RouteService.setUp(RouteService.java:130)
        at org.apache.camel.impl.engine.InternalRouteStartupManager.doInitRoutes(InternalRouteStartupManager.java:92)
        at org.apache.camel.impl.engine.AbstractCamelContext.doInit(AbstractCamelContext.java:2903)
        at org.apache.camel.support.service.BaseService.init(BaseService.java:83)
        at org.apache.camel.impl.engine.AbstractCamelContext.init(AbstractCamelContext.java:2585)
        at org.apache.camel.support.service.BaseService.start(BaseService.java:111)
        at org.apache.camel.impl.engine.AbstractCamelContext.start(AbstractCamelContext.java:2604)
        at org.apache.camel.impl.DefaultCamelContext.start(DefaultCamelContext.java:247)
        at org.apache.camel.main.KameletMain.doStart(KameletMain.java:129)
        at org.apache.camel.support.service.BaseService.start(BaseService.java:119)
        at org.apache.camel.dsl.jbang.core.commands.Run.run(Run.java:308)
        at org.apache.camel.dsl.jbang.core.commands.Run.call(Run.java:120)
        at org.apache.camel.dsl.jbang.core.commands.Run.call(Run.java:46)
        at picocli.CommandLine.executeUserObject(CommandLine.java:1953)
        at picocli.CommandLine.access$1300(CommandLine.java:145)
        at picocli.CommandLine$RunLast.executeUserObjectOfLastSubcommandWithSameParent(CommandLine.java:2358)
        at picocli.CommandLine$RunLast.handle(CommandLine.java:2352)
        at picocli.CommandLine$RunLast.handle(CommandLine.java:2314)
        at picocli.CommandLine$AbstractParseResultHandler.execute(CommandLine.java:2179)
        at picocli.CommandLine$RunLast.execute(CommandLine.java:2316)
        at picocli.CommandLine.execute(CommandLine.java:2078)
        at org.apache.camel.dsl.jbang.core.commands.CamelJBangMain.run(CamelJBangMain.java:43)
        at main.CamelJBang.main(CamelJBang.java:37)
Caused by: java.lang.ClassNotFoundException: org.eclipse.californium.elements.Connector
        at java.base/java.net.URLClassLoader.findClass(URLClassLoader.java:471)
        at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:589)
        at groovy.lang.GroovyClassLoader.loadClass(GroovyClassLoader.java:869)
        at groovy.lang.GroovyClassLoader.loadClass(GroovyClassLoader.java:979)
        at groovy.lang.GroovyClassLoader.loadClass(GroovyClassLoader.java:967)
        ... 42 more




Assuming camel-jbang provides default REST DSL implementation","davsclaus:1645012789:2022-02-16T19:59:49.522+0000:1645012789:2022-02-16T19:59:49.522+0000:Yeah that is a bit odd that camel-coap is downloaded - it should use platform-http that can do the rest-dsl out of the box
davsclaus:1645012998:2022-02-16T20:03:18.334+0000:1645012998:2022-02-16T20:03:18.334+0000:Yeah same error with 3.16
davsclaus:1645013244:2022-02-16T20:07:24.516+0000:1645013244:2022-02-16T20:07:24.516+0000:Okay so its camel-rest that has a default order and then try to discover and it does this a..z so coap comes first.
davsclaus:1645013963:2022-02-16T20:19:23.673+0000:1645013963:2022-02-16T20:19:23.673+0000:To run with 3.15 you can specify this on the CLI

 -Dcamel.component.rest.consumerComponentName=platform-http


jbang run  -Dcamel.component.rest.consumerComponentName=platform-http camel@apache/camel run rest-dsl-example.yaml
davsclaus:1645014725:2022-02-16T20:32:05.575+0000:1645014725:2022-02-16T20:32:05.575+0000:Okay fixes so camel-jbang will automatic select the correct rest-dsl components to use - the example works now"
0,CAMEL-17661,Test,Major,None,3.16.0,"
None
",Resolved,Fixed,3.16.0,Freeman Yue Fang,Freeman Yue Fang,0,1,2022-02-16 19:44:32+00:00,2022-02-17 12:35:07+00:00,"The goal is to port the tests from camel-avro to camel-avro-starter, to ensure they aslo work in spring-boot runtime.


For those Spring XML DSL based testcase from camel-avro, also migrate to routes.xml which is supported by camel-spring-boot, so that users scenario can also work with spring-boot runtime with minimum modification",ffang:1645016033:2022-02-16T20:53:53.653+0000:1645016033:2022-02-16T20:53:53.653+0000:PR is [here|https://github.com/apache/camel-spring-boot/pull/436]
0,CAMEL-17660,Improvement,Major,None,3.16.0,"
None
",Resolved,Fixed,3.16.0,Claus Ibsen,Claus Ibsen,0,1,2022-02-16 14:32:53+00:00,2022-02-16 14:42:04+00:00,Reported on user mailing list to be able to control whether a redelivery should be executed or not via the custom on redelivery processor.,
0,CAMEL-17659,Improvement,Major,None,3.x,"
None
",Resolved,Abandoned,3.x,Unassigned,Claus Ibsen,0,1,2022-02-16 13:24:21+00:00,2023-05-26 19:20:49+00:00,"This API is org.apache.camel.spi.InterceptStrategy an old api that is intended for Camel internally to be used, and it reveals some of the internals with definition / async processor and whatnot.


Only the intercept eip is using it, but we should make it use its own way instead and deprecate org.apache.camel.spi.InterceptStrategy


We do not want Camel end users to use this interface.",
0,CAMEL-17658,Bug,Major,"3.14.0, 3.15.0","3.14.2, 3.16.0","
None
",Resolved,Fixed,"3.14.2, 3.16.0",Jiri Ondrusek,Jiri Ondrusek,0,2,2022-02-16 12:35:50+00:00,2022-02-18 08:52:07+00:00,"If you add property `additionalProperties.database.connectionTimeZone=CET` into debezium component, it will apply only `&additionalProperties.database=CET`","jondruse:1644989028:2022-02-16T13:23:48.533+0000:1644989028:2022-02-16T13:23:48.533+0000:I probably missed some other aspect of the problem, JUnit test confirms, that problem is not happening.
jondruse:1644990361:2022-02-16T13:46:01.532+0000:1644990361:2022-02-16T13:46:01.532+0000:I'm reopening this issue, problem could be simulated via JUnit test (but it has to be test in a specialized debezium component - i.e. mysql)
jondruse:1644995039:2022-02-16T15:03:59.775+0000:1644995039:2022-02-16T15:03:59.775+0000:Issue was originally reported fr camel-quarkus as https://github.com/apache/camel-quarkus/issues/3488
davsclaus:1645145437:2022-02-18T08:50:37.267+0000:1645145437:2022-02-18T08:50:37.267+0000:Thanks for reporting and the PR. I found out to add an unit test in camel-core that reproduced this, and polished the fix a bit. I also backported to 3.14.x LTS branch"
0,CAMEL-17657,Wish,Blocker,3.14.1,,"

performance

",Resolved,Invalid,None,Unassigned,郝志北,0,1,2022-02-16 11:36:13+00:00,2022-02-16 13:21:05+00:00,"Hi, everyone, i've been used camel in my application for half an year, and i found that camel seems not to support non-blocking asynchronous process, what i mean is, in the process, every node was called and executed in asynchronous and non-blocking way, so that i can gain the benefits of low thread usage. So i tried to use AsyncProcessor to write my process logic code, but i found in the source code that camel use CountdownLatch to achieve asynchronous invoke, in which the caller thread still need to wait until the callee was finished.
I also search in the net such as google or stackoverflow, but found useless note and document , so is camel supports a way to implement asynchronous and non blocking processes? Look forward to and thank you for your enthusiastic answers!",
0,CAMEL-17656,Improvement,Major,None,3.16.0,"
None
",Resolved,Fixed,3.16.0,Claus Ibsen,Claus Ibsen,0,1,2022-02-16 11:09:57+00:00,2022-02-16 11:12:33+00:00,"When you run Camel standalone via main or jbang then we cannot so well see the start/stop log that happens before CamelContext itself is started.


We should add its own start/stop logging so you can better see this.


This also make it easy to see the version on startup and it failed before camel context is started.",
0,CAMEL-17655,Bug,Minor,3.14.1,"3.14.2, 3.16.0","
None
",Resolved,Fixed,"3.14.2, 3.16.0",Unassigned,Grigory Solovyov,0,2,2022-02-16 10:53:52+00:00,2022-02-16 13:20:40+00:00,"Hello! I am trying to use openTracing with kafka component. And find some strange behaviour when route have onCompletion definition. 


Pretty simple code example:




from(""kafka:someTopic"")
        .onCompletion()
            .process(exchange -> {
               // some code
            })
        .end()
.to(""log:"" + logger.getName() + ""?{{logging-params.error}}""); 



Another one:




from(""timer://foo?repeatCount=1"")
        .onCompletion()
            .process(exchange -> {                 
               // some code
             })
        .end()
.to(""log:"" + logger.getName() + ""?{{logging-params.error}}""); 



Stacktrace for example:




java.lang.NullPointerException: null
    at org.apache.camel.opentracing.TagProcessor.process(TagProcessor.java:55)
    at org.apache.camel.processor.errorhandler.RedeliveryErrorHandler$SimpleTask.run(RedeliveryErrorHandler.java:471)
    at org.apache.camel.impl.engine.DefaultReactiveExecutor$Worker.executeFromQueue(DefaultReactiveExecutor.java:218)
    at org.apache.camel.impl.engine.DefaultReactiveExecutor.executeFromQueue(DefaultReactiveExecutor.java:82)
    at org.apache.camel.impl.engine.DefaultAsyncProcessorAwaitManager.await(DefaultAsyncProcessorAwaitManager.java:96)
    at org.apache.camel.impl.engine.DefaultAsyncProcessorAwaitManager.process(DefaultAsyncProcessorAwaitManager.java:85)
    at org.apache.camel.support.AsyncProcessorSupport.process(AsyncProcessorSupport.java:41)
    at org.apache.camel.processor.OnCompletionProcessor.doProcess(OnCompletionProcessor.java:189)
    at org.apache.camel.processor.OnCompletionProcessor$OnCompletionSynchronizationAfterConsumer.onComplete(OnCompletionProcessor.java:318)
    at org.apache.camel.support.UnitOfWorkHelper.doneSynchronization(UnitOfWorkHelper.java:104)
    at org.apache.camel.support.UnitOfWorkHelper.doneSynchronizations(UnitOfWorkHelper.java:93)
    at org.apache.camel.impl.engine.DefaultUnitOfWork.done(DefaultUnitOfWork.java:238)
    at org.apache.camel.support.UnitOfWorkHelper.doneUow(UnitOfWorkHelper.java:61)
    at org.apache.camel.impl.engine.CamelInternalProcessor$UnitOfWorkProcessorAdvice.after(CamelInternalProcessor.java:777)
    at org.apache.camel.impl.engine.CamelInternalProcessor$UnitOfWorkProcessorAdvice.after(CamelInternalProcessor.java:712)
    at org.apache.camel.impl.engine.CamelInternalProcessor$AsyncAfterTask.done(CamelInternalProcessor.java:263)
    at org.apache.camel.AsyncCallback.run(AsyncCallback.java:44)
    at org.apache.camel.impl.engine.DefaultReactiveExecutor$Worker.schedule(DefaultReactiveExecutor.java:187)
    at org.apache.camel.impl.engine.DefaultReactiveExecutor.scheduleMain(DefaultReactiveExecutor.java:64)
    at org.apache.camel.processor.Pipeline.process(Pipeline.java:184)
    at org.apache.camel.impl.engine.CamelInternalProcessor.process(CamelInternalProcessor.java:398)
    at org.apache.camel.impl.engine.DefaultAsyncProcessorAwaitManager.process(DefaultAsyncProcessorAwaitManager.java:83)
    at org.apache.camel.support.AsyncProcessorSupport.process(AsyncProcessorSupport.java:41)
    at org.apache.camel.component.kafka.consumer.support.KafkaRecordProcessor.processExchange(KafkaRecordProcessor.java:152)
    at org.apache.camel.component.kafka.KafkaFetchRecords.processRecord(KafkaFetchRecords.java:409)
    at org.apache.camel.component.kafka.KafkaFetchRecords.processPolledRecords(KafkaFetchRecords.java:361)
    at org.apache.camel.component.kafka.KafkaFetchRecords.startPolling(KafkaFetchRecords.java:182)
    at org.apache.camel.component.kafka.KafkaFetchRecords.run(KafkaFetchRecords.java:101)
    at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)
    at java.util.concurrent.FutureTask.run(FutureTask.java:266)
    at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)
    at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)
    at java.lang.Thread.run(Thread.java:745)



without using onCompletion definition everything is OK.","davsclaus:1644988836:2022-02-16T13:20:36.531+0000:1644988836:2022-02-16T13:20:36.531+0000:camel-opentracing is deprecated, you should considering using camel-opentelemtry"
0,CAMEL-17623,Task,Major,None,None,"
None
",Resolved,Fixed,3.16.0,Otavio Rodolfo Piske,Otavio Rodolfo Piske,0,1,2022-02-09 08:38:03+00:00,2022-02-10 17:53:33+00:00,This is a task to deprecate the camel-testcontainers-spring component.,
0,CAMEL-17622,Task,Major,None,None,"
None
",Resolved,Fixed,3.16.0,Otavio Rodolfo Piske,Otavio Rodolfo Piske,0,1,2022-02-09 08:37:18+00:00,2022-02-10 17:53:47+00:00,This is a task to deprecate the camel-testcontainers-junit5 component.,
0,CAMEL-17621,Task,Major,None,None,"
None
",Resolved,Fixed,3.16.0,Otavio Rodolfo Piske,Otavio Rodolfo Piske,0,2,2022-02-09 08:35:46+00:00,2022-03-02 18:54:45+00:00,This is a task to deprecate the camel-testcontainers component.,"orpiske:1645435157:2022-02-21T17:19:17.280+0000:1645435157:2022-02-21T17:19:17.280+0000:There's still references to camel-testcontainers in other components that must be cleaned up.
davsclaus:1646213304:2022-03-02T17:28:24.966+0000:1646213322:2022-03-02T17:28:42.623+0000:Is there more work on this? Ah yeah that linked ticket
orpiske:1646218015:2022-03-02T18:46:55.275+0000:1646218015:2022-03-02T18:46:55.275+0000:Ahh, let me double check this [~davsclaus]. Maybe it's done already.
orpiske:1646218485:2022-03-02T18:54:45.175+0000:1646218485:2022-03-02T18:54:45.175+0000:All tasks have been completed, therefore marking as resolved."
0,CAMEL-17620,Task,Major,3.15.0,3.x,"
None
",Resolved,Information Provided,3.x,Unassigned,Tadayoshi Sato,0,2,2022-02-09 04:53:07+00:00,2023-08-09 09:13:19+00:00,"I sometimes see users complaining that it is not clear about what data type they can expect from an endpoint for further processing in the route.


The endpoint parameters are well documented already but the data type each endpoint should return is rarely documented, for example:
https://camel.apache.org/components/3.15.x/twitter-search-component.html


It would be great if we can find some way to automate the documentation of the data type an endpoint returns, or at least document them manually.","davsclaus:1644357800:2022-02-09T06:03:20.661+0000:1644357800:2022-02-09T06:03:20.661+0000:Its more important to document the kamelets, they are the higher level building blocks.
tadayosi:1644358430:2022-02-09T06:13:50.096+0000:1644358430:2022-02-09T06:13:50.096+0000:Yes, agreed. We should start from Kamelets docs."
0,CAMEL-17619,Task,Minor,None,None,"
None
",Resolved,Fixed,3.16.0,Peter Palaga,Peter Palaga,0,1,2022-02-08 17:23:05+00:00,2022-02-09 11:31:04+00:00,"There is no trace of org.json.simple in the Slack component anymore.
It used to be utilized for json parsing in the past. Here the last occurrence was removed: https://github.com/apache/camel/commit/cfd9ea1e726151922e0c5f93c2b42128cb0c59d2#diff-ade5607d95deef18f4077538b733120e3e1c038c211c4ead4fe720f37acec322",
0,CAMEL-17618,Bug,Minor,3.15.0,"3.11.6, 3.14.2, 3.16.0","
None
",Resolved,Fixed,"3.11.6, 3.14.2, 3.16.0",Freeman Yue Fang,Freeman Yue Fang,0,2,2022-02-08 17:21:06+00:00,2022-02-14 02:27:04+00:00,"Currently camel-ref endpoint always adds the underlying endpoint like
getCamelContext().addEndpoint(getEndpoint().getEndpointUri(), endpoint);
We should check if it exists or not firstly like
        if (getCamelContext().getEndpoint(getEndpoint().getEndpointUri()) == null) 

{
               getCamelContext().addEndpoint(getEndpoint().getEndpointUri(), endpoint);
       }


Because if we re-add the same endpoint, this endpoint actually will be stopped","ffang:1644566713:2022-02-11T16:05:13.458+0000:1644566713:2022-02-11T16:05:13.458+0000:The previous fix cause a camel-cxf test failure
https://github.com/apache/camel/commit/d098225b259d3ff52990f9c68251aab0e013b960
ffang:1644567022:2022-02-11T16:10:22.273+0000:1644567022:2022-02-11T16:10:22.273+0000:The previous check
getCamelContext().getEndpoint(getEndpoint().getEndpointUri())
may return an unexpected endpoint based on the getEndpoint().getEndpointUri() protocol scheme.For the CxfEndpoint, it starts with ""http://"",so getCamelContext().getEndpoint(getEndpoint().getEndpointUri()) will automatically return a HttpEndpoint first, we need to revise the fix a bit like
{code}
    if (endpoint == null) {
             // endpoint is mandatory
             endpoint = CamelContextHelper.mandatoryLookup(getCamelContext(), name, Endpoint.class);
-            if (getCamelContext().getEndpoint(getEndpoint().getEndpointUri()) == null) {
+            if (getCamelContext().getEndpoint(getEndpoint().getEndpointUri()) == null
+                    || getCamelContext().getEndpoint(getEndpoint().getEndpointUri()) != endpoint) {
                 getCamelContext().addEndpoint(getEndpoint().getEndpointUri(), endpoint);
             }
         }
{code}
to add the expected endpoint referred by the RefEndpoint.

Will send another PR soon

davsclaus:1644621715:2022-02-12T07:21:55.154+0000:1644621715:2022-02-12T07:21:55.154+0000:Backported the next fix to older branches"
0,CAMEL-17617,Improvement,Minor,3.15.0,3.16.0,"
None
",Resolved,Fixed,3.16.0,Claus Ibsen,Aurélien Pupier,0,2,2022-02-08 13:26:24+00:00,2022-02-10 11:59:22+00:00,"jbang is using the defautl jvm that it finds. it can result to this kind of error:



jbang -Dcamel.jbang.version=3.15.0 camel@apache/camel run test.yaml --max-messages=10 --logging-level=info --reload
[jcordes@jcordes ~]$ jbang -Dcamel.jbang.version=3.15.0 camel@apache/camel run test.yaml --max-messages=10 --logging-level=info --reload
[jbang] Building jar...
/home/jcordes/.jbang/cache/urls/f20491f9ebc0e16d2fca028eb3d4f03aafdf8cd62b8af1a9d1730bfe382d8165/CamelJBang.java:28: error: cannot access CamelJBangMain
import org.apache.camel.dsl.jbang.core.commands.CamelJBangMain;
                                               ^
  bad class file: /home/jcordes/.m2/repository/org/apache/camel/camel-jbang-core/3.15.0/camel-jbang-core-3.15.0.jar(org/apache/camel/dsl/jbang/core/commands/CamelJBangMain.class)
    class file has wrong version 55.0, should be 52.0
    Please remove or make sure it appears in the correct subdirectory of the classpath.
[jbang] [ERROR] Error during compile
[jbang] Run with --verbose for more details




the minimal java version can be specified https://www.jbang.dev/documentation/guide/latest/javaversions.html#managing-jdks","davsclaus:1644403618:2022-02-09T18:46:58.838+0000:1644403618:2022-02-09T18:46:58.838+0000:Camel requires Java 11.

Do you think that you can say something in jbang in the top of the script file that Java >= 11 or something so jbang can validate or fail if not having correct java version
apupier:1644450467:2022-02-10T07:47:47.912+0000:1644450496:2022-02-10T07:48:16.284+0000:yes, it is in the link https://www.jbang.dev/documentation/guide/latest/javaversions.html#managing-jdks

something like _// JAVA 11+_"
0,CAMEL-17616,Improvement,Minor,3.11.2,"3.11.6, 3.14.2, 3.16.0","
None
",Resolved,Fixed,"3.11.6, 3.14.2, 3.16.0",Unassigned,Benjamin BONNET,0,2,2022-02-08 09:13:08+00:00,2022-02-09 12:15:37+00:00,"Hi,


We are using a JdbcAggregationRepository with a transactional Datasource. When JdbcAggregationRepository is started, if its table contains lots of rows, a transaction timeout may occur and make it fail to start.


Actually, when repo starts, doStart method is invoked, that method calls getKeys() and iterates over every row in order to count them, which may be quite long if repo contains millions of rows. 


In order to avoid that issue, count could be implemented directly in the SQL query.","davsclaus:1644284907:2022-02-08T09:48:27.220+0000:1644284907:2022-02-08T09:48:27.220+0000:You are welcome to send a PR to count the keys in a faster way
davsclaus:1644380137:2022-02-09T12:15:37.159+0000:1644380137:2022-02-09T12:15:37.159+0000:Thanks for reporting and the PR"
0,CAMEL-17615,Improvement,Minor,"3.11.5, 3.14.0",3.17.0,"
None
",Resolved,Fixed,3.17.0,Otavio Rodolfo Piske,Otavio Rodolfo Piske,0,2,2022-02-08 08:12:52+00:00,2022-04-06 13:56:25+00:00,"There are several warnings about unrecognized configurations when the Kafka client starts. We should clean them up. 


For example:


 




2022-01-17 06:37:49.634 WARN 28548 --- [r-transactions]] o.a.k.clients.consumer.ConsumerConfig : The configuration 'specific.avro.reader' was supplied but isn't a known config.
2022-01-17 06:37:49.634 WARN 28548 --- [r-transactions]] o.a.k.clients.consumer.ConsumerConfig : The configuration 'specific.avro.reader' was supplied but isn't a known config.
2022-01-17 06:37:49.635 WARN 28548 --- [r-transactions]] o.a.k.clients.consumer.ConsumerConfig : The configuration 'sasl.kerberos.principal.to.local.rules' was supplied but isn't a known config.
2022-01-17 06:37:49.635 WARN 28548 --- [r-transactions]] o.a.k.clients.consumer.ConsumerConfig : The configuration 'sasl.kerberos.principal.to.local.rules' was supplied but isn't a known config.","davsclaus:1644286177:2022-02-08T10:09:37.184+0000:1644286177:2022-02-08T10:09:37.184+0000:Dont we use a maven plugin that generates the kafka configuration options, or was this only done for the vert-kafka component?
orpiske:1644287654:2022-02-08T10:34:14.068+0000:1644287654:2022-02-08T10:34:14.068+0000:For Camel Kafka no, we have in the code: [https://github.com/apache/camel/blob/main/components/camel-kafka/src/main/java/org/apache/camel/component/kafka/KafkaConfiguration.java#L360-L488.] 

I think the auto-generated might be for vertx-kafka (but I haven't checked).
orpiske:1644370732:2022-02-09T09:38:52.623+0000:1644370732:2022-02-09T09:38:52.623+0000:[~davsclaus] one thing that occurred to me is that some of these settings may only be application under specific scenarios (ie.: specific avro reader is only application in confluent platform, kerberos is only when using kerberos, etc). 

I am wondering if: 
 # We would prefer to remove them and instruct users to use the `additionalProperties` option to set them up (or use a custom client factory)
 # Try to be ""smart"" and figure out automatically when each setting is applicable or not.

 

IMHO, I'd go with option 1 and I'd let users handle the specific scenarios they have. However, this would mean a larger change of the users because to make it right, we would create a basic client and for everything else, we would let users setup their own clients.

 

Any thoughts or preferences about this?
davsclaus:1644380892:2022-02-09T12:28:12.584+0000:1644380892:2022-02-09T12:28:12.584+0000:Why are these options supplied, the code seems that they are only set if the value is != null. 
orpiske:1644381039:2022-02-09T12:30:39.832+0000:1644381039:2022-02-09T12:30:39.832+0000:I haven't dig much into this, but I suspect they are used to change the (internal) behavior of the Kafka's own Consumer instance.
davsclaus:1644383124:2022-02-09T13:05:24.353+0000:1644383124:2022-02-09T13:05:24.353+0000:Yeah it seems its a bit weird we see so many WARNs when running the tests of camel-kafka.
Some tests may set special options but lets dig in and see why they are set and the WARNs are printed.

Kafka API comes with these config classes that has the known options and we are using those so ideally we should not see WARNs.
However one strange thing was one of the SALS options was using a broker config class - but that class javadoc says its a common for client too.
orpiske:1646709492:2022-03-08T11:18:12.435+0000:1646709492:2022-03-08T11:18:12.435+0000:Oh, I need to look at this. I forgot to look at it in time for 3.16.
orpiske:1647930692:2022-03-22T14:31:32.850+0000:1647930692:2022-03-22T14:31:32.850+0000:I am going to look at this during this week. I'm hoping we can have a really clean Kafka client for our next LTS.
orpiske:1648016669:2022-03-23T14:24:29.269+0000:1648016669:2022-03-23T14:24:29.269+0000:This seems to be a known problem in Kafka:
 *  https://issues.apache.org/jira/browse/KAFKA-6793
 * https://issues.apache.org/jira/browse/KAFKA-7509
 * [https://github.com/apache/kafka/pull/5876]

From my understanding of these issues, it's not that the config is unknown, but that it is unused. The log message is probably misleading.

 

For now, I think we are fine with just testing if the value is not empty before setting it in the properties.
orpiske:1648087291:2022-03-24T10:01:31.312+0000:1648087291:2022-03-24T10:01:31.312+0000:Fixed with the linked PR."
0,CAMEL-17614,Task,Major,None,3.16.0,"
None
",Resolved,Fixed,3.16.0,Freeman Yue Fang,Freeman Yue Fang,0,1,2022-02-07 20:28:00+00:00,2022-02-09 12:44:36+00:00,"currently the camel-spring-boot infinispan exmaple requires a separate running Infinispan server. 
I think it's better to be able to run this example OOTB, like start a docker Infinispan server image and create the ""default"" cacheName if required(since the default cache doesn't exist in latest Infinispan server )",
0,CAMEL-17613,Bug,Major,3.11.2,3.17.0,"
None
",Resolved,Fixed,3.17.0,Karen Lease,Benjamin BONNET,0,3,2022-02-07 16:23:52+00:00,2022-04-26 07:52:12+00:00,"Hi,


using aggregate with a JdbcAggregationRepository, we are encountering a race condition that may leave a completed exchange in completed table even after that completed exchange has been sent. Unfortunately, that leads to duplicates since recovery task will eventually try and recover it.


Normally, when the exchange completes, it is deleted from repo exchange table and inserted into repo completed exchange table. Then exchange is sent and deleted from repo completed exchange table.


But, due to the fact those two actions are run by different threads (and in different transactions) that order may vary.


 


Here is a normal sequence : 


AggregateProcessor.doProcess
  doAggregation
    doAggregationComplete
      onCompletion
        JdbcAggregationRepository.remove : => INSERT ... INTO _completed  
  onSubmitCompletion  
    AggregateOnCompletion.onComplete   (via executorService)
      JdbcAggregationRepository.confirm  : => DELETE FROM _completed


With the use of executorService, confirm is run by another thread and may commit before remove commits. Eventually, when that occurs, one can check that DELETE statement returns 0 (number of deleted rows) instead of 1.","davsclaus:1644286010:2022-02-08T10:06:50.650+0000:1644286010:2022-02-08T10:06:50.650+0000:Oh that is a great analysis. 
davsclaus:1644403801:2022-02-09T18:50:01.294+0000:1644403801:2022-02-09T18:50:01.294+0000:Are you able to to work on this, or provide an unit test / example to help reproduce this?

Also I wonder if we need some new API or something to aggregation repostiory to maybe ensure that work items for same exchange IDs are executed sequentially or something we can ensure that remove / confirm is executed in right order
bbonnet:1644471442:2022-02-10T13:37:22.101+0000:1644471442:2022-02-10T13:37:22.101+0000:I could not isolate the issue in a unit test, but here is an execution log extract (I added some debug log after insert and delete statement):[^CAMEL-17613-log.txt]

According to log, INSERT occurs before DELETE, but when DELETE is executed, row is not yet visible. I wonder how it is possible :
 * transactions are run very close one with each other, probably using different JDBC connections. The DB (PostgreSQL) guarantees isolation, but I am not sure order is guaranteed too.
 * we are using XA transactions (with Atomikos as a transaction manager) and we have to check that it does not add asynchronee somewhere on commit path.

 
klease78:1644504195:2022-02-10T22:43:15.180+0000:1644504195:2022-02-10T22:43:15.180+0000:[~bbonnet] JdbcAggregationRepository uses a Spring TransactionTemplate which has ""default"" transaction isolation so it's not clear what level that provides.
Maybe you've set a specific value on the Atomikos manager or configured the DB itself.
I also noticed this in the Camel SQL component documentation which might be relevant if the JMS route is also transacted:
{quote}
JdbcAggregationRepository uses two distinct transaction templates from Spring-TX. One is read-only and one is used for read-write operations.
However, when using JdbcAggregationRepository within a route that itself uses <transacted /> and there’s common PlatformTransactionManager used, there may be a need to configure propagation behavior used by transaction templates inside JdbcAggregationRepository.
{quote}
bbonnet:1644538776:2022-02-11T08:19:36.870+0000:1644538776:2022-02-11T08:19:36.870+0000:[~klease78], isolation level  is implicitly set to PostgreSQL default isolation level : Read Committed. Propagation behaviour is explicitly set to PROPAGATION_REQUIRED.
klease78:1644569533:2022-02-11T16:52:13.401+0000:1644569533:2022-02-11T16:52:13.401+0000:[~bbonnet] Thanks for the info. Maybe you could try debug logging at the level of the transaction manager to get an even finer-grained view of the issue. 
[^Spring_jdbc_transactions.log] shows the result in one of the unit tests which uses the built-in Spring DataSourceTransactionManager. According to the log, the transaction which deletes the exchange from the initial repo and inserts it in the completed repo is committed *before* the main thread continues to process the exchange so the behavior you see shouldn't occur.
But in this simple case, the transaction is initiated in the call to JdbcAggregationRepository.remove(). I'm not familiar with Atomikos or with JMS either but maybe if your transaction is initiated in the JMS handling and propagated to the remove() call, it is committed a bit later in the sequence which could explain why the inserted row isn't yet visible in the Aggregator-initiated transaction.
bbonnet:1649137421:2022-04-05T13:43:41.324+0000:1649137421:2022-04-05T13:43:41.324+0000:Hi,

I have made a unit test that shows how transactions might execute in reverse order.

See [https://github.com/bonnetb/camel/tree/CAMEL-17613,]  (commit [https://github.com/bonnetb/camel/commit/4da7abe5543434cba48f3e0f7f0a1d7fdb160462]).

This test uses an Atomikos transaction manager and an XA datasource (H2). By extending Atomikos transaction manager, I added some delay at commit time for the transaction that should occur first. As a result, the other transaction (DELETE) occurs first and you may see an ERROR log ""DELETE statement did not return 1 but 0"".

I noticed you set 3.17.0 as fix version : have you already worked on a fix ?

 
davsclaus:1649137780:2022-04-05T13:49:40.983+0000:1649137780:2022-04-05T13:49:40.983+0000:No we just move the ticket forward - an unit test surely helps. You are welcome to dive in and see if you can come up with a suggest fix/improvement
klease78:1649310232:2022-04-07T13:43:52.833+0000:1649310232:2022-04-07T13:43:52.833+0000:[~bbonnet] Many thanks for the test. I have finally understood how this can happen. Since the route is transacted, the commit does not actually happen in the methods in the JdbcAggregationRepository but in a task which is run on the main thread after the aggregate processor returns from its process() call. So it could happen that the thread started to  process the completed aggregation runs first and completes before the commit on the insert.

One idea is to slightly delay the start of the Aggregator thread, for example by using a ScheduledThreadPoolExecutor.

Another idea is to handle the non-deleted exchange in the RecoveryTask. It doesn't need to be redelivered but this could call the confirm() method again.

 
davsclaus:1649312046:2022-04-07T14:14:06.314+0000:1649312046:2022-04-07T14:14:06.314+0000:I wonder if we can house-keep the jdbc repo so we can handle that if a DELETE comes before INSERT then we do not need to execute the INSERT
klease78:1649321661:2022-04-07T16:54:21.754+0000:1649321661:2022-04-07T16:54:21.754+0000:I don't think so. In fact the INSERT is already executed but the transaction is not committed, which is done in the TransactionErrorHandler. And the transaction also contains the DELETE from the main aggregation repository so we can't try to roll it back. But I think it is not so difficult to change the AggregateProcessor so it could retry the DELETE from the complete repository.
klease78:1650930732:2022-04-26T07:52:12.280+0000:1650930732:2022-04-26T07:52:12.280+0000:[~bbonnet] I adapted your test a bit to remove the Atomix and JTA dependencies and still managed to reproduce and fix the issue with H2 as the database."
0,CAMEL-17612,Task,Minor,3.14.1,"3.14.3, 3.16.0","
None
",Resolved,Fixed,"3.14.3, 3.16.0",Claus Ibsen,Zineb Bendhiba,0,1,2022-02-07 15:40:02+00:00,2022-03-06 08:46:17+00:00,"The official documentation of Camel Google Cloud Functions component says that the component is supported for Producer only.


However, this is a consumer example shown in the documentation




from(""google-functions://myCamelFunction?project=myProject&location=us-central1&operation=callFunction&serviceAccountKey=/home/user/Downloads/my-key.json"") 
.to(""direct:test"");



There's something wrong with the doc. https://camel.apache.org/components/3.14.x/google-functions-component.html",
0,CAMEL-17611,Improvement,Major,None,3.16.0,"
None
",Resolved,Fixed,3.16.0,Nicolas Filotto,Nicolas Filotto,0,2,2022-02-07 14:11:59+00:00,2022-02-11 11:14:20+00:00,"With the existing code it is possible to create a route from a route template thanks to TemplatedRouteBuilder with a pure Java code or simply with a Kamelet. However in some particular cases it could be interesting to be able to create routes from a route template from a pure XML or YAML file especially for camel users that don't want to use Kamelets and write Java code.


 


So for example, following XML snippet would allow to instantiate a route whose id is ""my-route"" from the route template ""myTemplate"" with the 2 parameters ""for"" and ""bar"" and the bean ""myBean"".   




<templatedRoute routeTemplateRef=""myTemplate"" routeId=""my-route"">
    <parameter name=""foo"" value=""fooVal""/>
    <parameter name=""bar"" value=""barVal""/> 
    <bean name=""myBean"" type=""#class:org.apache.camel.spring.routebuilder.MySpecialBean"">
        <property key=""name"" value=""John""/>
    </bean>
</templatedRoute>","essobedo:1644214473:2022-02-07T14:14:33.655+0000:1644214473:2022-02-07T14:14:33.655+0000:[~davsclaus] If you don't mind I would like to work on this ticket
davsclaus:1644214593:2022-02-07T14:16:33.231+0000:1644214593:2022-02-07T14:16:33.231+0000:Yeah sure
essobedo:1644306545:2022-02-08T15:49:05.927+0000:1644306545:2022-02-08T15:49:05.927+0000:The related PR https://github.com/apache/camel/pull/6903
essobedo:1644451549:2022-02-10T08:05:49.121+0000:1644451549:2022-02-10T08:05:49.121+0000:The PR [https://github.com/apache/camel-examples/pull/71] for the examples
davsclaus:1644452762:2022-02-10T08:26:02.202+0000:1644452762:2022-02-10T08:26:02.202+0000:Thanks

If you have the opportunity then it would be good to also add the xml example to spring boot
https://github.com/apache/camel-spring-boot-examples
essobedo:1644453023:2022-02-10T08:30:23.685+0000:1644453023:2022-02-10T08:30:23.685+0000:No problem, I will do it
essobedo:1644464063:2022-02-10T11:34:23.309+0000:1644464063:2022-02-10T11:34:23.309+0000:The PR [https://github.com/apache/camel-spring-boot-examples/pull/50] from the Spring Boot examples"
0,CAMEL-17610,Improvement,Minor,None,3.16.0,"

pull-request-available

",Resolved,Fixed,3.16.0,Unassigned,Billy Jaime Beltran,0,2,2022-02-07 13:24:37+00:00,2022-02-07 17:31:17+00:00,Currently CC and BCC are missing from the uri params but are supported by the Amazon SDK. Patch so we can send cc and bcc just like we do with To without having to manually create a javax mail instance.,acosentino:1644211822:2022-02-07T13:30:22.561+0000:1644211822:2022-02-07T13:30:22.561+0000:https://github.com/apache/camel/pull/6897
0,CAMEL-17609,Bug,Major,3.14.1,"3.14.2, 3.16.0","
None
",Resolved,Fixed,"3.14.2, 3.16.0",Unassigned,Tom Cassimon,3,3,2022-02-07 07:19:08+00:00,2022-03-04 08:37:05+00:00,"I'm working on an update of the camel library version used to the latest LTS release (3.14.1), but it seems to have broken my tests that are using transacted.


I have a simple test route which reads in a file, parses the content using bindy and sending the validated parts to a jms queue.




from(""inputFile:///temp/testing/input2/"")
    .autoStartup(true)
    .transacted()
    .unmarshal(format)
    .split(body())
        .to(""bean-validator:x"")
        .to(""direct:sendMessage2"")
    .end()
.end();

from(""direct:sendMessage2"")
    .convertBodyTo(String.class)
    .to(""jms://be.test.output"")
.end(); 



If one of the parts of the file doesn't pass the validation rules, the test expects to find no messages on the queue.


This used to work in camel-3.7.x, but now in camel 3.14.1 messages do appear on the queue, even when parts of the file failed the validation.


In the migration guide of 3.12 -> 3.13 is an entry about transactions, but it is not clear to me if this is related.


Upon further investigation the split() seems to cause the issue with the transactionality, if i put 2 posts to jms inline in the route and throw an exception before the second post the result is no messages on the queue.


Do i have to add something to the split to allow the transaction to propagate?","kinae:1646148351:2022-03-01T23:25:51.189+0000:1646148351:2022-03-01T23:25:51.189+0000:Could be related to 

https://issues.apache.org/jira/browse/CAMEL-16103
TCke83:1646354174:2022-03-04T08:36:14.700+0000:1646354174:2022-03-04T08:36:14.700+0000:Fixed with CAMEL-17474"
0,CAMEL-17608,Improvement,Major,3.15.0,3.16.0,"
None
",Resolved,Fixed,3.16.0,Jeremy Ross,Jeremy Ross,0,2,2022-02-06 14:41:55+00:00,2022-03-13 18:04:10+00:00,"When subclasses of the generated DTOs are used, Camel uses the name of the subclass as the sobject name, which won't work. Also, because instanceof check passes, camel ignores the sObjectName option. The solution would be for Camel to always honor the sObjectName option.","zregvart:1644210054:2022-02-07T13:00:54.332+0000:1644210054:2022-02-07T13:00:54.332+0000:Yeah, if folk provide the {{sObjectName}} that should be taken as is and override the name derived from the body. It does change the behavior from what we do for a long time, but I don't think it breaks the backward compatibility for most folks as they would either use {{sObjectName}} or they would rely on the class name; if both are specified and they differ this will, most likely, break for folk, so it might be a good idea to either throw an exception or log a warning. I suspect the logic as it stands today is in a number places so changing this we'd need to be a bit careful to stay consistent."
0,CAMEL-17607,Task,Major,None,3.16.0,"
None
",Resolved,Fixed,3.16.0,Nicolas Filotto,Claus Ibsen,0,2,2022-02-06 14:30:19+00:00,2022-02-14 14:16:29+00:00,https://twitter.com/dzikoysk/status/1490053959213625346?s=20&t=9wbTWACm35G2hmGJmT484A,essobedo:1644804444:2022-02-14T10:07:24.190+0000:1644804444:2022-02-14T10:07:24.190+0000:The related https://github.com/apache/camel/pull/6942
0,CAMEL-17606,Improvement,Minor,None,3.16.0,"
None
",Resolved,Fixed,3.16.0,Claus Ibsen,Claus Ibsen,0,1,2022-02-05 07:24:30+00:00,2022-02-07 09:04:04+00:00,"I wonder if we need a builder method to refer to property placeholder?


.username(""mail.sender"")


vs


.username(property(""mail.sender""))",
0,CAMEL-17605,Task,Major,None,3.16.0,"
None
",Resolved,Fixed,3.16.0,Claus Ibsen,Claus Ibsen,0,1,2022-02-04 12:06:17+00:00,2022-02-04 12:06:47+00:00,No Desc,
0,CAMEL-17604,New Feature,Trivial,None,None,"
None
",Resolved,Invalid,None,Unassigned,Vyacheslav Boyko,0,2,2022-02-04 11:13:58+00:00,2022-02-04 11:14:34+00:00,,"davsclaus:1643944474:2022-02-04T11:14:34.432+0000:1643944474:2022-02-04T11:14:34.432+0000:Please report at its github project page
https://github.com/camel-tooling/camel-idea-plugin"
0,CAMEL-17603,Dependency upgrade,Major,None,3.16.0,"
None
",Resolved,Fixed,3.16.0,Unassigned,Claus Ibsen,0,1,2022-02-04 11:12:50+00:00,2022-02-04 11:13:19+00:00,There are some newer releases we should use,
0,CAMEL-17602,Bug,Minor,"3.13.0, 3.14.1","3.14.3, 3.16.0","
None
",Resolved,Fixed,"3.14.3, 3.16.0",Claus Ibsen,Mikołaj Matejko,0,4,2022-02-04 11:11:14+00:00,2022-03-07 10:59:58+00:00,"Sqs2Producer turns Boolean header into messageAttribute with dataType=Number.Boolean, stringValue=""0"" or stringValue=""1""



However Sqs2Consumer seems to incorrectly convert messageAttribute into header while constructing Exchange - instead of turning the ""1"" -> true, ""0"" -> false it leaves the values as ""1"", ""0"" strings. Shouldn't it convert it directly to Boolean (true, false)?","acosentino:1643952797:2022-02-04T13:33:17.285+0000:1643952797:2022-02-04T13:33:17.285+0000:You're welcome to work on a Pull request for this. Thanks
davsclaus:1644021752:2022-02-05T08:42:32.394+0000:1644021752:2022-02-05T08:42:32.394+0000:It can also be other data types, eg Number.float and so on, so it appears the consumer should check the dataType in the translateValue method
klease78:1645349768:2022-02-20T17:36:08.478+0000:1645349768:2022-02-20T17:36:08.478+0000:Just a note about the types such as Number.int from the [AWS documentation|#message-attribute-data-types]:]
{panel:title=Message attribute data types}
*Custom* – To create a custom data type, append a custom-type label to any data type. For example:
 * {{{}Number.byte{}}}, {{{}Number.short{}}}, {{{}Number.int{}}}, and {{Number.float}} can help distinguish between number types.

*Note*
Amazon SQS doesn't interpret, validate, or use the appended data.
{panel}
Based on this, there are no predefined values for different kinds of Number attributes and it would depend on the application producing the messages. Maybe it's still interesting to check for common data numeric types and boolean."
0,CAMEL-17601,Improvement,Major,None,Future,"
None
",Open,Unresolved,Future,Radovan Netuka,Claus Ibsen,0,1,2022-02-04 11:09:39+00:00,2023-04-27 12:42:26+00:00,"JAXB is a pain for the the legacy XML DSL (spring <beans> and blueprint XML).
Also JAXB is no longer in the JDK and its heavy to use.


We have the new fast XML IO parser that we use for modern Camel apps.


We should find a way in the future to get rid of JAXB in the core model and use a different way of generating the XML XSD.


The current generator with some legacy maven plugins that generate JAXB -> XML Schema is brittle and will be in the future with modern JVM versions.


Today we hit problems with this where generating OSGi XML does not work but it works for Spring XML.",
0,CAMEL-17600,Task,Major,None,,"
None
",Open,Unresolved,None,Jean-Baptiste Onofré,Jean-Baptiste Onofré,0,2,2022-02-04 07:45:30+00:00,2022-03-25 08:39:46+00:00,No Desc,
0,CAMEL-17599,Bug,Major,"3.14.1, 3.15.0","3.14.2, 3.16.0","
None
",Resolved,Fixed,"3.14.2, 3.16.0",Claus Ibsen,James Netherton,0,1,2022-02-04 07:41:33+00:00,2023-04-10 06:33:55+00:00,"Originally reported on the a Quarkus Zulip thread:


https://quarkusio.zulipchat.com/#narrow/stream/187030-users/topic/Camel.20JDBC.20leaks.20statement


There are 2 different execution paths in JdbcProducer. doCreateAndExecuteSqlStatementWithHeaders & doCreateAndExecuteSqlStatement.


doCreateAndExecuteSqlStatementWithHeaders does close the PreparedStatement:


https://github.com/apache/camel/blob/camel-3.14.1/components/camel-jdbc/src/main/java/org/apache/camel/component/jdbc/JdbcProducer.java#L185-L188


doCreateAndExecuteSqlStatement does not:


https://github.com/apache/camel/blob/camel-3.14.1/components/camel-jdbc/src/main/java/org/apache/camel/component/jdbc/JdbcProducer.java#L244-L246


This PR & commit suggests auto-closing is perhaps not desirable:


https://github.com/apache/camel/pull/6192


The code prior to Camel 3.12.x did close the PreparedStatement in the finally block, so maybe that should be restored.","jamesnetherton:1643931755:2022-02-04T07:42:35.617+0000:1643931755:2022-02-04T07:42:35.617+0000:For reference, there's a reproducer camel-quarkus project here:

https://bitbucket.org/turing85/quarkus-camel-jms/"
0,CAMEL-17598,New Feature,Minor,3.14.1,4.x,"
None
",Open,Unresolved,4.x,Unassigned,Jeremy Ross,1,2,2022-02-03 20:45:32+00:00,2023-08-09 09:13:30+00:00,"If bindy fails to parse a value, say a date, an exception is thrown and the entire unmarshal operation is aborted. It would be nice if the exception could be handled and processing could resume. We'd probably also want a way to specify a default value in the case of a parse failure. 


Here are some choices that need to be made:



A way to indicate unmarshaling should resume in the event of a parse failure. Where would this live? Options are at the component option level, @CsvRecord level, and @DataField level. Maybe all of these with each one successively overriding the higher level setting. But maybe that's too complex. What would this be called? continueOnParseFailure? Is this even the right concept?
A way to specify a default value to use when a parse fails. @DataField already has a defaultValue element, so maybe we use this value in the event of a failure. If defaultValue is not set, it could default to null or the default value for a primitive type.



Zulip chat: https://camel.zulipchat.com/#narrow/stream/257298-camel/topic/Bindy.20continue.20on.20parse.20exception","zregvart:1643933503:2022-02-04T08:11:43.615+0000:1643933503:2022-02-04T08:11:43.615+0000:I think on a framework (i.e. Camel) level, adding an error handler that folk can provide implementations of could be helpful. Perhaps something like:
{code:java}
class ParseException extends Exception {
  int lineNumber;
  String line;
  // perhaps some other context needed here
}

interface ParserErrorHandler {
  /**
   * Given a ParseException that occurred while trying to parse a record choose to either rethrow the exception preventing further parsing, ignore it returning {@code null} or provide a substitute object for the parsed row.
   */
  Object handle(ParseException e);
}{code}

(2c)
jeremyross:1644308126:2022-02-08T16:15:26.154+0000:1644308126:2022-02-08T16:15:26.154+0000:I think that solution probably provides the best flexibility. But I suspect the use of options I described would cover the vast majority of uses cases and is obviously much simpler. 

I'm kinda liking the idea of having both of these solutions. The ability to set options to define simpler parse failure behavior, and ParseErrorHandler for ultimate flexibility.  "
0,CAMEL-17597,Test,Major,None,3.16.0,"
None
",Resolved,Fixed,3.16.0,Freeman Yue Fang,Freeman Yue Fang,0,1,2022-02-03 19:41:21+00:00,2022-02-03 22:05:02+00:00,No Desc,"ffang:1643890212:2022-02-03T20:10:12.950+0000:1643890212:2022-02-03T20:10:12.950+0000:It just works when the Docker Desktop on Mac is started. 
I also revise the tests in this module which requires a docker env to ExtendWith a dummy ZookeeprContainer to detect if docker env exists or not before run the test
PR attached
"
0,CAMEL-17596,Task,Minor,3.16.0,3.16.0,"
None
",Resolved,Fixed,3.16.0,Unassigned,Marouane Trabelsi,0,2,2022-02-03 15:06:07+00:00,2022-02-05 08:43:32+00:00,"Following the MainConfigurationProperties changes introduced in CAMEL-17567 and more specifically the org.apache.camel.main.MainConfigurationProperties#addConfigurationClass visibility having changed from public to private, all camel-examples relying on the mentioned method to configure the runtime are broken.


Here down a list of affected modules:



camel-example-main
camel-example-main-artemis
camel-example-main-lambda
camel-example-main-xml
camel-example-main-yaml","davsclaus:1643878696:2022-02-03T16:58:16.775+0000:1643878696:2022-02-03T16:58:16.775+0000:There is a 3.15.0 tag you can use for the release
https://github.com/apache/camel-examples/tree/camel-examples-3.15.0
davsclaus:1643878731:2022-02-03T16:58:51.839+0000:1643878731:2022-02-03T16:58:51.839+0000:The main branch is _work in progress_ and this can be expected
tmarwen:1643892704:2022-02-03T20:51:44.843+0000:1643892704:2022-02-03T20:51:44.843+0000:[~davsclaus] thanks for the quick feedback.

Would a contribution for the fix for the different main classes be welcomed?
davsclaus:1643893381:2022-02-03T21:03:01.610+0000:1643893381:2022-02-03T21:03:01.610+0000:Yeah sure you are welcome to send PRs to main branch that makes the examples work"
0,CAMEL-17595,New Feature,Minor,None,4.x,"
None
",Open,Unresolved,4.x,Unassigned,Sijmen Huizenga,0,2,2022-02-03 13:26:22+00:00,2023-08-09 09:13:36+00:00,"Add the ability to start a new trace during the exeuction of a route.


For example, we use an aggregate with completionInterval to group messages. All messages from the aggregate share the same traceID. This results in a single trace spanning all messages over many weeks. We would like each message after the aggregate to receive a new trace to improve visibility. Having the ability to manually close & start the trace would be ideal.


It would be amazing if it would be possible to call .reset() method from the ActiveSpanManager:




.process(e -> ActiveSpanManager.reset(e))",davsclaus:1662173948:2022-09-03T10:59:08.588+0000:1662173948:2022-09-03T10:59:08.588+0000:You are welcome to send a PR
0,CAMEL-17594,Bug,Minor,3.14.0,"3.14.2, 3.16.0","
None
",Resolved,Fixed,"3.14.2, 3.16.0",Claus Ibsen,Yasser Zamani,0,2,2022-02-03 11:20:53+00:00,2022-02-03 11:46:08+00:00,"issue when wireTap is inside a doCatch, and has .end(). Attached test run ends up in



java.lang.ClassCastException: class org.apache.camel.model.CatchDefinition cannot be cast to class org.apache.camel.model.TryDefinition




Removing .end() fixes issue but then it's confusing why exactly same wireTap inside doTry MUST have .end() and inside doCatch MUST NOT!",davsclaus:1643859968:2022-02-03T11:46:08.569+0000:1643859968:2022-02-03T11:46:08.569+0000:You need to use endDoCatch to go back that is added in next releases
0,CAMEL-17593,Improvement,Minor,3.13.0,"3.14.3, 3.16.0","
None
",Resolved,Fixed,"3.14.3, 3.16.0",Andrea Cosentino,Mikołaj Matejko,0,4,2022-02-03 09:41:31+00:00,2022-03-08 10:07:39+00:00,"When you try to send a message using AWS SDK and provide more then 10 messageAttributes then you will get a clean error what happened, e.g.:



When using Camel the behavior is different - Camel is going to skip all messageAttributes after the first 10 ones. It won't throw anything nor log anything. So it leads to losing information without even knowing it. 
Problematic place: Sqs2Producer#translateAttributes","acosentino:1643852826:2022-02-03T09:47:06.267+0000:1643852826:2022-02-03T09:47:06.267+0000:This is by design. https://issues.apache.org/jira/browse/CAMEL-17167

Adding a list of selected of attribute to add to message is overkilling. Make sqs throwing an exception is really avoidable.

It's up to the user to add at most 10 attributes. 
matejkom:1643853567:2022-02-03T09:59:27.368+0000:1643853567:2022-02-03T09:59:27.368+0000:It is quite easy to have situation like this when having complex logic and you send messages between components. Then you may land up in a situation that you have more than 10 headers in message. So currently after sending to SQS you will lose some of the headers without any knowledge. So it extremely influence the behavior of the application.

There is no info/validation for the user that the application-logic should be patched to provide 10 headers. And I believe the user should have that knowledge that the constructed message was not-OK, so he have ability to patch the application logic.
acosentino:1643855626:2022-02-03T10:33:46.367+0000:1643855626:2022-02-03T10:33:46.367+0000:We could agree on a tradeoff, like loggin a warn, listing the attributes that will be added and what will be discarded informing the user, but to me the logic should be the same. Throwing an exception without managing the situation is wrong to me.
matejkom:1643862351:2022-02-03T12:25:51.196+0000:1643862351:2022-02-03T12:25:51.196+0000:It would be very nice to have this warn logging (y)

Would it be possible to go even step further and have some sort of strategy in Sqs2Configuration for handling those?
e.g. Sqs2Configuration#exceedingMaxAttributesStrategy with `LOG` & `THROW`, so it would be up to the developer using Camel in the project to decide which way to go. With default `LOG` it would behave as you described. With `THROW` it would throw exception, so the behaviour would be equal to the one of AWS SDK

 
acosentino:1643863217:2022-02-03T12:40:17.903+0000:1643863217:2022-02-03T12:40:17.903+0000:Makes sense. 
nickorfas:1643892276:2022-02-03T20:44:36.508+0000:1643892276:2022-02-03T20:44:36.508+0000:It would be really nice to have the recommended by Mikolaj functionality.
davsclaus:1646626385:2022-03-07T12:13:05.112+0000:1646626385:2022-03-07T12:13:05.112+0000:Andrea, are you working on this? If not then I can take a look.

Is the 10 hardlimit on AWS, and would it potentially be changed? As we could make the 10 a configuration on the component level, so it can be adjusted in the future.
And can you see this 10 hardlimit somewhere on their documentation (anyone has a hyperlink)?
matejkom:1646626607:2022-03-07T12:16:47.467+0000:1646626607:2022-03-07T12:16:47.467+0000:[~davsclaus] 10 is a hardlimit for now, here is a description: [https://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/sqs-message-metadata.html]

""Each message can have up to 10 attributes""
acosentino:1646645329:2022-03-07T17:28:49.856+0000:1646645329:2022-03-07T17:28:49.856+0000:Yes [~davsclaus], it's an hard limit
acosentino:1646645394:2022-03-07T17:29:54.005+0000:1646645394:2022-03-07T17:29:54.005+0000:Feel free to work on this one, I'd like to have it in 3.16.0"
0,CAMEL-17592,Bug,Major,3.13.0,"3.11.6, 3.14.2, 3.16.0","
None
",Resolved,Fixed,"3.11.6, 3.14.2, 3.16.0",Claus Ibsen,Arnaud Level,0,3,2022-02-03 09:06:56+00:00,2022-02-03 17:02:43+00:00,"The concurrentConsumers URI parameter is not taken into account by the endpoint.
We can reproduce the issue with the following prototype:


from(""aws2-sqs://queuexxx?concurrentConsumers=5&amazonSQSClient=#sqsClient&
waitTimeSeconds=20"")
.process(exchange -> 

{
     System.out.println(""Message received..."");
}

)
.process(exchange -> {
     try 

{
        Thread.sleep(5000);
     }

 catch (InterruptedException e) {
        e.printStackTrace();
     }});


With the above queue, if we send 3 messages, we have to wait
5 seconds to see the second message (""Message received..."") and 5 more
seconds to see the third one. The expected behavior is to see the 3 messages
consumed without delay since 3 threads will consume them in parallel.


Turning on the Camel logs it seems that the next polling is done only after
the Delete for the previous message is sent (which is with a delay of 5s).
The messages are read 1 by 1 (=1 message per polling) so the above behavior is not seen because the message are consumed together by one polling and continue in the same thread.


Note that, as commented by Narsi Reddy Nallamilli in the user mailing list, we obtain the expected behavior by adding a delay in the route as follow: 


from(""aws2-sqs://queuexxx?concurrentConsumers=5&amazonSQSClient=#sqsClient&
waitTimeSeconds=20"")
.delay(1L)
.process(exchange -> 

{
    System.out.println(""Message received..."");
}

)
.process(exchange -> {
    try 

{
       Thread.sleep(5000);
    }

 catch (InterruptedException e) {
       e.printStackTrace();
    }});","narsi-nallamilli:1643863447:2022-02-03T12:44:07.205+0000:1643863550:2022-02-03T12:45:50.593+0000:[~arnaudlbcn] The expected behavior which you are seeking is changed with https://issues.apache.org/jira/browse/CAMEL-16383. 

By default the consumer creates a defaultScheduler with only one thread which is why  the messages are consumed serially. Before the change the scheduler thread are created based on concurrentConsumers attribute value, that is why it used to work.

You need to specify your own scheduler with 'scheduledExecutorService' as shown in  [https://camel.apache.org/components/3.7.x/aws2-sqs-component.html] with required pool size to work the way you want.

However I have tried this and it is not honoring the attribute. The issue is in [https://github.com/apache/camel/blob/main/components/camel-aws/camel-aws2-sqs/src/main/java/org/apache/camel/component/aws2/sqs/Sqs2Endpoint.java] where it creates the consumer with default schedule. It should consider the provided custom schedule if exists.

 
{code:java}
public Consumer createConsumer(Processor processor) throws Exception {
    Sqs2Consumer sqsConsumer = new Sqs2Consumer(this, processor);
    this.configureConsumer(sqsConsumer);
    sqsConsumer.setMaxMessagesPerPoll(this.maxMessagesPerPoll);
    DefaultScheduledPollConsumerScheduler scheduler = new DefaultScheduledPollConsumerScheduler(); {code}
 

 

[~davsclaus]  can you please have a look?
davsclaus:1643872124:2022-02-03T15:08:44.265+0000:1643872124:2022-02-03T15:08:44.265+0000:Yeah that seems like something that can be improved
davsclaus:1643873803:2022-02-03T15:36:43.493+0000:1643873803:2022-02-03T15:36:43.493+0000:There is a fix on main branch at
https://github.com/apache/camel/commit/599a3a0e2ab610e71dafe326965d697b8061db06

"
0,CAMEL-17591,Bug,Minor,None,3.16.0,"
None
",Resolved,Fixed,3.16.0,Claus Ibsen,Richard Groote,0,2,2022-02-03 07:49:25+00:00,2022-02-07 06:24:02+00:00,"Currently doing an migration from Apache Camel 2.25.x to 3.11.x and a simple expression using ognl is no longer working.


Below is an example expression




${body.replaceAll(""Bik (Ru)"",""bik_ru"").replaceAll(""a"",""b"") 



In the 2.25.x OgnlHelper.splitOgnl the above works because the 'parenthesisBracket' where detected with a boolean. In the 3.x code base the parenthesisBracket is detected using a int and the number of '(' and ')' are not the same. The reason that the brackets are not the same is because there are more or less brackets within the string being replaced.


It would be nice if the OgnlHelper would be capable of handling this situations.","davsclaus:1643861941:2022-02-03T12:19:01.442+0000:1643861941:2022-02-03T12:19:01.442+0000:You are using replaceAll that is java regular expression, so you need to escape the input
https://github.com/apache/camel/commit/beff9bed4b6a4f0062926e1e6238f6f503596bcb

{code}
    public static void main(String[] args) {
        String s = ""Bik (Ru)"".replaceAll(""Bik \\(Ru\\)"", ""bik_ru"");
        System.out.println(s);
    }
{code}

Because 
{code}
""Bik (Ru)"" 
{code}

Is used as regular expression then ( and ) are used for group, to use their value as text then they must be escaped
davsclaus:1643880522:2022-02-03T17:28:42.248+0000:1643880522:2022-02-03T17:28:42.248+0000:If you want a plain string replacement then use ""replace"" instead of ""replaceAll""
r.groote@beinformed.com:1643929819:2022-02-04T07:10:19.000+0000:1643929819:2022-02-04T07:10:19.000+0000:Totally agree, but my customer uses the 'replaceAll' statement in the Spring DSL so i will inform them.

But looking at the code of the OgnlHelper (maybe i'am wrong) that will still not work because it count the number of parenthesis without checking if it's within a string value.

So when i do body.replace(""a"",""b"").replace(""(((("",""-"") it will still not result in two methods because of the number of '(' in the  


{code:java}
            if (j == 0 || j == 1 && ognl.charAt(i - 1) == '?'
                    || ch != '.' && ch != '?' && ch != ']') {
                sb.append(ch);
                // special if we are doing square bracket
                if (ch == '[' && parenthesisBracketCnt == 0) {
                    squareBracketCnt++;
                } else if (ch == '(') {
                    parenthesisBracketCnt++;
                } else if (ch == ')') {
                    parenthesisBracketCnt--;
                }
                j++; // advance {code}
r.groote@beinformed.com:1643931088:2022-02-04T07:31:28.322+0000:1643931088:2022-02-04T07:31:28.322+0000:{code:java}
	@Test
	public void simpleTest() {
		Exchange exchange = new DefaultExchange(new DefaultCamelContext());
		
		exchange.getIn().setBody(""some string with (( and ))))"");
		
		SimpleLanguage language = new SimpleLanguage();
		language.setCamelContext(new DefaultCamelContext());
		
		Expression createExpression = language.createExpression(""${body.replace(\""((\"",\""--\"").replace(\""))))\"",\""----\"")}"");
		String evaluate = createExpression.evaluate(exchange, String.class);
		
		System.out.println(evaluate);
		
		


		createExpression = language.createExpression(""${body.replace(\""e\"",\""a\"").replace(\""i\"",\""a\"")}"");
		evaluate = createExpression.evaluate(exchange, String.class);
		System.out.println(evaluate);


	} {code}
With the above code the first one result is 'some string with --).replace()))) and ))))'  and i would expect 'some string with –- and ----
davsclaus:1644112172:2022-02-06T09:49:32.233+0000:1644112172:2022-02-06T09:49:32.233+0000:Yes it seems we should handle this better, thanks for the new test case.
CAMEL-13692 caused this problem.
r.groote@beinformed.com:1644186242:2022-02-07T06:24:02.062+0000:1644186242:2022-02-07T06:24:02.062+0000:I've tested it and this works fine, thanx"
0,CAMEL-17590,Bug,Minor,3.14.0,3.14.0,"
None
",Resolved,Invalid,3.14.0,Unassigned,Sergio Gonzalez Meana,0,2,2022-02-02 23:02:32+00:00,2022-02-05 18:22:14+00:00,"Hello 
 
We are trying to read files using the following connector 
https://github.com/apache/camel-kafka-connector-examples/tree/main/sftp/sftp-source
The connector sends the whole file in one record to kafka (useless on large files).
we have files of 500MB
 
Is it possible to convert the whole record into small batches?


We unsuccessfully tried a couple of approaches with not luck.


The transform does not allow to return a list of newrecord -> public R apply(R r) {


 
Thanks in advance",davsclaus:1643838356:2022-02-03T05:45:56.133+0000:1643838356:2022-02-03T05:45:56.133+0000:Use the user mailing list or the zulip chat room to ask for help
0,CAMEL-17589,Test,Minor,None,3.16.0,"
None
",Resolved,Fixed,3.16.0,Freeman Yue Fang,Freeman Yue Fang,0,1,2022-02-02 21:56:25+00:00,2022-03-30 16:31:16+00:00,"Currently all Integration Tests of camel-infinispan  are disabled for MAC, because docker image is used and Docker Desktop on Mac has different network configuration as Docker on Linux, this can cause issue when infinispan hotrod client is trying to access an internal node/IP from the host(mac), more details described here","ffang:1643811614:2022-02-02T22:20:14.165+0000:1643811614:2022-02-02T22:20:14.165+0000:PR attached
ffang:1644230915:2022-02-07T18:48:35.910+0000:1644230915:2022-02-07T18:48:35.910+0000:camel-spring-boot has the same issue, apply the same fix there
https://github.com/apache/camel-spring-boot/commit/d081b6ed001a0fa3a97f3eec8e39d5fdea8fe378"
0,CAMEL-17588,Bug,Minor,3.14.1,3.17.0,"
None
",Resolved,Won't Do,3.17.0,Unassigned,Björn Ohm,0,2,2022-02-02 15:24:59+00:00,2022-04-04 07:20:07+00:00,"We are running a Camel-Application on a Tomcat. While the Tomcat-Shutdown we observed a bunch of Thread-Local-WARNINGS in the catalina.out like:




02-Feb-2022 01:31:23.810 SCHWERWIEGEND [main] org.apache.catalina.loader.WebappClassLoaderBase.checkThreadLocalMapForLeaks The web application [provinzial-integration-intern] created a ThreadLocal with key of type [java.lang.ThreadLocal.SuppliedThreadLocal] (value [java.lang.ThreadLocal$SuppliedThreadLocal@4a4357f5]) and a value of type [org.apache.camel.impl.engine.DefaultReactiveExecutor.Worker] (value [org.apache.camel.impl.engine.DefaultReactiveExecutor$Worker@76e66f23]) but failed to remove it when the web application was stopped. Threads are going to be renewed over time to try and avoid a probable memory leak.



Obviously this belongs to the ThreadLocals used in org.apache.camel.impl.engine.DefaultReactiveExecutor.


In the worst case, this can lead to memory problems. 
The ThreadLocals should be cleaned up.","davsclaus:1643795937:2022-02-02T17:58:57.595+0000:1643795937:2022-02-02T17:58:57.595+0000:Thanks for reporting
Ohm:1646786370:2022-03-09T08:39:30.866+0000:1646788034:2022-03-09T09:07:14.786+0000:After update to 3.14.2 there are unfortunately still a large number (correlate to load) of the same Thread-Local-SEVERE-Messages while Tomcat-Shutdown. ([^catalina.out])
davsclaus:1646876281:2022-03-10T09:38:01.105+0000:1646876281:2022-03-10T09:38:01.105+0000:Can you put together a small sample project we can use to reproduce this. You can attach the project to this jira as .zip or put code on github etc.
davsclaus:1646876732:2022-03-10T09:45:32.219+0000:1646876732:2022-03-10T09:45:32.219+0000:Had some more look and its not possible to cleanup all thread locals as different threads may have used the reactive engine.

The worker is affinited per thread that uses the reactive engine.

That is why you also see IBM and other frameworks in the tomcat log.
Ohm:1646882206:2022-03-10T11:16:46.288+0000:1646882206:2022-03-10T11:16:46.288+0000:Hi [~davsclaus] ,

in my opinion this is not clean on the IBM-side either, but that's annother discussion;)

 If you say the ThreadLocals can't or shouldn't be cleaned up after use on the thread, then I'll of course accept that, hoping it won't have any negative effects.

Do you still need a sample project? Then I can try to make it available...

Regards
davsclaus:1646882379:2022-03-10T11:19:39.448+0000:1646882379:2022-03-10T11:19:39.448+0000:The sample would help to investigate if there is some ""clever hacks"" - there are some using reflection to go inside JDK ThreadLocal but then you clear everytyhing and not only Camel. But you could maybe find out if the values inside ThreaadLocal impl are from Camel and not, and then only clear Camel.

However I think its a dirty hack and the JDK documentation mentions that the JVM will automatic clear when classes are unloaded.

And Tomcat is the only JEE server, that I have seen, that logs these WARNS on undeploying apps.
davsclaus:1646886251:2022-03-10T12:24:11.749+0000:1646886251:2022-03-10T12:24:11.749+0000:Okay I have some cleanup code as a clever hack. It would be good if you could put a sample project together (so I can try with SNAPSHOT jars of camel-core with the fix).
As the fix is ""ugly"" then we would likely have this as a special feature you need to turn on to use, then you can use this on apache tomcat.
davsclaus:1646891765:2022-03-10T13:56:05.693+0000:1646891765:2022-03-10T13:56:05.693+0000:There is a PR here
https://github.com/apache/camel/pull/7182

Ohm:1646983329:2022-03-11T15:22:09.112+0000:1646983389:2022-03-11T15:23:09.317+0000:I knew from other situtions, where ThreadLocals are used, that they are cleaned up right after use (each time) in the current thread, typacilly in a finally-block (or similiar) and recreated new each time (I think this is the recommended way to handle ThreadLocals). I don't know, if this could be another approach (desired and possible). 

Your fix seems to be a one-time-cleanup while shutdown.
I tested it locally with my application and basically it worked (no more SEVERE-logs). But a problem could be, that the used {_}threads{_}-Map could grow unbounded over the time?? 

I have attached a small Camel-Spring-Boot-App [^plain-camel.zip], which started a CXF-Endpoint. After you post some SOAP-Requests, you can see in org.apache.camel.impl.engine.DefaultReactiveExecutor#workers the ThreadLocals... (see {_}/plain-camel/.readme{_}).
Theres is also a UnitTest, which do this for you ({_}plain.camel.PlainCamelApplicationTest.callService(){_}).
Of course this is just the case for incoming http-threads. I don't know in which cases the reactive-engine is used. For example we use JMS-Consumer with a thread-pool (growing and shrinking)...

!workers-threadLocals.PNG|width=268,height=226!
davsclaus:1647041894:2022-03-12T07:38:14.764+0000:1647041894:2022-03-12T07:38:14.764+0000:Hi

Yeah Bjorn you are on to something, when you have many threads that are not long lived - then the thread locals internal array can grow (however they are weak referenced so they should be nulled over time) - and the JVM will automatic expunge stale entries (see the JDK source).

But to be a good citizen then I think we can look at using a different pooling, see linked ticket created.
davsclaus:1648694787:2022-03-31T10:46:27.979+0000:1648694787:2022-03-31T10:46:27.979+0000:Thanks Bjorn for the test-case, there is a new camel-reactive-executor-tomcat module in Camel 3.17 that you can use.
Ohm:1649028007:2022-04-04T07:20:07.429+0000:1649028007:2022-04-04T07:20:07.429+0000:Ok, I will try to remember that;)"
0,CAMEL-17587,Improvement,Major,None,3.16.0,"
None
",Resolved,Fixed,3.16.0,Claus Ibsen,Claus Ibsen,0,1,2022-02-02 09:45:30+00:00,2022-02-09 10:38:39+00:00,"The thresholds for failure / success / interval etc should be removed, to make invoking health checks in camel always executing.


Such thresholds does not belong inside camel but the monitoring systems where they can setup such rules.","davsclaus:1644198559:2022-02-07T09:49:19.581+0000:1644200470:2022-02-07T10:21:10.572+0000:TODO: camel-core *DONE*
TODO: camel-spring-boot *DONE*
TODO: camel-examples *DONE*
TODO: camel-spring-boot-examples *DONE*
TODO: Deprecate in camel 3.14.x *DONE*
davsclaus:1644200968:2022-02-07T10:29:28.174+0000:1644200968:2022-02-07T10:29:28.174+0000:We can make configuration simpler to avoid the parent and just have a way to enable/disable individual checks

camel.health.config[timer].parent = routes
camel.health.config[timer].enabled = true

Can be

camel.health.routes[timer].enabled = true


davsclaus:1644201128:2022-02-07T10:32:08.519+0000:1644201128:2022-02-07T10:32:08.519+0000:Or instead of configuration then we can just have a single option where you can disable by pattern (multi separated by comma)

camel.health.check.disabled-pattern = netty
"
0,CAMEL-17586,Improvement,Minor,3.x,3.19.0,"
None
",Resolved,Fixed,3.19.0,Claus Ibsen,Manuel Shenavai,0,2,2022-02-01 21:07:47+00:00,2022-09-07 20:46:22+00:00,"If there is a mail with multiple attachments that have the same name, only one of the attachments will be added to the attachment map of the exchange. The other attachments will be ignored and only a warning will be logged.


https://github.com/mash-sap/camel/blob/main/components/camel-mail/src/main/java/org/apache/camel/component/mail/MailBinding.java#L371


This will cause data loss.","mash-sap:1643771058:2022-02-02T11:04:18.732+0000:1643791561:2022-02-02T16:46:01.891+0000:I created a pull request: [https://github.com/apache/camel/pull/6872]

With this change, mails with attachments of duplicate filename will not be processed
davsclaus:1662374873:2022-09-05T18:47:53.927+0000:1662374873:2022-09-05T18:47:53.927+0000:You can now set failOnDuplicateAttachment=true
mash-sap:1662533243:2022-09-07T14:47:23.951+0000:1662533243:2022-09-07T14:47:23.951+0000:Thanks for considering this request and improving the mail component (y)"
0,CAMEL-17585,Improvement,Minor,None,3.16.0,"
None
",Resolved,Fixed,3.16.0,Claus Ibsen,Marat Gubaidullin,0,2,2022-02-01 18:08:53+00:00,2022-02-02 11:26:26+00:00,There is no model metadata json for SagaOptionDefinition,"davsclaus:1643760821:2022-02-02T08:13:41.682+0000:1643760821:2022-02-02T08:13:41.682+0000:Yeah the saga model is a bit ""wrong""
davsclaus:1643763908:2022-02-02T09:05:08.700+0000:1643763908:2022-02-02T09:05:08.700+0000:This is one of those problems with jaxb and xml xsd generator that causes problems, if adding the option as a root type, then the xsd is invalid generated"
0,CAMEL-17584,Task,Minor,None,3.16.0,"
None
",Resolved,Fixed,3.16.0,Freeman Yue Fang,Freeman Yue Fang,0,1,2022-02-01 17:28:42+00:00,2022-02-01 18:47:08+00:00,The camelroutes actuator endpoint not enabled,ffang:1643707934:2022-02-01T17:32:14.057+0000:1643707934:2022-02-01T17:32:14.057+0000:xml-import example has the same issue
0,CAMEL-17583,Improvement,Major,None,3.16.0,"
None
",Resolved,Fixed,3.16.0,Claus Ibsen,Claus Ibsen,0,1,2022-02-01 14:56:51+00:00,2022-02-03 10:07:27+00:00,"If you for example have a app.properties file and routes that uses keys from this file, then it would be good to have this reloaded when using jbang in --reload mode.",
0,CAMEL-17582,Bug,Minor,2.16.3,,"
None
",Resolved,Invalid,None,Unassigned,Vincent Broucke,0,2,2022-02-01 14:02:23+00:00,2022-02-01 15:34:33+00:00,"We have a problem with an aggregation using the JdbcAggreationRepository in a distributed environment.


The scenario when the problem occurs is the following : we have a route that aggregates two messages received from RabbitMQ, let's say message1 and message2. Sometimes, message1 arrives on machine1 and message2 on machine2. We observe that information contained in message1 is lost when message2 is persisted to the database. We think that problem comes from AggregateProcessor in doAggregation method. We suppose that the aggregateProcessor1 and aggregateProcessor2 get nothing from the database : 


 




Exchange originalExchange = aggregationRepository.get(newExchange.getContext(), key);



Flow continues and aggregateProcessor1 wants to persist the exchange to the database using doAggregationRepositoryAdd methods :


 


 




doAggregationRepositoryAdd(newExchange.getContext(), key, originalExchange, answer);



When exchange is persisted, the aggregateProcessor2 wants also persists the exchange to the database but information contained in exchange1 will be lost because it uses the original exchange received from the database that was empty.


 


 


Have you encountered this problem? Is it fixed in another version?


 


Thank you,","davsclaus:1643695978:2022-02-01T14:12:58.630+0000:1643695978:2022-02-01T14:12:58.630+0000:Camel 2.x is EOL. 

Try with newer Camel version first.
v.broucke:1643700873:2022-02-01T15:34:33.003+0000:1643700873:2022-02-01T15:34:33.003+0000:Thank you for answer. We know that we use an EOL version of Camel but we cannot upgrade the version easilly..."
0,CAMEL-17581,Improvement,Major,None,3.16.0,"
None
",Resolved,Fixed,3.16.0,Claus Ibsen,Claus Ibsen,0,1,2022-02-01 10:40:14+00:00,2022-02-01 17:38:16+00:00,"This can be needed to be able to unbind a bean from the registry, such as when reloading routes and we want to update bean that has been changed, then we need to unbind first in case the bean was loaded using a new classloader",
0,CAMEL-17580,Improvement,Major,None,3.16.0,"
None
",Resolved,Fixed,3.16.0,Claus Ibsen,Claus Ibsen,0,1,2022-02-01 09:50:54+00:00,2022-02-02 15:12:33+00:00,"camel-main has configuration classes, but we can move this to camel-api and make it general. Then we can make this possible to run in all runtimes and not be tied to spring boot, quarkus etc.",
0,CAMEL-17579,Bug,Minor,"3.14.1, 3.15.0","3.14.2, 3.16.0","
None
",Resolved,Fixed,"3.14.2, 3.16.0",Nicolas Filotto,Nicolas Filotto,0,1,2022-02-01 09:19:24+00:00,2022-02-02 13:35:31+00:00,"While working on the example [`transformer-demo`|https://github.com/apache/camel-examples/tree/main/examples/transformer-demo,] I realized that it fails with the next error:


 


 




2022-01-31 10:46:43,910 [elClient.main()] ERROR DefaultErrorHandler            - Failed delivery for (MessageId: 2BE86653B2ADF34-0000000000000002 on ExchangeId: 2BE86653B2ADF34-0000000000000002). Exhausted after delivery attempt: 1 caught: org.apache.camel.InvalidPayloadException: No body available of type: org.apache.camel.example.transformer.demo.Order but has value: {""orderId"":""Order-JSON-0001"", ""itemId"":""MIZUYO-KAN"", ""quantity"":""16350""} of type: java.lang.String on: Message. Caused by: Error during type conversion from type: java.lang.String to the required type: org.apache.camel.example.transformer.demo.Order with value {""orderId"":""Order-JSON-0001"", ""itemId"":""MIZUYO-KAN"", ""quantity"":""16350""} due to javax.xml.bind.UnmarshalException: null. Exchange[2BE86653B2ADF34-0000000000000002]. Caused by: [org.apache.camel.TypeConversionException - Error during type conversion from type: java.lang.String to the required type: org.apache.camel.example.transformer.demo.Order with value {""orderId"":""Order-JSON-0001"", ""itemId"":""MIZUYO-KAN"", ""quantity"":""16350""} due to javax.xml.bind.UnmarshalException: null]
 
Message History (source location and message history is disabled)
---------------------------------------------------------------------------------------------------------------------------------------
Source                                   ID                             Processor                                          Elapsed (ms)
                                         json/json                      from[direct://json]                                          29
 ...
                                         java/wireTap1                  wireTap[direct:csv]                                           0
 
Stacktrace
---------------------------------------------------------------------------------------------------------------------------------------
org.apache.camel.InvalidPayloadException: No body available of type: org.apache.camel.example.transformer.demo.Order but has value: {""orderId"":""Order-JSON-0001"", ""itemId"":""MIZUYO-KAN"", ""quantity"":""16350""} of type: java.lang.String on: Message. Caused by: Error during type conversion from type: java.lang.String to the required type: org.apache.camel.example.transformer.demo.Order with value {""orderId"":""Order-JSON-0001"", ""itemId"":""MIZUYO-KAN"", ""quantity"":""16350""} due to javax.xml.bind.UnmarshalException: null. Exchange[2BE86653B2ADF34-0000000000000002]. Caused by: [org.apache.camel.TypeConversionException - Error during type conversion from type: java.lang.String to the required type: org.apache.camel.example.transformer.demo.Order with value {""orderId"":""Order-JSON-0001"", ""itemId"":""MIZUYO-KAN"", ""quantity"":""16350""} due to javax.xml.bind.UnmarshalException: null]
 at org.apache.camel.support.MessageSupport.getMandatoryBody(MessageSupport.java:125) ~[camel-support-3.15.0-SNAPSHOT.jar:3.15.0-SNAPSHOT]
 at org.apache.camel.processor.ContractAdvice.convertIfRequired(ContractAdvice.java:154) ~[camel-core-processor-3.15.0-SNAPSHOT.jar:3.15.0-SNAPSHOT]
 at org.apache.camel.processor.ContractAdvice.doTransform(ContractAdvice.java:134) ~[camel-core-processor-3.15.0-SNAPSHOT.jar:3.15.0-SNAPSHOT]
 at org.apache.camel.processor.ContractAdvice.before(ContractAdvice.java:69) ~[camel-core-processor-3.15.0-SNAPSHOT.jar:3.15.0-SNAPSHOT]
 at org.apache.camel.impl.engine.CamelInternalProcessor.process(CamelInternalProcessor.java:342) ~[camel-base-engine-3.15.0-SNAPSHOT.jar:3.15.0-SNAPSHOT]
 at org.apache.camel.component.direct.DirectProducer.process(DirectProducer.java:96) ~[camel-direct-3.15.0-SNAPSHOT.jar:3.15.0-SNAPSHOT]
 at org.apache.camel.processor.SendProcessor.process(SendProcessor.java:172) ~[camel-core-processor-3.15.0-SNAPSHOT.jar:3.15.0-SNAPSHOT]
 at org.apache.camel.processor.errorhandler.RedeliveryErrorHandler$SimpleTask.run(RedeliveryErrorHandler.java:471) [camel-core-processor-3.15.0-SNAPSHOT.jar:3.15.0-SNAPSHOT]
 at org.apache.camel.impl.engine.DefaultReactiveExecutor$Worker.schedule(DefaultReactiveExecutor.java:187) [camel-base-engine-3.15.0-SNAPSHOT.jar:3.15.0-SNAPSHOT]
 at org.apache.camel.impl.engine.DefaultReactiveExecutor.scheduleMain(DefaultReactiveExecutor.java:64) [camel-base-engine-3.15.0-SNAPSHOT.jar:3.15.0-SNAPSHOT]
 at org.apache.camel.processor.Pipeline.process(Pipeline.java:184) [camel-core-processor-3.15.0-SNAPSHOT.jar:3.15.0-SNAPSHOT]
 at org.apache.camel.impl.engine.CamelInternalProcessor.process(CamelInternalProcessor.java:399) [camel-base-engine-3.15.0-SNAPSHOT.jar:3.15.0-SNAPSHOT]
 at org.apache.camel.component.direct.DirectProducer.process(DirectProducer.java:96) [camel-direct-3.15.0-SNAPSHOT.jar:3.15.0-SNAPSHOT]
 at org.apache.camel.impl.engine.SharedCamelInternalProcessor.process(SharedCamelInternalProcessor.java:214) [camel-base-engine-3.15.0-SNAPSHOT.jar:3.15.0-SNAPSHOT]
 at org.apache.camel.impl.engine.SharedCamelInternalProcessor$1.process(SharedCamelInternalProcessor.java:111) [camel-base-engine-3.15.0-SNAPSHOT.jar:3.15.0-SNAPSHOT]
 at org.apache.camel.impl.engine.DefaultAsyncProcessorAwaitManager.process(DefaultAsyncProcessorAwaitManager.java:83) [camel-base-engine-3.15.0-SNAPSHOT.jar:3.15.0-SNAPSHOT]
 at org.apache.camel.impl.engine.SharedCamelInternalProcessor.process(SharedCamelInternalProcessor.java:108) [camel-base-engine-3.15.0-SNAPSHOT.jar:3.15.0-SNAPSHOT]
 at org.apache.camel.support.cache.DefaultProducerCache.send(DefaultProducerCache.java:199) [camel-support-3.15.0-SNAPSHOT.jar:3.15.0-SNAPSHOT]
 at org.apache.camel.impl.engine.DefaultProducerTemplate.send(DefaultProducerTemplate.java:176) [camel-base-engine-3.15.0-SNAPSHOT.jar:3.15.0-SNAPSHOT]
 at org.apache.camel.impl.engine.DefaultProducerTemplate.send(DefaultProducerTemplate.java:172) [camel-base-engine-3.15.0-SNAPSHOT.jar:3.15.0-SNAPSHOT]
 at org.apache.camel.impl.engine.DefaultProducerTemplate.send(DefaultProducerTemplate.java:137) [camel-base-engine-3.15.0-SNAPSHOT.jar:3.15.0-SNAPSHOT]
 at org.apache.camel.example.transformer.demo.client.CamelClient.main(CamelClient.java:84) [classes/:?]
 at jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method) ~[?:?]
 at jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) ~[?:?]
 at jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) ~[?:?]
 at java.lang.reflect.Method.invoke(Method.java:566) ~[?:?]
 at org.codehaus.mojo.exec.ExecJavaMojo$1.run(ExecJavaMojo.java:282) [exec-maven-plugin-1.6.0.jar:?]
 at java.lang.Thread.run(Thread.java:829) [?:?]
Caused by: org.apache.camel.TypeConversionException: Error during type conversion from type: java.lang.String to the required type: org.apache.camel.example.transformer.demo.Order with value {""orderId"":""Order-JSON-0001"", ""itemId"":""MIZUYO-KAN"", ""quantity"":""16350""} due to javax.xml.bind.UnmarshalException: null
 at org.apache.camel.converter.jaxb.FallbackTypeConverter.convertTo(FallbackTypeConverter.java:144) ~[camel-jaxb-3.15.0-SNAPSHOT.jar:3.15.0-SNAPSHOT]
 at org.apache.camel.converter.jaxb.FallbackTypeConverterLoader.lambda$registerFallbackConverters$0(FallbackTypeConverterLoader.java:44) ~[camel-jaxb-3.15.0-SNAPSHOT.jar:3.15.0-SNAPSHOT]
 at org.apache.camel.support.SimpleTypeConverter.convertTo(SimpleTypeConverter.java:101) ~[camel-support-3.15.0-SNAPSHOT.jar:3.15.0-SNAPSHOT]
 at org.apache.camel.impl.converter.CoreTypeConverterRegistry.doConvertTo(CoreTypeConverterRegistry.java:516) ~[camel-base-3.15.0-SNAPSHOT.jar:3.15.0-SNAPSHOT]
 at org.apache.camel.impl.converter.CoreTypeConverterRegistry.doConvertTo(CoreTypeConverterRegistry.java:356) ~[camel-base-3.15.0-SNAPSHOT.jar:3.15.0-SNAPSHOT]
 at org.apache.camel.impl.converter.CoreTypeConverterRegistry.mandatoryConvertTo(CoreTypeConverterRegistry.java:272) ~[camel-base-3.15.0-SNAPSHOT.jar:3.15.0-SNAPSHOT]
 at org.apache.camel.support.MessageSupport.getMandatoryBody(MessageSupport.java:123) ~[camel-support-3.15.0-SNAPSHOT.jar:3.15.0-SNAPSHOT]
 ... 27 more
Caused by: javax.xml.bind.UnmarshalException
 at com.sun.xml.bind.v2.runtime.unmarshaller.UnmarshallerImpl.handleStreamException(UnmarshallerImpl.java:455) ~[jaxb-impl-2.3.3.jar:2.3.3]
 at com.sun.xml.bind.v2.runtime.unmarshaller.UnmarshallerImpl.unmarshal0(UnmarshallerImpl.java:387) ~[jaxb-impl-2.3.3.jar:2.3.3]
 at com.sun.xml.bind.v2.runtime.unmarshaller.UnmarshallerImpl.unmarshal(UnmarshallerImpl.java:356) ~[jaxb-impl-2.3.3.jar:2.3.3]
 at org.apache.camel.converter.jaxb.FallbackTypeConverter.unmarshal(FallbackTypeConverter.java:298) ~[camel-jaxb-3.15.0-SNAPSHOT.jar:3.15.0-SNAPSHOT]
 at org.apache.camel.converter.jaxb.FallbackTypeConverter.unmarshall(FallbackTypeConverter.java:199) ~[camel-jaxb-3.15.0-SNAPSHOT.jar:3.15.0-SNAPSHOT]
 at org.apache.camel.converter.jaxb.FallbackTypeConverter.convertTo(FallbackTypeConverter.java:129) ~[camel-jaxb-3.15.0-SNAPSHOT.jar:3.15.0-SNAPSHOT]
 at org.apache.camel.converter.jaxb.FallbackTypeConverterLoader.lambda$registerFallbackConverters$0(FallbackTypeConverterLoader.java:44) ~[camel-jaxb-3.15.0-SNAPSHOT.jar:3.15.0-SNAPSHOT]
 at org.apache.camel.support.SimpleTypeConverter.convertTo(SimpleTypeConverter.java:101) ~[camel-support-3.15.0-SNAPSHOT.jar:3.15.0-SNAPSHOT]
 at org.apache.camel.impl.converter.CoreTypeConverterRegistry.doConvertTo(CoreTypeConverterRegistry.java:516) ~[camel-base-3.15.0-SNAPSHOT.jar:3.15.0-SNAPSHOT]
 at org.apache.camel.impl.converter.CoreTypeConverterRegistry.doConvertTo(CoreTypeConverterRegistry.java:356) ~[camel-base-3.15.0-SNAPSHOT.jar:3.15.0-SNAPSHOT]
 at org.apache.camel.impl.converter.CoreTypeConverterRegistry.mandatoryConvertTo(CoreTypeConverterRegistry.java:272) ~[camel-base-3.15.0-SNAPSHOT.jar:3.15.0-SNAPSHOT]
 at org.apache.camel.support.MessageSupport.getMandatoryBody(MessageSupport.java:123) ~[camel-support-3.15.0-SNAPSHOT.jar:3.15.0-SNAPSHOT]
 ... 27 more
Caused by: javax.xml.stream.XMLStreamException: ParseError at [row,col]:[1,1]
Message: Content is not allowed in prolog.
 at com.sun.org.apache.xerces.internal.impl.XMLStreamReaderImpl.next(XMLStreamReaderImpl.java:652) ~[?:?]
 at com.sun.xml.bind.v2.runtime.unmarshaller.StAXStreamConnector.bridge(StAXStreamConnector.java:134) ~[jaxb-impl-2.3.3.jar:2.3.3]
 at com.sun.xml.bind.v2.runtime.unmarshaller.UnmarshallerImpl.unmarshal0(UnmarshallerImpl.java:385) ~[jaxb-impl-2.3.3.jar:2.3.3]
 at com.sun.xml.bind.v2.runtime.unmarshaller.UnmarshallerImpl.unmarshal(UnmarshallerImpl.java:356) ~[jaxb-impl-2.3.3.jar:2.3.3]
 at org.apache.camel.converter.jaxb.FallbackTypeConverter.unmarshal(FallbackTypeConverter.java:298) ~[camel-jaxb-3.15.0-SNAPSHOT.jar:3.15.0-SNAPSHOT]
 at org.apache.camel.converter.jaxb.FallbackTypeConverter.unmarshall(FallbackTypeConverter.java:199) ~[camel-jaxb-3.15.0-SNAPSHOT.jar:3.15.0-SNAPSHOT]
 at org.apache.camel.converter.jaxb.FallbackTypeConverter.convertTo(FallbackTypeConverter.java:129) ~[camel-jaxb-3.15.0-SNAPSHOT.jar:3.15.0-SNAPSHOT]
 at org.apache.camel.converter.jaxb.FallbackTypeConverterLoader.lambda$registerFallbackConverters$0(FallbackTypeConverterLoader.java:44) ~[camel-jaxb-3.15.0-SNAPSHOT.jar:3.15.0-SNAPSHOT]
 at org.apache.camel.support.SimpleTypeConverter.convertTo(SimpleTypeConverter.java:101) ~[camel-support-3.15.0-SNAPSHOT.jar:3.15.0-SNAPSHOT]
 at org.apache.camel.impl.converter.CoreTypeConverterRegistry.doConvertTo(CoreTypeConverterRegistry.java:516) ~[camel-base-3.15.0-SNAPSHOT.jar:3.15.0-SNAPSHOT]
 at org.apache.camel.impl.converter.CoreTypeConverterRegistry.doConvertTo(CoreTypeConverterRegistry.java:356) ~[camel-base-3.15.0-SNAPSHOT.jar:3.15.0-SNAPSHOT]
 at org.apache.camel.impl.converter.CoreTypeConverterRegistry.mandatoryConvertTo(CoreTypeConverterRegistry.java:272) ~[camel-base-3.15.0-SNAPSHOT.jar:3.15.0-SNAPSHOT]
 at org.apache.camel.support.MessageSupport.getMandatoryBody(MessageSupport.java:123) ~[camel-support-3.15.0-SNAPSHOT.jar:3.15.0-SNAPSHOT]




 


 


After a deeper investigation, it appears that it occurs because the datatype of the message is lost after been copied by the ProcessorValidatorsuch that it ends up trying to convert a json payload with the JAXB fallback type converter which fails with the previous error.",essobedo:1643679042:2022-02-01T09:30:42.047+0000:1643679042:2022-02-01T09:30:42.047+0000:A potential fix for it https://github.com/apache/camel/pull/6866
0,CAMEL-17578,Improvement,Major,None,3.16.0,"
None
",Resolved,Fixed,3.16.0,Claus Ibsen,Claus Ibsen,0,1,2022-02-01 08:38:56+00:00,2022-02-01 17:38:24+00:00,"Such as when using Java DSL and there are custom converter classes from the source code, we should be able to easily add those. Currently the class is required to implement TypeConverter which is not needed by @Converter classes.",
0,CAMEL-17577,Bug,Minor,"3.14.1, 3.15.0","3.14.2, 3.16.0","
None
",Resolved,Fixed,"3.14.2, 3.16.0",Unassigned,Benjamin Graf,0,2,2022-02-01 07:16:18+00:00,2022-02-01 18:05:33+00:00,"Polling consumer using greedy flag to immediately poll again for large size of messages available are causing consumer health checks to fail for a possibly ""long"" time. In an environment like a Kubernates cluster this could cause recurring pod restarts that might tighten the need to use greedy because of a growing size of messages needed to be polled.


The variable firstPoolDone (btw rename to firstPollDone) in ScheduledPollConsumer should also be set true if first greedy run has been finished.","davsclaus:1643673745:2022-02-01T08:02:25.981+0000:1643673745:2022-02-01T08:02:25.981+0000:Do you work on a PR?
graben:1643674049:2022-02-01T08:07:29.853+0000:1643674049:2022-02-01T08:07:29.853+0000:I could deliver one until noon CET, okay?
davsclaus:1643674565:2022-02-01T08:16:05.489+0000:1643674565:2022-02-01T08:16:05.489+0000:Yes this is good, thanks
davsclaus:1643708514:2022-02-01T17:41:54.007+0000:1643708514:2022-02-01T17:41:54.007+0000:Thanks for reporting and the PR
davsclaus:1643708537:2022-02-01T17:42:17.037+0000:1643708537:2022-02-01T17:42:17.037+0000:You can turn off consumer health checks to use the same behavior as in previous camel releases
graben:1643709933:2022-02-01T18:05:33.482+0000:1643709933:2022-02-01T18:05:33.482+0000:I know, but it's nice to have it on. :) Unfortunately, I have to disable consumer health checks completely because the colon needed (camel.health.config[consumer{*}:{*}abc].enabled=false) does not work well with yaml files in OpenShift ConfigMaps."
0,CAMEL-17576,Improvement,Minor,3.15.0,3.16.0,"
None
",Resolved,Fixed,3.16.0,Claus Ibsen,Marat Gubaidullin,0,1,2022-01-31 20:17:48+00:00,2022-02-02 11:40:46+00:00,"Could sync baseUri attribute for Any23DataFormat?


it is baseUri in CameYamlDsl.json but baseURI in any23.json


 


https://github.com/apache/camel/blob/60a8242cec1e18643842d1a87c1f1fdf8d00590c/catalog/camel-catalog/src/generated/resources/org/apache/camel/catalog/models/any23.json#L19


 


https://github.com/apache/camel/blob/60a8242cec1e18643842d1a87c1f1fdf8d00590c/dsl/camel-yaml-dsl/camel-yaml-dsl/src/generated/resources/camelYamlDsl.json#L4187",
0,CAMEL-17575,Improvement,Major,3.16.0,3.16.0,"
None
",Resolved,Fixed,3.16.0,Claus Ibsen,Claus Ibsen,0,2,2022-01-31 14:09:03+00:00,2022-03-24 06:06:02+00:00,"We should update this example to use the new base package scanning, where we auto detect the route builders, type converters and configuration classes.","davsclaus:1644046715:2022-02-05T15:38:35.411+0000:1644046715:2022-02-05T15:38:35.411+0000:[~tmarwen] you are welcome to help with this ticket too. I have updated a few of the main-xxx examples, see main or main-lambda, and the commit diffs such as
https://github.com/apache/camel-examples/commit/33f5ae42b64f9085f9742b83aa3aa687d60a2f32

tmarwen:1644063047:2022-02-05T20:10:47.099+0000:1644063047:2022-02-05T20:10:47.099+0000:[~davsclaus] happy to help on this.

I will work on the remaining examples to use base package scanning.
davsclaus:1644128568:2022-02-06T14:22:48.363+0000:1644128568:2022-02-06T14:22:48.363+0000:Thanks Marouane I granted your user karma to self assign tickets in JIRA
davsclaus:1646626960:2022-03-07T12:22:40.975+0000:1646626960:2022-03-07T12:22:40.975+0000:Marourana do you have time to work on the remainder examples?
tmarwen:1646660757:2022-03-07T21:45:57.991+0000:1646660757:2022-03-07T21:45:57.991+0000:[~davsclaus] thanks for assigning the role to self-assign tickets.

Indeed, I have advanced on this and you should expect a PR by end of the week.

Unfortunately I have been slowed down by random test-failures that are totally unrelated to changes (as an example, the _camel-example-main-endpointdsl-aws2-s3-kafka_ modules tests are failing due to producer / consumer synchronization).
davsclaus:1646690786:2022-03-08T06:06:26.027+0000:1646690786:2022-03-08T06:06:26.027+0000:If the tests is also failing before you do changes then its okay to go ahead with your modifications.

And when you are done you are welcome to comment here, or create a new JIRA with details which examples you have seen test failures with.
tmarwen:1647574027:2022-03-18T11:27:07.518+0000:1647574152:2022-03-18T11:29:12.525+0000:[~davsclaus] I have pushed a PR with the implementation changes for most example main entries to use base package scanning.

Note that I have updated some examples to:
 * Add dynamic configuration ({{{}@Configuration{}}}) and services binding ({{{}@BindToRegistry{}}}) main application with respective test fixture such as for _camel-examples-netty-custom-correlation_ (You can refer to {{org.apache.camel.example.netty.MyServer}} as an example)
 * Updated some test fixtures to use base package scanning as well. I didn't apply this pattern to all examples waiting for more validation as this may be beneficial using the same configuration pattern for both main application and test implementation

I am already aware that the _Camel 3.16.0_ release is on the door and the ticket has been already moved to _3.17.0_ but since the release has been postponed, I pushed the changes to avoid extra main branch drifts. Let me know if I should update the PR once _Camel 3.16.0_ release is out to rebase it on the new release.
davsclaus:1647589203:2022-03-18T15:40:03.973+0000:1647589203:2022-03-18T15:40:03.973+0000:Thanks Marouane

Your work will make it into the 3.16.0 release.
davsclaus:1647589236:2022-03-18T15:40:36.624+0000:1647589236:2022-03-18T15:40:36.624+0000:You are welcome to keep contributing, you can find other things on JIRA, or reach out to us on the chat room.
tmarwen:1647669199:2022-03-19T13:53:19.098+0000:1647669199:2022-03-19T13:53:19.098+0000:Thanks [~davsclaus] for the validation.

Happy to bring more contribution, I will take a look into open issues and see where I can be of help."
0,CAMEL-17574,New Feature,Major,None,3.16.0,"
None
",Resolved,Fixed,3.16.0,Nicolas Filotto,Claus Ibsen,0,2,2022-01-31 14:08:03+00:00,2022-02-21 12:42:05+00:00,Testing camel-main apps could benefit from a camel-test-main module that makes this easier as you should not use CamelTestSupport for this but rely on setting up main and which classes to include / routes / configuration etc.,"essobedo:1644809510:2022-02-14T11:31:50.074+0000:1644809510:2022-02-14T11:31:50.074+0000:[~davsclaus] if it is ok with you, I can have a look to this one
davsclaus:1644815619:2022-02-14T13:13:39.992+0000:1644815619:2022-02-14T13:13:39.992+0000:Yes you are welcome
essobedo:1645093766:2022-02-17T18:29:26.099+0000:1645093766:2022-02-17T18:29:26.099+0000:The corresponding PR https://github.com/apache/camel/pull/6974"
0,CAMEL-17543,Improvement,Major,3.14.1,"3.14.2, 3.16.0","
None
",Resolved,Fixed,"3.14.2, 3.16.0",Andrea Cosentino,Andrea Cosentino,0,1,2022-01-24 12:43:24+00:00,2022-02-02 13:39:12+00:00,No Desc,
0,CAMEL-17542,Dependency upgrade,Minor,None,None,"
None
",Resolved,Fixed,3.15.0,Andrea Cosentino,Claus Ibsen,0,1,2022-01-24 12:17:02+00:00,2022-01-24 13:47:56+00:00,No Desc,
0,CAMEL-17541,Task,Major,None,3.15.0,"
None
",Resolved,Fixed,3.15.0,Claus Ibsen,Claus Ibsen,0,1,2022-01-24 08:17:04+00:00,2022-01-24 08:20:25+00:00,"The correct EIP name is toD but we use either to-d or tod in the kamelets.


You can find them via git grep xxxx


They should be renamed to toD","davsclaus:1642983431:2022-01-24T08:17:11.381+0000:1642983431:2022-01-24T08:17:11.381+0000:See also ticket
https://github.com/apache/camel-kamelets/issues/729"
0,CAMEL-17540,Improvement,Minor,3.x,3.15.0,"
None
",Resolved,Fixed,3.15.0,Claus Ibsen,Ashutosh Vaish,0,2,2022-01-23 15:43:39+00:00,2022-01-24 20:53:44+00:00,"We are using CamelJMS to connect with IBM MQ. We are doing request-reply over JMS. It was identified that our camel app is continuously polling the reply queues even when a unit of work was completed. I found that QueueReplyManager is coupled with DefaultMessageListenerContainer.


CamelJMS allows consumerType for JMS consumer to be Simple/Default/Custom. Why was it decided to use DefaultMessageListenerContainer for QueueReplyManager? Can we give a consumerType choice for this pattern too ?","davsclaus:1642927554:2022-01-23T16:45:54.998+0000:1642927554:2022-01-23T16:45:54.998+0000:Use the user chat / user mailing list to ask for help - not JIRA tickets
davsclaus:1642927582:2022-01-23T16:46:22.656+0000:1642927582:2022-01-23T16:46:22.656+0000:And the JMS component has a lot of options you can configure, read the doc please
ashu6397:1642927995:2022-01-23T16:53:15.810+0000:1642927995:2022-01-23T16:53:15.810+0000:Understood I will copy my questions over mailing list, thank you.
ashu6397:1642929122:2022-01-23T17:12:02.507+0000:1642929122:2022-01-23T17:12:02.507+0000:[~davsclaus] I have sent my question to [users@camel.apache.org|mailto:users@camel.apache.org.]

However my concern is with the actual code of QueueReplyManager. [createListenerContainer|https://javadoc.io/static/org.apache.camel/camel-jms/2.11.4/org/apache/camel/component/jms/reply/QueueReplyManager.html#createListenerContainer()] method has used DefaultMessageListenerContainer(DMLC). So even if I used consumerType camel JMS option it will default to DMLC which is a polling based consumer. I cannot find any other Camel JMS option which allows to switch over to SimpleMessageListenerContainer for request-reply hence I created an issue.
ashu6397:1642944360:2022-01-23T21:26:00.441+0000:1642944360:2022-01-23T21:26:00.441+0000:[~davsclaus] I would really appreciate if you could help here, we are in a big dilemma to continue using camel in-out pattern for our use case. As much I want to use camel this could be a deal breaker :(. We are actually connecting to mainframe IBM MQ and DefaultMessageListenerContainer polls the queue manager every second and causes high mainframe CPU usage (upto 100%). If I set the receiveTimeout greater than 1000L I do not get response fast, since the message sits in the queue until the next poll. Attaching some other forums threads explaining the same issue

[https://community.ibm.com/community/user/integration/viewdocument/top-tip-when-using-ibm-mq-and-the-s?CommunityKey=b382f2ab-42f1-4932-aa8b-8786ca722d55]

[https://stackoverflow.com/questions/14384038/spring-mdp-polling-interval]

 
ashu6397:1642944438:2022-01-23T21:27:18.123+0000:1642944438:2022-01-23T21:27:18.123+0000:I'm reopening the issue, if you feel there is no other alternative I will surely close this out.
davsclaus:1643012663:2022-01-24T16:24:23.049+0000:1643012663:2022-01-24T16:24:23.049+0000:You can now configure the consumerReplyToType to be Simple.
ashu6397:1643028824:2022-01-24T20:53:44.441+0000:1643028824:2022-01-24T20:53:44.441+0000:[~davsclaus] thanks for this update!"
0,CAMEL-17539,Task,Major,None,Future,"
None
",Open,Unresolved,Future,Unassigned,Claus Ibsen,0,1,2022-01-23 11:17:16+00:00,2023-08-09 09:13:54+00:00,"They are currently in the dsl folder. Lets moved them to their own jbang folder, and build it after dsl.",
0,CAMEL-17538,Dependency upgrade,Major,None,None,"
None
",Resolved,Fixed,3.15.0,James Netherton,Claus Ibsen,0,2,2022-01-23 08:49:03+00:00,2022-01-24 07:55:48+00:00,"The components in camel-microprofile are using older versions, when you get a chance do you mind taking a look and upgrading to newer so we are up to date again.","jamesnetherton:1642982144:2022-01-24T07:55:44.086+0000:1642982144:2022-01-24T07:55:44.086+0000:Bumped to the latest releases in this commit:

https://github.com/apache/camel/commit/7096caa4863791b5573eb1d66b4b70fb4ad0d0ab"
0,CAMEL-17537,Dependency upgrade,Minor,None,None,"
None
",Resolved,Fixed,3.17.0,Nicolas Filotto,Claus Ibsen,0,1,2022-01-22 17:31:12+00:00,2022-04-28 10:03:57+00:00,"There is newer version of deep learning, we should upgrade",
0,CAMEL-17536,Bug,Major,3.14.0,"3.14.1, 3.15.0","
None
",Resolved,Fixed,"3.14.1, 3.15.0",Claus Ibsen,Krzysztof Jamróz,0,2,2022-01-21 16:38:34+00:00,2022-01-24 16:00:45+00:00,"Camel sometimes hangs (100% usage of 1 CPU) during shutdown. This occurs intermittently during integration testing. We use recipientList to perform some dynamic routing and many messages can be processed in parallel threads by recipientList and there are a few of them in different routes (this will be important in a moment).


Stack trace of stuck thread:



""SpringApplicationShutdownHook"" #18 prio=5 os_prio=0 cpu=1784989.37ms elapsed=1790.21s tid=0x00007f7a13520000 nid=0xa80 runnable  [0x00007f79a3af5000]
   java.lang.Thread.State: RUNNABLE
    at org.apache.camel.support.cache.ServicePool.stop(ServicePool.java:193)
    at org.apache.camel.support.cache.ServicePool$$Lambda$2274/0x000000084108fc40.accept(Unknown Source)
    at java.util.LinkedHashMap$LinkedValues.forEach(java.base@11.0.13/LinkedHashMap.java:608)
    at org.apache.camel.support.cache.ServicePool.doStop(ServicePool.java:181)
    at org.apache.camel.support.service.BaseService.stop(BaseService.java:160)
    - locked <0x00000000e3ece780> (a java.lang.Object)
    at org.apache.camel.support.service.ServiceHelper.stopService(ServiceHelper.java:162)
    at org.apache.camel.support.cache.DefaultProducerCache.doStop(DefaultProducerCache.java:399)
    at org.apache.camel.support.service.BaseService.stop(BaseService.java:160)
    - locked <0x00000000e3ece740> (a java.lang.Object)
    at org.apache.camel.support.service.ServiceHelper.stopService(ServiceHelper.java:162)
    at org.apache.camel.support.service.ServiceHelper.stopService(ServiceHelper.java:147)
    at org.apache.camel.processor.RecipientList.doStop(RecipientList.java:222)
    at org.apache.camel.support.service.BaseService.stop(BaseService.java:160)
    - locked <0x00000000e3ecdb00> (a java.lang.Object)
    at org.apache.camel.support.service.ServiceHelper.stopService(ServiceHelper.java:162)
    at org.apache.camel.support.service.ServiceHelper.stopService(ServiceHelper.java:165)
    at org.apache.camel.support.service.ServiceHelper.stopService(ServiceHelper.java:147)
    at org.apache.camel.processor.Pipeline.doStop(Pipeline.java:226)
    at org.apache.camel.support.service.BaseService.stop(BaseService.java:160)
    - locked <0x00000000e3ecda48> (a java.lang.Object)
    at org.apache.camel.support.service.ServiceHelper.stopService(ServiceHelper.java:162)
    at org.apache.camel.support.service.ServiceHelper.stopService(ServiceHelper.java:147)
    at org.apache.camel.impl.engine.DefaultChannel.doStop(DefaultChannel.java:134)
    at org.apache.camel.support.service.BaseService.stop(BaseService.java:160)
    - locked <0x00000000e3eccde0> (a java.lang.Object)
    at org.apache.camel.support.service.ServiceHelper.stopService(ServiceHelper.java:162)
    at org.apache.camel.support.service.ServiceHelper.stopAndShutdownServices(ServiceHelper.java:257)
    at org.apache.camel.support.service.ServiceHelper.stopAndShutdownServices(ServiceHelper.java:215)
    at org.apache.camel.processor.errorhandler.RedeliveryErrorHandler.doShutdown(RedeliveryErrorHandler.java:1665)
    at org.apache.camel.support.ChildServiceSupport.shutdown(ChildServiceSupport.java:113)
    - locked <0x00000000e3ecc1e8> (a java.lang.Object)
    at org.apache.camel.support.service.ServiceHelper.stopAndShutdownService(ServiceHelper.java:233)
    at org.apache.camel.impl.engine.RouteService.stopChildServices(RouteService.java:409)
    at org.apache.camel.impl.engine.RouteService.doStop(RouteService.java:260)
    at org.apache.camel.support.ChildServiceSupport.stop(ChildServiceSupport.java:86)
    - locked <0x00000000e40873a0> (a java.lang.Object)
    at org.apache.camel.support.service.ServiceHelper.stopService(ServiceHelper.java:162)
    at org.apache.camel.support.service.ServiceHelper.stopAndShutdownService(ServiceHelper.java:227)
    at org.apache.camel.impl.engine.AbstractCamelContext.shutdownServices(AbstractCamelContext.java:3559)
    at org.apache.camel.impl.engine.AbstractCamelContext.shutdownServices(AbstractCamelContext.java:3584)
    at org.apache.camel.impl.engine.AbstractCamelContext.doStop(AbstractCamelContext.java:3366)
    at org.apache.camel.spring.boot.SpringBootCamelContext.doStop(SpringBootCamelContext.java:61)
    - locked <0x00000000e221e658> (a org.apache.camel.spring.boot.SpringBootCamelContext)
    at org.apache.camel.support.service.BaseService.stop(BaseService.java:160)
    - locked <0x00000000e221e8a8> (a java.lang.Object)
    at org.apache.camel.impl.engine.AbstractCamelContext.stop(AbstractCamelContext.java:2640)
    at org.apache.camel.spring.SpringCamelContext.stop(SpringCamelContext.java:128)
    at org.springframework.context.support.DefaultLifecycleProcessor.doStop(DefaultLifecycleProcessor.java:247)
    at org.springframework.context.support.DefaultLifecycleProcessor.access$300(DefaultLifecycleProcessor.java:54)
    at org.springframework.context.support.DefaultLifecycleProcessor$LifecycleGroup.stop(DefaultLifecycleProcessor.java:373)
    at org.springframework.context.support.DefaultLifecycleProcessor.stopBeans(DefaultLifecycleProcessor.java:206)
    at org.springframework.context.support.DefaultLifecycleProcessor.onClose(DefaultLifecycleProcessor.java:129)
    at org.springframework.context.support.AbstractApplicationContext.doClose(AbstractApplicationContext.java:1067)
    at org.springframework.context.support.AbstractApplicationContext.close(AbstractApplicationContext.java:1021)
    - locked <0x00000000e11e3868> (a java.lang.Object)
    at org.springframework.boot.SpringApplicationShutdownHook.closeAndWait(SpringApplicationShutdownHook.java:137)
    at org.springframework.boot.SpringApplicationShutdownHook$$Lambda$2265/0x0000000841088440.accept(Unknown Source)
    at java.lang.Iterable.forEach(java.base@11.0.13/Iterable.java:75)
    at org.springframework.boot.SpringApplicationShutdownHook.run(SpringApplicationShutdownHook.java:106)
    at java.lang.Thread.run(java.base@11.0.13/Thread.java:829)



Deeper inspection of heap dump reveals that linked list in ServicePool.cache is corrupted and has a loop, which causes foreach to loop infinitely (see attached screenshot from heapdump analysis).


Access to ServicePool.cache is not synchronized even though LinkedHashMap is not thread-safe. There is at least one code path that can add to the cache it concurrently (and indeed in this seems to happen in our tests):



org.apache.camel.processor.MulticastProcessor.process(Exchange, AsyncCallback)
org.apache.camel.processor.RecipientListProcessor.createProcessorExchangePairs(Exchange)
org.apache.camel.processor.RecipientListProcessor.doCreateProcessorExchangePairs(Exchange, Object, List<ProcessorExchangePair>, int)
org.apache.camel.support.cache.DefaultProducerCache.acquireProducer(Endpoint)
org.apache.camel.support.cache.ServicePool.acquire(Endpoint)
org.apache.camel.support.cache.ServicePool.cache



There are also a few unsynchronized invocations of DefaultProducerCache.acquireProducer from other processors.


I am not sure if other usages of cache need to be synchronized, maybe Camel lifecycle provides enough serialization.
 
The simpliest solution is to wrap cache in Collections.synchronizedMap but this might have negative impact on performance.","krzysztofjamroz:1642761064:2022-01-21T18:31:04.557+0000:1642761064:2022-01-21T18:31:04.557+0000:I created a fix [https://github.com/apache/camel/pull/6806|https://github.com/apache/camel/pull/6806]. 
{{Collections.synchronizedMap}} cannot be used because we would loose information if {{cache}} is {{LRUCache}}.
krzysztofjamroz:1642763981:2022-01-21T19:19:41.109+0000:1642764024:2022-01-21T19:20:24.840+0000:Switch in Camel from Caffeine to DefaultLRUCache as default  (only?) cache in CAMEL-16093 makes the problem more likely "
0,CAMEL-17535,Bug,Minor,3.14.0,None,"
None
",Resolved,Fixed,3.16.0,Karen Lease,Karen Lease,0,2,2022-01-21 16:36:57+00:00,2022-02-12 21:43:56+00:00,The example camel-example-spring-boot-rest-openapi-springdoc generates a swagger OpenAPI document which doesn't contain the correct context path. The Swagger UI isn't able to execute the operations because it doesn't include the /api in the path.,"klease78:1642755353:2022-01-21T16:55:53.598+0000:1642755353:2022-01-21T16:55:53.598+0000:The workaround mentioned in CAMEL-17139:

 
{code:java}
springdoc:
    swagger-ui:
        url: ${camel.rest.context-path}${camel.rest.api-context-path}
{code}
does resolve the problem by working around the root cause.
The root cause is that the OpenAPI bean generated by SpringdocAutoConfiguration does not set the URL for the api doc, because it assumes Springdoc should set it. But Springdoc only uses its own context path (server.servlet.context-path) and does not append the camel.rest.context-path. 
Forcing the swagger-ui.url property to include both the Spring context-path (if any) and the Camel context-path will override the link to the generated API docs. In fact, this causes the Swagger UI to refer to the OpenAPI doc which is generated by the code in camel-openapi-java which correctly generates a relative URL. The incorrect doc generated by the Springdoc configuration is present but is not referenced from the SwaggerUI.
Ideally, the Camel springdoc starter component would generate the correct relative URL so that users are not obliged to use the workaround.
 
davsclaus:1644621785:2022-02-12T07:23:05.914+0000:1644621785:2022-02-12T07:23:05.914+0000:Is there more work for this ticket, or can it be resolved?
klease78:1644673436:2022-02-12T21:43:56.192+0000:1644673436:2022-02-12T21:43:56.192+0000:The issue is resolved. It might be worth mentioning in the documentation for camel-springdoc that it only works using the ""servelet"" component for the REST configuration. I tried to make it work with jetty but with no success since using the camel-jetty-starter doesn't provide a ServletWebServerFactory bean for the Spring web context which is needed to serve the Swagger UI."
0,CAMEL-17534,Improvement,Major,None,Future,"
None
",Open,Unresolved,Future,Unassigned,Claus Ibsen,0,1,2022-01-21 14:04:53+00:00,2023-06-19 12:04:20+00:00,"The DSL model for EIPs is based on Java OO and JAXB and it have some impact on the model.


Some EIPs like Choice, DoTry, and others end up having some of their specific nodes like otherwise, doCatch, when etc part of the general model.


So from DSL point of view then users can constuct ""none valid"" routes.


JAXB is a bit brittle when you tweak it and we generate the XML XSD based on it, so we are under its mercy.


However its time to see if we can make the model more strict and then better be able to source code generate all DSLs languages (even Java) without having to have hacks.",
0,CAMEL-17533,Task,Major,None,3.15.0,"
None
",Resolved,Fixed,3.15.0,Andrea Cosentino,Andrea Cosentino,0,1,2022-01-21 13:42:43+00:00,2022-01-21 13:44:45+00:00,It's totally not OSGi-friendly and with newer version it's going to be worse.,
0,CAMEL-17532,Dependency upgrade,Minor,None,3.15.0,"
None
",Resolved,Fixed,3.15.0,James Netherton,James Netherton,0,1,2022-01-21 12:06:46+00:00,2022-01-21 15:30:12+00:00,"Since the implementation of CAMEL-17476 things are a bit out of sync in terms of dependencies for Google mail, drive, calendar & sheets. It'd be good to have them all aligned with the 1.32.1 variant of the relevant google-api-services dependencies.",
0,CAMEL-17531,Improvement,Major,None,3.15.0,"
None
",Resolved,Fixed,3.15.0,Claus Ibsen,Claus Ibsen,0,1,2022-01-21 12:03:36+00:00,2022-01-21 15:11:26+00:00,"We should source code generate known multi value options and their prefix, then we can use that in the send dynamic aware.",
0,CAMEL-17530,New Feature,Major,3.14.0,4.x,"
None
",Open,Unresolved,4.x,Unassigned,Reneesh,0,1,2022-01-21 10:26:48+00:00,2023-08-09 09:14:09+00:00,"Problem:
While accessing files from Azure blob in a concurrent executions environment, there is no way in which the file can be locked or leased by the application using Camel URI options or configurations, this results in executing the same file by different process if its available and cause exception while performing file processing and ended up in error.


Solution:
Azure API supports a Lease Blob operation, which can be used to lease a file for some duration while processing a file and later lease can be released upon completing the file processing. It will help in preventing the file being accessed by different process. 


Reference : https://docs.microsoft.com/en-us/rest/api/storageservices/lease-blob


It would be great if we can improve the camel azure storage component with this feature for upcoming releases or versions.",
0,CAMEL-17529,Dependency upgrade,Major,None,"3.14.1, 3.15.0","
None
",Resolved,Fixed,"3.14.1, 3.15.0",Claus Ibsen,Claus Ibsen,0,1,2022-01-21 09:05:51+00:00,2022-01-21 09:07:43+00:00,No Desc,
0,CAMEL-17528,Improvement,Major,None,"4.0-RC1, 4.0.0","
None
",Resolved,Fixed,"4.0-RC1, 4.0.0",Claus Ibsen,Claus Ibsen,0,1,2022-01-21 08:09:48+00:00,2023-06-19 14:23:34+00:00,"Today its mapped as



description
lang



But lets keep this simpler and just have it as description so we can do




<route id=""foo"" description=""something great ..."">




instead of 




<route id=""foo"">
  <description>Something great</description>
  ...",davsclaus:1662173624:2022-09-03T10:53:44.805+0000:1662174542:2022-09-03T11:09:02.248+0000:We can deprecate lang *DONE* and then later adjust
0,CAMEL-17527,Improvement,Minor,None,3.15.0,"
None
",Resolved,Fixed,3.15.0,Unassigned,skepticoitus interuptus,0,2,2022-01-20 19:47:35+00:00,2022-01-21 09:03:15+00:00,"The following command:




mvn help:describe -Dplugin=org.apache.camel:sync-properties-maven-plugin -Ddetail



...displays the following description of the org.apache.camel:sync-properties-maven-plugin (emphasis mine):




    ...
    Name: Camel :: Maven Plugins :: Sync Properties
    Description: Maven plugin to help generating Sync Properties between POMs
    
    ...
    sync-properties:sync-properties  
    Description: Copy the properties *in* a POM *in* a different POM for syncing purpose.
    ...



Consider Camel's source-to-sink metaphor. Think about how that metaphor relates the concepts of ""in"" and ""out"" to the Camel DSL's ""from()"" and ""to()"" semantics.


Applying those source-to-sink (""out"" and ""in"", ""from"" and ""to"") semantics to the original description of the SyncPropertiesMojo, and substituting the word ""in"" with the word it semantically corresponds to in the Camel source-to-sink metaphor, you would get:


 
Copy the properties from a POM from a different POM...


Would it not, therefore, be both more grammatically correct (in the English language) and clearer semantically to instead say:


Copy the properties from a POM to a different POM...",acosentino:1642681219:2022-01-20T20:20:19.324+0000:1642681219:2022-01-20T20:20:19.324+0000:It makes totally sense. For this kind of task a PR is enough no need for an issue.
0,CAMEL-17526,Bug,Major,None,3.15.0,"
None
",Resolved,Fixed,3.15.0,Freeman Yue Fang,Freeman Yue Fang,0,2,2022-01-20 19:22:43+00:00,2022-01-21 12:25:45+00:00,"Currently it always uses the serverUrl configration from camel-fhir component level, if it's null from component level, then even we configure it correctly on the endpoint level, it is still ignored.


Our current ITests don't catch this error because always set serverUrl on the camel-fhir component AbstractFhirTestSupport","ffang:1642678157:2022-01-20T19:29:17.237+0000:1642678157:2022-01-20T19:29:17.237+0000:This [PR|https://github.com/apache/camel/pull/6796/commits/9bfac71d49ddb6825af6a68a52270a6280e8086f] addressed it.
Also revised FhirCreateIT test to expose this problem
davsclaus:1642727015:2022-01-21T09:03:35.912+0000:1642727015:2022-01-21T09:03:35.912+0000:Should we backport this to 3.14.x ?
ffang:1642739092:2022-01-21T12:24:52.034+0000:1642739092:2022-01-21T12:24:52.034+0000:Hi [~davsclaus],

3.14.x doesn't have this problem. But I will backport the test there.

Cheers
Freeman"
0,CAMEL-17525,Improvement,Minor,None,None,"
None
",Resolved,Fixed,3.15.0,Claus Ibsen,Claus Ibsen,0,1,2022-01-20 19:14:39+00:00,2022-01-21 16:35:11+00:00,No Desc,
0,CAMEL-17524,Bug,Minor,3.14.0,"3.14.1, 3.15.0","
None
",Resolved,Fixed,"3.14.1, 3.15.0",Unassigned,Ryan Yeats,0,1,2022-01-20 18:04:59+00:00,2022-01-22 17:29:26+00:00,"https://issues.apache.org/jira/browse/CAMEL-17116 changed how resources were loaded in several components the problem being that now they don't use the classloader of the class making the resource calls in OSGi environments. Its a simple change to call the method loadResourceAsStream(String name, ClassLoader loader) and passing in the calling classes class loader instead of loadResourceAsStream(String name).","davsclaus:1642727063:2022-01-21T09:04:23.395+0000:1642727063:2022-01-21T09:04:23.395+0000:You are welcome to send a PR
davsclaus:1642728403:2022-01-21T09:26:43.178+0000:1642728576:2022-01-21T09:29:36.561+0000:camel-schematron fixed
camel-quartz already fixed
camel-jslt already fixed
camel-xmlsecurity fixed
ryeats:1642776198:2022-01-21T22:43:18.981+0000:1642776198:2022-01-21T22:43:18.981+0000:Sorry, I would have put up a PR right when i wrote the ticket but it took me a while to get my development environment working for camel and everything good to build. I checked your fix and it looks like you missed ClassPathURIResolver.java  resource loading call so I went ahead and pushed an additional PR up with that fix and a couple other places that may have the same issue.
ryeats:1642776250:2022-01-21T22:44:10.279+0000:1642776250:2022-01-21T22:44:10.279+0000:The fix that was originally applied did not fully resolve the issue.
davsclaus:1642811199:2022-01-22T08:26:39.660+0000:1642811199:2022-01-22T08:26:39.660+0000:We do not support all components in OSGi such as jbpm etc so they should not be changed
davsclaus:1642843766:2022-01-22T17:29:26.509+0000:1642843766:2022-01-22T17:29:26.509+0000:Ryan, thanks for the fixes. We had to rush this as we are building the 3.14.1 release later this weekend"
0,CAMEL-17523,Bug,Major,None,3.15.0,"
None
",Resolved,Fixed,3.15.0,Freeman Yue Fang,Freeman Yue Fang,0,1,2022-01-20 16:26:09+00:00,2022-01-20 18:32:12+00:00,No Desc,ffang:1642667546:2022-01-20T16:32:26.727+0000:1642667546:2022-01-20T16:32:26.727+0000:This [PR|https://github.com/apache/camel-spring-boot-examples/pull/45] fixed this up
0,CAMEL-17522,Dependency upgrade,Major,3.11.5,3.11.6,"
None
",Resolved,Fixed,3.11.6,Claus Ibsen,Claus Ibsen,0,1,2022-01-20 12:22:56+00:00,2022-01-23 09:52:20+00:00,No Desc,
0,CAMEL-17521,Bug,Major,"3.11.5, 3.14.0","3.11.6, 3.14.1, 3.15.0","
None
",Resolved,Fixed,"3.11.6, 3.14.1, 3.15.0",Claus Ibsen,Claus Ibsen,0,1,2022-01-20 11:01:43+00:00,2022-01-21 12:03:42+00:00,"When using httpClient.SocketTimeout=555555 then that gets included in the HTTP GET url that the client is sending to the server.


Reported on chat at
https://camel.zulipchat.com/#narrow/stream/257298-camel/topic/http.20query.20parameter/near/268668471","davsclaus:1642737662:2022-01-21T12:01:02.976+0000:1642737662:2022-01-21T12:01:02.976+0000:We should source code generate known multi value options and their prefix, then we can use that in the send dynamic aware.
"
0,CAMEL-17520,Bug,Minor,3.12.0,"3.14.1, 3.15.0","
None
",Resolved,Fixed,"3.14.1, 3.15.0",Claus Ibsen,Pasquale Congiusti,0,2,2022-01-20 09:32:04+00:00,2022-01-20 19:21:49+00:00,"It was reported on mailing list, there is some problem when trying to use square brackets as part of the URI params. I've run some expertiment with the RAW() function, but this is only applied to the value parameter, not the variable name (ie, param=RAW(value)).


As a reproducer, we may run this route (ie, via Camel K):




// camel-k: language=java

import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.model.rest.RestParamType;
import org.apache.camel.Exchange;

public class Test extends RouteBuilder {
  @Override
  public void configure() throws Exception {
      rest()
          .get(""/hello"")
          .param().name(""test[bogus]"").type(RestParamType.query).defaultValue(""false"").description(""Just for testing"").endParam()
          .to(""direct:hello"");

      from(""direct:hello"")
          .setHeader(Exchange.CONTENT_TYPE, constant(""text/plain""))
          .setBody().simple(""${headers.test[bogus]}"");

      // Write your routes here, for example:
      from(""timer:java?period=3000"")
        .to(""http://localhost:8080/hello?test[bogus]=true"")
        .log(""${body}"");
  }
}




It will end up with error:




[1] Caused by: org.apache.camel.ResolveEndpointFailedException: Failed to resolve endpoint: http://localhost:8080/hello?test%5Bbogus%5D=true due to: Error binding property (test[bogus]=true) with name: test[bogus] on bean: http://localhost:8080/hello?test%5Bbogus%5D=true with value: true
[1]     at org.apache.camel.impl.engine.AbstractCamelContext.doGetEndpoint(AbstractCamelContext.java:963)
[1]     at org.apache.camel.impl.engine.AbstractCamelContext.getEndpoint(AbstractCamelContext.java:845)
[1]     at org.apache.camel.support.CamelContextHelper.resolveEndpoint(CamelContextHelper.java:123)
[1]     at org.apache.camel.reifier.SendReifier.resolveEndpoint(SendReifier.java:43)
[1]     at org.apache.camel.reifier.SendReifier.createProcessor(SendReifier.java:36)
[1]     at org.apache.camel.reifier.ProcessorReifier.makeProcessor(ProcessorReifier.java:838)
[1]     at org.apache.camel.reifier.ProcessorReifier.addRoutes(ProcessorReifier.java:579)
[1]     at org.apache.camel.reifier.RouteReifier.doCreateRoute(RouteReifier.java:236)
[1]     ... 31 more
[1] Caused by: org.apache.camel.PropertyBindingException: Error binding property (test[bogus]=true) with name: test[bogus] on bean: http://localhost:8080/hello?test%5Bbogus%5D=true with value: true
[1]     at org.apache.camel.support.PropertyBindingSupport.doSetPropertyValue(PropertyBindingSupport.java:476)
[1]     at org.apache.camel.support.PropertyBindingSupport.doBuildPropertyOgnlPath(PropertyBindingSupport.java:326)
[1]     at org.apache.camel.support.PropertyBindingSupport.doBindProperties(PropertyBindingSupport.java:210)
[1]     at org.apache.camel.support.PropertyBindingSupport.access$100(PropertyBindingSupport.java:88)
[1]     at org.apache.camel.support.PropertyBindingSupport$Builder.bind(PropertyBindingSupport.java:1789)
[1]     at org.apache.camel.support.DefaultEndpoint.setProperties(DefaultEndpoint.java:413)
[1]     at org.apache.camel.support.DefaultEndpoint.configureProperties(DefaultEndpoint.java:388)
[1]     at org.apache.camel.support.DefaultComponent.setProperties(DefaultComponent.java:425)
[1]     at org.apache.camel.component.http.HttpComponent.createEndpoint(HttpComponent.java:377)
[1]     at org.apache.camel.support.DefaultComponent.createEndpoint(DefaultComponent.java:171)
[1]     at org.apache.camel.impl.engine.AbstractCamelContext.doGetEndpoint(AbstractCamelContext.java:929)
[1]     ... 38 more
[1] Caused by: java.lang.IllegalArgumentException: Cannot set property: test[bogus] as a Map because target bean has no setter method for the Map
[1]     at org.apache.camel.support.PropertyBindingSupport.setPropertyCollectionViaReflection(PropertyBindingSupport.java:523)
[1]     at org.apache.camel.support.PropertyBindingSupport.doSetPropertyValue(PropertyBindingSupport.java:453)
[1]     ... 48 more




Trying to apply the RAW() function on the parameter (ie, ?RAW(test[bogus])=true) does not convert the parameter, but create a new one called RAW(test[bogus])","davsclaus:1642664967:2022-01-20T15:49:27.720+0000:1642664967:2022-01-20T15:49:27.720+0000:Yeah so its because that filter parameter is not a known option on the endpoint - what we need to make sure in the core was that we know its lenient properties on HTTP endpoints and therefore should ignore that there is not a option called test on the endpoint. 

I have a pending fix

"
0,CAMEL-17519,Improvement,Minor,3.14.0,"3.11.6, 3.14.1, 3.15.0","
None
",Resolved,Fixed,"3.11.6, 3.14.1, 3.15.0",James Netherton,James Netherton,0,1,2022-01-20 09:14:21+00:00,2022-01-20 15:54:29+00:00,"It would enable some main configuration options to be picked up by Camel Quarkus. See issue reported here:


https://github.com/apache/camel-quarkus/issues/3394


Maybe also split the logic in internalBeforeStart into protected methods so that stuff can also be overridden if needed.",
0,CAMEL-17518,Bug,Major,None,None,"
None
",Resolved,Incomplete,None,Unassigned,Bhamini Bhat,0,2,2022-01-20 07:58:09+00:00,2022-01-21 16:51:14+00:00,Error creating bean with name 'camelContext': Instantiation of bean failed; nested exception is org.springframework.beans.BeanInstantiationException: Failed to instantiate [org.apache.camel.CamelContext]: Specified class is an interface.,"acosentino:1642636876:2022-01-20T08:01:16.891+0000:1642636876:2022-01-20T08:01:16.891+0000:Please:

* Report what is the Camel version you're using
* Report the route you're using
* Report configuration
* Maybe provide a little reproducer or at least a snippet of the code you're using

"
0,CAMEL-17517,Improvement,Major,None,3.15.0,"
None
",Resolved,Fixed,3.15.0,Freeman Yue Fang,Freeman Yue Fang,0,1,2022-01-19 21:06:45+00:00,2022-01-20 06:18:21+00:00,"Currently the fhir camel-spring-boot example requires to install FHIR server separately, and recommend to use 
https://github.com/Zorking/hapi-fhir-jpaserver-example
However, this project is out-of-maintainence and broken(I can't build it). 


I think it's better we install the working docker image as a FHIR server  so that we can run this example OOTB.",ffang:1642598030:2022-01-19T21:13:50.592+0000:1642598030:2022-01-19T21:13:50.592+0000:A [PR|https://github.com/apache/camel-spring-boot-examples/pull/44] to address this
0,CAMEL-17516,Bug,Major,"3.11.1, 3.11.5",3.14.0,"
None
",Resolved,Duplicate,3.14.0,Unassigned,Stefano Rocca,0,1,2022-01-19 18:34:44+00:00,2022-01-19 19:41:28+00:00,"While setting up a route template, if you use a parameter named like an environment variable, camel resolves first the environment variable and ignores the value of the parameter set using the TemplateRouteBuilder.


Here follows a short program that exhibit this behaviour (this code is also attached to this issue as ""sample_code.txt"")


import org.apache.camel.CamelContext;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.builder.TemplatedRouteBuilder;
import org.apache.camel.main.ConfigureRouteTemplates;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;


public class Main {
    
    public static final Logger LOG = LoggerFactory.getLogger(Main.class);
    
    public static class MyRouteBuilder extends RouteBuilder {
        
        public void configure() throws Exception {
            routeTemplate(""myTemplate"")
                .templateParameter(""name"")
                .templateParameter(""path"")
                .templateParameter(""myPeriod"", ""3s"")
                .from(""timer:{{name}}?period={{myPeriod}}"")
                    .log(""{{path}}"");
        }
    }


    public static class MyTemplateBuilder implements ConfigureRouteTemplates {
        public void configure(CamelContext context) 

{
            TemplatedRouteBuilder.builder(context, ""myTemplate"")
                .parameter(""name"", ""one"")
                .parameter(""path"", ""test path"")
            .add();
        }


    }
    public static void main(String[] args) throws Exception


{         org.apache.camel.main.Main m = new org.apache.camel.main.Main();         m.configure().addRoutesBuilder(MyRouteBuilder.class);         m.bind(""myTemplateBuilder"", new MyTemplateBuilder());         m.run(args);     }


}


This sample code, when run with Camell 3.11.1 or 3.11.5, outputs the content of the PATH variable.
If you run it with Camel 3.14.0, it outputs ""test path"".",
0,CAMEL-17515,Improvement,Minor,3.14.0,3.17.0,"
None
",Resolved,Fixed,3.17.0,Claus Ibsen,Babak Vahdat,0,2,2022-01-19 16:52:57+00:00,2022-04-04 10:34:10+00:00,https://camel.zulipchat.com/#narrow/stream/257298-camel/topic/.E2.9C.94.20timout.20of.20DefaultShutdownStrategy,"bvahdat:1642582949:2022-01-19T17:02:29.851+0000:1642582949:2022-01-19T17:02:29.851+0000:My current workaround is:

{{export CAMEL_MAIN_SHUTDOWNTIMEOUT=1}}
davsclaus:1648696020:2022-03-31T11:07:00.742+0000:1648696020:2022-03-31T11:07:00.742+0000:The link seems broken it shows an empty chat thread
davsclaus:1648700853:2022-03-31T12:27:33.661+0000:1648700853:2022-03-31T12:27:33.661+0000:However thinking about this - if a k8s container is terminating a pod, then it knows that its being terminated and should ideally regard it as ""NOT READY"" and stop sending traffic to it.

If a graceful shutdown is taking a longer time, and could that affect some monitoring systems that would ""report a problem"" if the camel app is ""NOT READY"" for a longer time (where it does not know it is being shutdown).

To be conservative then it sounds better to say ""NOT READY"" when graceful shutdown is started to stop sending new traffic, and allow Camel to shutdown cleanly.
davsclaus:1649039650:2022-04-04T10:34:10.293+0000:1649039650:2022-04-04T10:34:10.293+0000:Camel is now always DOWN during stopping/graceful shutdown"
0,CAMEL-17514,Bug,Minor,"3.13.0, 3.14.0","3.14.1, 3.15.0","
None
",Resolved,Fixed,"3.14.1, 3.15.0",Claus Ibsen,Michael Rambichler,0,3,2022-01-19 12:45:21+00:00,2022-02-17 16:25:38+00:00,"Expected Behaviour:


If UseMDCLogging=true and UseBreadcrumb=true is set then i expect then everywhere the MDC Value camel.breadcrumbId is set.


like it works in Camel Version < 3.12


Reproducable 
Camel Version > 3.11
 
Hint: If I use a custom UnitOfWorkFactory it works as expected. But I would assume that If MDCLogging is enabled then the DefaultUnitOfWork would handle this.
 
Log without MDC camel.Breadcrumb:
2022-01-19 12:01:00,335 INFO  [1 - timer://foo] route1                                   [route1 0141fbc5-bb47-4458-a982-1e6585109b8a] - Received exchange with breadcrumbID: 0141fbc5-bb47-4458-a982-1e6585109b8a
2022-01-19 12:01:00,337 INFO  [1 - timer://foo] c.t.a.r.h.HelloBreadcrumbRoute           [route1 0141fbc5-bb47-4458-a982-1e6585109b8a] - Process with bug
2022-01-19 12:01:00,338 INFO  [1 - timer://foo] c.t.a.r.h.OnExceptionProcessor           [***breadcrumbMissing***] - Some OnException process
2022-01-19 12:01:00,344 INFO  [1 - timer://foo] route2                                   [route2 ***breadcrumbMissing***] - Deadletter receive
 
Example:
@Override
public void configure() throws Exception {


   getContext().setUseMDCLogging(true);
   getContext().setUseBreadcrumb(true);


   DeadLetterChannelBuilder errorHandlerBuilder = new DeadLetterChannelBuilder();
   errorHandlerBuilder.setDeadLetterUri(""direct:deadletterTest"");
   errorHandlerBuilder.setOnExceptionOccurred(onExceptionProcessor);
   errorHandler(errorHandlerBuilder);


   from(""timer://foo?fixedRate=true&period=10000"")
      .log(""Received exchange with breadcrumbID: ${in.headers.breadcrumbId}"")
      .process(exchange -> 

{
          throw new Exception(""Some Bug"");
      }

);


   from(""direct:deadletterTest"")
      .log(""Deadletter received ${body}"");
   }


 
OnExceptionProcessor:
@Component
public class OnExceptionProcessor implements Processor {


   private static final Logger LOG = LoggerFactory.getLogger(OnExceptionProcessor.class);


   @Override
   public void process(Exchange exchange) throws Exception 

{
      LOG.info(""Some OnException process"");
   }

}","davsclaus:1642813680:2022-01-22T09:08:00.705+0000:1642813680:2022-01-22T09:08:00.705+0000:Have a pending fix. Needs some polish and improvements to unit tests.
vandenbrink@zorgdomein.nl:1644213872:2022-02-07T14:04:32.497+0000:1644213872:2022-02-07T14:04:32.497+0000:Hello [~davsclaus], I'm running into this issue as well, but the fix applied to 3.14.1 and 3.15.0 doesn't work for me. All MDC values are missing in the actual log output, the camel values (like breadcrumbId and routeId), but also values I add from my own code. I had to revert back to 3.11.5 to get it working again."
0,CAMEL-17513,Dependency upgrade,Major,None,None,"
None
",Resolved,Won't Fix,3.x,Unassigned,Claus Ibsen,0,1,2022-01-19 08:02:07+00:00,2022-09-03 10:53:00+00:00,No Desc,
0,CAMEL-17512,Improvement,Minor,None,3.17.0,"
None
",Resolved,Fixed,3.17.0,Claus Ibsen,James Netherton,0,2,2022-01-19 07:33:28+00:00,2022-05-11 05:36:05+00:00,"Originally reported here:


https://github.com/apache/camel-quarkus/issues/3461


If toD is used in routes, then the tracing SpanDecorator does not resolve the placeholder values (not sure if it's possible?). So when the recorded spans are viewed in a UI, it looks bit weird and confusing because it's not obvious where the trace events originated from.","davsclaus:1642663202:2022-01-20T15:20:02.654+0000:1642663202:2022-01-20T15:20:02.654+0000:Cannot reproduce this, when using toD and a JMS endpoint I see the resolved URI, eg jms:queue:blah



jamesnetherton:1642665379:2022-01-20T15:56:19.803+0000:1642665379:2022-01-20T15:56:19.803+0000:I'll check on the Camel Quarkus side and try to craft a unit test to replicate if it is broken.
davsclaus:1642677757:2022-01-20T19:22:37.728+0000:1642677757:2022-01-20T19:22:37.728+0000:Thanks, I was just doing a basic unit test in camel-opentelemetry, but debugging then I noticed that both the pre and post span had the resolved endpoint from toD
jamesnetherton:1643168303:2022-01-26T11:38:23.273+0000:1643168303:2022-01-26T11:38:23.273+0000:I think I tracked down why this issue happens. It only affects JMS endpoints or any component that extends camel-jms.

Here's where the URI is resolved:

https://github.com/apache/camel/blob/80b92e3624ae5db59a1a24a441f1b10b39eaa1a5/components/camel-jms/src/main/java/org/apache/camel/component/jms/JmsSendDynamicAware.java#L75-L78

The 'replaceFirst' part effectively replaces the dynamic queue name with the original toD expression. Not sure if this necessary or whether it could just return entry.getUri().

davsclaus:1643171986:2022-01-26T12:39:46.416+0000:1643171986:2022-01-26T12:39:46.416+0000:That is needed as otherwise you end up creating gazillion of endpoint instances as they have unique urls.
davsclaus:1643172032:2022-01-26T12:40:32.911+0000:1643172032:2022-01-26T12:40:32.911+0000:You can get the queue name via exchange header JmsConstants.JMS_DESTINATION_NAME - then you can modify the spam decorator to use this
davsclaus:1643328464:2022-01-28T08:07:44.767+0000:1643328464:2022-01-28T08:07:44.767+0000:I took a quick attempt, here is a PR
https://github.com/apache/camel/pull/6844

Would be good to get this testing with quarkus / jaeger. 

Because we then would need to do similar for other messaging decorators (kafka, amqp, rabbit etc.)"
0,CAMEL-17511,Bug,Minor,3.14.0,"3.14.1, 3.15.0","
None
",Resolved,Fixed,"3.14.1, 3.15.0",Unassigned,ncasaux,0,2,2022-01-18 22:35:57+00:00,2022-01-19 19:48:04+00:00,"Hello,


Currently, the endpoints of the camelroutes Springboot actuator are partially working. Indeed, the ones with parameters are not working.


As a result, we can not query the endpoint which allows to get routes INFO or DETAIL, or to STOP/START a route. For example, we can not query




/actuator/camelroutes/hello/INFO



which should returns infos about the ""hello"" route. We receive a HTTP 400 Bad request instead.


 


In the springboot doc, it says that for those parameters to work properly, the code should be compiled with ""-parameters"" arg (See https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#actuator.endpoints.implementing-custom.input).


I believe that camel-spring-boot is not compiled this way.


FYI, I had to change 




<maven.compiler.source>1.8</maven.compiler.source>
<maven.compiler.target>1.8</maven.compiler.target>



Previous values were 1.7 for both.","davsclaus:1642592577:2022-01-19T19:42:57.842+0000:1642592577:2022-01-19T19:42:57.842+0000:How do you make maven compiler plugin compile with ""-parameters"" ? their doc is vague
davsclaus:1642592775:2022-01-19T19:46:15.125+0000:1642592775:2022-01-19T19:46:15.125+0000:Okay found it via their parent pom
https://search.maven.org/artifact/org.springframework.boot/spring-boot-starter-parent/2.6.2/pom
davsclaus:1642592831:2022-01-19T19:47:11.445+0000:1642592831:2022-01-19T19:47:11.445+0000:Okay have a fix with
https://github.com/apache/camel-spring-boot/commit/e6dc657d4fede0278b59c21040f493ae923e0521"
0,CAMEL-17510,New Feature,Major,None,3.15.0,"
None
",Resolved,Fixed,3.15.0,Claus Ibsen,Claus Ibsen,0,1,2022-01-18 18:12:36+00:00,2022-01-19 19:38:00+00:00,"We have today: camel-yaml-dsl.json 


We also need a new: camelYamlDsl.json
which is in camelCase format.",
0,CAMEL-17509,Improvement,Major,None,"3.14.1, 3.15.0","
None
",Resolved,Fixed,"3.14.1, 3.15.0",Otavio Rodolfo Piske,Otavio Rodolfo Piske,0,1,2022-01-18 08:47:09+00:00,2022-01-18 12:56:03+00:00,"There are several circumstances in the consumer when we refer to the topic name in log messages (for example [1]). However, the code may not necessarily need to be connected to a single topic as we support topic patterns.


Our log messages should be clearer about this.


 


1. https://github.com/apache/camel/blob/camel-3.14.0/components/camel-kafka/src/main/java/org/apache/camel/component/kafka/KafkaFetchRecords.java#L247-L260",orpiske:1642481763:2022-01-18T12:56:03.006+0000:1642481763:2022-01-18T12:56:03.006+0000:Fixed and backported.
0,CAMEL-17508,Improvement,Major,None,3.15.0,"
None
",Resolved,Fixed,3.15.0,Claus Ibsen,Claus Ibsen,0,1,2022-01-18 06:27:49+00:00,2022-01-18 07:53:39+00:00,"from(""direct:start"")
                        .process(""#class:org.apache.camel.processor.EchoProcessor"")
                        .to(""mock:result"");",
0,CAMEL-17507,Task,Minor,3.14.0,3.19.0,"
None
",Resolved,Fixed,3.19.0,Claus Ibsen,ldawson,0,2,2022-01-17 18:57:47+00:00,2022-09-03 11:12:16+00:00,"I've been trying to figure out how route errors to my own error handler with the following, seemingly simple configuration, but Camel is swallowing the exception without routing it to any error handler I configure. I've run out of ideas. Any help would be much appreciated.


I've got a seda route that supports multiple consumers:




@Component
public class MessageGenerator {
public static final String ERROR_GENERATOR_CHANNEL = ""seda:my-error-generator?multipleConsumers=true&concurrentConsumers=3"";
  private final FluentProducerTemplate producerTemplate;
  public MessageGenerator(FluentProducerTemplate producerTemplate) {
    this.producerTemplate = producerTemplate;
  }
  public void generateMessage() {
    producerTemplate
        .to(ERROR_GENERATOR_CHANNEL)
        .withBody(""Hello World"")
        .asyncSend();
  }
}



 


I've got two separate POJO consumers:




@Configuration
public class MessageConsumer1 {
  @Consume(ERROR_GENERATOR_CHANNEL)
  void receiveMessage(String message) {
    System.out.println(""Received message 1: "" + message);
    throw new NullPointerException(""Error generated"");
  }
}





@Configuration
public class MessageConsumer2 {

  @Consume(ERROR_GENERATOR_CHANNEL)
  void receiveMessage(String message) {
    System.out.println(""Received message 2: "" + message);
  }

}



 


When I run the following example, the `NullPointerException` gets swallowed by the underlying Camel `MulticastProcessor` as we can see in the debug logs:




Received message 2: Hello World
Received message 1: Hello World
2022-01-15 13:40:23.711 DEBUG 32945 — [error-generator] o.a.camel.processor.MulticastProcessor   : Message exchange has failed: Multicast processing failed for number 0 for exchange: Exchange[] Exception: java.lang.NullPointerException: Error generated
2022-01-15 13:40:23.711 DEBUG 32945 — [error-generator] o.a.camel.processor.MulticastProcessor   : Message exchange has failed: Multicast processing failed for number 0 for exchange: Exchange[] Exception: java.lang.NullPointerException: Error generated 



 


The exception only gets logged as debug and never gets propagated to any error handler I set up.


Any thoughts on how I could receive the error in my own error handler rather than Camel swallowing the exception as a debug statement? Seems like there may be a bug here.


Note1: I've attempted many variations on both default error handling and default dead letter handling to no avail. I could just be doing it wrong...


Note2: that I'm using Spring[Boot] here too, hence the `@Configuration` annotation.


Note3: I've created a stack overflow question for this[ here|https://stackoverflow.com/questions/70725713/camel-no-error-handler-invoked-on-exception-with-multipleconsumer-true-and-pojo].","davsclaus:1642464230:2022-01-18T08:03:50.040+0000:1642464332:2022-01-18T08:05:32.307+0000:The @Consume POJO annotations are not part of any Camel routes, and you cannot use errorHandler / onException with that.
They are isolated consumers.

How exceptions are handled depends, in your example you send via a producer template in async mode. The result of that can contain the exception.
ldawson:1642494217:2022-01-18T16:23:37.980+0000:1642494873:2022-01-18T16:34:33.646+0000:[~davsclaus] Thanks for the follow-up. Should've mentioned that I also checked the response to no avail. When I look at the response in the Future<Exchange>, I still see no indication that there was an exception. Doing the following produces null output for both:
{code:java}
Future<Exchange> exchangeFuture = producerTemplate
    .to(ERROR_GENERATOR_CHANNEL)
    .withBody(""Hello World"")
    .asyncSend();

Exchange exchange = exchangeFuture.get();
System.out.println(""Exception: "" + exchange.getException());
System.out.println(""Handled exception: "" + exchange.getProperty(Exchange.EXCEPTION_CAUGHT, Throwable.class));{code}
Seems like the Future might be prematurely completing:
{code:java}
2022-01-18 08:20:44.552  INFO 49590 --- [           main] com.example.camel.errors.AppCamelErrors  : Starting application bootstrapping...
Exception: null
Handled exception: null
2022-01-18 08:20:44.562  INFO 49590 --- [           main] com.example.camel.errors.AppCamelErrors  : Started AppCamelErrors in 2.915 seconds (JVM running for 3.575)
Received message 2: Hello World
Received message 1: Hello World
2022-01-18 08:20:45.561 DEBUG 49590 --- [error-generator] o.a.camel.processor.MulticastProcessor   : Message exchange has failed: Multicast processing failed for number 0 for exchange: Exchange[] Exception: java.lang.NullPointerException: Error generated
2022-01-18 08:20:45.561 DEBUG 49590 --- [error-generator] o.a.camel.processor.MulticastProcessor   : Message exchange has failed: Multicast processing failed for number 0 for exchange: Exchange[] Exception: java.lang.NullPointerException: Error generated
{code}
Perhaps there may be a bug here.
ldawson:1642494557:2022-01-18T16:29:17.581+0000:1642494557:2022-01-18T16:29:17.581+0000:[~davsclaus] Re-opening for further conversation. I've added additional information. Let me know your thoughts & we can close again if necessary.
ldawson:1642494658:2022-01-18T16:30:58.124+0000:1642494658:2022-01-18T16:30:58.124+0000:{quote}The @Consume POJO annotations are not part of any Camel routes, and you cannot use errorHandler / onException with that.
{quote}
[~davsclaus] Would it be worthwhile to add this to the POJO consumer documentation? If so, I'd be happy to take a crack at this.
davsclaus:1642500657:2022-01-18T18:10:57.662+0000:1642500657:2022-01-18T18:10:57.662+0000:Yes you are very welcome to help with the documentation and improve the pojo pages.
davsclaus:1662174736:2022-09-03T11:12:16.808+0000:1662174736:2022-09-03T11:12:16.808+0000:docs updated"
0,CAMEL-17506,Bug,Minor,"2.25.2, 3.14.0","3.14.1, 3.15.0","
None
",Resolved,Fixed,"3.14.1, 3.15.0",Unassigned,Damien B,0,2,2022-01-17 14:51:51+00:00,2022-01-18 18:20:22+00:00,"In org.apache.camel.component.olingo4.api.impl.Olingo4AppImpl , the following snippet of code is used to decide wether we receive an entity or an entitySet on a read query with a keyPredicate:




List<UriParameter> keyPredicates = uriResourceEntitySet.getKeyPredicates();
// Check result type: single Entity or EntitySet based
// on key predicate detection
if (keyPredicates.size() == 1) {
  response = (T) odataReader.readEntity(content, getResourceContentType(uriInfo));
} else {
  response = (T) odataReader.readEntitySet(content, getResourceContentType(uriInfo));
} 



It assumes that if we have multiple parts in the key predicate, then we expect several entities in the response. But as we can see in OData Version 4.01. Part 2: URL Conventions (oasis-open.org) 4.3.6 example 26, a key predicate with several parts is just that, a multi-part key predicate still adressing a single entity.","davsclaus:1642407843:2022-01-17T16:24:03.926+0000:1642407843:2022-01-17T16:24:03.926+0000:Tis code is from the creator of the component about the predicate.

The switch case is a entitySet so its a bit weird if the result is not a set.


damienb:1642411872:2022-01-17T17:31:12.256+0000:1642467832:2022-01-18T09:03:52.113+0000:In OData 4, when you query with a (primary) key predicate, you expect either a single entity or nothing. If some OData 4 servers reply with an entity set, then it's a misuse of the protocol.
davsclaus:1642417050:2022-01-17T18:57:30.430+0000:1642417050:2022-01-17T18:57:30.430+0000:Okay, are you able to fix this by sending a PR against the main or 3.14.x branch
damienb:1642466826:2022-01-18T08:47:06.686+0000:1642466826:2022-01-18T08:47:06.686+0000:I'll take the time yes.
damienb:1642493558:2022-01-18T16:12:38.307+0000:1642493558:2022-01-18T16:12:38.307+0000:https://github.com/apache/camel/pull/6781
davsclaus:1642501222:2022-01-18T18:20:22.638+0000:1642501222:2022-01-18T18:20:22.638+0000:Thanks for the PR"
0,CAMEL-17505,Improvement,Major,None,3.20.0,"
None
",Resolved,Fixed,3.20.0,Nicolas Filotto,Claus Ibsen,0,2,2022-01-17 14:36:03+00:00,2022-11-07 14:34:44+00:00,"For Java DSL then we have a data format builder at org.apache.camel.builder.DataFormatClause


This class is very verbose as for Java DSL we have overloaded methods to set the various options, but it can get too far like xmlSecurity with 15 methods.


Instead, we should propose a builder DSL class that the RouteBuilder can provide.



marshal(
    dataFormat()
        .secureXml()
            .optionA(bla bla)
            .optionB(bla bla)
            .optionC(bla bla)
        .end()
)



Then we can still manually add a few methods for common use cases, so you can do marshal().secureXml(bla bla, true).","nfilotto:1666398659:2022-10-22T08:30:59.597+0000:1666566528:2022-10-24T07:08:48.433+0000:The problem, I'm facing with {{DataFormatClause}} is related to the fact that we already have some existing methods without parameters like {{avro()}} or {{base64()}} which prevent us to use the same name to access the builders. Any idea of another name that we could use? {{withAvro()}} / {{end()}}? {{avroBuilder()}} / {{end()}}? {{builder()}} / {{build()}}?
nfilotto:1666573140:2022-10-24T08:59:00.486+0000:1666573140:2022-10-24T08:59:00.486+0000:The other question that I have regarding this issue is: is it really worth implementing a generator? I mean, we don't have so many data formats and we don't add data formats so often.
nfilotto:1666583514:2022-10-24T11:51:54.137+0000:1666583514:2022-10-24T11:51:54.137+0000:[~davsclaus] Any ideas/remarks/suggestions about it? Thank you in advance
davsclaus:1666584285:2022-10-24T12:04:45.285+0000:1666584285:2022-10-24T12:04:45.285+0000:Yeah for 3.x its not worth the trouble.

In the future we should work on a  canonical model DSL where we 100% source code generate all DSLs, and therefore also generate a Java DSL where setting options in data formats, languages are easier.


davsclaus:1666584577:2022-10-24T12:09:37.280+0000:1666584577:2022-10-24T12:09:37.280+0000:For 3.x if you want to experiment, then there could be a DataFormatBuilder which you then need to use as argument into marshal / unmarshal

Maybe something ala:

marshal(dataFormatBuilder().secureXml())
        .optionA(bla bla)
        .optionB(bla bla)
        .optionC(bla bla)
)

And it can maybe be shorter named

marshal(dataFormat().secureXml())
        .optionA(bla bla)
        .optionB(bla bla)
        .optionC(bla bla)
)

Where dataFormat() is a method in RouteBuilder.

Mind this is just from top of my head, without any looking in the code
nfilotto:1666751544:2022-10-26T10:32:24.671+0000:1666751544:2022-10-26T10:32:24.671+0000:The corresponding PR https://github.com/apache/camel/pull/8626
nfilotto:1667798058:2022-11-07T13:14:18.660+0000:1667798058:2022-11-07T13:14:18.660+0000:Part 2 https://github.com/apache/camel/pull/8678"
0,CAMEL-17504,Bug,Minor,3.14.0,"3.14.1, 3.15.0","
None
",Resolved,Fixed,"3.14.1, 3.15.0",Claus Ibsen,Benjamin Graf,0,2,2022-01-17 13:15:59+00:00,2022-01-18 09:17:09+00:00,"Using BridgeExceptionHandlerToErrorHandler marks new Exchange as delivery exhausted




exchange.adapt(ExtendedExchange.class).setRedeliveryExhausted(true);




Link to Code


but SimpleTask in RedeliveryErrorHandler must be not exhausted.




boolean failure = exchange.getException() != null
    && !ExchangeHelper.isFailureHandled(exchange)
    && !exchange.isRedeliveryExhausted();

if (failure) {
    // previous processing cause an exception
    handleException();
    onExceptionOccurred();
    prepareExchangeAfterFailure(exchange);
    // we do not support redelivery so continue callback
    AsyncCallback cb = callback;
    taskFactory.release(this);
    reactiveExecutor.schedule(cb);
}




Link to Code


Seems to be broken somewhere after 3.7.x","davsclaus:1642401507:2022-01-17T14:38:27.849+0000:1642401507:2022-01-17T14:38:27.849+0000:Do you have a real world use-case / example that is affected in a camel upgrade or something?
graben:1642417096:2022-01-17T18:58:16.508+0000:1642417096:2022-01-17T18:58:16.508+0000:Sure, have a look into  [^camel-bridge.zip]. It still works with latest 3.7.x release but fails on 3.14.0. As you can see it polls multiple failure messages which are ""skipped"" by ErrorHandler and further processed.
davsclaus:1642468629:2022-01-18T09:17:09.384+0000:1642468629:2022-01-18T09:17:09.384+0000:Thanks for reporting and the test case"
0,CAMEL-17503,Bug,Minor,3.12.0,"3.11.6, 3.14.1, 3.15.0","
None
",Resolved,Fixed,"3.11.6, 3.14.1, 3.15.0",Unassigned,CG Poh,0,2,2022-01-17 06:03:40+00:00,2022-01-20 14:51:44+00:00,Camel AHC-WS client unable to reconnect to Server whenever the server reboots. The reConnect() in WsEndpoint.java get called but is not calling the connect() function.,"davsclaus:1642370784:2022-01-17T06:06:24.010+0000:1642370784:2022-01-17T06:06:24.010+0000:What version of Camel do you use, and can you make an example that can reproduce this issue?
cgp:1642380878:2022-01-17T08:54:38.177+0000:1642380878:2022-01-17T08:54:38.177+0000:We are using Camel K 1.7.0 which is using Camel 3.12.0. Our server is private and the code below is the snippet of the client connecting to it
{code:java}
fromF(""ahc-wss://private-server-url&bridgeErrorHandler=true&sendMessageOnError=true"")
  .filter(exchange -> exchange.getIn().getBody() != null)
  .toF(""kafka:%s?brokers=%s&groupId=%s&bridgeErrorHandler=true"", kafkaTopic, kafkaBrokers, kafkaGroupId);{code}
davsclaus:1642388921:2022-01-17T11:08:41.463+0000:1642388921:2022-01-17T11:08:41.463+0000:You are welcome to attempt to fix this and send a PR
cgp:1642558957:2022-01-19T10:22:37.736+0000:1642558957:2022-01-19T10:22:37.736+0000:Thanks, I will look into that
davsclaus:1642661504:2022-01-20T14:51:44.856+0000:1642661504:2022-01-20T14:51:44.856+0000:Thanks for the PR"
0,CAMEL-17502,Improvement,Minor,None,Future,"
None
",Open,Unresolved,Future,Unassigned,Claus Ibsen,0,1,2022-01-16 18:13:52+00:00,2023-08-09 09:14:18+00:00,"How to use a custom event notifier to listen to camel events, such as context stopping etc.",
0,CAMEL-17501,Bug,Minor,3.7.5,"3.11.6, 3.14.1, 3.15.0","
None
",Resolved,Fixed,"3.11.6, 3.14.1, 3.15.0",Claus Ibsen,Mingu Song,0,2,2022-01-16 16:14:33+00:00,2022-01-17 22:46:49+00:00,"In my case, the route string is a bit complex and long.


So the sanitizeUri function was not finished and camel context was stuck.


How about cut the route string first, then check and sanitize string.


I think it is better way and improving performance.


Please check this and let me change this.




protected static String getRouteMessage(String route) {
    // ensure to sanitize uri's in the route so we do not show sensitive information such as passwords
    route = URISupport.sanitizeUri(route);

    // cut the route after 60 chars so it won't be too big in the message
    // users just need to be able to identify the route so they know where to look
    if (route.length() > 60) {
        return route.substring(0, 60) + ""..."";
    } else {
        return route;
    }
}","davsclaus:1642328556:2022-01-16T18:22:36.594+0000:1642328556:2022-01-16T18:22:36.594+0000:Can you explain in more details what your problem was, what was not finished, and what was stuck
songmingu:1642345861:2022-01-16T23:11:01.157+0000:1642345861:2022-01-16T23:11:01.157+0000:Ok, our project use camel xml format with spring boot. (camel-spring-boot-starter:3.7.5)

Please see the attachment ""sample_xml.txt"". (This xml has syntax errors.)

And I test as blow.

In processing addRouteDefinitions, URISupport.sanitizeUri() function was not finished in FailedToCreateRouteException.getRouteMessage().
{code:java}
ExtendedCamelContext extendedCamelContext = camelContext.adapt(ExtendedCamelContext.class);
ModelCamelContext modelCamelContext = camelContext.adapt(ModelCamelContext.class);

try {
    InputStream is = new ByteArrayInputStream(routeXml.getBytes(StandardCharsets.UTF_8));
    RoutesDefinition routes = (RoutesDefinition) extendedCamelContext.getXMLRoutesDefinitionLoader().loadRoutesDefinition(camelContext, is);

    camelContext.getShutdownStrategy().setTimeout(5);
    camelContext.getShutdownStrategy().setSuppressLoggingOnTimeout(true);
    camelContext.getShutdownStrategy().setLogInflightExchangesOnTimeout(true);
    camelContext.setShutdownRunningTask(ShutdownRunningTask.CompleteCurrentTaskOnly);
    modelCamelContext.addRouteDefinitions(routes.getRoutes());
} catch (Exception exception) {
    exception.printStackTrace();
} {code}
songmingu:1642401233:2022-01-17T14:33:53.890+0000:1642401233:2022-01-17T14:33:53.890+0000:[~davsclaus] Our project use camel 3.7.5 version. Could you add to fix for 3.7.5 version?
davsclaus:1642402215:2022-01-17T14:50:15.336+0000:1642402215:2022-01-17T14:50:15.336+0000:No Camel 3.7.x is EOL and not supported anymore"
0,CAMEL-17500,Improvement,Minor,None,3.15.0,"
None
",Resolved,Fixed,3.15.0,Steve Storck,Steve Storck,0,3,2022-01-16 14:02:34+00:00,2022-01-28 13:41:57+00:00,"User Story:


As a user of the Dynamic Router EIP component, I want to be able to subscribe with URL parameters so that I am not required to create a control message POJO to send as the message body.


Description / Explanation:


While a control channel POJO gives full control over the subscription or unsubscription, it would be more convenient to be able to send these messages from a routing participant by using URL parameters.  Creating the control channel message for subscription looks like this:




DynamicRouterControlMessage billingSubMsg = new SubscribeMessageBuilder()
                .id(""billingSubscription"")
                .channel(""billing"")
                .priority(10)
                .endpointUri(myBillingNotificationUri)
                .predicate(new SomeBillingPredicate())
                .build(); 



Then this is sent to the dynamic router control channel by:




template.sendBody(""dynamic-router:control"", billingSubMsg);



The above could be simplified and combined by using the URI to specify the message:




template.sendBody(""dynamic-router:control/subscribe/billing?subscriptionId=billingSubscription&endpointUri=jms:billing&priority=10&predicate=${bodyAs(String)} regex '^\\d*[02468]$'"");



Alternatives can include:



Creating a Predicate as a bean, and referencing that bean as the predicate
Instantiating a Predicate and sending that predicate as the message body
Omitting the subscriptionId parameter, so that a subscription ID is generated and returned



Similarly, unsubscribing can be achieved by:


 




template.sendBody(""dynamic-router:control/unsubscribe/billing?subscriptionId=billingSubscription);



 


Acceptance Criteria:



Subscribing with all URI params:
	
given: All necessary dependencies present for setting up a route with the dynamic router component
when: Routing participant sends empty message body to the dynamic router with the subscription URI beginning with ""dynamic-router:control/subscribe/{channel name}"" and all other params
then: Routing participant is subscribed with all supplied values


Unsubscribing:
	
given: All necessary dependencies present for setting up a route with the dynamic router component, and routing participant has a valid subscription ID and channel name
when: Routing participant sends empty message body to the dynamic router with the subscription URI beginning with ""dynamic-router:control/unsubscribe/{channel name}"" and the subscription ID
then: Routing participant is unsubscribed for that channel and that subscription ID


Subscribing with URI params and Predicate bean:
	
given: All necessary dependencies present for setting up a route with the dynamic router component, and a Predicate bean has been registered in the registry
when: Routing participant sends an empty message to the dynamic router with the subscription URI beginning with ""dynamic-router:control/subscribe/{channel name}"", the predicate parameter referencing the predicate bean, and all other params
then: Routing participant is subscribed with all supplied values


Subscribing with URI params and Predicate as message body:
	
given: All necessary dependencies present for setting up a route with the dynamic router component and a Predicate has been instantiated
when: Routing participant sends an empty message to the dynamic router with the subscription URI beginning with ""dynamic-router:control/subscribe/{channel name}"", and all other params, and the predicate instance is set as the message body
then: Routing participant is subscribed with all supplied values


Subscribing with control message POJO operates without change:
	
given: All necessary dependencies present for setting up a route with the dynamic router component and a control message POJO has been instantiated
when: Routing participant sends subscribe POJO as message body to the control channel
then: Routing participant is subscribed with all supplied values


Unsubscribing with control message POJO operates without change:
	
given: All necessary dependencies present for setting up a route with the dynamic router component, routing participant has a valid subscription ID and channel name,  and a control message POJO for unsubscribing has been instantiated
when: Routing participant sends unsubscribe POJO as message body to the control channel
then: Routing participant is unsubscribed for that channel and that subscription ID


Provide a mode to allow routing to all matching participants
	
given: multiple subscribers with at least some overlapping filter predicates
when: incoming messages match multiple recipients' filters
then: all matching recipients receive a copy of the message","ffang:1643265651:2022-01-27T14:40:51.345+0000:1643265651:2022-01-27T14:40:51.345+0000:Fix up camel-spring-boot-examples caused by API changes here
https://github.com/apache/camel-spring-boot-examples/commit/90e1c2aedda0fabced86e04ab9e622ee0628beca
davsclaus:1643322212:2022-01-28T06:23:32.560+0000:1643322212:2022-01-28T06:23:32.560+0000:I assume this work is complete so we can resolve this ticket.
And if there is more work then create a new ticket for 3.16.0 release."
0,CAMEL-17499,Improvement,Major,None,3.15.0,"
None
",Resolved,Fixed,3.15.0,Claus Ibsen,Claus Ibsen,0,2,2022-01-16 11:06:05+00:00,2022-06-24 06:38:51+00:00,"After the 3.14 LTS release then we drop JDK8 and jump to JDK11 which then is a good time to start on some house cleaning.


The dataformats in the model are inconsistent in naming which causes some pain in the build system, and tooling, and also between DSLs.","davsclaus:1642313731:2022-01-16T14:15:31.037+0000:1642383823:2022-01-17T09:43:43.789+0000:TODO: rename in core project *DONE*
TODO: rename in camel-karaf *DONE*
TODO: rename in camel-spring-boot *DONE*
TODO: check kamelets if they use any with the old name *DONE*
TODO: rename in camel-quarkus (create ticket) *DONE*
TODO: update camel-k which detects in the DSL which camel JARs are in use (create ticket) *DONE*
davsclaus:1642385936:2022-01-17T10:18:56.124+0000:1642385936:2022-01-17T10:18:56.124+0000:Look at the complicated rename for json-xxx bindy-xxx avro-xxx and protobuf-xxx - there is maven plugins and other hacks that needs to be adjusted.
davsclaus:1642487255:2022-01-18T14:27:35.017+0000:1642575573:2022-01-19T14:59:33.827+0000:TODO: bindy *DONE*
TODO: avro *DONE*
TODO: json *DONE*
TODO: protobuf *DONE*
TODO: yam-snake *DONE*
ffang:1642516816:2022-01-18T22:40:16.336+0000:1642516816:2022-01-18T22:40:16.336+0000:Hi [~davsclaus],

This recent change broke several tests in camel-spring-boot project; and this [PR|https://github.com/apache/camel-spring-boot/pull/430] tries to fix them up.

Could you please take a look to see if it's OK?

Thanks!
Freeman
davsclaus:1642551184:2022-01-19T08:13:04.865+0000:1642551184:2022-01-19T08:13:04.865+0000:Thanks Freeman for fixing those tests
davsclaus:1642575147:2022-01-19T14:52:27.997+0000:1642576074:2022-01-19T15:07:54.807+0000:TODO: yaml-dsl schema has dataFormatName in enums for json libraries *DONE*"
0,CAMEL-17498,Improvement,Major,None,3.15.0,"
None
",Resolved,Duplicate,3.15.0,Claus Ibsen,Claus Ibsen,0,1,2022-01-16 07:14:38+00:00,2022-01-16 15:11:11+00:00,This was renamed but there are some parts left with gzip name still. We need to cleanup this,
0,CAMEL-17497,Improvement,Major,3.15.0,3.15.0,"
None
",Resolved,Fixed,3.15.0,Claus Ibsen,Marat Gubaidullin,0,1,2022-01-15 23:50:07+00:00,2022-01-17 08:03:44+00:00,"1. In camel-core-model Generated *.json file names are inconsistent:



most of filenames are cameCase however univocity-*.json and mime-multipart.json are kebabCase
customDataFromat.json has DataFormat at the end, however other filenase does not



https://github.com/apache/camel/tree/main/core/camel-core-model/src/generated/resources/org/apache/camel/model/dataformat 


Could we make all files camelCase and without DataFormat et the end.


 


2.  In camel-core-model  In DataFormats we have gzip but there is no gzip.json 


https://github.com/apache/camel/blob/main/core/camel-core-model/src/generated/resources/org/apache/camel/model/dataformat/dataFormats.json


 


3. Same in camel-catalogue. Partially camelCase, partially kebabCase and no gzip


https://github.com/apache/camel/tree/main/catalog/camel-catalog/src/generated/resources/org/apache/camel/catalog/dataformats",
0,CAMEL-17496,Improvement,Minor,None,3.15.0,"
None
",Resolved,Fixed,3.15.0,Claus Ibsen,Claus Ibsen,0,1,2022-01-15 07:21:26+00:00,2022-01-15 17:08:16+00:00,"09E4FE8399FEB29-0000000000000001 exchange Exchange[09E4FE8399FEB29-0000000000000001] sent to: stream://out took: 0 ms.
09E4FE8399FEB29-0000000000000001 exchange completed: Exchange[09E4FE8399FEB29-0000000000000001]
09E4FE8399FEB29-0000000000000002 exchange created: Exchange[09E4FE8399FEB29-0000000000000002]
09E4FE8399FEB29-0000000000000002 exchange Exchange[09E4FE8399FEB29-0000000000000002] sending to: stream://out
Hello World I am invoked 3 times
09E4FE8399FEB29-0000000000000002 exchange Exchange[09E4FE8399FEB29-0000000000000002] sent to: stream://out took: 0 ms.
09E4FE8399FEB29-0000000000000002 exchange completed: Exchange[09E4FE8399FEB29-0000000000000002]",davsclaus:1642208148:2022-01-15T08:55:48.840+0000:1642208148:2022-01-15T08:55:48.840+0000:We should avoid dumping the exchange id twice - the leading is the exchange id which makes it easier to correlate events from the same exchanges from logs etc
0,CAMEL-17495,New Feature,Minor,3.14.0,"3.21.0, 4.0-RC1, 4.0.0","
None
",Resolved,Fixed,"3.21.0, 4.0-RC1, 4.0.0",Dmitrii Kriukov,Joey,1,4,2022-01-15 07:17:33+00:00,2023-05-07 07:07:58+00:00,"I found that AS2 component could not support application/xml content type, which is part of the requirement for AS2 message.","davsclaus:1642202810:2022-01-15T07:26:50.489+0000:1642202810:2022-01-15T07:26:50.489+0000:Can you add more details about this, and is this something you would work on implementing?
t0920008899:1642208054:2022-01-15T08:54:14.472+0000:1642208054:2022-01-15T08:54:14.472+0000:I tried to use this component in my application, and found that the application/xml typed message cannot not be processed. I raised this in hope that xml type messages could be supported in new release.
TedL:1648444226:2022-03-28T13:10:26.627+0000:1648444226:2022-03-28T13:10:26.627+0000:I have the same problem but with the content-type text/xml.
davsclaus:1683328207:2023-05-06T07:10:07.157+0000:1683328207:2023-05-06T07:10:07.157+0000:Can we backport this to camel-3.x branch for inclusion in 3.21 release
dkryukov:1683336090:2023-05-06T09:21:30.794+0000:1683336090:2023-05-06T09:21:30.794+0000:[~davsclaus] I will handle this backporting"
0,CAMEL-17494,Test,Major,None,3.15.0,"
None
",Resolved,Fixed,3.15.0,Freeman Yue Fang,Freeman Yue Fang,0,2,2022-01-14 21:52:21+00:00,2022-01-17 15:41:06+00:00,"we can this test failure like this




Expecting actual not to be null




Three tests affected
ZooKeeperClusterServiceTest
ZooKeeperServiceRegistryTest
ConsulServiceRegistryIT","ffang:1642168466:2022-01-14T21:54:26.346+0000:1642168466:2022-01-14T21:54:26.346+0000:The cause behind this is same, ServiceRegistry service(ConsulServiceRegistry and ZooKeeperServiceRegistry) used in test never get chance to start. If I do change like
{code}
final CamelContext camelContext =  context.getBean(CamelContext.class);
-                    final ServiceRegistry serviceRegistry = camelContext.hasService(ServiceRegistry.class);
+                    final ServiceRegistry serviceRegistry = context.getBean(ServiceRegistry.class);
+                    
 
                     assertThat(serviceRegistry).isNotNull();
-
+                    serviceRegistry.start();
{code}
tests passed
davsclaus:1642389082:2022-01-17T11:11:22.301+0000:1642389082:2022-01-17T11:11:22.301+0000:You are welcome to fix the tests"
0,CAMEL-17463,Task,Minor,3.14.0,"3.14.1, 3.15.0","
None
",Resolved,Fixed,"3.14.1, 3.15.0",Unassigned,Aurélien Pupier,0,1,2022-01-10 15:23:57+00:00,2022-01-11 06:03:51+00:00,"https://camel.apache.org/components/next/twitter-search-component.html



typo paris instead of pairs `And multiple paris can be separated by semi colon.`
several <p/> are displayed",
0,CAMEL-17462,Task,Major,None,3.17.0,"
None
",Resolved,Won't Fix,3.17.0,Otavio Rodolfo Piske,Otavio Rodolfo Piske,0,2,2022-01-10 11:56:50+00:00,2022-04-03 08:13:26+00:00,"This component seems to be incompatible with Java 17. The tests fail with:


 


 




java.util.concurrent.CompletionException: java.lang.NoClassDefFoundError: Could not initialize class io.atomix.catalyst.buffer.util.HeapMemory
...
Caused by: java.lang.NoClassDefFoundError: Could not initialize class io.atomix.catalyst.buffer.util.HeapMemory
    at io.atomix.catalyst.buffer.UnsafeHeapBytes.allocate(UnsafeHeapBytes.java:42)","orpiske:1641787078:2022-01-10T11:57:58.288+0000:1641787078:2022-01-10T11:57:58.288+0000:We may need to upgrade to or create a new component based on Atomix v3.
davsclaus:1641941353:2022-01-12T06:49:13.504+0000:1641941935:2022-01-12T06:58:55.971+0000:We can deprecate this component, atomix is not so active anymore and this will be a pain to maintain over time. *DONE*
davsclaus:1641941511:2022-01-12T06:51:51.113+0000:1641941511:2022-01-12T06:51:51.113+0000:Atomix is also purely java tech stack as a distributed platform with zookeeper, hazelcast et all, where as kubernetes is a much better distributed platform.
davsclaus:1642111151:2022-01-14T05:59:11.936+0000:1642111151:2022-01-14T05:59:11.936+0000:[~ffang] we have deprecated this component, lets make make JDK17 skip testing this module.
orpiske:1648944806:2022-04-03T08:13:26.206+0000:1648944806:2022-04-03T08:13:26.206+0000:This component was deprecated and removed for Camel 3.17.0."
0,CAMEL-17461,Dependency upgrade,Minor,None,"3.14.2, 3.15.0","
None
",Resolved,Fixed,"3.14.2, 3.15.0",Claus Ibsen,James Netherton,0,2,2022-01-10 11:09:45+00:00,2022-09-29 07:05:51+00:00,"The are a few components using commons-pool 1.x. 


camel-netty DONE
camel-rabbitmq DONE
camel-spring-rabbitmq DONE (was not using pool anyway)


The last release was 1.6 in January 2012. It would be good to switch to 2.x which is actively maintained.",davsclaus:1641798869:2022-01-10T15:14:29.469+0000:1641798869:2022-01-10T15:14:29.469+0000:Also removed the old commons-pool v1 from various pom files
0,CAMEL-17460,Task,Major,None,None,"
None
",Resolved,Fixed,3.15.0,Claus Ibsen,Claus Ibsen,0,1,2022-01-10 10:48:39+00:00,2022-01-10 11:14:05+00:00,No Desc,
0,CAMEL-17459,Task,Major,None,3.15.0,"
None
",Resolved,Fixed,3.15.0,Claus Ibsen,Claus Ibsen,0,1,2022-01-10 09:05:15+00:00,2022-01-10 09:06:29+00:00,We should remove the XML <camelContext> in camel-cdi as we have a general routes loader now with the pluggable DSLs that should be used instead.,
0,CAMEL-17458,Improvement,Major,3.14.0,3.15.0,"
None
",Resolved,Fixed,3.15.0,Federico Mariani,Federico Mariani,0,1,2022-01-10 08:21:20+00:00,2022-01-10 10:55:03+00:00,"Add access token AuthenticationHandler, https://confluence.atlassian.com/enterprise/using-personal-access-tokens-1026032365.html",
0,CAMEL-17457,Bug,Minor,"3.14.0, 3.15.0","3.14.1, 3.15.0","

documentation
openapi

",Resolved,Fixed,"3.14.1, 3.15.0",Karen Lease,ncasaux,0,3,2022-01-09 14:21:11+00:00,2022-01-13 21:19:09+00:00,"Hello,


I'm using provided example: Spring Boot Example with Camel REST DSL and OpenApi (https://github.com/apache/camel-spring-boot-examples/tree/main/rest-openapi-springdoc)


I noticed that the generated tags are incorrect and contains some duplicate values, for example:




""/api/users"" : {
  ""get"" : {
    ""tags"" : [ ""/api/users/users"" ],
    ""responses"" : {
      ""200"" : {
        ""content"" : {
          ""application/json"" : {
            ""schema"" : {
              ""type"" : ""array"",
              ""items"" : {
                ""$ref"" : ""#/components/schemas/User""
              }
            }
          }
        },
        ""description"" : ""All users successfully returned""
      }
    },
    ""operationId"" : ""verb1"",
    ""summary"" : ""Find all users""
  }
}



Note the value ""/api/users/users""


I tried to investigate in the source code of the component, and I found this line of code in class RestOpenApiReader:




// we need to group the operations within the same tag, so use the path as default if not configured
String opPath = OpenApiHelper.buildUrl(buildBasePath(camelContext, rest), getValue(camelContext, rest.getPath()));
String pathAsTag = getValue(camelContext, rest.getTag() != null ? rest.getTag() : opPath);



I don't really understand the purpose of the opPath value, which contains the concatenation of ""/api/users"" and ""/users"". I guess it should be ""/api/users"" ?


It explains however why the pathAsTag value is consequently incorrect.


Hope it helps!","davsclaus:1641766094:2022-01-10T06:08:14.125+0000:1641766094:2022-01-10T06:08:14.125+0000:Yeah it should be /api/users
klease78:1641984177:2022-01-12T18:42:57.273+0000:1641984177:2022-01-12T18:42:57.273+0000:I suggest to change the generated tag so it would be just ""/users"" in this example. There is no way in the Camel Rest DSL to specify multiple tags and associate different operations to different tags, so it would make sense to use the main path specified in rest(path). Adding the context path (/api) doesn't add anything useful.
davsclaus:1642059557:2022-01-13T15:39:17.424+0000:1642059557:2022-01-13T15:39:17.424+0000:Karen, yeah you are welcome to work on a PR
klease78:1642063933:2022-01-13T16:52:13.845+0000:1642063933:2022-01-13T16:52:13.845+0000:Done."
0,CAMEL-17456,Dependency upgrade,Major,None,None,"
None
",Resolved,Fixed,3.15.0,Unassigned,Claus Ibsen,0,1,2022-01-09 07:47:40+00:00,2022-01-09 08:38:31+00:00,Any23 2.6 requires Java 11,"davsclaus:1641685800:2022-01-09T07:50:00.939+0000:1641685800:2022-01-09T07:50:00.939+0000:The SMX team need to do an osgi bundle release

    <bundle dependency='true'>mvn:org.apache.servicemix.bundles/org.apache.servicemix.bundles.any23/${apache-any23-bundle-version}</bundle>
davsclaus:1641688711:2022-01-09T08:38:31.798+0000:1641688711:2022-01-09T08:38:31.798+0000:There is a 2.5 karaf release we use"
0,CAMEL-17455,Improvement,Major,None,3.15.0,"
None
",Resolved,Fixed,3.15.0,Claus Ibsen,Claus Ibsen,0,1,2022-01-08 10:13:35+00:00,2022-01-08 15:40:00+00:00,"We do not use the endpoint(string) -> Endpoint methods on BuilderSupport that are part of Java DSL.


These causes the endpoint instance to be resolved too eager during bootstrap. And end users do not really use these methods.",
0,CAMEL-17454,Bug,Major,3.14.0,"3.14.1, 3.15.0","
None
",Resolved,Fixed,"3.14.1, 3.15.0",Claus Ibsen,Claus Ibsen,0,2,2022-01-08 09:23:10+00:00,2022-01-13 10:14:31+00:00,https://camel.zulipchat.com/#narrow/stream/257298-camel/topic/Duplicate.20Content-Type.20headers/near/267184902,"ramu11:1642021339:2022-01-13T05:02:19.238+0000:1642021339:2022-01-13T05:02:19.238+0000:[~davsclaus]  i have checked the camel-undertow code 
'DefaultUndertowHttpBinding' class has 2 methods  with same name 'populateCamelHeaders' with different method signatures


{code:java}
 @Override
    public void populateCamelHeaders(HttpServerExchange httpExchange, Map<String, Object> headersMap, Exchange exchange)
            throws Exception {
----------------------------------------------------------------------
 for (HttpString name : response.getResponseHeaders().getHeaderNames()) {
            // mapping the content-type
            //String name = httpName.toString();
            if (name.toString().toLowerCase(Locale.US).equals(""content-type"")) {
                name = ExchangeHeaders.CONTENT_TYPE;
            }

{code}


and


{code:java}
// 
  @Override
    public void populateCamelHeaders(HttpServerExchange httpExchange, Map<String, Object> headersMap, Exchange exchange)
            throws Exception {

  for (HttpString name : httpExchange.getRequestHeaders().getHeaderNames()) {
            // mapping the content-type
            //String name = httpName.toString();
            if (name.toString().toLowerCase(Locale.US).equals(""content-type"")) {
                name = ExchangeHeaders.CONTENT_TYPE;
            }
{code}



davsclaus:1642038384:2022-01-13T09:46:24.821+0000:1642038384:2022-01-13T09:46:24.821+0000:Thanks, yeah so its related to UndertowHelper.appendHeader that will if there is an existing header with the same key, make that into a list, and so we have duplicates
davsclaus:1642039817:2022-01-13T10:10:17.823+0000:1642039817:2022-01-13T10:10:17.823+0000:Okay so it was a bit more tricky as this was only when using undertow with rest component, where it was filtering headers wrongly which cause the duplicate"
0,CAMEL-17453,Test,Major,None,"3.11.6, 3.14.1, 3.15.0","
None
",Resolved,Fixed,"3.11.6, 3.14.1, 3.15.0",Freeman Yue Fang,Freeman Yue Fang,0,1,2022-01-07 19:45:36+00:00,2022-01-07 20:57:06+00:00,"broken tests from Camel/Junit API change, only can see the error with
-Djava.awt.headless=false",ffang:1641556579:2022-01-07T19:56:19.841+0000:1641556579:2022-01-07T19:56:19.841+0000:Also enhance consumer side MTOM test a bit
0,CAMEL-17452,Bug,Minor,3.14.0,"3.14.1, 3.15.0","
None
",Resolved,Fixed,"3.14.1, 3.15.0",Unassigned,Claus Skou Nielsen,0,2,2022-01-07 14:02:21+00:00,2022-01-20 06:18:04+00:00,"The following unit test demonstrates the problem with URISupport#sanitize:




    @Test
    public void testSanitizeUriWithRawPasswordAndSimpleExpression() {
        String uriPlain = ""http://foo?username=me&password=RAW(me#@123)&foo=bar&port=21&tempFileName=${file:name.noext}.tmp&anotherOption=true"";
        String uriCurly = ""http://foo?username=me&password=RAW{me#@123}&foo=bar&port=21&tempFileName=${file:name.noext}.tmp&anotherOption=true"";
        String expected = ""http://foo?username=me&password=xxxxxx&foo=bar&port=21&tempFileName=${file:name.noext}.tmp&anotherOption=true"";
        // ""http://foo?username=me&password=xxxxxx.tmp&anotherOption=true"" is the actual result
        assertEquals(expected, URISupport.sanitizeUri(uriPlain));
        assertEquals(expected, URISupport.sanitizeUri(uriCurly));
    }




The problem is that the SECRETS pattern in URISupport eagerly eats everything up until the ending of ${file:name.noext}.


It can be resolved by changing the regex-pattern, like so:




private static final Pattern SECRETS = Pattern.compile(
            ""([?&][^=]*(?:passphrase|password|secretKey|accessToken|clientSecret|authorizationToken|saslJaasConfig)[^=]*)=(RAW(([{][^}]*[}])|([(][^)]*[)]))|[^&]*)"",
            Pattern.CASE_INSENSITIVE);","davsclaus:1641627674:2022-01-08T15:41:14.094+0000:1641627674:2022-01-08T15:41:14.094+0000:You are welcome to submit a PR
davsclaus:1642630684:2022-01-20T06:18:04.298+0000:1642630684:2022-01-20T06:18:04.298+0000:Thanks for the PR"
0,CAMEL-17451,Improvement,Major,3.15.0,None,"
None
",Resolved,Fixed,3.15.0,Claus Ibsen,Claus Ibsen,0,1,2022-01-07 13:25:59+00:00,2022-01-08 16:13:12+00:00,jbang run -Dcamel.jbang.version=3.15.0-SNAPSHOT camel@apache/camel run chuck.yaml --trace,
0,CAMEL-17450,Improvement,Major,None,3.15.0,"
None
",Resolved,Fixed,3.15.0,Claus Ibsen,Claus Ibsen,0,1,2022-01-07 10:47:25+00:00,2022-01-07 11:50:56+00:00,Lets see if we can add source location for a KameletBinding file,"davsclaus:1641526706:2022-01-07T11:38:26.334+0000:1641527449:2022-01-07T11:50:49.853+0000:TODO: sink *DONE*
TODO: source *DONE*
TODO: steps *DONE*
"
0,CAMEL-17449,Improvement,Major,3.15.0,,"
None
",Resolved,Duplicate,None,Unassigned,Claus Ibsen,0,2,2022-01-07 09:22:59+00:00,2022-05-30 07:29:42+00:00,"https://camel.apache.org/manual/camel-jbang.html#_create_project


You have to specify the extensions manually via --quarkusDependencies


It would be good if we can find out what camel-xxx JARs are in use, and then map these to quarkus GAVs


G = org.apache.camel -> org.apache.camel.quarkus
A = camel-timer -> camel-quarkus-timer","Federico Mariani:1641800636:2022-01-10T15:43:56.928+0000:1641800636:2022-01-10T15:43:56.928+0000:Hi, I can't think of any way to find out camel-xxx JARs are in use, but I have an idea for quarkus GAV mapping, We can use [https://github.com/apache/camel-quarkus/blob/2.6.0/catalog/pom.xml] camel-quarkus catalog in order to create a Map, that maps camel-xxx jar to camel-quarkus-xxx jar, wdyt?
davsclaus:1641851529:2022-01-11T05:52:09.211+0000:1641851529:2022-01-11T05:52:09.211+0000:Yes but we cannot have a hard dependency on the quarkus catalog in the core camel project, so it needs to be downloaded dynamic or maybe added the that jbang main file as DEPS.

But the mapping should be straightfoward as the GAV are all mapped for A (artifactId) as camel-ftp -> camel-quarkus-ftp. So I dont think we need a catalog as much anyway. But if we can find a nice way to use it then that is still better however."
0,CAMEL-17448,Task,Minor,None,3.20.0,"
None
",Resolved,Fixed,3.20.0,Otavio Rodolfo Piske,Otavio Rodolfo Piske,0,1,2022-01-06 17:53:46+00:00,2022-10-04 07:35:48+00:00,"The report from the maven-dependency-plugin lists several unused dependencies in several of our modules. We need to review and remove the unused ones.


There are too many modules with reportedly unused dependencies in components (see the components-report.zip attachment for details).","orpiske:1663908894:2022-09-23T12:54:54.988+0000:1663908894:2022-09-23T12:54:54.988+0000:Components with names starting from A to C: done.
orpiske:1663913485:2022-09-23T14:11:25.049+0000:1663913485:2022-09-23T14:11:25.049+0000:Components with names starting from D to G: done.
orpiske:1663915171:2022-09-23T14:39:31.617+0000:1663915171:2022-09-23T14:39:31.617+0000:Components with names starting from H to I: done.
orpiske:1664840148:2022-10-04T07:35:48.020+0000:1664840148:2022-10-04T07:35:48.020+0000:Most of the components have been cleaned up."
0,CAMEL-17447,Task,Minor,None,3.20.0,"
None
",Resolved,Fixed,3.20.0,Otavio Rodolfo Piske,Otavio Rodolfo Piske,0,1,2022-01-06 17:43:59+00:00,2022-10-04 14:19:37+00:00,"The report from the maven-dependency-plugin lists several unused dependencies in several of our modules. We need to review and remove the unused ones.


Modules with reportedly unused dependencies in core (see the core-modules-report.zip attachment for details):



core/camel-cloud
core/camel-support
core/camel-core-languages
core/camel-support
core/camel-core-catalog
core/camel-main
core/camel-xml-io-util
core/camel-core-xml
core/camel-xml-jaxp
core/camel-util
core/camel-health
core/camel-management-api
core/camel-management
core/camel-core-engine
core/camel-core
core/camel-xml-jaxb
core/camel-xml-io",orpiske:1664864377:2022-10-04T14:19:37.735+0000:1664864377:2022-10-04T14:19:37.735+0000:Resolved with: https://github.com/apache/camel/pull/8469
0,CAMEL-17446,Bug,Minor,3.13.0,3.15.0,"
None
",Resolved,Fixed,3.15.0,Karen Lease,Karen Lease,0,2,2022-01-06 16:21:42+00:00,2022-01-21 16:52:00+00:00,"An issue reported on the users list shows that using trigger.repeatInterval=1200 causes the first 2 events to be fired sooner than expected after the scheduler is started.


This is due to the delay between creating the Quartz Trigger and when the scheduler is started.


Changing the log message to show the milliseconds in the trigger's next fire time would be helpful. In addition, it appears counter-intuitive that triggerStartDelay is ignored if positive, as shown in QuartzEndpoint.createTrigger() below:




if (getComponent().getScheduler().isStarted() || triggerStartDelay < 0) {
    triggerBuilder.startAt(new Date(System.currentTimeMillis() + triggerStartDelay));
}



Is this intentional?","davsclaus:1641468725:2022-01-06T19:32:05.866+0000:1641468725:2022-01-06T19:32:05.866+0000:I think its something that can be added to the documentation, as there will always be ""such problem"". A quartz scheduler is not 100% accurate and fires exactly at 1200 millis between. 

Otherwise a big task would be to provisionally create triggers during bootstrap, and then after the scheduler is started, then schedule those provisional triggers to the scheduler. Then that problem is no longer.
klease78:1641550797:2022-01-07T18:19:57.981+0000:1641550797:2022-01-07T18:19:57.981+0000:I'll look into updating the documentation. It's mainly an issue with short intervals which are perhaps not that common. In any case, I notice the first run of the trigger takes longer to launch (20 to 30 msec in the test case) than the remaining ones, so the first one always appears to be delayed.

Regarding the timestamp for the next fire time log, I see it depends on the actual logging implementation used; in the test case which uses log4j it is displaying the msec which helps to understand the issue. I'd suggest forcing the format when constructing the log message.

But is it normal not to set the triggerStartDelay when it's positive? The current code will only set it to some time in the past, likely causing several events to be generated immediately when the scheduler is started.
davsclaus:1641688910:2022-01-09T08:41:50.282+0000:1641688943:2022-01-09T08:42:23.511+0000:About the < 0 then see CAMEL-17133
That idea is to simulate a ""fireNow"" by forcing a misfire

davsclaus:1641689088:2022-01-09T08:44:48.929+0000:1641689088:2022-01-09T08:44:48.929+0000:> Regarding the timestamp for the next fire time log, I see it depends on the actual logging implementation used; in the test case which uses log4j it is displaying the msec which helps to understand the issue. I'd suggest forcing the format when constructing the log message.

Yeah that is a good idea
klease78:1641810891:2022-01-10T18:34:51.171+0000:1641810891:2022-01-10T18:34:51.171+0000:>That idea is to simulate a ""fireNow"" by forcing a misfire

Yes, I see that, and I see the documentation of the parameter related to the scheduler being started is consistent with the code.

But Quartz allows to set an explicit start and end time on a simple trigger, and this isn't possible in Camel. That could be done with trigger.startTime and trigger.endTime properties, where startTime would then override the triggerStartDelay and be applied even when the scheduler is not yet started.

For now I submitted a PR for the log message and the documentation for triggerParameters."
0,CAMEL-17445,Task,Trivial,3.14.0,None,"
None
",Resolved,Fixed,3.15.0,Unassigned,Aurélien Pupier,0,1,2022-01-06 15:06:28+00:00,2022-01-06 19:28:18+00:00,there is a reference to http://camel.apache.org/running-camel-standalone-and-have-it-keep-running.html which is giving a 404,
0,CAMEL-17444,Improvement,Major,None,3.15.0,"
None
",Resolved,Fixed,3.15.0,Claus Ibsen,Claus Ibsen,0,2,2022-01-06 14:33:22+00:00,2022-01-06 19:25:56+00:00,"The debugger needs to retrieve the message history of the exchange, so the tool can display the history.


https://camel.zulipchat.com/#narrow/stream/258729-camel-tooling/topic/Intellij.20plugin/near/267065057","javaduke:1641452174:2022-01-06T14:56:14.503+0000:1641452174:2022-01-06T14:56:14.503+0000:I think I can take care of it, let me create a prototype and if it works, I'll submit a PR."
0,CAMEL-17443,Wish,Major,3.14.0,3.x,"
None
",Resolved,Information Provided,3.x,Unassigned,Yasser Zamani,0,2,2022-01-06 13:19:28+00:00,2022-09-03 10:48:24+00:00,"from(""file:./target/source?move=../archive"")
.transacted()
.choice().when(minAgePredicate).markRollbackOnly()
.otherwise()
....




moves the consumed file to the archive folder even when it's marked to rollback!


When I replace .markRollbackOnly() with .rollback(), it works as expected i.e. it doesn't move the file to the archive folder and polls it again and again until minAgePredicate satisfied. But the problem is that it logs a lot of warnings i.e. in each poll it warns about the rollback.


As per docs, I wished I could ask Camel to just rollback and abort/stop exchange silently with .markRollbackOnly().","davsclaus:1641446813:2022-01-06T13:26:53.901+0000:1641446813:2022-01-06T13:26:53.901+0000:Transactions are for transacted resources such as JMS and JDBC.
Not really for file / ftp etc. 

You should look at using a file filter directly on the file where you can skip files that dont match the min age predicate, then the file consumer will only process valid files.
yasserzamani:1641450176:2022-01-06T14:22:56.130+0000:1641450176:2022-01-06T14:22:56.130+0000:Thanks [~davsclaus]! It's not about valid/invalid files. That minAgePredicate is about postponing the file until it satisfies our specified min age. So filtering won't help. I'd tried it. Camel internally mark that file as processed and won't poll it again at all.

As said {{.rollback()}} works as I described in description. Because it throws exception. The problem is it also logs warning messages which I wished I was able to avoid with .markRollbackOnly().
davsclaus:1641450560:2022-01-06T14:29:20.403+0000:1641450560:2022-01-06T14:29:20.403+0000:You can use 

onException(rollback exception).logExhausted(false);

to disable. the logging
yasserzamani:1641451954:2022-01-06T14:52:34.301+0000:1641451954:2022-01-06T14:52:34.301+0000:Thanks but
{code:java}
onException(RollbackExchangeException.class).log(""YASSER"").logExhausted(false);
{code}

didn't help neither global nor on route. I see one WARN from {{DefaultErrorHandler}}, then I see ""YASSER"", then I see another WARN from again {{DefaultErrorHandler}} (but a multiline log this time), then I see one from {{TransactionErrorHandler}} of Camel JTA, then one from {{GenericFileOnCompletion}} of Camel file component.

No problem. Currently we can live with them. But *it would be awesome if file component was able to not move the file and abort exchange when there's .markRollbackOnly() specified. Similar behavior like now that I've used .rollback() but with no exception. that's all what this ticket is about.*
davsclaus:1641630830:2022-01-08T16:33:50.676+0000:1641630830:2022-01-08T16:33:50.676+0000:You can implement the min predicate logic in the file filter, eg get the age of the file and then return true | false whether its accepted or not. Then you do not have to use the filter EIP in the route.


davsclaus:1641630945:2022-01-08T16:35:45.945+0000:1641630945:2022-01-08T16:35:45.945+0000:Using rollbackOnly without transactions is ""interresting"" thought. It would mean we could regard the uow as failed if exception != null or rollbackonly = true. However most consumers would expect that it failed due to an exception, so we may have to set an exception at this stage (so there is an exception) but the error handler would not log anything as there was nothing before.
yasserzamani:1641646796:2022-01-08T20:59:56.318+0000:1641646796:2022-01-08T20:59:56.318+0000:{quote}You can implement the min predicate logic in the file filter, eg get the age of the file and then return true | false whether its accepted or not. Then you do not have to use the filter EIP in the route.
{quote}
But once filtered for one time, Camel will never poll and try that file again, right? If so then as said above, we don't want to skip those files, but we just want to postpone them until they get a specified minimum age. Currently {{.rollback()}} works perfectly - It aborts the exchange (i.e. won't move the file to archive) and also will poll the file again and again. it doesn't skip the file (as we want). This ticket wishes to make it possible to get same behavior, but with no exception/rollback logs."
0,CAMEL-17442,Task,Major,None,3.15.0,"
None
",Resolved,Fixed,3.15.0,Otavio Rodolfo Piske,Otavio Rodolfo Piske,0,1,2022-01-06 12:24:49+00:00,2022-01-23 17:48:05+00:00,"Currently, they are using test scope which forces the users to redeclare the 


camel-test-infra-common in the modules code which pollutes the pom file. It needs to use the default (runtime) scope so it is handled automatically.",orpiske:1641542811:2022-01-07T16:06:51.387+0000:1641542811:2022-01-07T16:06:51.387+0000:Resolved w/ the linked PR.
0,CAMEL-17441,Bug,Major,3.14.0,"3.14.1, 3.15.0","
None
",Resolved,Fixed,"3.14.1, 3.15.0",Claus Ibsen,Claus Ibsen,0,1,2022-01-06 09:44:02+00:00,2022-01-06 09:45:28+00:00,"We forgot to add the loaded HC


Its a feature that needs to be enabled, see the main-health example",
0,CAMEL-17440,Bug,Minor,3.14.0,3.15.0,"
None
",Resolved,Fixed,3.15.0,Claus Ibsen,Claus Ibsen,0,2,2022-01-06 06:25:28+00:00,2022-01-06 08:49:48+00:00,"Looks like it fires twice on the first job, eg on startup




07:22:42.099 [DefaultQuartzScheduler-MyYamlCamel_Worker-2] INFO  my-route.yaml:24 - A Hello how are you?
07:22:42.099 [DefaultQuartzScheduler-MyYamlCamel_Worker-1] INFO  my-route.yaml:24 - A Hello how are you?
07:22:42.099 [DefaultQuartzScheduler-MyYamlCamel_Worker-2] INFO  my-route.yaml:26 - B Bye World
07:22:42.099 [DefaultQuartzScheduler-MyYamlCamel_Worker-1] INFO  my-route.yaml:26 - B Bye World
07:22:44.007 [DefaultQuartzScheduler-MyYamlCamel_Worker-3] INFO  my-route.yaml:24 - A Hello how are you?
07:22:44.007 [DefaultQuartzScheduler-MyYamlCamel_Worker-3] INFO  my-route.yaml:26 - B Bye World




This is from the main-yaml example where its supposed to run with a cron that triggers every 2nd second: 0/2 * * * * ?","davsclaus:1641424518:2022-01-06T07:15:18.648+0000:1641424518:2022-01-06T07:15:18.648+0000:Okay so this is because using 

camel.component.quartz.start-delayed-seconds = 3

then due to that delay then any jobs that was supposed to trigger is misfired and so in 3 sec then 1 task must be triggered that is misfired and then fired asap
davsclaus:1641430035:2022-01-06T08:47:15.775+0000:1641430035:2022-01-06T08:47:15.775+0000:Okay removing the startDelayed option as it causes more pain."
0,CAMEL-17439,Task,Major,3.15.0,3.15.0,"
None
",Resolved,Implemented,3.15.0,Unassigned,Claus Ibsen,0,1,2022-01-06 06:02:40+00:00,2022-01-07 13:13:25+00:00,"With the change in that javadoc helper then all the json descriptions now have <p/> embedded as <p\/>




-    ""usePooledConnection"": { ""kind"": ""property"", ""displayName"": ""Use Pooled Connection"", ""group"": ""common"", ""label"": ""common"", ""required"": false, ""type"": ""boolean"", ""javaType"": ""boolean"", ""deprecated"": false, ""deprecationNote"": """", ""autowired"": false, ""secret"": false, ""defaultValue"": true, ""description"": ""Enables or disables whether a PooledConnectionFactory will be used so that when messages are sent to ActiveMQ from outside of a message consuming thread, pooling will be used rather than the default with the Spring JmsTemplate which will create a new connection, session, producer for each message then close them all down again. The default value is true."" },
-    ""useSingleConnection"": { ""kind"": ""property"", ""displayName"": ""Use Single Connection"", ""group"": ""common"", ""label"": ""common"", ""required"": false, ""type"": ""boolean"", ""javaType"": ""boolean"", ""deprecated"": false, ""deprecationNote"": """", ""autowired"": false, ""secret"": false, ""defaultValue"": false, ""description"": ""Enables or disables whether a Spring SingleConnectionFactory will be used so that when messages are sent to ActiveMQ from outside of a message consuming thread, pooling will be used rather than the default with the Spring JmsTemplate which will create a new connection, session, producer for each message then close them all down again. The default value is false and a pooled connection is used by default."" },
+    ""usePooledConnection"": { ""kind"": ""property"", ""displayName"": ""Use Pooled Connection"", ""group"": ""common"", ""label"": ""common"", ""required"": false, ""type"": ""boolean"", ""javaType"": ""boolean"", ""deprecated"": false, ""deprecationNote"": """", ""autowired"": false, ""secret"": false, ""defaultValue"": true, ""description"": ""Enables or disables whether a PooledConnectionFactory will be used so that when messages are sent to ActiveMQ from outside of a message consuming thread, pooling will be used rather than the default with the Spring JmsTemplate which will cre
ate a new connection, session, producer for each message then close them all down again. <p\/> The default value is true."" },
+    ""useSingleConnection"": { ""kind"": ""property"", ""displayName"": ""Use Single Connection"", ""group"": ""common"", ""label"": ""common"", ""required"": false, ""type"": ""boolean"", ""javaType"": ""boolean"", ""deprecated"": false, ""deprecationNote"": """", ""autowired"": false, ""secret"": false, ""defaultValue"": false, ""description"": ""Enables or disables whether a Spring SingleConnectionFactory will be used so that when messages are sent to ActiveMQ from outside of a message consuming thread, pooling will be used rather than the default with the Spring JmsTemplate which will create a new connection, session, producer for each message then close them all down again. <p\/> The default value is false and a pooled connection is used by default."" },",davsclaus:1641532405:2022-01-07T13:13:25.761+0000:1641532405:2022-01-07T13:13:25.761+0000:We reverted the javadoc helper change
0,CAMEL-17438,Improvement,Minor,None,3.20.0,"
None
",Resolved,Fixed,3.20.0,Nicolas Filotto,Cristian Canino,0,3,2022-01-06 00:13:27+00:00,2022-10-07 15:15:49+00:00,"Example:


To the list below:



listDeployments




listDeploymentsByLabels




getDeployment




createDeployment




deleteDeployment




scaleDeployment



Add



replaceDeployment","nfilotto:1665042956:2022-10-06T15:55:56.303+0000:1665042956:2022-10-06T15:55:56.303+0000:[~davsclaus] Within the context of this issue, I would like first to fix all the warnings so I'm wondering If I can remove all the code related to the Service Call EIP or should I keep it as deprecated?
davsclaus:1665115546:2022-10-07T12:05:46.868+0000:1665115546:2022-10-07T12:05:46.868+0000:It was only recently deprecated in 3.19, so IMHO its a bit too soon to remove code.
nfilotto:1665115613:2022-10-07T12:06:53.215+0000:1665115613:2022-10-07T12:06:53.215+0000:OK, thx for the answer
nfilotto:1665122784:2022-10-07T14:06:24.748+0000:1665122784:2022-10-07T14:06:24.748+0000:The corresponding PR https://github.com/apache/camel/pull/8495"
0,CAMEL-17437,Bug,Major,"3.14.0, 3.15.0","3.14.1, 3.15.0","
None
",Resolved,Fixed,"3.14.1, 3.15.0",Jiri Ondrusek,Jiri Ondrusek,0,2,2022-01-05 12:00:00+00:00,2022-01-11 15:46:24+00:00,"I'm investigating an error on camel-quarkus (https://github.com/apache/camel-quarkus/issues/3436) and found that it is happening on camel itself. It affects probably more components, so I set ""camel-core"" as a component.


 


Here is a description:



aws2-sqs allows to use client from contex, which is autowired into the component
if deadletter is used (via RouteBuilder), endpoint is created immediately (even if context is not started yet) - see BuilderSupport l434 (code)
Creation of component fails, because there is no client which could be autowired (see code)



 


I created junit reproducer in my fork - https://github.com/JiriOndrusek/camel/commit/f8d294afae9c6919b19cb6ca6f7cec50570d6208","jondruse:1641355264:2022-01-05T12:01:04.445+0000:1641355264:2022-01-05T12:01:04.445+0000:[~davsclaus] ([~acosentino] ) I assigned this issue to myself (I see it as a nice way of learning how those core processes work). But I understand that that you'd like to fix it by yourselve, in that case please reassign issue to yourselves.
If you agree with me looking into this, I'd appreciate any type of suggestion, you might have. Thank you in advance.
jondruse:1641356461:2022-01-05T12:21:01.686+0000:1641356461:2022-01-05T12:21:01.686+0000:I'm adding a code for junit test in text form (in case that my commit is overwritten by accident)

```
public class SqsDeadletterWithClientRegistryLocalstackIT extends Aws2SQSBaseTest {

    @EndpointInject(""direct:start"")
    private ProducerTemplate template;

    @EndpointInject(""mock:result"")
    private MockEndpoint result;

    @Override
    protected CamelContext createCamelContext() throws Exception {
        CamelContext ctx = super.createCamelContext();
        AmazonSQSClientMock awsSQSClient = new AmazonSQSClientMock();


        Sqs2Component sqs = ctx.getComponent(""aws2-sqs"", Sqs2Component.class);

        //todo if those 2 lines are enabled, test is successful, becouse it will use client from context
        sqs.getConfiguration().setAmazonSQSClient(null);
        ctx.getRegistry().bind(""awsSQSClient"", awsSQSClient);

        return ctx;

    }

    @Test
    public void deadletter() throws Exception {
        result.expectedMessageCount(1);

        Exchange exchange = template.send(""direct:start"", ExchangePattern.InOnly, new Processor() {
            public void process(Exchange exchange) throws Exception {
                exchange.getIn().setBody(""test1"");
            }
        });

        assertMockEndpointsSatisfied();
    }

    @Override
    protected RouteBuilder createRouteBuilder() throws Exception {

        //todo use generated query name for usage with real aws provider
        return new RouteBuilder() {
            @Override
            public void configure() throws Exception {
                errorHandler(deadLetterChannel(""aws2-sqs://deadletter?autoCreateQueue=true"")
                        .useOriginalMessage());

                from(""direct:start"").startupOrder(2).process(e -> {throw new IllegalStateException();}).toF(""aws2-sqs://%s?autoCreateQueue=true"", sharedNameGenerator.getName());

                from(""aws2-sqs://deadletter"").to(""mock:result"");
            }
        };
    }
}
```
davsclaus:1641357787:2022-01-05T12:43:07.769+0000:1641357787:2022-01-05T12:43:07.769+0000:Jiri, you are surely welcome to work on this.
davsclaus:1641357946:2022-01-05T12:45:46.271+0000:1641357946:2022-01-05T12:45:46.271+0000:Yeah the endpoint can likely be build at a late phase in the actual dead letter channel in an doInit or doStart phase etc.
jondruse:1641360150:2022-01-05T13:22:30.281+0000:1641360150:2022-01-05T13:22:30.281+0000:Postponing creation to later phase should work, this was also my intention. I'll try to achieve this, thanks.
jondruse:1641519579:2022-01-07T09:39:39.875+0000:1641519579:2022-01-07T09:39:39.875+0000:This issue could be closed after this reverting PR is merged (https://github.com/apache/camel/pull/6674), because error is not happening at all. Problem was caused by the flaw in the reproducer test (see https://github.com/apache/camel/pull/6674/files#diff-32c38baf67be071134dc969e3335ca18b722b02fc780365d77b833180028fa2fR40-L45). "
0,CAMEL-17436,Bug,Major,3.14.0,"3.14.1, 3.15.0","
None
",Resolved,Fixed,"3.14.1, 3.15.0",Claus Ibsen,Michał Ostrowski,0,2,2022-01-05 11:40:56+00:00,2022-01-05 13:17:04+00:00,"I belive there are some bugs in CamelHealthCheckAutoConfiguration that prevents disabling health check on single route or consumer.


For example, configuration like this:


camel.health.config[consumer\:cron-delete-expired-tokens].parent=consumers
camel.health.config[consumer\:cron-delete-expired-tokens].enabled=false


causes disabling all consumers health checks.


Configuration like this:


camel.health.config[consumer\:cron-delete-expired-tokens].parent=routes
camel.health.config[consumer\:cron-delete-expired-tokens].enabled=false


disables all routes health checks.


Not setting parent causes NullPointerException in HealthCheckRegistry::resolveById().","karbi:1641354384:2022-01-05T11:46:24.406+0000:1641354408:2022-01-05T11:46:48.473+0000:I have made  [pull request|https://github.com/apache/camel-spring-boot/pull/428] with test and bugfix.
davsclaus:1641359802:2022-01-05T13:16:42.707+0000:1641359802:2022-01-05T13:16:42.707+0000:Thanks for reporting and the PR.
I fixed the NPE by causing an error message about the parent must be set"
0,CAMEL-17435,Task,Major,None,3.15.0,"
None
",Resolved,Fixed,3.15.0,Otavio Rodolfo Piske,Otavio Rodolfo Piske,0,2,2022-01-05 09:45:15+00:00,2022-01-18 11:41:07+00:00,We may have dependencies that are unused or unnecessary after migrating to Java 11. This is a task to review them.,"davsclaus:1641691930:2022-01-09T09:32:10.593+0000:1641691930:2022-01-09T09:32:10.593+0000:Cannot build spring boot

[ERROR] Failed to execute goal org.apache.camel.springboot:camel-spring-boot-generator-maven-plugin:3.15.0-SNAPSHOT:generate-dependencies-bom (default) on project camel-spring-boot-dependencies-generator: Found 5 conflicts between the current managed dependencies and the external BOMS:
[ERROR]  - com.sun.xml.messaging.saaj:saaj-impl:jar
[ERROR]  - jakarta.xml.bind:jakarta.xml.bind-api:jar
[ERROR]  - javax.annotation:javax.annotation-api:jar
[ERROR]  - javax.xml.ws:jaxws-api:jar
[ERROR]  - org.glassfish.jaxb:jaxb-runtime:jar
orpiske:1641699891:2022-01-09T11:44:51.250+0000:1641699891:2022-01-09T11:44:51.250+0000:Ouch. I will take a look at this one tomorrow. 
orpiske:1641707073:2022-01-09T13:44:33.381+0000:1641707073:2022-01-09T13:44:33.381+0000:I managed to find some time to take a look and sent a quick fix for it.
davsclaus:1641765980:2022-01-10T06:06:20.670+0000:1641765980:2022-01-10T06:06:20.670+0000:Thanks, spring boot can now build
orpiske:1642477267:2022-01-18T11:41:07.531+0000:1642477267:2022-01-18T11:41:07.531+0000:This work is done, so I think we can close this."
0,CAMEL-17434,Task,Major,None,None,"
None
",Closed,Fixed,None,David Jencks,David Jencks,0,1,2022-01-05 02:50:08+00:00,2022-01-05 22:48:18+00:00,"With Antora 3 we can:



shift from outdated <module>/assets/images to <module>/images
shift from `include::
{attachmentsdir}
...` to `include::attachment$...`",djencks:1641394098:2022-01-05T22:48:18.574+0000:1641394098:2022-01-05T22:48:18.574+0000:All PRs applied
0,CAMEL-17433,Task,Major,None,,"
None
",Closed,Fixed,None,David Jencks,David Jencks,0,2,2022-01-04 22:36:28+00:00,2022-01-08 10:35:04+00:00,"The JavadocHelper has some limitations in processing javadoc and xml:



< and > characters are removed when not paired
xml tags are not recognized well, e.g. < this is not a tag > is treated as a tag and removed
Already encoded entities are re-encoded, so > becomes &gt;



It turns out that there are hundreds of examples of these problems in generated code.


I'm going to fix the problems in JavadocHelper and let the regen_bot supply the corrected generated code.


Thanks to Jeremy Ross for making me aware of this problem.","djencks:1641394042:2022-01-05T22:47:22.687+0000:1641394042:2022-01-05T22:47:22.687+0000:All PRs applied.
jamesnetherton:1641528158:2022-01-07T12:02:38.921+0000:1641528158:2022-01-07T12:02:38.921+0000:This change has broken a number of the component descriptions in the catalog metadata. E.g see ahc-ws.json in this commit

https://github.com/apache/camel/commit/e01780aa3bc3c901e06d09962094fa780b8decc1"
0,CAMEL-17432,Task,Major,None,3.15.0,"
None
",Resolved,Fixed,3.15.0,Otavio Rodolfo Piske,Otavio Rodolfo Piske,0,1,2022-01-04 19:40:25+00:00,2022-01-06 08:59:42+00:00,"The --release option of the compiler has safer guarantees of compatibility with the specified Java version. These guarantees are not available supported when using --source and --target (see: https://www.morling.dev/blog/bytebuffer-and-the-dreaded-nosuchmethoderror). 


 


Now that we moved to Java 11 as the minimum, we should replace the usages of those 2 flags with just the release option.",
0,CAMEL-17431,Task,Major,None,3.15.0,"
None
",Resolved,Fixed,3.15.0,Otavio Rodolfo Piske,Otavio Rodolfo Piske,0,1,2022-01-04 16:51:41+00:00,2022-01-06 08:59:52+00:00,"If any module does not override the source and target version defined by maven compiler plugin, it seems to default to Java 7 since it inherits it from the Apache parent pom.


 


For example, looking at the effective pom for camel-kafka we can see that:


 


<maven.compiler.source>1.7</maven.compiler.source>
<maven.compiler.target>1.7</maven.compiler.target>


This is not a problem in this case, because its hierarchy does override the source and target options at the camel-parent. However, this may be confusing when analyzing the effective pom (or problematic if, somehow, the maven compiler plugin options are overridden).",
0,CAMEL-17430,Bug,Major,"3.13.0, 3.14.0","3.14.1, 3.15.0","
None
",Resolved,Fixed,"3.14.1, 3.15.0",Unassigned,Henrik Karlsson,0,1,2022-01-04 16:47:11+00:00,2022-01-05 06:14:00+00:00,"After upgrading to 3.14.0 I got this error then calling an open api from a route:



Invalid url: /camel/api/v1/register. If you are forwarding/bridging http endpoints, then enable the bridgeEndpoint option on the endpoint: http://localhost:8093/s-smtp/v1/email?httpMethod=POST



The endpoint used in the route looks like this:




.to(""s-smtp:SendEmail?authUsername={{api.client-id}}&authPassword={{api.client-secret}}&authenticationPreemptive=true&throwExceptionOnFailure=false&bridgeEndpoint=true"") 



After debugging I found that the cause of this is found on line 533 in RestOpenApiEndpoint:




// Add rest endpoint parameters
if (this.parameters != null && operation.getParameters() != null) {
    for (Map.Entry<String, Object> entry : this.parameters.entrySet()) {
        for (OasParameter param : operation.getParameters()) {
            // skip parameters that are part of the operation as path as otherwise
            // it will be duplicated as query parameter as well
            boolean clash = ""path"".equals(param.in) && entry.getKey().equals(param.getName());
            if (!clash) {
                nestedParameters.put(entry.getKey(), entry.getValue());
            }
        }
    }
} 



If the operation in question don't have any parameters this.parameters will never be added to the underlying endpoint.


Found this change in this commit:


https://github.com/apache/camel/commit/94847d8c4a84e39be31c38ca30a5f4a3575ece29#diff-f9d1965ec0771a782838b7a5c10c2e6e228fb6f4ce0776172488638a63d8a611R529",
0,CAMEL-17429,Task,Major,None,3.15.0,"
None
",Resolved,Fixed,3.15.0,Otavio Rodolfo Piske,Otavio Rodolfo Piske,0,1,2022-01-04 16:33:56+00:00,2022-01-07 16:08:39+00:00,"There's several Maven profiles for JDK8, JDK9 and others that have become unsupported as of Camel 3.15. This task is related to cleaning them up.",orpiske:1641542919:2022-01-07T16:08:39.155+0000:1641542919:2022-01-07T16:08:39.155+0000:The profiles for deprecated JDKs were removed.
0,CAMEL-17428,Improvement,Major,None,3.15.0,"
None
",Resolved,Fixed,3.15.0,Andrea Cosentino,Claus Ibsen,0,1,2022-01-04 14:55:40+00:00,2022-01-05 13:09:51+00:00,"Something to make it easy to capture JFR on startup, eg add camel-jfr and enable it on startup.",
0,CAMEL-17427,Improvement,Major,"3.13.0, 3.14.0",3.15.0,"
None
",Resolved,Fixed,3.15.0,Claus Ibsen,Michał Ostrowski,0,2,2022-01-04 13:04:09+00:00,2022-01-09 08:40:25+00:00,"In version 3.13.0 behaviour of scheduled consumers helath checks was changed. Consumer is considered DOWN until at least one successful execution - CAMEL-17168.


In case of rarely executed routes (i.e. once a day), consumer could be DOWN for several hours. It causes Camel context to be DOWN and in our case whole Spring Boot application to be DOWN.


Our workaround is to disable consumers healthchecks, but it's a shame to give up on this nice feature.


Possible solution would be to add configuration option to enable old health logic for specific consumers, or at least on whole context.


I'm willing to provide patch but I want to discuss optimal solution.","davsclaus:1641334660:2022-01-05T06:17:40.402+0000:1641334660:2022-01-05T06:17:40.402+0000:You can turn off consumer health checks then it works as before, using only the route health check as you say


davsclaus:1641334846:2022-01-05T06:20:46.844+0000:1641334846:2022-01-05T06:20:46.844+0000:What is the use case for having a ""once per day"" route in your same Camel service? Such a ""route"" is likely better as a separate job if you run on the cloud, where it can be a kubernetes cron job. 

However I agree that maybe we can improve on this in the DSL to have a ""healthCheck(false)"", and allow to specify for such routes that they should not be part of the health check, because they are run so rarely and should not affect the overall health status.

And as such you can disable these routes already, see the docs.
https://camel.apache.org/manual/health-check.html#_configuring_routes_health_check

karbi:1641356714:2022-01-05T12:25:14.852+0000:1641356714:2022-01-05T12:25:14.852+0000:We have several jobs that are launched on different schedules. Some jobs are security related, so monitoring is important part of this project.

We are using CRON component for jobs that are launched at constant hours, and Scheduler component for jobs with fixed delay (from seconds to minutes).

I understand the reason behind the change in health check logic, but IMO it does not suit CRON component that executes once a day, week or even year.

 

BTW. I was trying to disable health checks on specific consumers, but I found a bug - CAMEL-17436

 

 
davsclaus:1641443161:2022-01-06T12:26:01.030+0000:1641447357:2022-01-06T13:35:57.556+0000:Oh yeah for the scheduler component since its internal, we should regard it as READY immediately. *DONE*
davsclaus:1641447424:2022-01-06T13:37:04.252+0000:1641447434:2022-01-06T13:37:14.808+0000:Michal, for cron component which actual scheduler do you use, is that camel-quartz?
karbi:1641541403:2022-01-07T15:43:23.318+0000:1641541416:2022-01-07T15:43:36.311+0000:We are using CamelSpringCronService from camel-spring.
davsclaus:1641607451:2022-01-08T10:04:11.039+0000:1641607451:2022-01-08T10:04:11.039+0000:CamelSpringCronService *DONE*
davsclaus:1641688825:2022-01-09T08:40:25.742+0000:1641688825:2022-01-09T08:40:25.742+0000:The internal scheduler based is now always up"
0,CAMEL-17426,Bug,Major,None,3.15.0,"
None
",Resolved,Fixed,3.15.0,James Netherton,Luca Burgazzoli,0,4,2022-01-04 10:48:26+00:00,2022-01-18 17:09:09+00:00,"While running the camel quarkus healt example, I noticed that the health checks from camel are conflated so as example, the liveness block looks as follow:




{
    ""checks"": [
        {
            ""data"": {
                ""consumer:netty"": ""DOWN"",
                ""consumer:timer"": ""UP"",
                ""context"": ""UP"",
                ""context.name"": ""camel-7"",
                ""context.status"": ""Started"",
                ""context.version"": ""3.14.0"",
                ""failure.count"": ""0"",
                ""invocation.count"": ""5"",
                ""invocation.time"": ""2022-01-04T11:32:56.024411+01:00[Europe/Rome]"",
                ""route.context.name"": ""camel-7"",
                ""route.id"": ""netty"",
                ""route.status"": ""Stopped"",
                ""route:netty"": ""UP"",
                ""route:timer"": ""UP"",
                ""success.count"": ""5"",
                ""toolong"": ""UP""
            },
            ""name"": ""camel-readiness-checks"",
            ""status"": ""DOWN""
        }
    ],
    ""status"": ""DOWN""
}




As you may notice, there are inconsistencies, like, multiple routes are conflated and only the latest one appears: 




{
  ""route.id"": ""netty"",
  ""route.status"": ""Stopped"",
  ""route:netty"": ""UP"",
  ""route:timer"": ""UP""
}




The issue seems to be cause by the fact that the camel-microprofile-health component does not mirrors the checks from camel but instead it aggregate them (see AbstractCamelMicroProfileHealthCheck.java) 


SmallRye offers a sort of registry so we should probably register the camel health checks to the SmallRye registry (this may have the side effect to make the camel-microprofile-health smallrye dependant)


In addition, it would be nice of SmallRye would allow to discovery registries","lb:1641264538:2022-01-04T10:48:58.623+0000:1641264538:2022-01-04T10:48:58.623+0000:/cc [~davsclaus] [~jamesnetherton] what do you think ?
lb:1641279649:2022-01-04T15:00:49.197+0000:1641279649:2022-01-04T15:00:49.197+0000:As alternative we could have a quarkus specific implementation
jamesnetherton:1641353413:2022-01-05T11:30:13.317+0000:1641353413:2022-01-05T11:30:13.317+0000:We could perhaps have a custom Camel HealthCheckRegistry (extending DefaultHealthCheckRegistry) which intercepts the register and unregister events, and then does the same action on the SmallRye registry. WDYT?

I notice the SmallRye Health registry APIs are marked as experimental, so not sure if there's an element of risk if we decide to use them. 

Maybe it's not such a big deal if we made the component dependent on SmallRye Health. Seems we already made the fault tolerance component dependent on the SmallRye impl anyway.

lb:1641354306:2022-01-05T11:45:06.841+0000:1641354306:2022-01-05T11:45:06.841+0000:Yep that is one of the option I was thinking about.

Another alternative is to have two impl:
- a pure microprofile one, that for example either report UP or DOWN but in case of DOWN it just report the details of the first occurrence. 
- a smallrye one in which the Camel HealthCheckRegistry wraps the SmallRye registries as you suggested (but I'm not sure if it is worth haviong a separate component for smallrye)
jamesnetherton:1641360981:2022-01-05T13:36:21.517+0000:1641360981:2022-01-05T13:36:21.517+0000:Yeah maybe having another separate component is overkill. It depends on whether we really need to keep a generic solution based on the pure MP spec.

I'm thinking we should go with leveraging the SmallRye registries. The output produced by the health reporter is more intuitive and simpler to read compared to how it shows with the current aggregated way, where everything is grouped under 'camel-liveness-checks' & 'camel-readiness-checks'.

If we think this an acceptable way forwards, I could take a look at making the required modifications to the code.

lb:1641361115:2022-01-05T13:38:35.136+0000:1641361115:2022-01-05T13:38:35.136+0000:I'm +1 with that so if you have any spare time, please go ahead 
davsclaus:1641361175:2022-01-05T13:39:35.241+0000:1641361175:2022-01-05T13:39:35.241+0000:+1 good plan
jamesnetherton:1641436335:2022-01-06T10:32:15.684+0000:1641436335:2022-01-06T10:32:15.684+0000:One small issue I encountered is what happens if a Camel health check is enabled / disabled at runtime.

There's currently no way of knowing that the health check configuration was updated in order to add / remove it on the SmallRye registry.

lb:1641779249:2022-01-10T09:47:29.726+0000:1641779249:2022-01-10T09:47:29.726+0000:[~jamesnetherton] would be enough to return UNKNOWN for disabled checks ? 

lb:1641779297:2022-01-10T09:48:17.486+0000:1641779297:2022-01-10T09:48:17.486+0000:[~astefanutti] not sure but this change may affect the work you have done on camel
jamesnetherton:1641785789:2022-01-10T11:36:29.639+0000:1641785789:2022-01-10T11:36:29.639+0000:[~lb] There is no UNKOWN status in MicroProfile Health unfortunately. I can propose that it's added though.

There is a 'check.enabled' metadata element added by Camel which will get propagated into the SmallRye health output. So that could be a way to determine that the health check is disabled and was not invoked and we leave the status as UP. Conceptually not 100% perfect, but I think it's probably acceptable initially.

lb:1641786813:2022-01-10T11:53:33.950+0000:1641786813:2022-01-10T11:53:33.950+0000:Agree, we could probably do something like

{code}
registry.enable(String id)
registry.disable(String id)
{code}

And delegate the actual implementation to the registry
jamesnetherton:1641786852:2022-01-10T11:54:12.575+0000:1641786852:2022-01-10T11:54:12.575+0000:I guess it depends on how important supporting enabling / disabling checks at runtime is. Because if it's not critical, then we can just avoid adding the check to the SmallRye registries if it's disabled.

jamesnetherton:1641787143:2022-01-10T11:59:03.865+0000:1641787143:2022-01-10T11:59:03.865+0000:Also to clarify - SmallRye health currently has no concept of disabled health checks at runtime.
lb:1641787454:2022-01-10T12:04:14.070+0000:1641787454:2022-01-10T12:04:14.070+0000:Yes, I don't recall the reason for enabled/disabled checks at runtime :) 
antonin.stefanutti:1641863533:2022-01-11T09:12:13.457+0000:1641863533:2022-01-11T09:12:13.457+0000:[~lb] Camel K currently looks up for the check named {{camel-readiness-checks}}, and reads its status, as well as the presence of the {{.data[""error.message""]}}. The {{data}} is reported as is in the integration status, so it's more for consumers of the integration statuses that conflation is an issue. I haven't checked the type of the {{data}} field, but maybe it's possible to have a more structured form, that would avoid loosing information and maintain a bijection with the routes.
lb:1641864397:2022-01-11T09:26:37.318+0000:1641864397:2022-01-11T09:26:37.318+0000:The data block should be Map<String, Object> so it could be possible to use a structured ""payload"", see https://github.com/eclipse/microprofile-health/blob/master/api/src/main/java/org/eclipse/microprofile/health/HealthCheckResponse.java#L53
However I think the issue may still be present as you may have a number of ""error.message"", like we may have one error per check, can we maybe translate the readiness error in conditions ?
jamesnetherton:1641865060:2022-01-11T09:37:40.855+0000:1641865060:2022-01-11T09:37:40.855+0000:SmallRye health can only handle data values of types Boolean, Long & String so it's not really possible to structure the data.
antonin.stefanutti:1641865739:2022-01-11T09:48:59.525+0000:1641865739:2022-01-11T09:48:59.525+0000:Right, I remember now and mapped the type to Golang accordingly: https://github.com/apache/camel-k/blob/27ea823b6997d8b1a4477944739b578e07b487f7/pkg/controller/integration/health.go#L47.

Yet it's polymorphism for primitive types, not object. That being said, it could be loosely structured, as it kinda is already, but improved to guarantee a bijection. 

For the {{error.message}}, it's only checked to move the integration to the {{Error}} phase. So there could be a message per route, and Camel K would move the integration in {{Error}} phase as soon as there is at least one error message.

Currently, Camel K passes the data as is. It would totally be possible to parse further these data into conditions for example, once that conflation issue is solved."
0,CAMEL-17425,Bug,Major,"3.13.0, 3.14.0","3.14.1, 3.15.0","

osgi

",Resolved,Fixed,"3.14.1, 3.15.0",Unassigned,Francois Papon,0,4,2022-01-03 19:59:47+00:00,2022-01-05 13:20:16+00:00,"It seems like this commit broke the OSGi compatibility by loading resources from another classloader: 


https://github.com/apache/camel/commit/11bd8012743868712904b449024344bcf8130d2b#diff-8514339d35970f5c1e68df154846a293656b9a482d332b7f4423755ba0d2b0f9 


For example, when upgrading to Camel 3.14.0, we have this error when starting a quartz route endpoint: 


Caused by: java.lang.RuntimeException: org.quartz.SchedulerException: Quartz properties file not found in classpath: org/quartz/quartz.properties","davsclaus:1641211327:2022-01-03T20:02:07.623+0000:1641211327:2022-01-03T20:02:07.623+0000:You are welcome to send a PR that uses the old code in the quartz component that the code commented also mentioned it was on purpose
davsclaus:1641211396:2022-01-03T20:03:16.649+0000:1641211396:2022-01-03T20:03:16.649+0000:You can probably copy that quartz.properties from the quartz JAR and put it in your own bundle at that location to workaround
fpapon:1641260476:2022-01-04T09:41:16.233+0000:1641260476:2022-01-04T09:41:16.233+0000:Ok, I will send a PR.

 "
0,CAMEL-17424,Bug,Minor,3.14.0,3.18.0,"
None
",Resolved,Fixed,3.18.0,Otavio Rodolfo Piske,Rafał Gała,0,3,2022-01-03 18:09:34+00:00,2022-06-10 07:33:14+00:00,"Hello 


Something has been introduced in 3.14.0 that causes long Camel shutdown when there has been an attempt to consume form a topic without necessary authorizations. The more consumers has been started the longer Camel takes to shut down.


Below is what is logged many times after a shutdown has been initiated (I masked some parts I did not want to share). In this case I consumed from two topics: some-other-topic-that-consumer-was-authorized-to  and e2k-test-bledu.



2022-01-03 18:27:05.032  WARN 25556 --- [rdReplaceEvent]] o.a.c.component.kafka.KafkaFetchRecords  : Exception org.apache.kafka.common.errors.TopicAuthorizationException caught while polling some-other-topic-that-consumer-was-authorized-to-Thread 0 from kafka topic some-other-topic-that-consumer-was-authorized-to at offset {}: Not authorized to access topics: [e2k-test-bledu]
2022-01-03 18:27:05.032  WARN 25556 --- [rdReplaceEvent]] o.a.c.component.kafka.KafkaFetchRecords  : Deferring processing to the exception handler based on polling exception strategy
2022-01-03 18:27:05.032  INFO 25556 --- [rdReplaceEvent]] o.a.k.c.c.internals.AbstractCoordinator  : [Consumer clientId=consumer-event2kafka_test3-12, groupId=event2kafka_test3] (Re-)joining group
2022-01-03 18:27:05.051  INFO 25556 --- [rdReplaceEvent]] o.a.k.c.c.internals.AbstractCoordinator  : [Consumer clientId=consumer-event2kafka_test3-12, groupId=event2kafka_test3] Successfully joined group with generation Generation{generationId=83, memberId='consumer-event2kafka_test3-12-74747411-96e8-4111-bab3-224cf754018f', protocol='range'}
2022-01-03 18:27:05.066  INFO 25556 --- [-PZOdmowaTrans]] o.a.k.c.c.internals.ConsumerCoordinator  : [Consumer clientId=consumer-event2kafka_test3-13, groupId=event2kafka_test3] Requesting to re-join the group and trigger rebalance since the assignment metadata has changed from (***masked***)
2022-01-03 18:27:05.066  INFO 25556 --- [-PZOdmowaTrans]] o.a.k.c.c.internals.ConsumerCoordinator  : [Consumer clientId=consumer-event2kafka_test3-13, groupId=event2kafka_test3] Requesting to re-join the group and trigger rebalance since the assignment metadata has changed from (***masked***)
2022-01-03 18:27:05.071  WARN 25556 --- [rdReplaceEvent]] org.apache.kafka.clients.NetworkClient   : [Consumer clientId=consumer-event2kafka_test3-12, groupId=event2kafka_test3] Error while fetching metadata with correlation id 133 : {e2k-test-bledu=TOPIC_AUTHORIZATION_FAILED}
2022-01-03 18:27:05.071 ERROR 25556 --- [rdReplaceEvent]] org.apache.kafka.clients.Metadata        : [Consumer clientId=consumer-event2kafka_test3-12, groupId=event2kafka_test3] Topic authorization failed for topics [e2k-test-bledu]
2022-01-03 18:27:05.071  INFO 25556 --- [rdReplaceEvent]] o.a.k.c.c.internals.AbstractCoordinator  : [Consumer clientId=consumer-event2kafka_test3-12, groupId=event2kafka_test3] Rebalance failed.

org.apache.kafka.common.errors.TopicAuthorizationException: Not authorized to access topics: [e2k-test-bledu] 



My use case may be specific because I start a separate route for every topic I want to consume from (I do not want to have a shared consumer for all topics because I need different prameters for selected topics, like offset reset etc.). Currently I consume from 44 topics and the Camel takes like four minutes to shut down.","rgala:1641205223:2022-01-03T18:20:23.073+0000:1641205223:2022-01-03T18:20:23.073+0000:Looks like this is more serious. I just noticed that lack of authorization to a single topic is preventing consumption from all other topics :( I had similar issue on 3.5.0 but it disappeared when I upgraded do 3.13.0 (unsure which version between 3.5.0 and 3.13.0 fixed this though).
rgala:1641267207:2022-01-04T11:33:27.259+0000:1641267207:2022-01-04T11:33:27.259+0000:I debugged a bit and it looks like the issue may be related to the loop in *run* method of {*}KafkaFetchRecords{*}. Prior to 3.14.0 there was no loop and when an exception occured inside {*}{*}{*}startPolling{*} method, the run method exited and the thread ended. Now it keeps retrying all the time and failing due to lack of authorization which may have some impact on the shutdown process.

 

Also I noticed that when all consumers share the same consumer group id, authorization error is causing errors in *org.apache.kafka.clients.consumer.KafkaConsumer* instances that have nothing to do with the topic there are no authorizations to. Looks like internally Kafka client shares some components per consumer group and I think nothing can be done on Camel side about this :( Why did it not cause issues prior to 3.14.0 is because just before the *run* method ended the *safeUnsubscribe* was called.

 

I will try to solve this using custom *pollExceptionStrategy* to force consumer to stop when TopicAuthorizationException occured.
davsclaus:1654302492:2022-06-04T08:28:12.084+0000:1654302492:2022-06-04T08:28:12.084+0000:Can you try with 3.17.0 as a lot of hardening et all has gone into camel-kafka
rgala:1654468108:2022-06-06T06:28:28.232+0000:1654468108:2022-06-06T06:28:28.232+0000:It behaves differently on 3.17.0:

Af first call to 
{code:java}
ConsumerRecords<Object, Object> allRecords = consumer.poll(pollDuration); {code}
in KafkaFetchRecords class it fails with TopicAuthorizationException, but the default poll exception strategy tells it to just go on so it calls the above again but this time it does not fail anymore with TopicAuthorizationException, but it also does not fetch any records (the consumer is in some weird state after first poll attempt). It keeps trying to poll records like if there was no authorization issue at all. Luckily the Camel shutdown process is not affected by this.

I would like to implement my own poll exception strategy and just stop polling when TopicAuthorizationException occurs, but continue with all other exceptions, but as I pointed out in CAMEL-18142, it seems impossible now. I could store the exception during the call to
{code:java}
pollExceptionStrategy.handle(partitionLastOffset, e) {code}
and then use it in *canContinue()* method later on, but it is not a thread safe solution unless I use a ThreadLocal wrapper etc.
davsclaus:1654474818:2022-06-06T08:20:18.167+0000:1654474818:2022-06-06T08:20:18.167+0000:[~orpiske] sounds a bit like we should maybe react differently on TopicAuthorizationException out of the box?
orpiske:1654476059:2022-06-06T08:40:59.594+0000:1654476072:2022-06-06T08:41:12.936+0000:[~davsclaus] [~rgala]  I think we should handle this differently, indeed. I need to research and think a bit about this. I am considering whether it would be easier to issue a call between the subscription and the poll that would ensure the authentication happens, so we can try to avoid over-complicating the poll handling strategy. This is, of course, a very early thought. So please, do let me know your suggestions if you have any ...
orpiske:1654476147:2022-06-06T08:42:27.111+0000:1654476147:2022-06-06T08:42:27.111+0000:BTW, I am assigning this one to me, but anyone interested in looking at it, please let me know as I have no ETA for looking at it just yet.
rgala:1654493423:2022-06-06T13:30:23.546+0000:1654493423:2022-06-06T13:30:23.546+0000:I would return false from canContinue() of  BridgeErrorStrategy in case of this exception (or even all exceptions that extend KafkaException).
orpiske:1654493647:2022-06-06T13:34:07.367+0000:1654493647:2022-06-06T13:34:07.367+0000:[~rgala] thanks. If I come up with a quick patch for that, are you able to test?
rgala:1654493763:2022-06-06T13:36:03.690+0000:1654493763:2022-06-06T13:36:03.690+0000:If I manage to build Camel locally, then yes :)
orpiske:1654562258:2022-06-07T08:37:38.611+0000:1654562258:2022-06-07T08:37:38.611+0000:Hi, for now I worked on a quick fix based on your suggestion: [https://github.com/apache/camel/pull/7733]

 

I'd like to create a test case for it, but I don't have time right now. I'll keep the PR open for some time.
orpiske:1654817594:2022-06-10T07:33:14.740+0000:1654817594:2022-06-10T07:33:14.740+0000:I added a quick fix based on [~rgala] 's suggestion. Please let me know or reopen the ticket in case it's still broken.

Thanks everyone for the review and suggestions."
0,CAMEL-17423,Improvement,Minor,3.14.0,4.x,"
None
",Open,Unresolved,4.x,Unassigned,Rob Arnhart,0,3,2022-01-03 17:10:49+00:00,2023-08-09 09:14:40+00:00,"I work for a cloud service provider that includes an integration application that uses Camel for the core operations of an integration. Because of factors such as industry regulation and customer InfoSec policies/requirements, placing access keys within an application, its filesystem, associated direct data stores, etc. is not permitted. This requires credentials to be provided by a lookup service that provides decrypted values to an application, exposed through variables. While our SaaS offering does provide an identity hub that integrates with customer IdPs, these integration applications will not use those as credential stores, directly.


With that, the serviceAccountKey would need to be provided via a variable, environment variable, etc., where the JSON string would be passed into that field value.


I've made a modification to allow for this by modifying the getCredentialsProvider method of the GooglePubsubCompenent.java file of the camel-google-pubsub component. This would respond to a prefix and then take the value from the passed parameter and use it for the credentials.


GooglePubsubComponent.java

private CredentialsProvider getCredentialsProvider(GooglePubsubEndpoint endpoint) throws IOException {
        CredentialsProvider credentialsProvider;

        // The original method logic
        //        if (endpoint.isAuthenticate()) {
        //            credentialsProvider = FixedCredentialsProvider.create(ObjectHelper.isEmpty(endpoint.getServiceAccountKey())
        //                    ? GoogleCredentials.getApplicationDefault() : ServiceAccountCredentials.fromStream(ResourceHelper
        //                            .resolveMandatoryResourceAsInputStream(getCamelContext(), endpoint.getServiceAccountKey())));
        //        } else {
        //            credentialsProvider = NoCredentialsProvider.create();
        //        }

        // Modified for JSON input
        if (endpoint.isAuthenticate()) {
            if (ObjectHelper.isEmpty(endpoint.getServiceAccountKey())) {
                credentialsProvider = FixedCredentialsProvider.create(GoogleCredentials.getApplicationDefault());
            } else if (endpoint.getServiceAccountKey().startsWith(""json:"")) {  // <- For the JSON string
                credentialsProvider = FixedCredentialsProvider.create(ServiceAccountCredentials.fromStream(
                    new ByteArrayInputStream(Base64.getUrlDecoder().decode(endpoint.getServiceAccountKey().substring(5)))));
            } else {
                credentialsProvider = FixedCredentialsProvider.create(ServiceAccountCredentials.fromStream(
                    ResourceHelper.resolveResourceAsInputStream(getCamelContext(), endpoint.getServiceAccountKey())));
            }
        } else {
            credentialsProvider = NoCredentialsProvider.create();
        }

        return credentialsProvider;
}




This would then allows for the component to be defined with the serviceAccountKey as below. The JSON string would need to be encoded via Base64 to allow the internal encoded key to be properly passed through.


GcpPubsubRoute.java

@Override
public void configure() throws Exception {
    from(""direct:gcpTest"").id(""gcpTest"")
        .setHeader(GooglePubsubConstants.ATTRIBUTES,
            constant(Map.of(""testKey1"", ""testValue1"", ""testKey2"", ""testValue2"")))
        .setBody(simple(""{\""someKey\"": \""someValue\""}""))
        .toD(""google-pubsub:{{PROJECT_NAME}}:{{TOPIC_NAME}}?serviceAccountKey=json:{{BASE64_CREDS}}"")
        .log(""Message ID: ${header."" + GooglePubsubConstants.MESSAGE_ID + ""}"");
}




I understand the concern around using an environment variable to pass credentials to a container. There is, however, a common pattern of cloud providers that expose external configuration to containers through environment variables.","acosentino:1641246872:2022-01-04T05:54:32.425+0000:1641246872:2022-01-04T05:54:32.425+0000:I'm just wondering why the Google SDK doesn't provide anything for use cases like this. [~cibsen@e-ma.net] what do you think about this?
bvollmer:1649911784:2022-04-14T12:49:44.732+0000:1649911784:2022-04-14T12:49:44.732+0000:[~acosentino], [~rarnhart] : What about an option to override the client implementation to pass in a custom CredentialsProvider implementation?
acosentino:1649912573:2022-04-14T13:02:53.689+0000:1649912573:2022-04-14T13:02:53.689+0000:It makes sense totally, please raise another issue for that and if you have time open a PR.
rarnhart:1650000691:2022-04-15T13:31:31.719+0000:1650000691:2022-04-15T13:31:31.719+0000:Yeah, I'd like to see that implemented as well [~bvollmer] and [~acosentino] - good suggestion. :D"
0,CAMEL-17422,Task,Minor,None,3.15.0,"
None
",Resolved,Fixed,3.15.0,Claus Ibsen,skepticoitus interuptus,0,1,2022-01-03 15:32:54+00:00,2022-01-06 09:12:44+00:00,"The word ""splitted"" is used throughout the Camel documentation and source code.


However, among professional copy editors and native English language speakers, use of ""splitted"" (anywhere; at any time) is universally considered to be grammatically incorrect.


In the English language, the grammatically correct past tense of ""split"" is ""split"".",
0,CAMEL-17421,Improvement,Major,None,3.15.0,"
None
",Resolved,Fixed,3.15.0,Claus Ibsen,Claus Ibsen,0,1,2022-01-03 14:17:24+00:00,2022-01-04 08:47:32+00:00,"Some EIPs like OnException are abstract which we need to output in the json model, as tooling needs to know",
0,CAMEL-17420,New Feature,Major,None,3.15.0,"
None
",Resolved,Fixed,3.15.0,Claus Ibsen,Claus Ibsen,0,1,2022-01-03 12:39:22+00:00,2022-01-04 15:41:57+00:00,"There is some overhead to capture this for Java DSL (and other JVM languages) on startup. The XML,YAML has no overhead as the parsers track this information already.",
0,CAMEL-17419,New Feature,Major,None,3.15.0,"
None
",Resolved,Won't Fix,3.15.0,Unassigned,Claus Ibsen,0,1,2022-01-03 12:05:39+00:00,2022-01-05 15:32:43+00:00,We can now include this in the backlog tracer,
0,CAMEL-17418,New Feature,Major,None,3.15.0,"
None
",Resolved,Fixed,3.15.0,Claus Ibsen,Claus Ibsen,0,1,2022-01-03 12:04:55+00:00,2022-01-05 07:15:37+00:00,We can include this in the message history,davsclaus:1641338137:2022-01-05T07:15:37.153+0000:1641338137:2022-01-05T07:15:37.153+0000:This is already there via the NamedNode
0,CAMEL-17417,New Feature,Major,None,3.15.0,"
None
",Resolved,Fixed,3.15.0,Claus Ibsen,Claus Ibsen,0,1,2022-01-03 12:04:15+00:00,2022-01-06 11:13:52+00:00,"We can now include this, when the error handler dumps an error to the log","davsclaus:1641347641:2022-01-05T09:54:01.872+0000:1641347641:2022-01-05T09:54:01.872+0000:{code}
Message History
---------------------------------------------------------------------------------------------------------------------------------------
Location                       RouteId              ProcessorId          Processor                                          Elapsed (ms)
MyJavaRouteBuilder:29          route1               route1               from[timer://java?period=2s]                                  9
MyJavaRouteBuilder:32          route1               setBody1             setBody[bean[MyJavaRouteBuilder method:randomNumbe            2
MyJavaRouteBuilder:33          route1               log1                 log                                                           1
MyJavaRouteBuilder:34          route1               filter1              filter[simple{${body} < 30}]                                  0
MyJavaRouteBuilder:35          route1               throwException1      throwException[java.lang.IllegalArgumentException]            0

Stacktrace
---------------------------------------------------------------------------------------------------------------------------------------
{code}"
0,CAMEL-17416,Improvement,Major,None,3.15.0,"
None
",Resolved,Won't Do,3.15.0,Unassigned,Claus Ibsen,0,1,2022-01-03 12:02:28+00:00,2022-01-04 08:47:32+00:00,"We need for tooling a way for them to know which node ids that can be used for breakpoints.


There are some abstracts like onException that cannot have a breakpoint etc.",
0,CAMEL-17415,Improvement,Minor,None,3.15.0,"
None
",Resolved,Fixed,3.15.0,Claus Ibsen,Claus Ibsen,0,1,2022-01-03 10:38:21+00:00,2022-01-05 13:48:44+00:00,To make it easy to enable tracing in the logs,
0,CAMEL-17414,Improvement,Major,None,3.15.0,"
None
",Resolved,Abandoned,3.15.0,Unassigned,Claus Ibsen,0,1,2022-01-03 10:37:06+00:00,2022-01-23 13:46:07+00:00,"For tooling they may desire the absolute location, which can be from an embedded jar such as when running in spring-boot.


And for reporting and logging etc you may want a relative location from ""project"".",
0,CAMEL-17383,New Feature,Major,None,3.15.0,"
None
",Resolved,Fixed,3.15.0,Claus Ibsen,Claus Ibsen,0,1,2021-12-26 09:30:26+00:00,2021-12-26 09:40:19+00:00,Needed by tooling so we can know what is available in the running Camel application,
0,CAMEL-17382,New Feature,Major,None,None,"
None
",Resolved,Fixed,3.15.0,Claus Ibsen,Claus Ibsen,0,1,2021-12-25 15:02:58+00:00,2021-12-25 15:06:25+00:00,https://github.com/apache/camel-k-runtime/issues/767,
0,CAMEL-17381,Task,Major,None,3.15.0,"
None
",Resolved,Duplicate,3.15.0,Jean-Baptiste Onofré,Claus Ibsen,0,1,2021-12-25 13:41:13+00:00,2022-01-13 22:08:42+00:00,"Some of the features have errors when running the platform/karaf/features check.


However they seem to work when installing manually in karaf.
So its something in the karaf maven plugin that does the feature validation that has problems after upgrading to JDK11.","davsclaus:1642061967:2022-01-13T16:19:27.985+0000:1642061967:2022-01-13T16:19:27.985+0000:The feature validator does not work for ""wrap"" urls on JDK11 vs JDK8

[WARNING] Error:
	Error downloading wrap:file:/Users/davsclaus/.m2/repository/org/asynchttpclient/async-http-client/2.12.3/async-http-client-2.12.3.jar$Export-Package=org.asynchttpclient.*;version=2.12.3
	Error downloading wrap:file:/Users/davsclaus/.m2/repository/org/asynchttpclient/async-http-client-netty-utils/2.12.3/async-http-client-netty-utils-2.12.3.jar$Export-Package=org.asynchttpclient.netty.util.*;version=2.12.3
	Error downloading wrap:file:/Users/davsclaus/.m2/repository/org/asynchttpclient/async-http-client/2.12.3/async-http-client-2.12.3.jar$Export-Package=org.asynchttpclient.*;version=2.12.3
	Error downloading wrap:file:/Users/davsclaus/.m2/repository/org/asynchttpclient/async-http-client-netty-utils/2.12.3/async-http-client-netty-utils-2.12.3.jar$Export-Package=org.asynchttpclient.netty.util.*;version=2.12.3
davsclaus:1642082718:2022-01-13T22:05:18.429+0000:1642082718:2022-01-13T22:05:18.429+0000:Freeman fixed this"
0,CAMEL-17380,Improvement,Major,None,3.15.0,"
None
",Resolved,Fixed,3.15.0,Claus Ibsen,Claus Ibsen,0,1,2021-12-25 11:54:51+00:00,2021-12-25 12:09:48+00:00,The camel-dsl-support uses endpointdsl. But we should move that out as its not needed when using yaml-dsl and others.,
0,CAMEL-17379,Dependency upgrade,Major,None,3.15.0,"
None
",Resolved,Fixed,3.15.0,Zineb Bendhiba,Claus Ibsen,0,2,2021-12-25 08:13:57+00:00,2022-01-25 18:27:54+00:00,"There are some test errors such as


Caused by: java.io.FileNotFoundException: 'org/optaplanner/examples/cloudbalancing/solver/cloudBalancingConstraints.drl' cannot be opened because it does not exist
	at org.drools.core.io.impl.ClassPathResource.getURL(ClassPathResource.java:165)
	at org.drools.core.io.impl.ClassPathResource.getInputStream(ClassPathResource.java:146)
	at org.drools.core.io.impl.BaseResource.getBytes(BaseResource.java:149)
	... 91 more","zbendhiba:1643095684:2022-01-25T15:28:04.946+0000:1643095684:2022-01-25T15:28:04.946+0000:I'd go for the final one 8.16

 
zbendhiba:1643100493:2022-01-25T16:48:13.405+0000:1643100493:2022-01-25T16:48:13.405+0000:PR: https://github.com/apache/camel/pull/6824
davsclaus:1643106474:2022-01-25T18:27:54.783+0000:1643106474:2022-01-25T18:27:54.783+0000:Thanks for the help"
0,CAMEL-17378,New Feature,Major,None,3.15.0,"
None
",Resolved,Fixed,3.15.0,Claus Ibsen,Claus Ibsen,0,1,2021-12-24 13:49:49+00:00,2021-12-24 13:53:12+00:00,So when you use Camel with Spring Boot its all the same GAV (eg -starter),
0,CAMEL-17377,New Feature,Major,None,3.15.0,"
None
",Resolved,Fixed,3.15.0,Claus Ibsen,Claus Ibsen,0,1,2021-12-24 13:44:51+00:00,2021-12-24 13:48:32+00:00,No Desc,
0,CAMEL-17376,Dependency upgrade,Major,None,3.15.0,"
None
",Resolved,Fixed,3.15.0,Claus Ibsen,Claus Ibsen,0,1,2021-12-24 08:11:42+00:00,2021-12-24 08:12:21+00:00,No Desc,
0,CAMEL-17375,Task,Major,3.7.7,None,"
None
",Resolved,Fixed,None,Unassigned,Sebb,0,1,2021-12-23 17:55:20+00:00,2022-09-03 10:46:29+00:00,"The page https://camel.apache.org/releases/release-3.7.7/ currently links to the archive server, however 3.7.7 is a current release. AS such, its links must use the ASF mirror system","davsclaus:1640304775:2021-12-24T08:12:55.468+0000:1640304775:2021-12-24T08:12:55.468+0000:The 3.7.x is EOL and it was the last release
sebb:1640324771:2021-12-24T13:46:11.011+0000:1640324771:2021-12-24T13:46:11.011+0000:The release has only just been announced:

https://lists.apache.org/thread/mzgbmcqx9g07mjbdomh04pfsvww0w98n

Also the page says it is LTS.

During its initial release period, at least, the download URLs must use the mirror systems"
0,CAMEL-17374,Bug,Minor,None,,"
None
",Resolved,Incomplete,None,Unassigned,Stepan Shcherbakov,0,2,2021-12-23 15:11:19+00:00,2022-05-17 15:03:47+00:00,"My program has camel route:


timer -> direct:send:to:recipientList
direct:send:to:recipientList -> recipientList -> direct1
                                                                    -> direct2
direct1 -> processor -> file
direct2 -> processor -> http (which fails with error)


redelivery set to infinite (-1) and redelivery delay set to 100ms


I called CamelContext.shutdown() and it shutdowned successful.
Suddenly, after 30s from shutdown was completed, 3 recipientList processors raised and started to redelivery:


2021/12/23-13:40:35.265 Camel (ContextName) thread #10 - RecipientList(463) W! org.apache.camel.processor.errorhandler.RedeliveryErrorHandler - Error during processing OnExceptionOccurred. This exception is ignored.
java.lang.IllegalArgumentException: my exception 
at my error handler
at chassis//org.apache.camel.processor.errorhandler.RedeliveryErrorHandler$RedeliveryTask.onExceptionOccurred(RedeliveryErrorHandler.java:953) at chassis//org.apache.camel.processor.errorhandler.RedeliveryErrorHandler$RedeliveryTask.doRun(RedeliveryErrorHandler.java:635) at chassis//org.apache.camel.processor.errorhandler.RedeliveryErrorHandler$RedeliveryTask.run(RedeliveryErrorHandler.java:623) at chassis//org.apache.camel.impl.engine.DefaultReactiveExecutor$Worker.schedule(DefaultReactiveExecutor.java:148) at chassis//org.apache.camel.impl.engine.DefaultReactiveExecutor.schedule(DefaultReactiveExecutor.java:55) at chassis//org.apache.camel.processor.MulticastProcessor.lambda$schedule$1(MulticastProcessor.java:312) at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515) at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264) at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128) at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628) at java.base/java.lang.Thread.run(Thread.java:834)


Exception from error handler is ok because I throw it when camel context is stopped.
Why there are working camel threads after context was shutdowned?
These threads never stop and trying to redelivery every 100ms (as redelivery delay set).","davsclaus:1640248681:2021-12-23T16:38:01.638+0000:1640248681:2021-12-23T16:38:01.638+0000:What Camel version do you use, and can you show a improved example what you do and how to reproduce this.

A shutdown is never guaranteed to terminate all threads as they can be inflight and controlled by 3rd party systems. And when you shutdown Camel you often shutdown the JVM and then those threads of course die. So why after shutting down Camel do you keep the JVM running?
styopa1769:1646455467:2022-03-05T12:44:27.659+0000:1646455467:2022-03-05T12:44:27.659+0000:Sorry, forgot about this bug. But today it appeared again :(

I use camel with version 3.7.2.

In our application there are a lot of camel contexts and we use a *controller* to control them. That is why JVM is still running after context shutdown.

*Controller* creates new camel context every start and does not reuse it after shutdown.
styopa1769:1652771027:2022-05-17T15:03:47.437+0000:1652771027:2022-05-17T15:03:47.437+0000:Hello!

I found bug, it was because of https://issues.apache.org/jira/browse/CAMEL-17588

Now it should be fixed, thank you"
0,CAMEL-17373,Bug,Major,3.15.0,3.15.0,"
None
",Resolved,Fixed,3.15.0,Federico Mariani,Zineb Bendhiba,0,2,2021-12-23 13:19:51+00:00,2022-01-06 13:15:12+00:00,"Hello,


it seems that latest changes in 3.15.0-SNAPSHOT, are failing tests using the 


camel.component.fhir.server-url parameter. 


 


Also, I can't have a successfull build on my local machine of the components.


Example of errors:




[ERROR] org.apache.camel.component.fhir.FhirExtraParametersIT.testEncodeRequestToXml  Time elapsed: 0.01 s  <<< ERROR!
org.apache.camel.FailedToCreateRouteException: Failed to create route route55 at: >>> To[fhir://search/searchByUrl?inBody=url] <<< in route: Route(route55)[From[direct://SEARCH_BY_URL] -> [To[fhir://se... because of Failed to resolve endpoint: fhir://search/searchByUrl?inBody=url due to: The FHIR URL must be set!
        at org.apache.camel.reifier.RouteReifier.doCreateRoute(RouteReifier.java:240)
        at org.apache.camel.reifier.RouteReifier.createRoute(RouteReifier.java:74)
        at org.apache.camel.impl.DefaultModelReifierFactory.createRoute(DefaultModelReifierFactory.java:49)
        at org.apache.camel.impl.DefaultCamelContext.startRouteDefinitions(DefaultCamelContext.java:868)
        at org.apache.camel.impl.DefaultCamelContext.startRouteDefinitions(DefaultCamelContext.java:758)
        at org.apache.camel.impl.engine.AbstractCamelContext.doInit(AbstractCamelContext.java:2862)
        at org.apache.camel.support.service.BaseService.init(BaseService.java:83)
        at org.apache.camel.impl.engine.AbstractCamelContext.init(AbstractCamelContext.java:2568)
        at org.apache.camel.support.service.BaseService.start(BaseService.java:111)
        at org.apache.camel.impl.engine.AbstractCamelContext.start(AbstractCamelContext.java:2587)
        at org.apache.camel.impl.DefaultCamelContext.start(DefaultCamelContext.java:247)
        at org.apache.camel.test.junit5.CamelTestSupport.startCamelContext(CamelTestSupport.java:754)
        at org.apache.camel.test.junit5.CamelTestSupport.doSetUp(CamelTestSupport.java:528)
        at org.apache.camel.test.junit5.CamelTestSupport.setUp(CamelTestSupport.java:369)
        at jdk.internal.reflect.GeneratedMethodAccessor2.invoke(Unknown Source)
        at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
        at java.base/java.lang.reflect.Method.invoke(Method.java:566)
        at org.junit.platform.commons.util.ReflectionUtils.invokeMethod(ReflectionUtils.java:725)
        at org.junit.jupiter.engine.execution.MethodInvocation.proceed(MethodInvocation.java:60)
        at org.junit.jupiter.engine.execution.InvocationInterceptorChain$ValidatingInvocation.proceed(InvocationInterceptorChain.java:131)
        at org.junit.jupiter.engine.extension.TimeoutExtension.intercept(TimeoutExtension.java:149)
        at org.junit.jupiter.engine.extension.TimeoutExtension.interceptLifecycleMethod(TimeoutExtension.java:126)
        at org.junit.jupiter.engine.extension.TimeoutExtension.interceptBeforeEachMethod(TimeoutExtension.java:76)
        at org.junit.jupiter.engine.execution.ExecutableInvoker$ReflectiveInterceptorCall.lambda$ofVoidMethod$0(ExecutableInvoker.java:115)
        at org.junit.jupiter.engine.execution.ExecutableInvoker.lambda$invoke$0(ExecutableInvoker.java:105)
        at org.junit.jupiter.engine.execution.InvocationInterceptorChain$InterceptedInvocation.proceed(InvocationInterceptorChain.java:106)
        at org.junit.jupiter.engine.execution.InvocationInterceptorChain.proceed(InvocationInterceptorChain.java:64)
        at org.junit.jupiter.engine.execution.InvocationInterceptorChain.chainAndInvoke(InvocationInterceptorChain.java:45)
        at org.junit.jupiter.engine.execution.InvocationInterceptorChain.invoke(InvocationInterceptorChain.java:37)
        at org.junit.jupiter.engine.execution.ExecutableInvoker.invoke(ExecutableInvoker.java:104)
        at org.junit.jupiter.engine.execution.ExecutableInvoker.invoke(ExecutableInvoker.java:98)
        at org.junit.jupiter.engine.descriptor.ClassBasedTestDescriptor.invokeMethodInExtensionContext(ClassBasedTestDescriptor.java:506)
        at org.junit.jupiter.engine.descriptor.ClassBasedTestDescriptor.lambda$synthesizeBeforeEachMethodAdapter$21(ClassBasedTestDescriptor.java:491)
        at org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.lambda$invokeBeforeEachMethods$3(TestMethodTestDescriptor.java:171)
        at org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.lambda$invokeBeforeMethodsOrCallbacksUntilExceptionOccurs$6(TestMethodTestDescriptor.java:199)
        at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)
        at org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.invokeBeforeMethodsOrCallbacksUntilExceptionOccurs(TestMethodTestDescriptor.java:199)
        at org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.invokeBeforeEachMethods(TestMethodTestDescriptor.java:168)
        at org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.execute(TestMethodTestDescriptor.java:131)
        at org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.execute(TestMethodTestDescriptor.java:66)
        at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$6(NodeTestTask.java:151)
        at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)
        at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$8(NodeTestTask.java:141)
        at org.junit.platform.engine.support.hierarchical.Node.around(Node.java:137)
        at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$9(NodeTestTask.java:139)
        at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)
        at org.junit.platform.engine.support.hierarchical.NodeTestTask.executeRecursively(NodeTestTask.java:138)
        at org.junit.platform.engine.support.hierarchical.NodeTestTask.execute(NodeTestTask.java:95)
        at java.base/java.util.ArrayList.forEach(ArrayList.java:1541)
        at org.junit.platform.engine.support.hierarchical.SameThreadHierarchicalTestExecutorService.invokeAll(SameThreadHierarchicalTestExecutorService.java:41)
        at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$6(NodeTestTask.java:155)
        at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)
        at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$8(NodeTestTask.java:141)
        at org.junit.platform.engine.support.hierarchical.Node.around(Node.java:137)
        at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$9(NodeTestTask.java:139)
        at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)
        at org.junit.platform.engine.support.hierarchical.NodeTestTask.executeRecursively(NodeTestTask.java:138)
        at org.junit.platform.engine.support.hierarchical.NodeTestTask.execute(NodeTestTask.java:95)
        at java.base/java.util.ArrayList.forEach(ArrayList.java:1541)
        at org.junit.platform.engine.support.hierarchical.SameThreadHierarchicalTestExecutorService.invokeAll(SameThreadHierarchicalTestExecutorService.java:41)
        at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$6(NodeTestTask.java:155)
        at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)
        at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$8(NodeTestTask.java:141)
        at org.junit.platform.engine.support.hierarchical.Node.around(Node.java:137)
        at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$9(NodeTestTask.java:139)
        at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)
        at org.junit.platform.engine.support.hierarchical.NodeTestTask.executeRecursively(NodeTestTask.java:138)
        at org.junit.platform.engine.support.hierarchical.NodeTestTask.execute(NodeTestTask.java:95)
        at org.junit.platform.engine.support.hierarchical.SameThreadHierarchicalTestExecutorService.submit(SameThreadHierarchicalTestExecutorService.java:35)
        at org.junit.platform.engine.support.hierarchical.HierarchicalTestExecutor.execute(HierarchicalTestExecutor.java:57)
        at org.junit.platform.engine.support.hierarchical.HierarchicalTestEngine.execute(HierarchicalTestEngine.java:54)
        at org.junit.platform.launcher.core.EngineExecutionOrchestrator.execute(EngineExecutionOrchestrator.java:107)
        at org.junit.platform.launcher.core.EngineExecutionOrchestrator.execute(EngineExecutionOrchestrator.java:88)
        at org.junit.platform.launcher.core.EngineExecutionOrchestrator.lambda$execute$0(EngineExecutionOrchestrator.java:54)
        at org.junit.platform.launcher.core.EngineExecutionOrchestrator.withInterceptedStreams(EngineExecutionOrchestrator.java:67)
        at org.junit.platform.launcher.core.EngineExecutionOrchestrator.execute(EngineExecutionOrchestrator.java:52)
        at org.junit.platform.launcher.core.DefaultLauncher.execute(DefaultLauncher.java:114)
        at org.junit.platform.launcher.core.DefaultLauncher.execute(DefaultLauncher.java:86)
        at org.junit.platform.launcher.core.DefaultLauncherSession$DelegatingLauncher.execute(DefaultLauncherSession.java:86)
        at org.junit.platform.launcher.core.SessionPerRequestLauncher.execute(SessionPerRequestLauncher.java:53)
        at org.apache.maven.surefire.junitplatform.JUnitPlatformProvider.invokeAllTests(JUnitPlatformProvider.java:154)
        at org.apache.maven.surefire.junitplatform.JUnitPlatformProvider.invoke(JUnitPlatformProvider.java:127)
        at org.apache.maven.surefire.booter.ForkedBooter.runSuitesInProcess(ForkedBooter.java:377)
        at org.apache.maven.surefire.booter.ForkedBooter.execute(ForkedBooter.java:138)
        at org.apache.maven.surefire.booter.ForkedBooter.run(ForkedBooter.java:465)
        at org.apache.maven.surefire.booter.ForkedBooter.main(ForkedBooter.java:451)
Caused by: org.apache.camel.ResolveEndpointFailedException: Failed to resolve endpoint: fhir://search/searchByUrl?inBody=url due to: The FHIR URL must be set!
        at org.apache.camel.impl.engine.AbstractCamelContext.doGetEndpoint(AbstractCamelContext.java:969)
        at org.apache.camel.impl.engine.AbstractCamelContext.getEndpoint(AbstractCamelContext.java:851)
        at org.apache.camel.support.CamelContextHelper.resolveEndpoint(CamelContextHelper.java:123)
        at org.apache.camel.reifier.SendReifier.resolveEndpoint(SendReifier.java:43)
        at org.apache.camel.reifier.SendReifier.createProcessor(SendReifier.java:36)
        at org.apache.camel.reifier.ProcessorReifier.makeProcessor(ProcessorReifier.java:838)
        at org.apache.camel.reifier.ProcessorReifier.addRoutes(ProcessorReifier.java:579)
        at org.apache.camel.reifier.RouteReifier.doCreateRoute(RouteReifier.java:236)
        ... 85 more
Caused by: org.apache.camel.RuntimeCamelException: The FHIR URL must be set!
        at org.apache.camel.component.fhir.internal.FhirHelper.getFhirContext(FhirHelper.java:147)
        at org.apache.camel.component.fhir.internal.FhirHelper.createClient(FhirHelper.java:50)
        at org.apache.camel.component.fhir.FhirComponent.createClient(FhirComponent.java:64)
        at org.apache.camel.component.fhir.FhirComponent.createEndpoint(FhirComponent.java:57)
        at org.apache.camel.component.fhir.FhirComponent.createEndpoint(FhirComponent.java:29)
        at org.apache.camel.support.component.AbstractApiComponent.createEndpoint(AbstractApiComponent.java:87)
        at org.apache.camel.support.DefaultComponent.createEndpoint(DefaultComponent.java:171)
        at org.apache.camel.impl.engine.AbstractCamelContext.doGetEndpoint(AbstractCamelContext.java:935)
        ... 92 more","Federico Mariani:1640260505:2021-12-23T19:55:05.484+0000:1640260505:2021-12-23T19:55:05.484+0000:Hi, I think component init is not working because endpoint properties are not set on the configuration object, I managed to fix it by overriding {_}protected Endpoint createEndpoint(String uri, String remaining, Map<String, Object> parameters) throws Exceptio{_}, though an afterPropertiesSet protected method would be nice to have to init client, here you can see the changes [https://github.com/apache/camel/compare/main...Croway:CAMEL-17373?expand=1]

In particular I just refactored
{code:java}
if (endpointConfiguration.getClient() == null) {
                if (configuration != null) {
                    endpointConfiguration.setServerUrl(configuration.getServerUrl());
                    endpointConfiguration.setFhirContext(configuration.getFhirContext());
                }

                endpointConfiguration.setClient(createClient(endpointConfiguration));
            }
{code}
from _createEndpoint_ to _""afterPropertiesSet""._
WDYT? am I missing something?
zbendhiba:1641446112:2022-01-06T13:15:12.572+0000:1641446112:2022-01-06T13:15:12.572+0000:Thanks for the fix"
0,CAMEL-17372,Bug,Major,"3.12.0, 3.13.0, 3.14.0","3.14.1, 3.15.0","
None
",Resolved,Fixed,"3.14.1, 3.15.0",Andrea Cosentino,Andrea Cosentino,0,2,2021-12-23 07:15:30+00:00,2021-12-24 14:20:05+00:00,No Desc,"davsclaus:1640249032:2021-12-23T16:43:52.126+0000:1640249032:2021-12-23T16:43:52.126+0000:I think I did some work on main, and so have added it there - its in the camel-package-maven-plugin you need to add it
acosentino:1640251752:2021-12-23T17:29:12.172+0000:1640251752:2021-12-23T17:29:12.172+0000:It's already in the MojoHelper https://github.com/apache/camel/blob/main/tooling/maven/camel-package-maven-plugin/src/main/java/org/apache/camel/maven/packaging/MojoHelper.java#L52
acosentino:1640252383:2021-12-23T17:39:43.623+0000:1640252383:2021-12-23T17:39:43.623+0000:Ah ok, it was only in 3.14.x to do."
0,CAMEL-17371,Improvement,Major,None,3.15.0,"
None
",Resolved,Fixed,3.15.0,Unassigned,Eugene Berman,0,2,2021-12-22 17:53:36+00:00,2021-12-23 13:41:45+00:00,Similar to `setMessageHeaderOnBreakpoint` and `removeMessageHeaderOnBreakpoint1 there should be set/remove Exchange property methods.,davsclaus:1640238105:2021-12-23T13:41:45.094+0000:1640238105:2021-12-23T13:41:45.094+0000:Thanks for the PR
0,CAMEL-17370,Improvement,Minor,None,3.15.0,"
None
",Resolved,Fixed,3.15.0,Otavio Rodolfo Piske,Luca Burgazzoli,0,3,2021-12-22 08:56:47+00:00,2022-01-03 15:40:39+00:00,"As per documentation, you can install the camel jbang app, by running the following command:




$ jbang app install CamelJBang@apache/camel




And then you can use it to run integrations like:




$ CamelJBang run jms-amqp-10-sink-binding.yaml




I wonder if instead of CamelJBang we can simply use camel, like




$ jbang app install camel@apache/camel
$ camel run jms-amqp-10-sink-binding.yaml","lb:1640134625:2021-12-22T08:57:05.317+0000:1640134625:2021-12-22T08:57:05.317+0000:[~orpiske] [~davsclaus]
davsclaus:1640136177:2021-12-22T09:22:57.184+0000:1640136177:2021-12-22T09:22:57.184+0000:yeah that is a better and shorter name ;)
orpiske:1640137544:2021-12-22T09:45:44.061+0000:1640137544:2021-12-22T09:45:44.061+0000:+1 from me as well. I can take care of this when I get back from PTO.
orpiske:1641195639:2022-01-03T15:40:39.549+0000:1641195639:2022-01-03T15:40:39.549+0000:Resolved with the linked PR."
0,CAMEL-17369,Improvement,Minor,None,4.x,"
None
",Open,Unresolved,4.x,Andrea Cosentino,Andrea Cosentino,0,1,2021-12-22 07:27:37+00:00,2023-08-09 09:14:58+00:00,Like CAMEL-16883,
0,CAMEL-17368,Improvement,Minor,None,4.x,"
None
",Open,Unresolved,4.x,Andrea Cosentino,Andrea Cosentino,0,1,2021-12-22 07:27:03+00:00,2023-08-09 09:15:01+00:00,Like CAMEL-16883,
0,CAMEL-17367,Bug,Minor,"3.12.0, 3.14.0","3.14.1, 3.15.0","
None
",Resolved,Fixed,"3.14.1, 3.15.0",Claus Ibsen,Andrew Rosenberg,0,2,2021-12-21 20:02:09+00:00,2022-01-09 10:55:07+00:00,"I'm trying something like this


.toD(
{{ kafka(""my-topic"")}}
{{ .brokers(""kafka.brokers"")}}
{{ .partitioner(org.apache.kafka.clients.producer.RoundRobinPartitioner.class.getName())}}
{{ .valueSerializer(ByteArraySerializer.class.getName()))}}


and I get this error


Metadata response reported invalid topics //my-topic


This is because parseTopicName in KafkaSendDynamicAware is unaware of the // in the uri.","davsclaus:1640122893:2021-12-22T05:41:33.537+0000:1640122893:2021-12-22T05:41:33.537+0000:Try with Camel 3.14.0 first before reporting
Iapetus999:1640168717:2021-12-22T18:25:17.988+0000:1640168717:2021-12-22T18:25:17.988+0000:Confirmed that it's in 3.14.0
davsclaus:1640240459:2021-12-23T14:20:59.377+0000:1640240459:2021-12-23T14:20:59.377+0000:Can you expand on your reporting and provide a more detailed description of the problem, such as full route or reproducer example.
davsclaus:1641696712:2022-01-09T10:51:52.202+0000:1641696712:2022-01-09T10:51:52.202+0000:Okay I think I see what you mean, I am trying to reproduce and fix this"
0,CAMEL-17366,Bug,Minor,"3.12.0, 3.14.0",,"
None
",Resolved,Information Provided,None,Unassigned,Andrew Rosenberg,0,2,2021-12-21 19:56:44+00:00,2022-09-03 10:45:56+00:00,"I have an expression like this but what's in `fileName` doesn't resolve to the header value. I think it's being escaped when it shouldn't be.


.simple(
{{ aws2S3(""${headers."" + FILE_BUCKET_HEADER_KEY + ""}"")}}
{{ .amazonS3Client(""#commonS3Client"")}}
{{ .bridgeErrorHandler(true)}}
{{ .useDefaultCredentialsProvider(true)}}
{{ .advanced().autocloseBody(true).basic()}}
{{ .includeBody(false)}}
{{ .deleteAfterRead(false)}}
{{ .fileName(""${headers."" + FILE_URI_HEADER_KEY + ""}"")}}
{{ .getUri())}}


My workaround that works is this but I don't love it


.simple(
{{ aws2S3(""${headers."" + FILE_BUCKET_HEADER_KEY + ""}""}}
{{ + ""?fileName=${headers."" + FILE_URI_HEADER_KEY + ""}"")}}
{{ .amazonS3Client(""#commonS3Client"")}}
{{ .bridgeErrorHandler(true)}}
{{ .useDefaultCredentialsProvider(true)}}
{{ .advanced().autocloseBody(true).basic()}}
{{ .includeBody(false)}}
{{ .deleteAfterRead(false)}}
{{ .getUri())}}","davsclaus:1640122906:2021-12-22T05:41:46.777+0000:1640122906:2021-12-22T05:41:46.777+0000:Try with Camel 3.14.0 first before reporting
Iapetus999:1640168936:2021-12-22T18:28:56.414+0000:1640168936:2021-12-22T18:28:56.414+0000:Confirmed it's still in 3.14.0
davsclaus:1640240481:2021-12-23T14:21:21.698+0000:1640240481:2021-12-23T14:21:21.698+0000:Can you expand on your reporting and provide a more detailed description of the problem, such as full route or reproducer example.
davsclaus:1641696979:2022-01-09T10:56:19.351+0000:1641696979:2022-01-09T10:56:19.351+0000:Try with

{code}
 .fileName(""$simple{headers."" + FILE_URI_HEADER_KEY + ""}"")
{code}
Iapetus999:1641801475:2022-01-10T15:57:55.545+0000:1641801647:2022-01-10T16:00:47.060+0000:Hi Claus.

The expression doesn't get parsed and AWS S3 Client receives {{key=""$simple\{headers.computeFileUri}""}}
davsclaus:1654302547:2022-06-04T08:29:07.115+0000:1654302547:2022-06-04T08:29:07.115+0000:Try with 3.17.0 or newer and report back"
0,CAMEL-17365,Improvement,Minor,3.14.0,3.15.0,"
None
",Resolved,Fixed,3.15.0,Jeremy Ross,Jeremy Ross,0,1,2021-12-21 17:53:42+00:00,2022-01-09 18:13:12+00:00,"It's currently hard coded to the properties in the RestResources class. Instead it should be dynamic so we don't have to add new properties all the time.


Look at doing the same with `Limits`.",
0,CAMEL-17364,New Feature,Minor,None,3.x,"
None
",Resolved,Won't Fix,3.x,Unassigned,Claus Ibsen,0,1,2021-12-21 15:33:11+00:00,2022-09-03 10:45:06+00:00,No Desc,"davsclaus:1640072043:2021-12-21T15:34:03.471+0000:1640072043:2021-12-21T15:34:03.471+0000:The endpoint and component DSLs are currently tied to the core camel project.

It requires some effort in the maven plugins to add support for building for 3rd party standalone camel components in their own set of classes.
"
0,CAMEL-17363,Improvement,Major,None,3.15.0,"
None
",Resolved,Implemented,3.15.0,Claus Ibsen,Claus Ibsen,0,1,2021-12-21 14:59:05+00:00,2021-12-22 09:21:34+00:00,So you can configure in the maven plugin to skip specific components in the DSL,"davsclaus:1640133400:2021-12-22T08:36:40.430+0000:1640133400:2021-12-22T08:36:40.430+0000:They now take input from camel-catalog, so we can filter on the catalog level
davsclaus:1640136094:2021-12-22T09:21:34.770+0000:1640136094:2021-12-22T09:21:34.770+0000:components that are disabled during a build, eg not included in the components/pom.xml is now not in the DSLs / catalog / parent pom etc.

"
0,CAMEL-17362,Bug,Major,None,,"
None
",Resolved,Duplicate,None,Andrea Cosentino,Andrea Cosentino,0,1,2021-12-21 12:59:46+00:00,2022-01-13 10:54:41+00:00,"It consumes all the commits at first poll, then if you commit something the new commit is not consumed.",acosentino:1642042469:2022-01-13T10:54:29.776+0000:1642042469:2022-01-13T10:54:29.776+0000:Fixed in CAMEL-17473
0,CAMEL-17361,Improvement,Major,None,3.15.0,"
None
",Resolved,Fixed,3.15.0,Claus Ibsen,Claus Ibsen,0,1,2021-12-21 08:39:40+00:00,2021-12-21 08:48:51+00:00,"It is overkill to have a leaf for routecontrollers when there is only 1 mbean - either the default or the supervised. 


It should be in services like all the others we have there.",
0,CAMEL-17360,Dependency upgrade,Major,None,None,"
None
",Resolved,Fixed,"3.14.1, 3.15.0",Freeman Yue Fang,Freeman Yue Fang,0,1,2021-12-20 21:31:39+00:00,2021-12-21 15:35:04+00:00,"camel-xmlsecurity
camel-jsch
camel-crypto
camel-asn1
camel-ssh
camel-pdf
camel-ftp
camel-as2
camel-fop
have this dependency",
0,CAMEL-17359,Improvement,Major,None,None,"
None
",Resolved,Fixed,3.15.0,Claus Ibsen,Claus Ibsen,0,1,2021-12-20 14:48:29+00:00,2021-12-21 08:49:24+00:00,https://github.com/camel-tooling/camel-idea-plugin/pull/637#issuecomment-997989261,
0,CAMEL-17358,Bug,Major,"3.11.4, 3.14.0","3.11.6, 3.14.1, 3.15.0","

AWS

",Resolved,Fixed,"3.11.6, 3.14.1, 3.15.0",Andrea Cosentino,thanos,0,3,2021-12-20 13:21:40+00:00,2022-01-13 10:51:41+00:00,"Just migrated from Camel AWS SDK1 Producer to SDK2 Producer and our unit tests break because the Content Type of the uploaded object is not set at the PutObjectRequest level but only at the ObjectMetadata object. It appears, after quick comparison between SDK1 and SDK2 that in SDK1 AWS-SDK was happy to take the content type from the metadata while now it expects it to be in the PutObjectRequest field.


 


A test case will be uploaded shortly to demonstrate the bug","thagg1975:1641963815:2022-01-12T13:03:35.814+0000:1641963815:2022-01-12T13:03:35.814+0000:Hello [~acosentino]  [~davsclaus] this bug is rather blocking for us, can you please provide us expected date of release for 3.11.6 LTS or 3.14.1  ?
acosentino:1641964051:2022-01-12T13:07:31.085+0000:1641964051:2022-01-12T13:07:31.085+0000:For 3.11.6 at least two or three weeks from now, but it depends from the release manager availability. For 3.14.1 it could be before, but always talking about weeks.  I'll fix this tomorrow or beginning of next week."
0,CAMEL-17357,Improvement,Major,Future,,"
None
",Resolved,Won't Fix,None,Unassigned,Olaf Heyder,0,2,2021-12-20 12:23:03+00:00,2021-12-20 18:54:19+00:00,"One purpose of the CamelInvocationHandler (& Friends) is to translate a java.lang.reflect.Method to  an Exchange in order to eventually have the registered Producer process that Exchange. Currently the name of the method gets lost when the Exchange is prepared.


It would be helpful if the Exchange contained the method name (as a String), e.g. as an appropiate header. In that case it would be possible to write a new Camel Component ""jsonrpc"". according to Camel's design concept, because the jsonrpc protocol requires the name of the method in the request message.


My suggestion is to attach the method name to the Exchange in method


protected Object invokeProxy(final Method method, final ExchangePattern pattern, Object[] args, boolean binding)","davsclaus:1639974997:2021-12-20T12:36:37.106+0000:1639974997:2021-12-20T12:36:37.106+0000:That is part of the old Camel 2.x that is EOL
japhno:1639992377:2021-12-20T17:26:17.299+0000:1639992377:2021-12-20T17:26:17.299+0000:[~davsclaus] Please rethink your decision. How would you implement a _jsonrpc_ Component?

The old Camel 2.x used the _BeanInvocation_ class as a container for the data to be exchanged. And the serialized(!) _BeanInvocation_ object was sent on the wire which was indeed not a good approach.

Why?
 # It is generally considered unsafe as malicious payload can exploit the host system. (see also [here|https://activemq.apache.org/objectmessage]).
 # The Java serialized form of even small objects is very verbose so it takes up a lot of space on the wire, also Java serialization is slow compared to custom marshalling techniques. (see also [here|https://activemq.apache.org/components/artemis/documentation/1.5.0/perf-tuning.html]. Search for ""serialized"")
 # Both sides (client+server) must talk Java - no platform independence.
 # Implementing serialization correctly can be tricky.

Hence, the _BeanInvocation_ was retired for good reason.

Now let's assume we want to use Camel to talk to a _jsonrpc_ service where the message exchange is text based.

A Java server may implement some interface like this:

 
{code:java}
interface Foo {
    Bar doSomething(Fee p1, Bee p2);
}
{code}
And the server may publish its service using _jsonrpc_ in a platform independent manner. In such a case a client would have to send a request message like this:

 

 
{code:java}
{
  ""method"" : ""doSomething"",
  ""jsonrpc"" : ""2.0"",
  ""id"" : ""some-correlation-id..."",
  ""params"" : [
    {
      the marshalled Fee object
    },
    {
      the marshalled Bee object
    }
  ]
}
{code}
 

Briefly, the server expects the request message to be a JSON object which it needs to unmarshal before the actual method call.

From a Camel user's point of view I would like to have a proxy of the Foo service in the client. This can easily be achieved even today like this:

 
{code:java}
Foo foo = ProxyHelper.createProxy(jsonrpEndpoint, Foo.class);
{code}
+But only+ as long as the _Endpoint_ (i.e. its {_}Producer{_}) is able to process the _Exchange_ which was prepared by the _AbstractInvocationHandler._ (The producer can delegate the actual conversion to a JSON Converter like the Jackson or gson libraries.)

Today the _AbstractInvocationHandler_ does not attach the name of the method (in case of the example above ""doSomething"") to the exchange. Hence the producer is not able to do the conversion, because the method name (mandatory for a _jsonrpc_ request) is missing.

 

In other words, I am missing a _jsonrpc_ Component in the Camel toolkit. Therefore I hereby ask for the prerequisite for a Camel'ish solution.

Shall I open a feature request, or can we can go with this one and I send you my _jsonrpc_ Component for review and maybe adding to Camel?

PS: The Consumer of the Endpoint could be configured with a corresponding Converter to unmarshal the response from the server. Even here I imagine a powerful default converter which is able to handle 99% of all possible responses.
davsclaus:1639997659:2021-12-20T18:54:19.757+0000:1639997659:2021-12-20T18:54:19.757+0000:No sorry we will not compromise the camel-bean component or anything in the core about serialized java over rpc.

You can build custom camel components where you can add everything in this component for such functionality."
0,CAMEL-17356,Task,Minor,"3.12.0, 3.13.0, 3.14.0",None,"
None
",Closed,Not A Problem,None,Unassigned,Elie Francis,0,2,2021-12-20 12:01:52+00:00,2021-12-20 13:18:45+00:00,"Until version 3.11.2, the packaged jar file for each component had a modification date for each inner file. Starting from version 3.12.0, this ""modification date"" value is empty. The absence of date for this files affects Spring Boot applications at start-up time, because the class expect to have valid dates for all classes.


Here is a screenshot for camel-core-engine v 3.11.2





And here is another one for V 3.14.0





The related error stack trace is here :




Exception in thread ""main"" java.time.DateTimeException: Invalid value for MonthOfYear (valid values 1 - 12): 0
        at java.time.temporal.ValueRange.checkValidValue(ValueRange.java:311)
        at java.time.temporal.ChronoField.checkValidValue(ChronoField.java:703)
        at java.time.LocalDate.of(LocalDate.java:267)
        at java.time.LocalDateTime.of(LocalDateTime.java:336)
        at org.springframework.boot.loader.jar.CentralDirectoryFileHeader.decodeMsDosFormatDateTime(CentralDirectoryFileHeader.java:127)
        at org.springframework.boot.loader.jar.CentralDirectoryFileHeader.getTime(CentralDirectoryFileHeader.java:116)
        at org.springframework.boot.loader.jar.JarEntry.<init>(JarEntry.java:58)
        at org.springframework.boot.loader.jar.JarFileEntries.getEntry(JarFileEntries.java:316)","davsclaus:1639973229:2021-12-20T12:07:09.263+0000:1639973229:2021-12-20T12:07:09.263+0000:What are you doing, we have many users of Camel using Camel on Spring Boot and have no problems.

So can you tell more exactly what you are doing, and provide a sample project or something to demonstrate/reproduce your issue.
davsclaus:1639973353:2021-12-20T12:09:13.393+0000:1639973353:2021-12-20T12:09:13.393+0000:Okay so it seems you are using windows, what version of windows is that
efrancis59:1639977492:2021-12-20T13:18:12.883+0000:1639977492:2021-12-20T13:18:12.883+0000:I'm using spring boot version 2.1.6.

I tried with a newer version (2.5.7), it woks without any problem. So I'll modify my framework version. 

Thanks

 
efrancis59:1639977525:2021-12-20T13:18:45.918+0000:1639977525:2021-12-20T13:18:45.918+0000:Works with newer versions of spring boot"
0,CAMEL-17355,Task,Major,None,3.15.0,"
None
",Resolved,Fixed,3.15.0,Unassigned,Claus Ibsen,0,1,2021-12-20 09:53:37+00:00,2021-12-20 10:08:35+00:00,"camel-cdi is not very much in use, lets reduce what we have to keep maintenance low",
0,CAMEL-17354,Task,Major,None,None,"
None
",Resolved,Fixed,3.15.0,Claus Ibsen,Claus Ibsen,0,3,2021-12-20 09:02:47+00:00,2022-10-16 17:32:33+00:00,"camel-atomix
camel-beanstalk
camel-beanio
camel-cdi (legacy xml)
camel-etcd
camel-elsql
camel-ganglia
camel-nsq
camel-hystrix
camel-jing
camel-leveldb-legacy
camel-msv
camel-nagios
camel-ribbon
camel-sip
camel-soroush
camel-spring-javaconfig DONE
camel-tagsoup
camel-yammer","davsclaus:1639965067:2021-12-20T09:51:07.536+0000:1639965067:2021-12-20T09:51:07.536+0000:We are deprecating this in 3.15, and then starting to remove them before the summer LTS release
davsclaus:1640412722:2021-12-25T14:12:02.197+0000:1640412722:2021-12-25T14:12:02.197+0000:TODO: deprecate all these components *DONE* for Camel 3.15
orpiske:1648598257:2022-03-30T07:57:37.959+0000:1648598257:2022-03-30T07:57:37.959+0000:[~davsclaus] out of curiosity: are we planning to remove them for 3.17?
davsclaus:1648598844:2022-03-30T08:07:24.202+0000:1648598844:2022-03-30T08:07:24.202+0000:Yeah the list of components are not really important, and we have 3.14 LTS with them for a long time still.
davsclaus:1648598876:2022-03-30T08:07:56.054+0000:1648598876:2022-03-30T08:07:56.054+0000:So lets create a new JIRA with 3.17 as target and point to this list
orpiske:1648599018:2022-03-30T08:10:18.152+0000:1648599018:2022-03-30T08:10:18.152+0000:Awesome. I think this will help us move further w/ Java 17 support. +1 for the list. I can create it.
orpiske:1648599137:2022-03-30T08:12:17.247+0000:1648599137:2022-03-30T08:12:17.247+0000:Done: CAMEL-17879.
acjohnson:1665765696:2022-10-15T00:41:36.119+0000:1665765696:2022-10-15T00:41:36.119+0000:[~davsclaus] we are heavy users of NSQ, what is the likelihood camel-nsq could get added back to Camel? It looks like we can use it in 3.14 LTS with for about 14 months and after that there will be no upgrade path? Thanks!
davsclaus:1665912753:2022-10-16T17:32:33.435+0000:1665912753:2022-10-16T17:32:33.435+0000:Aaron, the official java client was not manitanined and is dead
https://github.com/nsqio/nsq-java

You are welcome to create a JIRA to switch to a new active client. A list of clients is at
https://nsq.io/clients/client_libraries.html

And it seems that this is active and MIT license so we can use that at ASF
https://github.com/sproutsocial/nsq-j

If you can work on that, create a JIRA and port the old code over to the new client and send PR to ASF"
0,CAMEL-17353,Dependency upgrade,Major,None,None,"
None
",Resolved,Information Provided,"3.11.5, 3.14.1, 3.15.0",Unassigned,liupingtest,0,2,2021-12-20 07:01:00+00:00,2021-12-20 12:56:46+00:00,No Desc,"davsclaus:1639959271:2021-12-20T08:14:31.979+0000:1639959271:2021-12-20T08:14:31.979+0000:See
https://camel.apache.org/blog/2021/12/log4j2/
davsclaus:1639976185:2021-12-20T12:56:25.233+0000:1639976185:2021-12-20T12:56:25.233+0000:Upgraded to 2.17.0, thanks for reporting and the PR"
0,CAMEL-17352,New Feature,Major,None,None,"
None
",Resolved,Fixed,3.15.0,Unassigned,Claus Ibsen,0,1,2021-12-18 09:28:29+00:00,2021-12-20 18:47:11+00:00,"When using to(""log:foo"") then we log the message with various key=values etc.


But sometimes you just want only the message body, and then you can use log(""${body}"") but that is not an endpoint.


So we can make to(""log:foo?plain=true"") to make it log only the body as-is.",
0,CAMEL-17351,Improvement,Major,None,None,"
None
",Resolved,Fixed,3.15.0,Andrea Cosentino,Andrea Cosentino,0,1,2021-12-17 17:38:49+00:00,2021-12-20 13:26:11+00:00,"Being able to use file:, classpath:, http: etc.


Actually it is just a file path.",
0,CAMEL-17350,Bug,Minor,2.21.0,None,"

camel-zipfile
charset
newbie
patch
zip

",Resolved,Information Provided,None,Unassigned,Sudheer Mishra,0,2,2021-12-17 07:18:54+00:00,2021-12-17 11:40:28+00:00,"I am using ZipAggregationStrategy with multicast & parallel processing and it doesn't delete the zip file created in temp folder.


I tried to troubleshoot the issue and found that ZipAggregationStrategy adds addOnCompletion block to delete the zip file in the copy of the original exchange.


Once parallel processing finishes it doesn't update the original exchange and zip file remains as it is in temp folder.","davsclaus:1639712428:2021-12-17T11:40:28.109+0000:1639712428:2021-12-17T11:40:28.109+0000:Camel 2.21 is EOL and not supported.
Camel 2.25 is running out of support end of this month and we only fix CVEs in camel itself.

You can try to upgrade to newer 2.x or 3.x."
0,CAMEL-17349,Sub-task,Major,None,3.15.0,"
None
",Resolved,Fixed,3.15.0,Karen Lease,Karen Lease,0,2,2021-12-16 17:58:05+00:00,2022-01-25 15:27:09+00:00,"This test can fail if it is launched at the same time as AggregateTimeoutWithNoExecutorServiceTest because it doesn't distinguish the AggregatorTimeout threads from different tests. Fixed the tests to pass the name of the context such as ""camel-123"" to only count threads for the current test.",davsclaus:1643095629:2022-01-25T15:27:09.403+0000:1643095629:2022-01-25T15:27:09.403+0000:Great work on fixing the core tests
0,CAMEL-17348,Improvement,Minor,3.14.0,Future,"
None
",Open,Unresolved,Future,Unassigned,Zachary Gutterman,0,2,2021-12-16 16:15:54+00:00,2023-08-09 09:15:50+00:00,"The camel-Jira newIssue endpoint depends on Jira's sorting by id to find the most recent issue. Jira sort by id, however, does not sort across all projects and is not a reliable way to return a list of newest issues. (See attached screenshot of sorted issues by id desc with endpoint /rest/api/latest/search?jql=ORDER+BY+id+desc.) A solution could use the ""created"" field instead which reliably returns issues by most recent.",davsclaus:1662173088:2022-09-03T10:44:48.868+0000:1662173088:2022-09-03T10:44:48.868+0000:Thanks are you able to send a PR
0,CAMEL-17347,Bug,Major,3.11.3,,"
None
",Resolved,Information Provided,None,Unassigned,Andrey Filippov,0,2,2021-12-16 10:22:53+00:00,2021-12-19 08:52:58+00:00,"Hello,


I am checking 2 simple routes. First one is:


<blueprint xmlns=""http://www.osgi.org/xmlns/blueprint/v1.0.0""
    xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance""
    xsi:schemaLocation=""http://www.osgi.org/xmlns/blueprint/v1.0.0 blueprint-1.0.0.xsd "">
    <bean id=""rabbitConnectionFactory"" class=""org.springframework.amqp.rabbit.connection.CachingConnectionFactory"">
      <property name=""uri"" value=""amqp://localhost:5672""/>
      <property name=""username"" value=""guest""/>
      <property name=""password"" value=""guest""/>
    </bean>    <camelContext
        xmlns=""http://camel.apache.org/schema/blueprint""
        xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance""
        xsi:schemaLocation=""http://camel.apache.org/schema/blueprint camel-blueprint-3.4.5.xsd"">        <route id=""consume"">            <from uri=""spring-rabbitmq:ex1?queues=bar&prefetchCount=1"" />
            <onException>
                <exception>java.lang.Exception</exception>
                <redeliveryPolicy maximumRedeliveries=""2"" redeliveryDelay=""10000"" retryAttemptedLogLevel=""WARN""/>
                <handled><constant>true</constant></handled>
                <to uri=""direct:error"" />
            </onException>            <log message="">>>Consumer start""/>            <throwException exceptionType=""java.lang.NullPointerException""
                                message=""Not supported, sorjan""/>            <log message="">>>Body:  ${body}""/>
            <log message="">>>Headers:  ${headers}""/>
            <when>
                <simple>${body} == null</simple>
                <log message="">>>@@@@@@@@@@@@@@@@@@@@@@ Body is null!!!!""/>
            </when>
            
        </route>        <route>
            <from uri=""direct:error"" />
            <log message="">>>Error happens body:  ${body}""/>
        </route>    </camelContext>
</blueprint>


In this case a message from a queue is marked unacknowledged until the very end - after all redelivery attempts have fired. By the other hand, if I use polling consumer - like this:


<blueprint xmlns=""http://www.osgi.org/xmlns/blueprint/v1.0.0""
    xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance""
    xsi:schemaLocation=""http://www.osgi.org/xmlns/blueprint/v1.0.0 blueprint-1.0.0.xsd "">
    <bean id=""rabbitConnectionFactory"" class=""org.springframework.amqp.rabbit.connection.CachingConnectionFactory"">
      <property name=""uri"" value=""amqp://localhost:5672""/>
      <property name=""username"" value=""guest""/>
      <property name=""password"" value=""guest""/>
    </bean>    <camelContext
        xmlns=""http://camel.apache.org/schema/blueprint""
        xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance""
        xsi:schemaLocation=""http://camel.apache.org/schema/blueprint camel-blueprint-3.4.5.xsd"">        <route id=""consume"">
            <from uri=""timer:consume?period=60000"" />
            <onException>
                <exception>java.lang.Exception</exception>
                <redeliveryPolicy maximumRedeliveries=""2"" redeliveryDelay=""10000"" retryAttemptedLogLevel=""WARN""/>
                <handled><constant>true</constant></handled>
                <to uri=""direct:error"" />
            </onException>
            <log message="">>>Consumer start""/>            <pollEnrich>
                <constant>spring-rabbitmq:ex1?queues=bar&prefetchCount=1&acknowledgeMode=MANUAL</constant>
            </pollEnrich>            <throwException exceptionType=""java.lang.NullPointerException""
                                message=""Not supported, sorjan""/>
            <log message="">>>Body:  ${body}""/>
            <log message="">>>Headers:  ${headers}""/>
            <when>
                <simple>${body} == null</simple>
                <log message="">>>@@@@@@@@@@@@@@@@@@@@@@ Body is null!!!!""/>
            </when>
            
        </route>        <route>
            <from uri=""direct:error"" />
            <log message="">>>Error happens body:  ${body}""/>
        </route>    </camelContext>
</blueprint>


In this case a message is disappeared from a queue immediately after pollEnrich without intermediate unacknowledged mark. 


I think this behavior is not 100% correct. 


P.s. Sorry - I used a wrong component in this ticket description cause camel-spring-rabbitmq is not in the list.","davsclaus:1639621970:2021-12-16T10:32:50.793+0000:1639621970:2021-12-16T10:32:50.793+0000:The polling consumer uses org.springframework.amqp.rabbit.core.RabbitTemplate to poll the message, and its spring behavior that will ack the message. This is a simpler consumer that works for a on-demand receive and seems to not offer as advanced features as the regular consumer.

The regular consumer is a org.springframework.amqp.rabbit.listener.api.ChannelAwareMessageListener
afilippov:1639716277:2021-12-17T12:44:37.509+0000:1639875178:2021-12-19T08:52:58.657+0000:[~davsclaus] thanks for the reply. Yes, org.apache.camel.component.springrabbit.SpringRabbitPollingConsumer uses org.springframework.amqp.rabbit.core.RabbitTemplate but the last one has a flag called 'channelTransacted' - [1]. And if I mark a route with <transacted /> and add 

<bean id=""rabbitTxManager""
        class=""org.springframework.amqp.rabbit.transaction.RabbitTransactionManager"">
        <property name=""connectionFactory"" ref=""rabbitConnectionFactory""/>
    </bean>

to the scope the behavior does not change - messages are read from a queue immediately without intermediate acks. At the same time If I do the same tx stuff with Artemis, messages will not be marked as delivered until the end of the route. I might be wrong but Camel could use 'channelTransacted' flag in the polling consumer.

 

 

[1] [https://docs.spring.io/spring-amqp/reference/html/amqp.html#transactions]"
0,CAMEL-17346,Improvement,Minor,3.14.0,3.15.0,"
None
",Resolved,Fixed,3.15.0,Unassigned,Jeremy Ross,0,1,2021-12-15 19:35:40+00:00,2021-12-15 20:11:50+00:00,"Currently, any 401 response results in attempting to re-login. If the error message is password expired, it's unrecoverable and we should not continue to re-attempt login. Instead, make an exception and let it bubble up.",
0,CAMEL-17345,New Feature,Major,None,3.15.0,"
None
",Resolved,Fixed,3.15.0,Federico Mariani,Claus Ibsen,0,2,2021-12-15 18:04:59+00:00,2022-01-08 10:11:46+00:00,"Add a new create-project command that would setup what you would ""run"" as a maven project with a pom.xml file, and source files in src/main/resources and src/main/java - and a log4j.properties file etc, so you can start with jbang and quickly hack/try something and run that, etc and then continue this as a regular maven project.","Federico Mariani:1639987910:2021-12-20T16:11:50.177+0000:1639987910:2021-12-20T16:11:50.177+0000:I'd like to work on this issue, but I have some question:

# Can https://github.com/camel-tooling/generator-camel-project be somehow reused, or is it overkill?
# I though I'd use a template engine like freemarker to generate the maven project, wdyt?
## How should I handle external classpath jars? (I'm thinking about -cp flag).
## The generated project should be built on quarkus or ""plain"" camel?
davsclaus:1640046119:2021-12-21T08:21:59.332+0000:1640046119:2021-12-21T08:21:59.332+0000:Yes overkill, we should just generate files for a camel-quarkus project as that is what camel-k is using.

Using a template engine is okay. But I think we only need to generate a pom.xml file,
and then move the source into src/main/java or src/main/resources.
And if so then maybe a template engine is also a bit overkill, as the dynamic part of the pom.xml is only the dependency section.

However we can use freemarker and then just add camel-freemarker to camel-kamelet-main where we have other set of needed dependencies for running with jbang, that is okay.



"
0,CAMEL-17344,Bug,Major,3.13.0,3.15.0,"
None
",Resolved,Fixed,3.15.0,Unassigned,Jeremy Ross,0,1,2021-12-15 16:58:03+00:00,2021-12-15 20:11:58+00:00,No Desc,
0,CAMEL-17343,Sub-task,Major,None,3.15.0,"
None
",Resolved,Fixed,3.15.0,Karen Lease,Karen Lease,0,1,2021-12-15 16:22:29+00:00,2022-01-26 08:49:58+00:00,"The SedaDefaultDiscardWhenFullTest and SedaDiscardWhenFullTest assume that a delay of 100msec is sufficient to ensure that at least one message is consumed so another can be sent without being discarded. During parallel execution this is not always the case since the consumer doesn't always get run in time.


Modify test to delay until the mock consumes at least 1 message.",
0,CAMEL-17342,Improvement,Major,None,3.15.0,"
None
",Resolved,Fixed,3.15.0,Unassigned,Eugene Berman,0,1,2021-12-15 15:10:27+00:00,2021-12-16 05:48:40+00:00,"In addition to the message body and headers, the debugger should also be able to dump exchange properties.",
0,CAMEL-17341,Improvement,Major,None,3.15.0,"
None
",Resolved,Fixed,3.15.0,Unassigned,Eugene Berman,0,1,2021-12-15 15:09:11+00:00,2021-12-16 05:48:10+00:00,The debugger should be able to evaluate an expression at a given suspended node ID in any Camel language.,
0,CAMEL-17340,New Feature,Major,None,3.15.0,"
None
",Resolved,Fixed,3.15.0,Claus Ibsen,Claus Ibsen,0,1,2021-12-15 12:48:43+00:00,2021-12-26 10:08:46+00:00,"For DSLs that has line number support we can make the debugger aware and provide this detail to the tooling, so it the exact source code line - as id's are often auto assigned, then its harder to pin point where in the source a breakpoint is at.","davsclaus:1639716783:2021-12-17T12:53:03.783+0000:1639716783:2021-12-17T12:53:03.783+0000:There are now MBean operations on manager camel context / managed routes that can return the mapping between node ids and source location/line-number that assist tooling
davsclaus:1640484513:2021-12-26T10:08:33.119+0000:1640484513:2021-12-26T10:08:33.119+0000:See dumpRoutesSourceLocationsAsXml on the camel context mbean"
0,CAMEL-17339,Improvement,Major,None,4.x,"
None
",Open,Unresolved,4.x,Andrea Cosentino,Andrea Cosentino,0,1,2021-12-15 12:07:00+00:00,2023-08-09 09:16:16+00:00,"Let's try to avoid this, it's better to have a comma separated string for Kamelets purpose, but also because it is much more cleaner in terms of reifiers.",acosentino:1639543096:2021-12-15T12:38:16.820+0000:1639543096:2021-12-15T12:38:16.820+0000:Azure-CosmosDB Done.
0,CAMEL-17338,New Feature,Major,None,3.15.0,"
None
",Resolved,Fixed,3.15.0,Claus Ibsen,Claus Ibsen,0,1,2021-12-15 08:35:29+00:00,2022-01-04 08:46:21+00:00,We can make the tracer include the name of the source file and line number of the EIP when tracing (if available) since some DSL loaders support this (xml and yaml).,
0,CAMEL-17337,Bug,Minor,3.x,3.15.0,"
None
",Resolved,Fixed,3.15.0,Unassigned,Paul Coombes,0,2,2021-12-14 16:58:12+00:00,2021-12-16 06:27:44+00:00,"In the 3.x branches, the FhirComponent contains a FhirConfiguration property which results in the getClient method creating a new IGenericClient from the method supplied configuration due to the configuration property never being initialised.




@Component(""fhir"")
public class FhirComponent extends AbstractApiComponent<FhirApiName, FhirConfiguration, FhirApiCollection> {

    @Metadata(label = ""advanced"")
    FhirConfiguration configuration;




This property appears to shadow a property of the same name on AbstractApiComponent




public abstract class AbstractApiComponent<E extends Enum<E> & ApiName, T, S extends ApiCollection<E, T>>
        extends DefaultComponent {

    @Metadata(label = ""advanced"", description = ""Component configuration"")
    protected T configuration;




This is an issue for me as I am attempting to register a IClientInterceptor to help with a SMART on FHIR workflow, which no longer works as the configuration supplied during class construction is ignored and a IGenericClient is never persisted.


To work around the issue in the interim, creating a component that extends FhirComponent, overriding the getClient method to utilise the configuration from AbstractApiComponent appears to resolve the issue.


Assuming I'm not missing anything obvious regarding the purpose for the configuration property on the FhirComponent class, and if desired, am more than happy to submit a PR with a fix.",davsclaus:1639520339:2021-12-15T06:18:59.409+0000:1639520339:2021-12-15T06:18:59.409+0000:You are welcome to attempt to submit a PR to fix this
0,CAMEL-17336,Bug,Major,3.13.0,"3.14.1, 3.15.0","
None
",Resolved,Fixed,"3.14.1, 3.15.0",Jeremy Ross,Jeremy Ross,0,2,2021-12-14 16:30:46+00:00,2021-12-15 16:48:21+00:00,"If Camel uses an ObjectMapper from the registry, it does not honor useList=true.","davsclaus:1639520281:2021-12-15T06:18:01.534+0000:1639520281:2021-12-15T06:18:01.534+0000:Can you backport to camel-3.14.x branch
jeremyross:1639558089:2021-12-15T16:48:09.405+0000:1639558089:2021-12-15T16:48:09.405+0000:Done."
0,CAMEL-17335,Dependency upgrade,Major,None,"3.7.7, 3.11.5, 3.14.1, 3.15.0","
None
",Resolved,Fixed,"3.7.7, 3.11.5, 3.14.1, 3.15.0",Claus Ibsen,Claus Ibsen,0,1,2021-12-14 14:40:46+00:00,2021-12-14 14:51:13+00:00,http://logback.qos.ch/news.html,
0,CAMEL-17334,New Feature,Major,None,3.16.0,"
None
",Resolved,Later,3.16.0,Unassigned,Claus Ibsen,0,1,2021-12-14 14:25:14+00:00,2022-03-02 17:31:57+00:00,"This should be off by default, but we can add a flag to enable this, so routes loaders can be instructed to keep a copy of the loaded resource.


This allows tooling and others to get hold of the source of the route so they can better display tooling information with the source code.",
0,CAMEL-17303,Bug,Major,3.14.0,3.14.0,"
None
",Resolved,Fixed,3.14.0,Claus Ibsen,Marat Gubaidullin,0,2,2021-12-08 15:40:57+00:00,2021-12-08 19:53:42+00:00,"Could not start routes with components
1. Netty example 




- from:
    uri: 'netty-http:http://localhost:8080/demo'
    steps:
      - log:
          message: '${body}'




Throws



org.apache.camel.FailedToCreateRouteException: Failed to create route route1: Route(route1)[From[netty-http:http://localhost:8080/demo] ->... because of No endpoint could be found for: netty-http://http://localhost:8080/demo, please check your classpath contains the needed Camel component jar.




2. Kafka example




- from:
    uri: 'kafka:demo'
    steps:
      - log:
          message: '${body}'




Throws



org.apache.camel.FailedToCreateRouteException: Failed to create route route1: Route(route1)[From[kafka:demo] -> [Log[${body}]]] because of No endpoint could be found for: kafka://demo, please check your classpath contains the needed Camel component jar.",davsclaus:1638964422:2021-12-08T19:53:42.071+0000:1638964422:2021-12-08T19:53:42.071+0000:Oh I cleaned up too much code - the autodownload works again
0,CAMEL-17302,Improvement,Major,None,3.14.0,"
None
",Resolved,Fixed,3.14.0,Claus Ibsen,Claus Ibsen,0,1,2021-12-08 13:44:46+00:00,2021-12-08 13:54:53+00:00,"When reloading 2+ routes then you get an event per route.
But if you only want to react after all are reloaded, then you need to know the index/total",
0,CAMEL-17301,New Feature,Major,None,3.14.0,"
None
",Resolved,Fixed,3.14.0,Claus Ibsen,Claus Ibsen,0,1,2021-12-08 12:24:47+00:00,2021-12-08 19:56:06+00:00,"We should keep track of known endpoints the platform-http is being registered with, then we can use that to list them, such as when camel is starting up to assist developers


Camel HTTP endpoints:


 http://localhost:8080/hello
http://localhost:8080/order/

{id}",davsclaus:1638943161:2021-12-08T13:59:21.850+0000:1638943161:2021-12-08T13:59:21.850+0000:We can update the http url only if its changed - currently its logged on reload
0,CAMEL-17300,Task,Major,None,3.14.0,"
None
",Resolved,Fixed,3.14.0,Claus Ibsen,Claus Ibsen,0,1,2021-12-08 09:48:20+00:00,2021-12-09 15:52:23+00:00,"Just a little example of using this, we have in main at main-xml and main-yaml",
0,CAMEL-17299,New Feature,Major,None,3.14.0,"
None
",Resolved,Fixed,3.14.0,Claus Ibsen,Claus Ibsen,0,1,2021-12-08 07:01:22+00:00,2021-12-08 09:45:41+00:00,Lets make this configurable so you can turn on it and specify the port number as part of CLI args.,
0,CAMEL-17298,Bug,Minor,3.13.0,3.14.0,"
None
",Resolved,Fixed,3.14.0,Claus Ibsen,Marat Gubaidullin,0,2,2021-12-07 23:07:10+00:00,2021-12-09 10:51:30+00:00,"The following code




from(""timer:test?repeatCount=1"")
    .setHeader(Exchange.HTTP_URI, simple(""https://gorest.co.in/public/v1/users/123/posts""))
    .toD(""vertx-http:${header.CamelHttpUri}"");




throws exception:



Error processing exchange. Exchange[AB574B09C060549-0000000000000000]. Caused by: [org.apache.camel.http.base.HttpOperationFailedException - HTTP operation failed invoking https://gorest.co.in/public/v1/users/123/posts/public/v1/users/123/posts with statusCode: 404]: org.apache.camel.http.base.HttpOperationFailedException: HTTP operation failed invoking https://gorest.co.in/public/v1/users/123/posts/public/v1/users/123/posts with statusCode: 404




Because it duplicates path public/v1/users/123/posts/public/v1/users/123/posts


Same code with camel-http work fine




.toD(""${header.CamelHttpUri}"")","davsclaus:1638928217:2021-12-08T09:50:17.077+0000:1638928217:2021-12-08T09:50:17.077+0000:That is because you use toD and ""abuse"" the Exchange.HTTP_URI header.
You can use to then it should work
marat.gubaidullin@gmail.com:1638939825:2021-12-08T13:03:45.927+0000:1638939825:2021-12-08T13:03:45.927+0000:1. *to* works for camel-vertx-http
{code:java}
.to(""vertx-http:${header.CamelHttpUri}"")
{code}

2. However *toD* works for camel-http
{code:java}
.toD(""${header.CamelHttpUri}"")
{code}

3. But *to* {color:red}does not work{color} for camel-http
{code:java}
.to(""${header.CamelHttpUri}"")
{code}

This is kind of confusing
davsclaus:1639013822:2021-12-09T09:37:02.682+0000:1639013822:2021-12-09T09:37:02.682+0000:Ad 2)
This only works because the http uri is with https that is the http component name also (http/https)

So if you do it as

{code}
.toD(""http:${header.CamelHttpUri}"")
{code}

Then it fails just like vertx-http does
davsclaus:1639018290:2021-12-09T10:51:30.704+0000:1639018290:2021-12-09T10:51:30.704+0000:There was a bug in toD when using vertx-http when compared to camel-http."
0,CAMEL-17297,Sub-task,Major,3.13.0,,"
None
",Resolved,Fixed,None,Unassigned,Karen Lease,0,1,2021-12-07 22:21:43+00:00,2022-09-03 10:41:59+00:00,"DurationRoutePolicyMaxSecondsTest and DurationRoutePolicyFactoryTest frequently don't receive as many messages as expected. In fact, there is a 1 second delay in the timer before any messages are sent, so if the timer thread is not started immediately, the timeout occurs before it has time to send the expected number of messages.


Setting a delay of 100 on the timer reduces the risk of failure.",
0,CAMEL-17296,Bug,Minor,3.13.0,3.15.0,"
None
",Resolved,Fixed,3.15.0,Karen Lease,Karen Lease,0,2,2021-12-07 22:00:24+00:00,2022-01-06 09:00:55+00:00,"The option stopOnAggregateException has no effect. This was added in CAMEL-10272, but since Camel 3.0, the MulticastProcessor method isStopOnAggregateException is no longer called. If any exception is caught in an aggregation strategy, it is set on the original Exchange object and the processing is terminated, whether this option is set or not.


If the option is obsolete, it should be removed and the documentation and test cases should be updated.","davsclaus:1638966116:2021-12-08T20:21:56.839+0000:1638966116:2021-12-08T20:21:56.839+0000:Yeah Karen you are welcome to deprecate the option, and add a note in the 3.14 upgrade guide, and then we can remove the option in 3.15.
klease78:1640250103:2021-12-23T17:01:43.379+0000:1640250103:2021-12-23T17:01:43.379+0000:Sorry, I didn't get to it before the 3.14 release. I will deprecate the option in the definitions. I could already remove it from the reifiers and processors since it has no effect anyway. Is that OK with you, [~davsclaus] ?
davsclaus:1640254695:2021-12-23T18:18:15.114+0000:1640254695:2021-12-23T18:18:15.114+0000:Yes
klease78:1641206842:2022-01-03T18:47:22.476+0000:1641206842:2022-01-03T18:47:22.476+0000:Done"
0,CAMEL-17295,Bug,Minor,3.11.4,3.14.0,"
None
",Resolved,Fixed,3.14.0,Claus Ibsen,Ralf Steppacher,0,2,2021-12-07 20:30:21+00:00,2021-12-10 09:50:24+00:00,"The following works with Camel versions 3.11.3 and 3.13.0 but fails with version 3.11.4:




rest(""/Assertion?authTokenSourceUri={"" + HEADER_AUTH_TOKEN_SOURCE_URI + ""}"").id(ROUTE_REST_GET_ASSERTION)
    .get()
    .produces(MediaType.TEXT_XML_VALUE)
    .route()
    // route definition omitted




With version 3.11.4 this yields an org.apache.camel.ResolveEndpointFailedException:



Caused by: org.apache.camel.ResolveEndpointFailedException: Failed to resolve endpoint: servlet:///Assertion?httpMethodRestrict=GET due to: There are 1 parameters that couldn't be set on the endpoint. Check the uri if the parameters are spelt correctly and that they are properties of the endpoint. Unknown parameters=[{authTokenSourceUri={authTokenSourceUri}?consumerComponentName=servlet}]




Specifying the query parameter via DSL works with all three versions:




rest(""/Assertion"").id(ROUTE_REST_GET_ASSERTION)
    .get()
    .param()
        .name(HEADER_AUTH_TOKEN_SOURCE_URI)
        .type(RestParamType.query)
    .endParam()
    // rest is same as above","davsclaus:1638917833:2021-12-08T06:57:13.233+0000:1638917833:2021-12-08T06:57:13.233+0000:Can you test with 3.13.0
ralfsteppacher:1638927994:2021-12-08T09:46:34.855+0000:1638927994:2021-12-08T09:46:34.855+0000:[~davsclaus], it is already in the description. It works with Camel
* 3.11.3
* 3.13.0

It does not work with Camel
* 3.11.4

davsclaus:1638930118:2021-12-08T10:21:58.342+0000:1638930118:2021-12-08T10:21:58.342+0000:Okay are you able to try 3.14.0-SNAPSHOT
ralfsteppacher:1638935206:2021-12-08T11:46:46.878+0000:1638935206:2021-12-08T11:46:46.878+0000:[~davsclaus], version {{3.14.0-SNAPSHOT}} gives me the same error about the unresolvable endpoint due to the unknown parameter.
davsclaus:1638936399:2021-12-08T12:06:39.075+0000:1638936399:2021-12-08T12:06:39.075+0000:Can you attach some kind of reproducer, or unit test, or make something more easy to use for reproducing
davsclaus:1639036366:2021-12-09T15:52:46.309+0000:1639036366:2021-12-09T15:52:46.309+0000:One last bug to fix before the release.
davsclaus:1639042024:2021-12-09T17:27:04.698+0000:1639042024:2021-12-09T17:27:04.698+0000:Using the param does give you more power as you can specify if the query param is required.
And if you have the client request validation enabled it can pre-validate and fail the request if the param is missing
davsclaus:1639046303:2021-12-09T18:38:23.851+0000:1639046303:2021-12-09T18:38:23.851+0000:I have reproducer this on main branch. So it looks like query parameters was not detected in rest-dsl when you use those { } placeholders. So before it worked because of _luck_.
We can try to detect those like we do for context-path, and setup it as a query param automatic.
ralfsteppacher:1639054273:2021-12-09T20:51:13.535+0000:1639054273:2021-12-09T20:51:13.535+0000:[~davsclaus], thank you for the addtl. info on the param DSL method!
davsclaus:1639090149:2021-12-10T06:49:09.605+0000:1639090149:2021-12-10T06:49:09.605+0000:This is a bigger fix/improvement so landing in 3.14.0 only"
0,CAMEL-17294,Improvement,Minor,None,3.14.0,"
None
",Resolved,Fixed,3.14.0,Claus Ibsen,Marat Gubaidullin,0,2,2021-12-07 17:05:52+00:00,2021-12-08 12:47:45+00:00,"Json DataFormat library names are case sensitive, ex. the following code work fine:




- from:
    uri: ""platform-http:/hello""
    steps:
      - set-body:
          constant: ""Hello World""
      - marshal:
          json: 
            library: Gson
 



However 



 library: gson 



 throws an exception



java.lang.IllegalArgumentException: No enum constant org.apache.camel.model.dataformat.JsonLibrary.gson
        at java.base/java.lang.Enum.valueOf(Enum.java:240)
        at org.apache.camel.model.dataformat.JsonLibrary.valueOf(JsonLibrary.java:25)
        at org.apache.camel.dsl.yaml.deserializers.ModelDeserializers$JsonDataFormatDeserializer.setProperty(ModelDeserializers.java:7375)",davsclaus:1638938865:2021-12-08T12:47:45.976+0000:1638938865:2021-12-08T12:47:45.976+0000:We now convert to enum as camel-core does it
0,CAMEL-17293,Improvement,Major,None,3.16.0,"
None
",Resolved,Fixed,3.16.0,Claus Ibsen,Marat Gubaidullin,0,2,2021-12-07 15:12:35+00:00,2022-03-08 10:06:17+00:00,"It would be great if camel-jang supports configuration in Integration CRD, ex:




apiVersion: camel.apache.org/v1
kind: Integration
metadata:
  name: hello-world
spec:
  configuration:
    - type: property
      value: 'camel.component.jdbc.dataSource.serverName=iot-psql\:5432'","davsclaus:1638864520:2021-12-07T16:08:40.822+0000:1638864520:2021-12-07T16:08:40.822+0000:Ah yeah I guess for property types we can map that - but we need potentially to have this mapped during camel-main bootstrap where it does this kind of startup properties.
davsclaus:1643082661:2022-01-25T11:51:01.910+0000:1643082661:2022-01-25T11:51:01.910+0000:Camel K has deprecated spec/configuration and spec/resources in favour of using traits.

See the upcoming camel-k 1.8 blog announcement
davsclaus:1645937329:2022-02-27T12:48:49.953+0000:1645937329:2022-02-27T12:48:49.953+0000:We have a chicken-and-egg situation as camel-jbang/main will auto-configure first and then load routes, and when loading routes, we can then load spec/configuration (and traits in the future) which also want to auto-configure general options such as components etc.

So we need 2-passes for auto-configuration, or a way to do pre-routes loading where we only discover configuration / modelines etc but that is also complex.
davsclaus:1645945804:2022-02-27T15:10:04.066+0000:1646705136:2022-03-08T10:05:36.706+0000:TODO: camel trait properties *DONE*
davsclaus:1646698668:2022-03-08T08:17:48.398+0000:1646698668:2022-03-08T08:17:48.398+0000:{code}
apiVersion: camel.apache.org/v1
kind: Integration
metadata:
  name: trait-example.yaml
spec:
  traits:
    camel:
      configuration:
        properties:
          - camel.component.seda.queueSize = 1
          - camel.component.seda.defaultPollTimeout = 5000
    environment:
      configuration:
        vars:
          - TEST_VARIABLE = HELLO_WORLD_
    logging:
      configuration:
        json: true
        level: DEBUG
  flows:
    - route:
        id: route1
        from:
          uri: timer:demo
          parameters:
            repeatCount: 10
        steps:
          - setBody:
              simple: '{{TEST_VARIABLE}}'
          - log:
              message: ${body}
              loggingLevel: INFO
          - to: seda:seda1
    - route:
        id: route2
        from:
          uri: seda:seda1
          parameters:
            size: 1
        steps:
          - log:
              message: ${body}
              loggingLevel: INFO    
{code}
davsclaus:1646705172:2022-03-08T10:06:12.690+0000:1646705172:2022-03-08T10:06:12.690+0000:Also added support for environment/vars - but that is only when using them in camel as property placeholders - as it cannot adjust the OS ENV before the JVM startup."
0,CAMEL-17292,Improvement,Major,None,3.16.0,"
None
",Resolved,Fixed,3.16.0,Claus Ibsen,Marat Gubaidullin,0,2,2021-12-07 15:11:20+00:00,2022-02-14 14:17:12+00:00,"It would be great if camel-jbang support modeline, ex:




// camel-k:  message=Hello World

- from:
    uri: 'kamelet:timer-source'
    steps:
      - log:
          message: '{{message}}'
    parameters:
      period: 1000
      message: Hello","davsclaus:1638864585:2021-12-07T16:09:45.301+0000:1638864585:2021-12-07T16:09:45.301+0000:https://camel.apache.org/camel-k/1.7.x/cli/modeline.html
davsclaus:1644653756:2022-02-12T16:15:56.372+0000:1644653756:2022-02-12T16:15:56.372+0000:We will only support some traits that makes sense for jvm runtimes

- dependency
- property
- build-property
- name
- env ???

davsclaus:1644737359:2022-02-13T15:29:19.386+0000:1644737359:2022-02-13T15:29:19.386+0000:This is a bit worng
{code}
// camel-k:  message=Hello World
{code}

That should be
{code}
// camel-k:  property=message=Hello World
{code}

Also mind that spaces is not yet supported so it should be when it works
{code}
// camel-k:  property=message='Hello World'
{code}
"
0,CAMEL-17291,Bug,Major,None,3.14.0,"
None
",Resolved,Fixed,3.14.0,Andrea Cosentino,Andrea Cosentino,0,1,2021-12-07 14:44:49+00:00,2021-12-09 13:24:29+00:00,"This would be a problem in context where it should be a string, like for example in a binding through Kamelet. We can transform in a list later in the code.",
0,CAMEL-17290,Improvement,Minor,None,3.14.0,"
None
",Resolved,Fixed,3.14.0,James Netherton,James Netherton,0,2,2021-12-07 14:01:20+00:00,2021-12-08 07:34:52+00:00,"If Vert.x authentication handlers are configured on the router, then a property will be populated on the RoutingContext containing information about the authenticated user. 


It could be useful to make this available to users so that they can look up details about the authenticated user in their routes.


It'd also be a means to fixing a recently reported Camel Quarkus issue where a user was attempting to access some of the Quarkus security internals via the platform-http component.


https://github.com/apache/camel-quarkus/issues/3353","davsclaus:1638917980:2021-12-08T06:59:40.549+0000:1638917980:2021-12-08T06:59:40.549+0000:Would you mind adding a bit to the documentation also
jamesnetherton:1638920084:2021-12-08T07:34:44.437+0000:1638920084:2021-12-08T07:34:44.437+0000:I have added a 'Message Headers' section to the component docs."
0,CAMEL-17289,New Feature,Major,None,3.15.0,"
None
",Resolved,Fixed,3.15.0,Unassigned,Claus Ibsen,0,1,2021-12-07 13:51:30+00:00,2022-01-24 12:27:20+00:00,See CAMEL-17275,
0,CAMEL-17288,Improvement,Major,None,3.14.0,"
None
",Resolved,Fixed,3.14.0,Claus Ibsen,Claus Ibsen,0,1,2021-12-07 06:58:29+00:00,2021-12-07 10:56:53+00:00,"You can in a kamelet define options with dash style


    required:



kafka-brokers
kafka-topic
kafka-service-account-id
kafka-service-account-secret
log-message



Which can get mapped to camelCase keys and some required check code cannot match because it lookup with kafkaBrokers",
0,CAMEL-17287,Improvement,Minor,None,3.19.0,"
None
",Resolved,Information Provided,3.19.0,Claus Ibsen,Marat Gubaidullin,0,2,2021-12-06 17:45:18+00:00,2022-09-03 11:20:48+00:00,"Following definitions are defined as oneOf string or object but there is no required property to map string to object property.


org.apache.camel.model.BeanDefinition
org.apache.camel.model.InterceptFromDefinition
org.apache.camel.model.RollbackDefinition
org.apache.camel.model.RoutingSlipDefinition","davsclaus:1662174982:2022-09-03T11:16:22.411+0000:1662175233:2022-09-03T11:20:33.368+0000:For bean then its because you can either use ref or bean-type to specify what bean to use (ref = id to lookup, bean-type = FQN class name) - and that you need to set one of them, but we dont have a way to represent this in the model
davsclaus:1662175045:2022-09-03T11:17:25.760+0000:1662175045:2022-09-03T11:17:25.760+0000:InterceptFromDefinition then uri is optional, as if you do not specify then all endpoints is intercepted (eg its like a * as default value)
davsclaus:1662175095:2022-09-03T11:18:15.225+0000:1662175095:2022-09-03T11:18:15.225+0000:RollbackDefinition then message is optional so if you do not set any value then its a generic rollback without any custom message.
davsclaus:1662175201:2022-09-03T11:20:01.545+0000:1662175201:2022-09-03T11:20:01.545+0000:RoutingSlipDefinition is using header-name as inlined value and comma as default separator 

routingSlip(""myHeader"")....

Otherwise you can configure it via expression language et all"
0,CAMEL-17286,Improvement,Major,None,3.15.0,"
None
",Resolved,Fixed,3.15.0,Claus Ibsen,Claus Ibsen,0,1,2021-12-06 17:01:42+00:00,2022-01-09 10:14:44+00:00,"We align to the other EIPs


So we are deprecating propertyName on this EIP and adding name.
Then we remove this for next LTS (3.15 onwards).","davsclaus:1638781513:2021-12-06T17:05:13.005+0000:1641694361:2022-01-09T10:12:41.929+0000:TODO deprecated propertyName in Camel 3.14 and added new name to be used instead (similar to all the other EIPs) *DONE*
TODO remove propertyName in Camel 3.15 and update migration doc *DONE*
"
0,CAMEL-17285,Test,Major,3.14.0,3.14.0,"
None
",Resolved,Fixed,3.14.0,Otavio Rodolfo Piske,Otavio Rodolfo Piske,0,1,2021-12-06 16:19:19+00:00,2021-12-06 20:19:19+00:00,"Recently the async manual commit support for Kafka has stopped working. It needs to be investigated.


 


Kafka's client is not thread safe and a recent change may have moved the thread responsible for creating it and/or performing the commit:


 



 
java.util.ConcurrentModificationException: KafkaConsumer is not safe for multi-threaded access
        at org.apache.kafka.clients.consumer.KafkaConsumer.acquire(KafkaConsumer.java:2445) ~[kafka-clients-2.8.1.jar:?]
        at org.apache.kafka.clients.consumer.KafkaConsumer.acquireAndEnsureOpen(KafkaConsumer.java:2429) ~[kafka-clients-2.8.1.jar:?]
        at org.apache.kafka.clients.consumer.KafkaConsumer.commitSync(KafkaConsumer.java:1486) ~[kafka-clients-2.8.1.jar:?]
        at org.apache.camel.component.kafka.DefaultKafkaManualSyncCommit.commitOffset(DefaultKafkaManualSyncCommit.java:58) ~[classes/:?]
        at org.apache.camel.component.kafka.DefaultKafkaManualSyncCommit.commit(DefaultKafkaManualSyncCommit.java:49) ~[classes/:?]
        at org.apache.camel.component.kafka.integration.KafkaConsumerAsyncManualCommitIT$1.lambda$configure$0(KafkaConsumerAsyncManualCommitIT.java:92) ~[test-classes/:?]
        at org.apache.camel.support.processor.DelegateSyncProcessor.process(DelegateSyncProcessor.java:65) ~[classes/:?]
        at org.apache.camel.processor.errorhandler.RedeliveryErrorHandler$SimpleTask.run(RedeliveryErrorHandler.java:469) ~[classes/:?]
        at org.apache.camel.impl.engine.DefaultReactiveExecutor$Worker.schedule(DefaultReactiveExecutor.java:187) ~[classes/:?]
        at org.apache.camel.impl.engine.DefaultReactiveExecutor.schedule(DefaultReactiveExecutor.java:59) ~[classes/:?]
        at org.apache.camel.processor.aggregate.AggregateProcessor.lambda$onSubmitCompletion$4(AggregateProcessor.java:891) ~[classes/:?]
        at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128) [?:?]
        at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628) [?:?]
        at java.lang.Thread.run(Thread.java:829) [?:?]","orpiske:1638786429:2021-12-06T18:27:09.729+0000:1638786429:2021-12-06T18:27:09.729+0000:Updating to test. We changed the way we handle manual commit factories and the older one stopped working.
orpiske:1638789956:2021-12-06T19:25:56.383+0000:1638789956:2021-12-06T19:25:56.383+0000:It was just an outdated test case. It should be fixed with the linked PR."
0,CAMEL-17284,Dependency upgrade,Major,None,3.15.0,"
None
",Resolved,Fixed,3.15.0,Ramu,Claus Ibsen,0,2,2021-12-06 16:14:08+00:00,2022-01-27 13:07:27+00:00,"We should upgrade to newer kafka clients.


They should be backwards compatible and major runtimes like SB and Quarkus is/have upgraded too.","davsclaus:1643075718:2022-01-25T09:55:18.945+0000:1643075718:2022-01-25T09:55:18.945+0000:Kafka 3.1.x has been released
davsclaus:1643175407:2022-01-26T13:36:47.081+0000:1643175407:2022-01-26T13:36:47.081+0000:Ramu, Otavio have a lot of experinence with the camel-kafka component and will help with the upgrade
orpiske:1643175920:2022-01-26T13:45:20.105+0000:1643175920:2022-01-26T13:45:20.105+0000:Ramu, I'll be happy to assist/test/review/provide insights ... anything that you need. Feel free to reach out via Zulip, email, hangouts, etc.

I am watching this ticket, so I'll try to be very responsive here too.

And thanks for helping with this!
orpiske:1643252233:2022-01-27T10:57:13.346+0000:1643252264:2022-01-27T10:57:44.334+0000:I tried it and it seems the upgrade is simple. I did not find any problems on my local test. Since we want to squeeze this one for 3.15, I did the PR myself and dropped a note to [~ramu11] that I was cutting the line. As we are in a different TZ, it would be good to have some tests on CI for this and use most of the time we have."
0,CAMEL-17283,Improvement,Major,None,3.15.0,"
None
",Resolved,Fixed,3.15.0,Claus Ibsen,Marat Gubaidullin,0,2,2021-12-06 13:52:54+00:00,2022-01-25 12:10:27+00:00,"According to schema RouteTemplateDefinition is oneOf string or object.





If object then everything is clear. 
But if it is string, how this string might look like and how to map it to the required properties?","davsclaus:1643083462:2022-01-25T12:04:22.703+0000:1643083462:2022-01-25T12:04:22.703+0000:Yes this is wrong, it should not be inlined"
0,CAMEL-17282,Improvement,Major,None,3.14.0,"
None
",Resolved,Fixed,3.14.0,Claus Ibsen,Claus Ibsen,0,2,2021-12-06 13:37:58+00:00,2021-12-06 16:11:39+00:00,"Remove Header EIP has deprecated headerName in 3.11 LTS. We should remove this and make name required.


We nee to update kamelets as some uses the old name.
And then update the migration guide docs.",
0,CAMEL-17281,Improvement,Minor,None,3.15.0,"
None
",Resolved,Fixed,3.15.0,Claus Ibsen,Claus Ibsen,0,1,2021-12-06 13:36:12+00:00,2022-01-24 12:10:38+00:00,"Such as DeadLetterChannelBuilder.


The options in the code vs @YamlProperty are not in sync.",davsclaus:1638938902:2021-12-08T12:48:22.142+0000:1638938902:2021-12-08T12:48:22.142+0000:This is a bit more tricky as its the source code generator that does this - so if you add them manually the code is regenerated
0,CAMEL-17280,New Feature,Major,None,3.15.0,"
None
",Resolved,Fixed,3.15.0,Claus Ibsen,Claus Ibsen,0,1,2021-12-06 12:47:09+00:00,2022-01-25 09:22:15+00:00,"We can use github rest api to fetch the files in a repo/directory, then we can find the files there to be included in jbang run


For example this example at


curl https://api.github.com/repos/apache/camel-k/contents/examples/kamelets/kameletbindings


Then we can find all supported files (eg yaml) and skip readme.md files etc


Then you can run this example with just


jbang run https://github.com/apache/camel-k/tree/main/examples/kamelets/kameletbindings",
0,CAMEL-17279,Improvement,Major,None,3.14.0,"
None
",Resolved,Fixed,3.14.0,Claus Ibsen,Claus Ibsen,0,1,2021-12-06 12:32:34+00:00,2021-12-08 07:01:36+00:00,"We should include the http platform provider when running via jbang, otherwise you have to add the JAR manually.


Also consider for circuit breakers that you need an implementation, so we should default to what they use in camel-k / camel-quarkus","davsclaus:1638861493:2021-12-07T15:18:13.096+0000:1638861493:2021-12-07T15:18:13.096+0000:We may consider allowing jbang to embed http server with --http-server option etc. So you can choose when to use it, and also maybe configure its port etc. 

But lets start with automatic include http server if platform-http is in use"
0,CAMEL-17278,New Feature,Major,None,3.14.0,"
None
",Resolved,Fixed,3.14.0,Federico Mariani,Claus Ibsen,0,2,2021-12-06 10:24:13+00:00,2021-12-09 18:44:06+00:00,"We should find out how we can run CamelJBang in JVM debug mode with


java -agentlib:jdwp=transport=dt_socket,address=5005,server=y,suspend=y


Then users can attach remote JVM debugger in case they want to do some trouble shooting.","Federico Mariani:1639028606:2021-12-09T13:43:26.489+0000:1639028606:2021-12-09T13:43:26.489+0000:isn't [https://www.jbang.dev/documentation/guide/latest/debugging.html] enough? I just executed `jbang --cp . --debug /path/to/CamelJBang.java run redis-source-test.yaml` and I can attach a remote debugger from idea
davsclaus:1639031329:2021-12-09T14:28:49.931+0000:1639031329:2021-12-09T14:28:49.931+0000:Ah that is great, you are welcome to add information to the camel-jbang.adoc file under the docs folder, thanks
Federico Mariani:1639033676:2021-12-09T15:07:56.198+0000:1639033676:2021-12-09T15:07:56.198+0000:https://github.com/apache/camel/pull/6519"
0,CAMEL-17277,Improvement,Minor,3.13.0,None,"
None
",Resolved,Fixed,3.14.0,Unassigned,Henrik Karlsson,0,1,2021-12-06 07:56:46+00:00,2021-12-06 08:48:35+00:00,"Trying to detect the body mediatype when the Datasonnet header is used can lead to unwanted transformation of the body.


Can't find camel-datasonnet as a component in Jira",
0,CAMEL-17276,Improvement,Major,None,3.14.0,"
None
",Resolved,Fixed,3.14.0,Claus Ibsen,Claus Ibsen,0,1,2021-12-05 07:20:11+00:00,2021-12-06 17:53:30+00:00,"When you run examples with mvn camel:run, then we could have logging output ala camel jbang - then its easier to read the logging output.",
0,CAMEL-17275,Improvement,Major,None,3.14.0,"
None
",Resolved,Fixed,3.14.0,Claus Ibsen,Claus Ibsen,0,1,2021-12-04 22:14:12+00:00,2022-01-24 12:27:31+00:00,We should be able to load a KameletBinding yaml file with the yaml dsl route loader. We can then map the binding to a route / integration (just as camel-k can do).,"davsclaus:1638628798:2021-12-04T22:39:58.652+0000:1638847645:2021-12-07T11:27:25.483+0000:TODO: source kamelet/uri *DONE*
TODO: sink kamelet/uri *DONE*
TODO: steps *DONE*
TODO: error handler *DONE*
TODO: error handler DeadLetterChannel *DONE*
TODO: error handler log *DONE*
davsclaus:1638695674:2021-12-05T17:14:34.506+0000:1642998451:2022-01-24T12:27:31.369+0000:TODO: knative *DONE*
TODO: strimzi *DONE*

For knative then we need to port over the camel-k-runtime component so we can use this as a component.
For strimzi we can likely map this to camel-kafka component
davsclaus:1638753106:2021-12-06T09:11:46.197+0000:1638856156:2021-12-07T13:49:16.217+0000:TODO: update camel-jbang docs *DONE*
davsclaus:1638847633:2021-12-07T11:27:13.766+0000:1638847633:2021-12-07T11:27:13.766+0000:Will leave bean and ref error handler for later as they seems not really useable for Camel end users to implement a custom code
https://github.com/apache/camel-k/issues/2815"
0,CAMEL-17274,Bug,Minor,"3.8.0, 3.9.0, 3.10.0, 3.11.0, 3.12.0, 3.13.0",3.14.0,"
None
",Resolved,Fixed,3.14.0,Claus Ibsen,Michael Andre Pearce,0,2,2021-12-04 21:55:37+00:00,2021-12-06 13:22:23+00:00,"A regression is caused by CAMEL-15560 by removal of collectXmlRoutesFromDirectory methods, which overrode default method to use spring's application context, but no equivalent was made in replacement.


To fix this is seems simply a new implementation of new equivalent method, re-introducing loading resource by the spring applicationContext.


Unfortunately it seems this is only seen/issue up once a fully packaged springboot jar/war is created and run, and route xml's fail to load, as such very hard to unit test, and like wise no pre-existing tests clearly for old behaviour either, thus it broke.


related to: https://stackoverflow.com/questions/68065987/apache-camel-routes-in-xml-not-loaded-in-spring-boot/


 


Attached is a sample extracted application demonstrating the issue, see its readme. The zipped app is currently working using 3.7.6 but you will note on changing camel dependency to 3.8.0 the routes do not load, nor start.


 


A PR will be linked to this ticket that fixes this issue.","davsclaus:1638753273:2021-12-06T09:14:33.436+0000:1638753273:2021-12-06T09:14:33.436+0000:Okay so a ""difference"" is that your spring boot application is packaged as a war and not a jar - most users use jar.

davsclaus:1638753395:2021-12-06T09:16:35.518+0000:1638753395:2021-12-06T09:16:35.518+0000:It works if you use packaging = jar
davsclaus:1638755129:2021-12-06T09:45:29.988+0000:1638755129:2021-12-06T09:45:29.988+0000:Added support for the WAR layout"
0,CAMEL-17273,Task,Major,3.15.0,3.15.0,"
None
",Resolved,Duplicate,3.15.0,Unassigned,Claus Ibsen,0,2,2021-12-04 11:14:02+00:00,2022-01-10 05:16:38+00:00,After the LTS release we should cleanup karaf and removed deprecated stuff such as camel-osgi-activator,"fpapon:1641740318:2022-01-09T22:58:38.244+0000:1641740318:2022-01-09T22:58:38.244+0000:Hi [~davsclaus]

This issue seems to be related to this one https://issues.apache.org/jira/browse/CAMEL-17387

Is it the same?"
0,CAMEL-17272,New Feature,Major,None,3.14.0,"
None
",Resolved,Fixed,3.14.0,Claus Ibsen,Claus Ibsen,0,1,2021-12-04 09:48:59+00:00,2021-12-04 11:04:56+00:00,"When using old classic spring xml files with <camelContext> then its spring that does the xml loading / parsing. And to refer to other xml files, you need to add special support for this.


Then you can have other spring xml files with


<routeConfigurationContext>
  <routeConfiguration>
  <routeConfiguration>
  <routeConfiguration>
</routeConfigurationContext>",davsclaus:1638586430:2021-12-04T10:53:50.917+0000:1638586430:2021-12-04T10:53:50.917+0000:Added this for blueprint and cdi xml as well
0,CAMEL-17271,Test,Major,3.14.0,None,"
None
",Resolved,Fixed,3.14.0,Claus Ibsen,Claus Ibsen,0,1,2021-12-04 08:24:19+00:00,2021-12-04 09:26:13+00:00,CMTest.testAsPartOfARoute:164 Unexpected exception type thrown ==> expected: <org.apache.camel.component.cm.exceptions.cmresponse.NoAccountFoundForProductTokenException> but was: <org.apache.camel.component.cm.exceptions.cmresponse.CMResponseException>,
0,CAMEL-17270,New Feature,Major,None,None,"
None
",Resolved,Won't Fix,4.x,Unassigned,Claus Ibsen,0,1,2021-12-04 08:17:01+00:00,2023-11-22 20:09:37+00:00,"We can load route(s) from those DSLs.


In camel-k you can however have additional features, such as setting up beans, components etc. 


And it would also be good if we can parse if there are helper methods, than just the route configure method.",
0,CAMEL-17269,Bug,Major,None,3.14.0,"
None
",Resolved,Fixed,3.14.0,Unassigned,Viliam,0,1,2021-12-03 15:38:56+00:00,2021-12-06 13:09:31+00:00,The Splunk HEC Component does not allow an IPv4 address in place of a hostname.,vkrizan:1638523334:2021-12-03T17:22:14.650+0000:1638523334:2021-12-03T17:22:14.650+0000:PR: [https://github.com/apache/camel/pull/6500]
0,CAMEL-17268,Bug,Major,3.13.0,,"
None
",Closed,Invalid,None,Unassigned,Henrik Karlsson,0,1,2021-12-03 15:30:50+00:00,2021-12-03 16:09:26+00:00,"Path parameter values in rest request are not url decoded before set as headers.


Example:


The operation GetUser has this path /users/{email}. Then sending a request to this endpoint with email=john.doe@acme.com (url encoded -> /users/john.doe%40acme.com) will result in a header email=john.doe%40acme.com instead of the expected email=john.doe@acme.com.


If email would have been a query parameter instead (/users?email=john.doe%40acme.com), the value of the header email would be 'john.doe@acme.com'","henka-rl:1638518966:2021-12-03T16:09:26.613+0000:1638518966:2021-12-03T16:09:26.613+0000:I hade this issue a couple of weeks ago, but now I can't reproduce it..."
0,CAMEL-17267,Bug,Major,3.13.0,3.14.0,"
None
",Resolved,Fixed,3.14.0,Unassigned,Henrik Karlsson,0,2,2021-12-03 14:53:54+00:00,2021-12-04 06:56:47+00:00,"Then creating http endpoints for an openapi operation the http method is not set on the endpoint. If http methods not using the same query parameters only the query parameters from the last operation registered will be used.


Example:


The path /users has two operations GetUsers (GET) and CreateUser (POST). GetUsers has a query parameter 'search' and CreateUser has no query parameters. CreateUser is the last operation that's registered and therefore no query parameters is registered on that endpoint.
Calling GetUsers (.to(""api:GetUsers"")) with the header 'search' set will result in a request without the search query parameter.


By just adding httpMethod to the Endpoint Properties will solve this problem.",davsclaus:1638572206:2021-12-04T06:56:46.574+0000:1638572206:2021-12-04T06:56:46.574+0000:Thanks for reporting and fixing this
0,CAMEL-17266,New Feature,Major,None,3.14.0,"
None
",Resolved,Fixed,3.14.0,Claus Ibsen,Claus Ibsen,0,1,2021-12-03 08:36:38+00:00,2021-12-03 09:21:57+00:00,"We download today into memory as a byte array. However we can use stream caching so it can be offloaded to disk.


Also google storate client api has a way to store to file, so we can also add option ala localWorkDirectory to store there.",
0,CAMEL-17265,Improvement,Minor,None,3.15.0,"
None
",Resolved,Fixed,3.15.0,Claus Ibsen,Marat Gubaidullin,0,2,2021-12-02 17:38:53+00:00,2022-01-24 12:13:53+00:00,"camel-catalog and camel-core-model are different, ex.


1. in camel-catalog we have expression and serviceCall that are not in camel-core-model
 
2. camel-core-model we have json data format requires for marshal/unmarshal, however in camel-catalog only specific json libraries
 
3. Expression languages are different
 
4. Folder names: model vs models, dataformat vs dataformats, language vs languages
 
5. Folder structures: dataformat inside model vs dataformat in the same as models","davsclaus:1638497618:2021-12-03T10:13:38.722+0000:1638497618:2021-12-03T10:13:38.722+0000:Tools should only be using camel-catalog JAR
davsclaus:1638503819:2021-12-03T11:56:59.213+0000:1638503819:2021-12-03T11:56:59.213+0000:Ad 1)

core/camel-core-model/src/generated/resources/org/apache/camel/model/cloud/serviceCall.json
catalog/camel-catalog/src/generated/resources/org/apache/camel/catalog/models/serviceCall.json

core/camel-core-model/src/generated/resources/org/apache/camel/model/language/expression.json
catalog/camel-catalog/src/generated/resources/org/apache/camel/catalog/models/expression.json



davsclaus:1638503880:2021-12-03T11:58:00.473+0000:1638503880:2021-12-03T11:58:00.473+0000:Ad 4)

Do not use camel-core-model, only use camel-catalog

Ad 5)

Do not use camel-core-model, only use camel-catalog

davsclaus:1638503990:2021-12-03T11:59:50.360+0000:1638503990:2021-12-03T11:59:50.360+0000:Ad 3)

What do you mean by Expression languages are different

The languages can have different options (yes) but often you do not need to use them.
davsclaus:1638504377:2021-12-03T12:06:17.067+0000:1638504377:2021-12-03T12:06:17.067+0000:Ad 2)

Yeah data format are the ""special kid"". 
So when you choose json then we have 5 or so different implementations. 

In the camel-catalog/dataformats, you can find then via
    ""modelName"": ""json"",

Then you can find all the implementatons.

You can see the same for ""bindy"", and ""avro""


marat.gubaidullin@gmail.com:1638506529:2021-12-03T12:42:09.149+0000:1638506544:2021-12-03T12:42:24.798+0000:Ad 2) Yes, with json we have 5 implementations, however the following code is legit:
 
{code:java}
- unmarshal:         
    json:
{code}
 
when Karavan read this code what properties should be showed in the property panel for this dataFormat?
davsclaus:1638506783:2021-12-03T12:46:23.050+0000:1638506783:2021-12-03T12:46:23.050+0000:Ah yeah json-jackson is the default json library.
marat.gubaidullin@gmail.com:1638507134:2021-12-03T12:52:14.431+0000:1638507134:2021-12-03T12:52:14.431+0000:What are default libraries for bindy and avro?
Are these defaults configured somewhere or could be hardcoded?
davsclaus:1638508835:2021-12-03T13:20:35.933+0000:1638508835:2021-12-03T13:20:35.933+0000:    @Metadata(defaultValue = ""ApacheAvro"")
    private AvroLibrary library = AvroLibrary.ApacheAvro;

    @Metadata(defaultValue = ""Jackson"")
    private JsonLibrary library = JsonLibrary.Jackson;

    @XmlAttribute(required = true)
    @Metadata(required = true, javaType = ""org.apache.camel.model.dataformat.BindyType"", enums = ""Csv,Fixed,KeyValue"")
    private String type;

davsclaus:1638508881:2021-12-03T13:21:21.541+0000:1638508881:2021-12-03T13:21:21.541+0000:So avro would be apache avro, eg camel-avro
ApacheAvro(""avro""),

And for bindy, then you must choose the type"
0,CAMEL-17264,New Feature,Major,None,3.14.0,"
None
",Resolved,Fixed,3.14.0,Claus Ibsen,Claus Ibsen,0,1,2021-12-02 06:41:05+00:00,2021-12-02 09:23:59+00:00,Properties from file locations etc should be able to reload / load from updated location.,
0,CAMEL-17263,Improvement,Minor,None,3.14.0,"
None
",Resolved,Fixed,3.14.0,Claus Ibsen,Sergey Smith,0,1,2021-12-01 16:02:56+00:00,2021-12-02 11:12:31+00:00,"It more flexible when KafkaManualCommitFactory can be tuned at Endpoint
Example: KafkaManualCommitFactory can be used to watching over commits with async processing",
0,CAMEL-17262,Improvement,Minor,None,3.14.0,"
None
",Resolved,Fixed,3.14.0,Claus Ibsen,Sergey Smith,0,3,2021-12-01 15:59:12+00:00,2021-12-02 10:37:37+00:00,"It more flexible when KafkaClientFactory can be tuned at Endpoint
Example: DelayedKafkaClientFactory for some consumers that consume messages with delay.","acosentino:1638346708:2021-12-01T16:18:28.512+0000:1638346708:2021-12-01T16:18:28.512+0000:I don't think it's a good idea, multiple factories on multiple endpoints mean need to manage multiple lifecycles.
davsclaus:1638351987:2021-12-01T17:46:27.669+0000:1638351987:2021-12-01T17:46:27.669+0000:You can just register a 2nd kafka component that has a different factory. See the component-dsl


davsclaus:1638411915:2021-12-02T10:25:15.830+0000:1638411915:2021-12-02T10:25:15.830+0000:I took a look and the endpoint is already prepare for this, all we need to do is to expose the option for docs / uriparam
otr_kuznetsov.sergei:1638412372:2021-12-02T10:32:52.669+0000:1638412657:2021-12-02T10:37:37.135+0000:Thnx.
2nd kafka component - is complex way than require more strong skills from programmers

[~acosentino],
This useful for growing project where you add new functional as routes.
When it is time you simply divide code into separate projects."
0,CAMEL-17261,New Feature,Major,None,3.17.0,"
None
",Resolved,Fixed,3.17.0,Claus Ibsen,Claus Ibsen,0,1,2021-12-01 15:40:36+00:00,2022-04-15 15:30:43+00:00,"We can add the bind goal like we have with camel-k CLI


CamelJBang bind source sink


This uses then kamelets / camel uris, so you can do


bind aws-sqs-source log:foo


The kamelet requires some options, so you can provide them in a properties file. Or use JVM system properties with -D",
0,CAMEL-17260,New Feature,Major,None,3.14.0,"
None
",Resolved,Fixed,3.14.0,Claus Ibsen,Claus Ibsen,0,1,2021-12-01 15:33:19+00:00,2021-12-01 19:22:10+00:00,"If you reload routes then Camel is safe to restart all routes. However there may be routes loaded from other files that was not changed, and so they will be stopped/removed.",
0,CAMEL-17259,New Feature,Major,None,3.14.0,"
None
",Resolved,Fixed,3.14.0,Unassigned,Claus Ibsen,0,1,2021-12-01 13:21:21+00:00,2021-12-01 15:32:17+00:00,"We can add support for using wildcards or eg dot to say


CamelJBang run *
CamelJBang run .


CamelJBang run foo*


So in the top it adds all files (* or dot)
And in the 2nd we list all files and pick files matching (eg starts with foo)


If there is .properties files, then they are regarded as properties. Otherwise they are DSL routes.",
0,CAMEL-17258,New Feature,Minor,None,3.15.0,"
None
",Resolved,Fixed,3.15.0,Unassigned,Vyacheslav Boyko,0,3,2021-12-01 12:58:18+00:00,2022-01-23 12:16:13+00:00,"14:07:29.172 [Test worker] INFO  org.apache.camel.Tracing - *--> 
[route1      ] [from[direct://start]             ] Exchange[Id: 
E2E34A8700E4EE3-0000000000000000, BodyType: ...

14:07:29.176 [Test worker] INFO  org.apache.camel.Tracing - [route1      
] [marshal[org.apache.camel.model.da] Exchange[Id: 
E2E34A8700E4EE3-0000000000000000, BodyType: ...

14:07:29.274 [Test worker] INFO  org.apache.camel.Tracing - [route1      
] [direct://payment-details         ] Exchange[Id: 
E2E34A8700E4EE3-0000000000000000, BodyType: ...

14:07:29.276 [Test worker] INFO  org.apache.camel.Tracing - ---> 
[rms-payment-] [from[direct://payment-details]   ] Exchange[Id: 
E2E34A8700E4EE3-0000000000000000, BodyType: byte[], ...

14:07:29.276 [Test worker] INFO  org.apache.camel.Tracing - 
[rms-payment-] [setProperty[CamelKafkaManualCommi] Exchange[Id: 
E2E34A8700E4EE3-0000000000000000, BodyType: ...

14:07:29.288 [Test worker] INFO  org.apache.camel.Tracing - 
[rms-payment-] [removeHeader[CamelKafkaManualComm] Exchange[Id: 
E2E34A8700E4EE3-0000000000000000, BodyType: ...
 



 


 


This is how my usual tracing log looks like.


I need to expand blocks called in DefaultTracer as RouteId and Label - blocks bounded by `[...]`. davsclaus in users mailing list offers me to implement this feature myself.","bvn13:1638334723:2021-12-01T12:58:43.965+0000:1638334802:2021-12-01T13:00:02.362+0000:I want to implement it. Assign it on me, please.
acosentino:1638335021:2021-12-01T13:03:41.884+0000:1638335021:2021-12-01T13:03:41.884+0000:A comment is enough. We usually don't give assignee permissions in the beginning, the contributor needs to contribute for a while. By the way, the comment is enough and we know someone is working on that
bvn13:1639233864:2021-12-11T22:44:24.388+0000:1639270357:2021-12-12T08:52:37.825+0000:I have finished it [https://github.com/apache/camel/pull/6528]
davsclaus:1641692439:2022-01-09T09:40:39.809+0000:1641765955:2022-01-10T06:05:55.870+0000:Need to update spring-boot with the new configuration but we cannot build spring boot currently *DONE*"
0,CAMEL-17257,New Feature,Major,None,3.14.0,"
None
",Resolved,Fixed,3.14.0,Claus Ibsen,Claus Ibsen,0,1,2021-12-01 11:18:32+00:00,2021-12-01 19:21:18+00:00,"This allows us to know from which source the routes come from, when using RouteLoader to load routes into CamelContext.


This can be handy for routes reload and tooling to know what is the source file location of the running route.",
0,CAMEL-17256,New Feature,Major,None,3.14.0,"
None
",Resolved,Fixed,3.14.0,Claus Ibsen,Claus Ibsen,0,1,2021-12-01 10:46:23+00:00,2021-12-01 15:33:32+00:00,"So you can run more files than only a single file.
And you can also mix different DSLs so you can have a yaml and java file run together.","davsclaus:1638327134:2021-12-01T10:52:14.250+0000:1638327134:2021-12-01T10:52:14.250+0000:The route reload now needs to be aware that if you have multiple files then when it reloads then the not-changed file are also removed, but not started again.
"
0,CAMEL-17255,Improvement,Minor,3.11.3,3.14.0,"
None
",Resolved,Fixed,3.14.0,Claus Ibsen,Sergey Smith,0,2,2021-12-01 06:52:52+00:00,2021-12-01 16:09:48+00:00,"interface KafkaClientFactory mast return Consumer interface insted KafkaConsumer class.


Example usage: Mocking for testing when creating Extended Consumer.


Same for Producer","davsclaus:1638320498:2021-12-01T09:01:38.002+0000:1638320498:2021-12-01T09:01:38.002+0000:Using interfaces now
otr_kuznetsov.sergei:1638339487:2021-12-01T14:18:07.854+0000:1638339500:2021-12-01T14:18:20.410+0000:wrere i can get patch?
davsclaus:1638342223:2021-12-01T15:03:43.383+0000:1638342223:2021-12-01T15:03:43.383+0000:Its coming in the next Camel 3.14.0 release later this month"
0,CAMEL-17254,New Feature,Major,None,Future,"
None
",Open,Unresolved,Future,Unassigned,Claus Ibsen,0,1,2021-12-01 06:48:28+00:00,2023-08-09 09:17:04+00:00,"It can be beneficial to allow JFR to stream metrics once per second with aggregated metrics for context / per route.


When analysing the JVM performance then you would like to know the ""load"" from Camel in terms of number of messages inflight at a given time etc.",
