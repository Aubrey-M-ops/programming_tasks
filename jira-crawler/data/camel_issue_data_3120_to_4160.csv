,Issue Key,Type,Priority,Affects Version/s,Component/s,Labels,Status,Resolution,Fix Version/s,Assignee,Reporter,Votes,Watchers,Created,Updated,Description,Comments
0,CAMEL-17223,Improvement,Major,None,3.14.0,"
None
",Resolved,Fixed,3.14.0,Claus Ibsen,Claus Ibsen,0,1,2021-11-22 13:25:10+00:00,2021-11-23 09:27:08+00:00,No Desc,"davsclaus:1637565634:2021-11-22T15:20:34.068+0000:1637565634:2021-11-22T15:20:34.068+0000:We will now stop on --reload and terminate on normal.

I need a little bit more work to make maxDurationSeconds support stopping routes, as it does things differently than the others.
Also need to add the new option to camel spring boot"
0,CAMEL-17222,Improvement,Minor,None,,"
None
",Resolved,Fixed,None,Unassigned,Federico Mariani,0,2,2021-11-22 12:27:56+00:00,2022-02-04 12:05:53+00:00,"When using CamelJBang@apache/camel I had the following issue 




[jbang] Resolving dependencies...
[jbang] Loading MavenCoordinate [org.apache.camel:camel-bom:pom:RELEASE]
[jbang] Resolving org.apache.camel:camel-jbang-core:RELEASE...[jbang] [ERROR] Could not resolve dependency org.apache.camel:camel-jbang-core:RELEASE




due to dist/CamelJbang.java with default RELEASE version (from jbang catalog), I think it would be nice if the default version points to the latest release","davsclaus:1637555575:2021-11-22T12:32:55.723+0000:1637555575:2021-11-22T12:32:55.723+0000:Yeah its these here, they need to be updated to a release version, such as 3.13.0 - or in the mean time 3.14.0-SNAPSHOT.
https://github.com/apache/camel/blob/main/dsl/camel-jbang/camel-jbang-main/dist/CamelJBang.java#L21

Federico Mariani:1637556090:2021-11-22T12:41:30.284+0000:1637556090:2021-11-22T12:41:30.284+0000:Maybe [https://github.com/apache/camel/blob/main/dsl/camel-jbang/camel-jbang-main/dist/CamelJBang.java|https://github.com/apache/camel/blob/main/dsl/camel-jbang/camel-jbang-main/dist/CamelJBang.java#L21] can be automatically generated during the build process? though the file has to be present on github https://github.com/apache/camel/blob/main/jbang-catalog.json"
0,CAMEL-17221,Bug,Major,"3.8.0, 3.9.0, 3.10.0, 3.11.0, 3.12.0, 3.13.0",None,"
None
",Resolved,Fixed,3.14.0,Unassigned,Hokutor,0,1,2021-11-22 09:44:55+00:00,2021-11-23 07:44:48+00:00,"in HuaweiCloud ImageRecognition component and SimpleNotification component,  the ignoreSslVerification param of the endpoints does not work if the proxyHost is not set.


Below is the sorce code related.",
0,CAMEL-17220,Dependency upgrade,Major,None,3.14.0,"
None
",Resolved,Fixed,3.14.0,Unassigned,Claus Ibsen,0,2,2021-11-21 08:05:08+00:00,2021-11-23 13:19:18+00:00,No Desc,"Federico Mariani:1637632656:2021-11-23T09:57:36.220+0000:1637632656:2021-11-23T09:57:36.220+0000:camel-spring-boot-xml tests are failing due to unresolved circular dependency.
{code:java}
Caused by: org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'xmlProducerTemplate': Cannot resolve reference to bean 'xmlCamelContext' while setting bean property 'camelContext'; nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'xmlCamelContext': Invocation of init method failed; nested exception is org.apache.camel.RuntimeCamelException: org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'org.apache.camel.impl.health.DefaultHealthCheckRegistry': Initialization of bean failed; nested exception is org.springframework.beans.factory.BeanCurrentlyInCreationException: Error creating bean with name 'xmlCamelContext': Requested bean is currently in creation: Is there an unresolvable circular reference? {code}
seems like that there is a circular dependency between DefaultHealthCheckRegistry and camelContext bean
davsclaus:1637636171:2021-11-23T10:56:11.321+0000:1637636171:2021-11-23T10:56:11.321+0000:Thanks for trying this - I am looking into this, as it seems we need to move the health check setup to a later phase"
0,CAMEL-17219,Improvement,Minor,3.11.3,,"
None
",Closed,Duplicate,None,Unassigned,Benjamin Graf,0,2,2021-11-20 15:19:13+00:00,2021-11-21 16:40:34+00:00,DefaultExchangeFormatter showProperties only shows user properties not internal properties.,"davsclaus:1637483121:2021-11-21T16:25:21.695+0000:1637483121:2021-11-21T16:25:21.695+0000:That is also expected, you can work on adding a new option named: showAllProperties
graben:1637483231:2021-11-21T16:27:11.657+0000:1637483991:2021-11-21T16:39:51.038+0000:Just see it has been already included :)"
0,CAMEL-17218,Task,Trivial,3.13.0,3.14.0,"
None
",Resolved,Fixed,3.14.0,Unassigned,Benjamin Graf,0,1,2021-11-20 08:50:01+00:00,2021-11-21 16:32:11+00:00,"ExchangeHelper.getOriginalInMessage says ""If its disabled, then null is returned."" but DefaultUnitOfWork throws IllegalStateException.",
0,CAMEL-17217,Improvement,Major,None,3.14.0,"
None
",Resolved,Fixed,3.14.0,Claus Ibsen,Claus Ibsen,0,1,2021-11-19 16:38:13+00:00,2021-11-21 14:50:26+00:00,"So we for example run a groovy route, then we can download and use the camel-groovy-dsl to be able to load the route.",
0,CAMEL-17216,Improvement,Major,None,3.14.0,"
None
",Resolved,Fixed,3.14.0,Federico Mariani,Claus Ibsen,0,2,2021-11-19 16:25:25+00:00,2021-11-22 12:29:36+00:00,"If you run a route that has property placeholders or whatnot, then it would be nice to be able to configure them in a user.properties file / application.properties and then include that when running


You can specify each property as JVM system args, eg -Dfoo=123 but that is tedious if you have many properties to set.","davsclaus:1637553812:2021-11-22T12:03:32.528+0000:1637553812:2021-11-22T12:03:32.528+0000:Thanks Federico

If you have ideas for improving camel-jbang then feel free to create JIRAs and/or hack and send PRs
Federico Mariani:1637555376:2021-11-22T12:29:36.048+0000:1637555376:2021-11-22T12:29:36.048+0000:Actually I had some problems when using CamelJBang@apache/camel the first time, maybe default version handling can be improved https://issues.apache.org/jira/browse/CAMEL-17222"
0,CAMEL-17215,Improvement,Major,None,3.14.0,"
None
",Resolved,Fixed,3.14.0,Claus Ibsen,Claus Ibsen,0,1,2021-11-19 16:23:22+00:00,2021-11-22 10:16:41+00:00,If we have duration max messages / max seconds etc. then we should restart these on reload triggered,
0,CAMEL-17214,Improvement,Major,None,3.14.0,"
None
",Resolved,Fixed,3.14.0,Claus Ibsen,Claus Ibsen,0,1,2021-11-19 11:58:46+00:00,2021-11-21 14:48:26+00:00,"Often you just want to manual terminate the app or use durations to auto terminate.


The file watcher can cause a problem as it can even hang on startup",
0,CAMEL-17213,Bug,Major,3.13.0,3.14.0,"
None
",Resolved,Fixed,3.14.0,Claus Ibsen,Mikołaj Matejko,0,1,2021-11-19 11:41:23+00:00,2021-11-26 10:38:46+00:00,"After upgrading from Camel 3.11.3 to Camel 3.13.0 we noticed that Camel cannot establish SFTP connection and throws an `org.apache.camel.component.file.GenericFileOperationFailedException: Cannot connect to` exception.


 


By diving into it we found out that the cause is `maximumReconnectAttempts` property which we had set to 0.


before Camel 3.13 -> maximumReconnectAttempts as the name says determined how many retries of connecting to sftp we should have (so setting it to 0 means we will try to connect once, and then we won’t try to reconnect in case of failure)
in Camel 3.13 -> maximumReconnectAttempts means how many connections to sftp we should have, so setting it to 0 means that we will never try to establish the connection 


To solve this for now we changed maximumReconnectAttempts to 1, however we noticed that SftpOperations.java was refactored and probably this bug was unintentionally introduced, as it doesn't seem as correct behavior.",
0,CAMEL-17212,Improvement,Major,None,3.14.0,"
None
",Resolved,Fixed,3.14.0,Claus Ibsen,Claus Ibsen,0,1,2021-11-19 10:35:42+00:00,2021-12-01 10:19:19+00:00,"The run goal says its for running a kamelet. But it can run regular Camel YAML routes also.


And we can make it possible to run also XML, Java, Groovy etc by automatic downloading their needed DSL components.


But this ticket is about making the run goal not Kamelet only.",
0,CAMEL-17211,Bug,Minor,2.17.3,,"
None
",Closed,Won't Fix,None,Unassigned,Chris Petersen,0,3,2021-11-19 09:51:12+00:00,2021-11-22 09:40:32+00:00,"we have found an issue in the camel-rabbitmq component during network recovery. The issue is basically that the requestTimeout is not being respected, in the following log the requestTimeout is 120000 but anything after 60000 results in a TimeoutMap eviction and when a new connection is created which results in a new CID and the message is lost as there is no binding between the new exchange and the temporary queue anymore and on top of that, the log bellow shows that the message is received in the “Early reply received” log statement but since that CID has been evicted it just sits there and becomes unrecoverable.


Please let us know if you need additional information about the issue.


JDK: amazon-corretto-8


The URL used is:
rabbitmq://x.x.x.x:5672/default?username=user&password=bitnami&queue=""publishQueueName""&routingKey=""routingKey""&publisherAcknowledgements=false&mandatory=true&connectionTimeout=5000&requestTimeout=120000""


 


2021-11-12 12:03:28.808  INFO 28596 — [nio-8585-exec-1] PUBLISH-TO-RBMQ                          : -> Sending to queue:


--> {""type"":""test"",""message"":""hello""}


2021-11-12 12:03:28.811  INFO 28596 — [nio-8585-exec-1] o.a.c.c.rabbitmq.RabbitMQProducer        : Starting reply manager service RabbitMQReplyManagerTimeoutChecker[default]


2021-11-12 12:03:28.822  INFO 28596 — [nio-8585-exec-1] o.a.c.c.r.reply.ReplyManagerSupport      : Using temporary queue name: amq.gen-TvgwWekSu3FVNrPOtNFhdA


2021-11-12 12:03:28.827  INFO 28596 — [nio-8585-exec-1] o.a.c.c.r.reply.CorrelationTimeoutMap    : in putIfAbsent with key Camel-ID-CP-local-57668-1636714990003-0-3


2021-11-12 12:03:28.828  WARN 28596 — [nio-8585-exec-1] o.a.c.c.rabbitmq.RabbitMQProducer        : Got a closed channel from the pool


2021-11-12 12:03:48.884  INFO 28596 — [hecker[default]] o.a.c.c.r.r.TemporaryQueueReplyHandler   : in onTimeout with correlationId= Camel-ID-CP-local-57668-1636714990003-0-3


2021-11-12 12:03:48.885  WARN 28596 — [hecker[default]] o.a.c.c.r.reply.ReplyManagerSupport      : Timeout occurred after 20000 millis waiting for reply message with correlationID [Camel-ID-CP-local-57668-1636714990003-0-3] on destination amq.gen-TvgwWekSu3FVNrPOtNFhdA. Setting ExchangeTimedOutException on (MessageId: ID-CP-local-57668-1636714990003-0-1 on ExchangeId: ID-CP-local-57668-1636714990003-0-2) and continue routing.


2021-11-12 12:03:48.890 ERROR 28596 — [hecker[default]] o.a.camel.processor.DefaultErrorHandler  : Failed delivery for (MessageId: ID-CP-local-57668-1636714990003-0-1 on ExchangeId: ID-CP-local-57668-1636714990003-0-2). Exhausted after delivery attempt: 1 caught: org.apache.camel.ExchangeTimedOutException: The OUT message was not received within: 20000 millis due reply message with correlationID: Camel-ID-CP-local-57668-1636714990003-0-3 not received on destination: amq.gen-TvgwWekSu3FVNrPOtNFhdA. Exchange[ID-CP-local-57668-1636714990003-0-2]


 


Message History


---------------------------------------------------------------------------------------------------------------------------------------


RouteId              ProcessorId          Processor                                                                        Elapsed (ms)


[PUBLISH-TO-RBMQ   ] [PUBLISH-TO-RBMQ   ] [direct://PUBLISH-TO-RBMQ                                                      ] [     20088]


[PUBLISH-TO-RBMQ   ] [setBody2          ] [setBody[simple\{{""type"":""test"",""message"":""hello""}}]                            ] [         3]


[PUBLISH-TO-RBMQ   ] [log3              ] [log                                                                           ] [         1]


[PUBLISH-TO-RBMQ   ] [to1               ] [rabbitmq://10.42.0.181:5672/default?username=user&password=xxxxxx&queue=MY-HEL] [     20078]


 


Stacktrace


---------------------------------------------------------------------------------------------------------------------------------------


 


org.apache.camel.ExchangeTimedOutException: The OUT message was not received within: 20000 millis due reply message with correlationID: Camel-ID-CP-local-57668-1636714990003-0-3 not received on destination: amq.gen-TvgwWekSu3FVNrPOtNFhdA. Exchange[ID-CP-local-57668-1636714990003-0-2]


                at org.apache.camel.component.rabbitmq.reply.ReplyManagerSupport.processReply(ReplyManagerSupport.java:153) ~[camel-rabbitmq-2.17.3.jar:2.17.3]


                at org.apache.camel.component.rabbitmq.reply.TemporaryQueueReplyHandler.onTimeout(TemporaryQueueReplyHandler.java:67) [camel-rabbitmq-2.17.3.jar:2.17.3]


                at org.apache.camel.component.rabbitmq.reply.CorrelationTimeoutMap.onEviction(CorrelationTimeoutMap.java:54) [camel-rabbitmq-2.17.3.jar:2.17.3]


                at org.apache.camel.component.rabbitmq.reply.CorrelationTimeoutMap.onEviction(CorrelationTimeoutMap.java:30) [camel-rabbitmq-2.17.3.jar:2.17.3]


                at org.apache.camel.support.DefaultTimeoutMap.purge(DefaultTimeoutMap.java:230) [camel-core-2.17.3.jar:2.17.3]


                at org.apache.camel.support.DefaultTimeoutMap.run(DefaultTimeoutMap.java:180) [camel-core-2.17.3.jar:2.17.3]


                at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511) [na:1.8.0_202]


                at java.util.concurrent.FutureTask.runAndReset(FutureTask.java:308) [na:1.8.0_202]


                at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$301(ScheduledThreadPoolExecutor.java:180) [na:1.8.0_202]


                at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:294) [na:1.8.0_202]


                at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149) [na:1.8.0_202]


                at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624) [na:1.8.0_202]


                at java.lang.Thread.run(Thread.java:748) [na:1.8.0_202]


 


2021-11-12 12:03:48.898 ERROR 28596 — [nio-8585-exec-1] o.a.c.c.C.[.[.[/].[dispatcherServlet]    : Servlet.service() for servlet [dispatcherServlet] in context with path [] threw exception [Request processing failed; nested exception is org.apache.camel.CamelExecutionException: Exception occurred during execution on the exchange: Exchange[ID-CP-local-57668-1636714990003-0-2]] with root cause


 


org.apache.camel.ExchangeTimedOutException: The OUT message was not received within: 20000 millis due reply message with correlationID: Camel-ID-CP-local-57668-1636714990003-0-3 not received on destination: amq.gen-TvgwWekSu3FVNrPOtNFhdA. Exchange[ID-CP-local-57668-1636714990003-0-2]


                at org.apache.camel.component.rabbitmq.reply.ReplyManagerSupport.processReply(ReplyManagerSupport.java:153) ~[camel-rabbitmq-2.17.3.jar:2.17.3]


                at org.apache.camel.component.rabbitmq.reply.TemporaryQueueReplyHandler.onTimeout(TemporaryQueueReplyHandler.java:67) ~[camel-rabbitmq-2.17.3.jar:2.17.3]


                at org.apache.camel.component.rabbitmq.reply.CorrelationTimeoutMap.onEviction(CorrelationTimeoutMap.java:54) ~[camel-rabbitmq-2.17.3.jar:2.17.3]


                at org.apache.camel.component.rabbitmq.reply.CorrelationTimeoutMap.onEviction(CorrelationTimeoutMap.java:30) ~[camel-rabbitmq-2.17.3.jar:2.17.3]


                at org.apache.camel.support.DefaultTimeoutMap.purge(DefaultTimeoutMap.java:230) ~[camel-core-2.17.3.jar:2.17.3]


                at org.apache.camel.support.DefaultTimeoutMap.run(DefaultTimeoutMap.java:180) ~[camel-core-2.17.3.jar:2.17.3]


                at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511) ~[na:1.8.0_202]


                at java.util.concurrent.FutureTask.runAndReset(FutureTask.java:308) ~[na:1.8.0_202]


                at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$301(ScheduledThreadPoolExecutor.java:180) ~[na:1.8.0_202]


                at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:294) ~[na:1.8.0_202]


                at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149) ~[na:1.8.0_202]


                at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624) ~[na:1.8.0_202]


                at java.lang.Thread.run(Thread.java:748) [na:1.8.0_202]


 


2021-11-12 12:04:43.439  WARN 28596 — [hecker[default]] o.a.c.c.r.reply.ReplyManagerSupport      : Early reply received with correlationID [Camel-ID-CP-local-57668-1636714990003-0-3] -> [123, 34, 116, 121, 112, 101, 34, 58, 34, 116, 101, 115, 116, 34, 44, 34, 109, 101, 115, 115, 97, 103, 101, 34, 58, 34, 104, 101, 108, 108, 111, 32, 98, 97, 99, 107, 32, 102, 114, 111, 109, 32, 110, 111, 100, 101, 74, 83, 32, 53, 34, 125]


2021-11-12 12:04:48.577  WARN 28596 — [hecker[default]] o.a.c.c.r.reply.ReplyManagerSupport      : Reply received for unknown correlationID [Camel-ID-CP-local-57668-1636714990003-0-3]. The message will be ignored: [123, 34, 116, 121, 112, 101, 34, 58, 34, 116, 101, 115, 116, 34, 44, 34, 109, 101, 115, 115, 97, 103, 101, 34, 58, 34, 104, 101, 108, 108, 111, 32, 98, 97, 99, 107, 32, 102, 114, 111, 109, 32, 110, 111, 100, 101, 74, 83, 32, 53, 34, 125]","acosentino:1637287277:2021-11-19T10:01:17.699+0000:1637287277:2021-11-19T10:01:17.699+0000:Camel 2.x is EOL, we are not going to release new versions in the near future. 

For what it worths, you're reporting 2.25.2 as version, but in the log I see 2.17.3. I think there is something wrong.
davsclaus:1637287350:2021-11-19T10:02:30.785+0000:1637287350:2021-11-19T10:02:30.785+0000:2.x is EOL in this regard - we only fix critical security issues.

Camel 3.x has improved rabbitmq component and there is also a spring-rabbitmq that uses the spring client for this which can be more roboust.
dkcp:1637504557:2021-11-21T22:22:37.781+0000:1637504557:2021-11-21T22:22:37.781+0000:Oh yeah, we are using 2.25.2 versions of camel, we tried with 2.17 as that was the version we upgraded from to see if the issue also exists which it does, I just upgraded the test app to 3.0.0-M1 to see if the issue also exists, if it does I will post the log
dkcp:1637545210:2021-11-22T09:40:10.901+0000:1637545210:2021-11-22T09:40:10.901+0000:Hi, yes from 3.0.0-M1 the issue doesn't exist, thank you"
0,CAMEL-17210,Improvement,Major,None,3.14.0,"
None
",Resolved,Fixed,3.14.0,Claus Ibsen,Claus Ibsen,0,1,2021-11-18 21:18:43+00:00,2021-11-21 14:48:37+00:00,"So you can run via


jbang CamelJBang run https://github.com/apache/camel-k/blob/main/examples/languages/routes.yaml


Something similar to what we can do with kamel CLI
https://camel.apache.org/camel-k/next/running/run-from-github.html",
0,CAMEL-17209,Improvement,Major,3.13.0,3.14.0,"
None
",Resolved,Fixed,3.14.0,Claus Ibsen,Claus Ibsen,0,1,2021-11-18 21:05:25+00:00,2021-11-18 21:14:32+00:00,The example for java-flight-recorder does not capture any events due to not being enabled automatic. This is a bit counter intuitive as the jfr dump recording is then empty for camel events.,
0,CAMEL-17208,Task,Major,None,,"
None
",Resolved,Fixed,None,David Jencks,David Jencks,0,1,2021-11-18 19:39:01+00:00,2022-09-03 10:39:27+00:00,"The network of subproject version dependencies is more complicated than we previously accounted for in the website release docs.  We've recently seen that:



camel-quarkus 2.4.x depends on camel components 3.12.x, so 3.12.x needs to remain in the docs as long as cq 2.4.x
camel-k 1.7.x depends on camel-quarkus 2.4.x, so cq 2.4.x and camel 3.12.x need to remain in the docs as long as camel-k 1.7.x



I imagine there are a lot more subproject interdependencies that have not yet been discovered or even properly set up.  It would be great to have



each subproject clearly document which other subprojects it depends on with the versions of these other subprojects, as I've suggested in https://github.com/apache/camel-k/issues/2759.
a centralized view of all such dependencies.



However, we should at least document that these dependencies generally exist and that removing any version from the documentation needs to check that no other subprojects are referencing it.",
0,CAMEL-17207,Improvement,Minor,None,3.15.0,"
None
",Resolved,Won't Fix,3.15.0,Claus Ibsen,Claus Ibsen,0,1,2021-11-18 12:46:49+00:00,2021-12-03 09:29:12+00:00,"If you create a route from a kamelet / route-template and then later stop this route, then the kamelet route keeps running


For example stopping route earthquake here
https://github.com/apache/camel-examples/blob/main/examples/kamelet-main/src/main/resources/camel/my-route.yaml


Then the underlying route (that actually starts from a timer) is not stopped.","davsclaus:1638494952:2021-12-03T09:29:12.066+0000:1638494952:2021-12-03T09:29:12.066+0000:Lets keep the stop route api per route.

For route reload feature we just reload all routes."
0,CAMEL-17206,Improvement,Major,None,3.14.0,"
None
",Resolved,Fixed,3.14.0,Claus Ibsen,Claus Ibsen,0,1,2021-11-18 10:05:30+00:00,2021-11-18 10:48:34+00:00,No Desc,"davsclaus:1637201188:2021-11-18T10:06:28.297+0000:1637201188:2021-11-18T10:06:28.297+0000:Should come with route reload enabled / easy configurable out of the box, so users can do code changes and have it reload automatic.
We also need this for camel-jbang / Karavan.
davsclaus:1637203642:2021-11-18T10:47:22.892+0000:1637203642:2021-11-18T10:47:22.892+0000:You can reload a jbang file 

jbang -Dcamel.jbang.version=3.14.0-SNAPSHOT CamelJBang@apache/camel run my-route.yaml --reload"
0,CAMEL-17205,Improvement,Major,None,3.14.0,"
None
",Resolved,Fixed,3.14.0,Claus Ibsen,Claus Ibsen,0,1,2021-11-18 09:47:49+00:00,2021-11-18 10:02:23+00:00,"The failure route id / endpoint uri is not present, which we should set earlier so the custom prepare processor can have access to it.",
0,CAMEL-17204,Task,Minor,3.12.0,3.14.0,"

log-level

",Resolved,Fixed,3.14.0,Unassigned,Joe O'Connor,0,2,2021-11-17 14:53:05+00:00,2021-11-18 05:42:22+00:00,"When uploading a file to S3 using multipart uploads, a warning message is logged for each one:


""While trying to upload the file {} file, 0 bytes were skipped""


This seems to have been introduced by some static analysis fixes in


https://github.com/apache/camel/pull/5842/files#diff-69d246dde09cb26ec2795e3fa893ba7e969dba1a1aa9f361a03ced8976a9535b


 


For the first iteration of the loop, filePosition is expected to be zero so this is the expected return value.


Does not seem to affect any functionality, just an unnecessary warning is logged","davsclaus:1637133795:2021-11-17T15:23:15.346+0000:1637133795:2021-11-17T15:23:15.346+0000:You are welcome to send a PR to fix this
joeoconnor:1637133934:2021-11-17T15:25:34.549+0000:1637133934:2021-11-17T15:25:34.549+0000:Thanks Claus, here's a proposed fix:

https://github.com/apache/camel/pull/6445"
0,CAMEL-17203,Task,Minor,3.11.3,,"
None
",Resolved,Later,None,Unassigned,Andre Weickel,0,2,2021-11-17 11:08:02+00:00,2022-09-03 10:39:09+00:00,"We have a custom component that extends the Camel ftp component but when we build our project not all resources are generated. The files in folder src/generated/resources/META-INF/services/org/apache/camel/configurer are available but folder src/generated/resources/META-INF/services/org/apache/camel/component/* is missing.


Therefore we removed the generated folder in org.apache.camel.camel-ftp and build the project to see if the folder is generated but then we get the following error:


 


Failed to execute goal org.apache.camel:camel-package-maven-plugin:3.11.3:generate (generate) on project camel-ftp: Error generating data org.apache.maven.plugin.MojoExecutionException: Error loading other model. Reason: java.lang.IllegalArgumentException: FirstVersion is not specified. This can be done in @UriEndpoint or in pom.xml file.


 


It seems to be a bug because firstVersion is actually maintained in @UriEndpoint of FtpEndpoint, FtpsEndpoint and SftpEndpoint. When I maintain an additional firstVersion in the pom.xml file then the build is successful but folder and files of src/generated/resources/META-INF/services/org/apache/camel/component/*  are also not generated for project org.apache.camel.camel-ftp.","davsclaus:1637127620:2021-11-17T13:40:20.935+0000:1637127620:2021-11-17T13:40:20.935+0000:You need to use camel-component-maven-plugin
https://camel.apache.org/manual/camel-component-maven-plugin.html
davsclaus:1637129449:2021-11-17T14:10:49.091+0000:1637129449:2021-11-17T14:10:49.091+0000:You are creating an non official Camel component so your first version should be your version and not Camel, so it should be correct to set it in the pom.xml
AWeickel:1637281394:2021-11-19T08:23:14.857+0000:1637281394:2021-11-19T08:23:14.857+0000:Even when we use camel-component-maven-plugin only META-INF/…/configurer is generated but not META-INF/…/component. It is the same behavior as in org.apache.camel.camel-ftp.

When we remove the whole “generated” folder in org.apache.camel.camel-ftp and build the project there is also no component folder generated. Only the configurer folder.
davsclaus:1637287214:2021-11-19T10:00:14.018+0000:1637287214:2021-11-19T10:00:14.018+0000:You can add the component file yourself in src/main/resources/META-INF - its just a tiny file with a mapping between the name and the class
davsclaus:1637287254:2021-11-19T10:00:54.773+0000:1637287254:2021-11-19T10:00:54.773+0000:Can you put together your custom component code and attach as .zip or put on github somewhere. We need an easy way to reproduce and look into this, before we will help more.
davsclaus:1662172749:2022-09-03T10:39:09.146+0000:1662172749:2022-09-03T10:39:09.146+0000:No response from reporter"
0,CAMEL-17202,Bug,Minor,3.13.0,3.14.0,"
None
",Resolved,Fixed,3.14.0,Claus Ibsen,Henrik Karlsson,0,2,2021-11-17 10:23:42+00:00,2021-11-23 05:41:26+00:00,"If two openapi spec uses the same method, basePath and uriTemplate the componentEndpointUri will be the same. Then the second endpoint is created the first one  is found in the camel context and the host property is overwritten. This causes all calls to these operations in routes goes to the second api.


API One:
host: https://api.one.com
method: GET
basePath: /api
uriTemplate: /users/{email}
title: api-one
version: 1.0.2


API Two:
host: https://api.two.com
method: GET
basePath: /api
uriTemplate: /users/{email}
title: api-two
version: 2.0.1


In RestOpenApiEndpoint.createProducerFor() the componentEndpointUri is created like this:




final String componentEndpointUri = ""rest:"" + method + "":"" + basePath + "":"" + uriTemplate 



For both of the operations described above the componentEndpointUri will be



""rest:GET:/api:/users/{email}""



When the camelContext.getEndpoint is called with this uri for API Two the endpoint for created for API One is returned instead of creating a new and the host parameter is set to 'https://api.two.com'.


To solve this I've added title and version from the openapi spec as query parameters to the componentEndpointUri:




final String componentEndpointUri = ""rest:"" + method + "":"" + basePath + "":"" + uriTemplate
    + ""?title="" + openapi.info.title + ""&version="" + openapi.info.version; 



Title and version are required in OpenAPI 3.x so they should always be available.","davsclaus:1637116341:2021-11-17T10:32:21.718+0000:1637116341:2021-11-17T10:32:21.718+0000:Why do you have two API endpoint with the same uri combination ?
henka-rl:1637119797:2021-11-17T11:29:57.626+0000:1637119797:2021-11-17T11:29:57.626+0000:It's two different apis. They use different hostnames, but one operation in both apis happens to use the same basePath and uriTemplate.
davsclaus:1637127511:2021-11-17T13:38:31.130+0000:1637127511:2021-11-17T13:38:31.130+0000:Ah yeah its on the producer side
davsclaus:1637129525:2021-11-17T14:12:05.509+0000:1637129525:2021-11-17T14:12:05.509+0000:We should use id of rest() that can be unique and use that as part of the producer uri
Using a combination of version and title is not ideal
henka-rl:1637279984:2021-11-19T07:59:44.881+0000:1637279984:2021-11-19T07:59:44.881+0000:But isn't rest() only used for consumer?
davsclaus:1637289116:2021-11-19T10:31:56.753+0000:1637289116:2021-11-19T10:31:56.753+0000:Can you put together a reproducer example of this
henka-rl:1637540427:2021-11-22T08:20:27.625+0000:1637540427:2021-11-22T08:20:27.625+0000:Yes, I'll fix an example of this. 
henka-rl:1637547892:2021-11-22T10:24:52.521+0000:1637547892:2021-11-22T10:24:52.521+0000:[https://github.com/henka-rl/camel-17202-example]

 
davsclaus:1637549686:2021-11-22T10:54:46.776+0000:1637549686:2021-11-22T10:54:46.776+0000:Thanks for the example
davsclaus:1637559972:2021-11-22T13:46:12.981+0000:1637559972:2021-11-22T13:46:12.981+0000:Thanks for the example, I found a fix, and your app now works and passes its test"
0,CAMEL-17201,Improvement,Major,None,3.14.0,"
None
",Resolved,Fixed,3.14.0,Claus Ibsen,Claus Ibsen,0,1,2021-11-16 16:12:13+00:00,2021-11-17 08:25:45+00:00,"We can auto detect when a new component is in use, then try to auto download its JAR - we can do this for kamelets because their spec list the deps. But for regular routes, then we have only the uri scheme name


```
~/Desktop ❯ CamelJBang run foo.yaml --max-messages=10 --debug-level=info
Starting Camel JBang!
A new lock file was created on /Users/davsclaus/Desktop/./.run14397159960467045040.camel.lock. Delete this file to stop running
17:00:17.745 [main] INFO  org.apache.camel.main.BaseMainSupport - Auto-configuration summary
17:00:17.749 [main] INFO  org.apache.camel.main.BaseMainSupport -     camel.main.lightweight=true
17:00:17.749 [main] INFO  org.apache.camel.main.BaseMainSupport -     camel.main.routesIncludePattern=file:foo.yaml
17:00:17.749 [main] INFO  org.apache.camel.main.BaseMainSupport -     camel.main.name=CamelJBang
17:00:17.749 [main] INFO  org.apache.camel.main.BaseMainSupport -     camel.main.durationMaxMessages=10
17:00:17.749 [main] INFO  org.apache.camel.main.BaseMainSupport -     camel.component.kamelet.location=classpath:/kamelets,github:apache:camel-kamelets
org.apache.camel.FailedToCreateRouteException: Failed to create route route2 at: >>> To[aws2-kinesis:mystream?proxyPort=8080&trustAllCertificates=true] <<< in route: Route(route2)[From[timer:yaml?period=1000] -> [SetBody[const... because of No endpoint could be found for: aws2-kinesis://mystream?proxyPort=8080&trustAllCertificates=true, please check your classpath contains the needed Camel component jar.
        at org.apache.camel.reifier.RouteReifier.doCreateRoute(RouteReifier.java:240)
        at org.apache.camel.reifier.RouteReifier.createRoute(RouteReifier.java:74)
        at org.apache.camel.impl.DefaultModelReifierFactory.createRoute(DefaultModelReifierFactory.java:49)
        at org.apache.camel.impl.DefaultCamelContext.startRouteDefinitions(DefaultCamelContext.java:851)
        at org.apache.camel.impl.DefaultCamelContext.startRouteDefinitions(DefaultCamelContext.java:741)
        at org.apache.camel.impl.engine.AbstractCamelContext.doInit(AbstractCamelContext.java:2773)
        at org.apache.camel.support.service.BaseService.init(BaseService.java:83)
        at org.apache.camel.impl.engine.AbstractCamelContext.init(AbstractCamelContext.java:2491)
        at org.apache.camel.support.service.BaseService.start(BaseService.java:111)
        at org.apache.camel.impl.engine.AbstractCamelContext.start(AbstractCamelContext.java:2510)
        at org.apache.camel.impl.DefaultCamelContext.start(DefaultCamelContext.java:246)
        at org.apache.camel.main.KameletMain.doStart(KameletMain.java:114)
        at org.apache.camel.support.service.BaseService.start(BaseService.java:119)
        at org.apache.camel.dsl.jbang.core.commands.Run.run(Run.java:114)
        at org.apache.camel.dsl.jbang.core.commands.Run.call(Run.java:73)
        at org.apache.camel.dsl.jbang.core.commands.Run.call(Run.java:32)
        at picocli.CommandLine.executeUserObject(CommandLine.java:1953)
        at picocli.CommandLine.access$1300(CommandLine.java:145)
        at picocli.CommandLine$RunLast.executeUserObjectOfLastSubcommandWithSameParent(CommandLine.java:2352)
        at picocli.CommandLine$RunLast.handle(CommandLine.java:2346)
        at picocli.CommandLine$RunLast.handle(CommandLine.java:2311)
        at picocli.CommandLine$AbstractParseResultHandler.execute(CommandLine.java:2179)
        at picocli.CommandLine.execute(CommandLine.java:2078)
        at org.apache.camel.dsl.jbang.core.commands.CamelJBangMain.run(CamelJBangMain.java:42)
        at main.CamelJBang.main(CamelJBang.java:30)
```",davsclaus:1637050366:2021-11-16T16:12:46.183+0000:1637050366:2021-11-16T16:12:46.183+0000:We can use the camel-catalog to know the maven GAV of the endpoint
0,CAMEL-17200,Bug,Minor,3.13.0,None,"
None
",Resolved,Fixed,3.14.0,Claus Ibsen,Mathieu Souchet,0,2,2021-11-16 14:26:19+00:00,2021-12-03 08:32:00+00:00,"The `includeFolders` parameter of `camel-google-storage` component doesn't work.


The documentation (https://camel.apache.org/components/3.12.x/google-storage-component.html#_component_option_includeFolders) says that we just have to set the parameter to `false` in order to ignore folder elements of buckets,


but actually the parameter does the opposite : if it is `false`, only folder elements are included by Camel.


Responsible piece of code is here : https://github.com/apache/camel/blob/main/components/camel-google/camel-google-storage/src/main/java/org/apache/camel/component/google/storage/GoogleCloudStorageConsumer.java#L147


I think the condition is reversed","acosentino:1637044083:2021-11-16T14:28:03.373+0000:1637044083:2021-11-16T14:28:03.373+0000:you're welcome to provide a PR
acosentino:1637044113:2021-11-16T14:28:33.890+0000:1637044113:2021-11-16T14:28:33.890+0000:and this is not a blocker, there is a workaround.
mat_souch:1637045659:2021-11-16T14:54:19.109+0000:1637045671:2021-11-16T14:54:31.094+0000:Hello Andrea,
{quote}you're welcome to provide a PR
{quote}
Ok for the PR, i will do that.
{quote}and this is not a blocker, there is a workaround.
{quote}
Ok ... and can you provide me this workaround ?
acosentino:1637047577:2021-11-16T15:26:17.897+0000:1637047577:2021-11-16T15:26:17.897+0000:If false/true are flipped, simply set the includeFolder to true, or not? From what you report it seems there is just a misinterpretation of the boolean value in the code. Didn't check myself yet. By the way, we consider block stuff like ""the project is not compiling"" or something completely broken in the core. I don't think we should consider this a blocker and btw there won't be a 3.13.1 release, but directly the 3.14.0 LTS release."
0,CAMEL-17199,Task,Major,3.13.0,None,"
None
",Resolved,Fixed,3.14.0,Otavio Rodolfo Piske,Otavio Rodolfo Piske,0,1,2021-11-16 10:42:36+00:00,2021-11-16 16:15:50+00:00,"This is related about these 2 comments in an issue for Karavan:



https://github.com/apache/camel-karavan/issues/104#issuecomment-970136615
https://github.com/apache/camel-karavan/issues/104#issuecomment-970137884



 


We should probably standardize our CLI commands to use the following notation 
jbang -Dcamel.jbang.version=<version> CamelJBang@apache/camel --help


 


This avoids the problems w/ RELEASE artifacts resolution and may prevent problems if we remove the CamelJBang script when / if JBang adds the other extension point (or plugin support).


 


Our documentation still makes references to CamelJBang as the CLI command, so it would be better to align the narrative.",orpiske:1637044961:2021-11-16T14:42:41.703+0000:1637044961:2021-11-16T14:42:41.703+0000:Fixed with the linked PR.
0,CAMEL-17198,Bug,Minor,3.12.0,3.13.0,"
None
",Resolved,Fixed,3.13.0,Unassigned,Adam,0,2,2021-11-15 10:53:56+00:00,2021-11-16 15:56:23+00:00,"I'm generating code with the Camel Salesforce Maven plugin v3.12.0, and it's creating valid Java classes except for an import import org.apache.camel.component.salesforce.api.PicklistEnumConverter; - that class doesn't exist. 


I can see lots of references to that class in Github, and I can find [Javadoc|(https://javadoc.io/static/org.apache.camel/camel-salesforce/3.4.4/org/apache/camel/component/salesforce/api/PicklistEnumConverter.html) for it, but it's Camel v3.4.4.


I'm using the basic options when using the plugin (just authentication and regex-filtering on a specific object), so I'm not sure what could be going wrong.


I'm using Maven 3.8.3.","zregvart:1636948850:2021-11-15T12:00:50.124+0000:1636948850:2021-11-15T12:00:50.124+0000:This issue [was fixed|https://github.com/apache/camel/commit/827644dd7c463d2a80a9808bb801e43c725af3f0] in 3.13.0.
CatchDepthHeightLight:1637049383:2021-11-16T15:56:23.153+0000:1637049383:2021-11-16T15:56:23.153+0000:Ah great, thanks. This works for me 👍"
0,CAMEL-17197,Improvement,Minor,None,3.19.0,"
None
",Resolved,Fixed,3.19.0,Nicolas Filotto,Claus Ibsen,0,2,2021-11-15 10:35:19+00:00,2022-09-15 11:53:01+00:00,"When running test IT tests


[INFO] Running org.apache.camel.component.elasticsearch.integration.ElasticsearchGetSearchDeleteExistsUpdateIT
Nov 15, 2021 11:34:27 AM org.elasticsearch.client.RestClient logResponse
WARNING: request [POST http://localhost:52347/_msearch?typed_keys=true] returned 1 warnings: [299 Elasticsearch-7.3.2-1c1faf1 ""[types removal] Specifying types in multi search requests is deprecated.""]
Nov 15, 2021 11:34:28 AM org.elasticsearch.client.RestClient logResponse
WARNING: request [PUT http://localhost:52347/getrequestbody()-foo/getrequestbody()-bar/getrequestbody()-testId?timeout=1m] returned 1 warnings: [299 Elasticsearch-7.3.2-1c1faf1 ""[types removal] Specifying types in document index requests is deprecated, use the typeless endpoints instead (/

{index}/_doc/{id}, /{index}

/_doc, or /

{index}/_create/{id}).""]


Nov 15, 2021 11:34:28 AM org.elasticsearch.client.RestClient logResponse


WARNING: request 
[GET http://localhost:52347/getrequestbody()-foo/getrequestbody()-bar/getrequestbody()-testId]
 returned 1 warnings: [299 Elasticsearch-7.3.2-1c1faf1 ""
[types removal]
 Specifying types in document get requests is deprecated, use the /{index}

/_doc/

{id} endpoint instead.""]


Nov 15, 2021 11:34:28 AM org.elasticsearch.client.RestClient logResponse


WARNING: request 
[PUT http://localhost:52347/deleterequestbody()-foo/deleterequestbody()-bar/deleterequestbody()-testId?timeout=1m]
 returned 1 warnings: [299 Elasticsearch-7.3.2-1c1faf1 ""
[types removal]
 Specifying types in document index requests is deprecated, use the typeless endpoints instead (/{index}/_doc/{id}

, /

{index}/_doc, or /{index}

/_create/

{id}).""]


Nov 15, 2021 11:34:28 AM org.elasticsearch.client.RestClient logResponse


WARNING: request 
[DELETE http://localhost:52347/deleterequestbody()-foo/deleterequestbody()-bar/deleterequestbody()-testId?timeout=1m]
 returned 1 warnings: [299 Elasticsearch-7.3.2-1c1faf1 ""
[types removal]
 Specifying types in document index requests is deprecated, use the /{index}/_doc/{id}

 endpoint instead.""]","davsclaus:1636943761:2021-11-15T10:36:01.454+0000:1636943761:2021-11-15T10:36:01.454+0000:[INFO] Running org.apache.camel.component.elasticsearch.integration.ElasticsearchBulkIT
Nov 15, 2021 11:33:53 AM org.elasticsearch.client.RestClient logResponse
WARNING: request [POST http://localhost:52274/_bulk?timeout=1m] returned 1 warnings: [299 Elasticsearch-7.3.2-1c1faf1 ""[types removal] Specifying types in bulk requests is deprecated.""]
Nov 15, 2021 11:33:53 AM org.elasticsearch.client.RestClient logResponse
WARNING: request [POST http://localhost:52274/_bulk?timeout=1m] returned 1 warnings: [299 Elasticsearch-7.3.2-1c1faf1 ""[types removal] Specifying types in bulk requests is deprecated.""]
nfilotto:1663203743:2022-09-15T09:02:23.257+0000:1663203743:2022-09-15T09:02:23.257+0000:should be fixed by https://github.com/apache/camel/pull/8381"
0,CAMEL-17196,Dependency upgrade,Major,None,3.14.0,"
None
",Resolved,Fixed,3.14.0,Unassigned,Claus Ibsen,0,1,2021-11-15 09:45:36+00:00,2021-11-15 09:53:06+00:00,This is the last release of 7.x that is ASL2 license. Newer versions are their own license,
0,CAMEL-17195,Improvement,Major,3.x,3.14.0,"
None
",Resolved,Fixed,3.14.0,Jeremy Ross,Jeremy Ross,0,1,2021-11-15 04:25:58+00:00,2021-11-16 17:26:39+00:00,"If salesforce determines a replalyId to be invalid, fallbackReplayId would be used to restart the subscription. The obvious values are -1 (new messages after subscription begins), and -2 (all messages salesforce has stored, plus new messages). Let's default it to -1.",
0,CAMEL-17194,Task,Major,None,3.15.0,"
None
",Resolved,Fixed,3.15.0,Claus Ibsen,Claus Ibsen,0,1,2021-11-14 08:20:02+00:00,2021-12-21 15:33:20+00:00,"When you build a component then it update sources in these DSLs per component.


Instead we should when building these DSLs make them scan all components and build the DSL source code only once.


This also reduces the complexity of updating the source code, as they can just re-generate everything when building.","davsclaus:1640052250:2021-12-21T10:04:10.800+0000:1640071939:2021-12-21T15:32:19.529+0000:componentdsl seems easier as its less complex *DONE*
endpointdsl has some project classloader to deal with enums *DONE*

generate only once, and not per component *DONE*"
0,CAMEL-17193,Task,Major,None,Future,"
None
",Open,Unresolved,Future,Unassigned,Claus Ibsen,0,1,2021-11-13 12:54:14+00:00,2023-08-09 09:17:17+00:00,"Spring Boot has special section added to the camel core projects component docs.
The other sub projects does not.


We should move this to its own camel spring boot docs, like we do for camel-quarkus
https://camel.apache.org/camel-quarkus/next/reference/extensions/asterisk.html


Then we can have generated something similar as above that has this spring boot auto configuration table. And any custom spring boot doc for this particular component.


This makes the core documentation vanilla.",
0,CAMEL-17192,Task,Major,None,3.15.0,"
None
",Resolved,Fixed,3.15.0,Claus Ibsen,Claus Ibsen,0,1,2021-11-13 12:17:50+00:00,2021-12-21 09:42:08+00:00,"Currently they are in the core folder, but we should move them under dsl.


Then they are built later, and dont cause pain when working on the core modules, due to having dependency on all components etc.


And now we have a dsl folder, where it makes sense to have them",davsclaus:1640048986:2021-12-21T09:09:46.692+0000:1640048986:2021-12-21T09:09:46.692+0000:Move camel-allcomponents from core to catalog
0,CAMEL-17191,Task,Minor,None,None,"
None
",Resolved,Fixed,None,Unassigned,Sebb,0,1,2021-11-12 14:56:09+00:00,2022-09-03 10:37:57+00:00,"AFAICT the apache-camel-quarkus-2.3.0-src.zip artifact is still current according to the download page [1], yet it has been dropped from the mirror system.


Please either restore it to the mirror system, or drop it as a current release.


 


[1] https://camel.apache.org/download/#camel-quarkus","davsclaus:1636703619:2021-11-12T15:53:39.626+0000:1636703619:2021-11-12T15:53:39.626+0000:2.4.0 release is on the way so the 2.3.0 is going away soon
sebb:1636707900:2021-11-12T17:05:00.892+0000:1636707900:2021-11-12T17:05:00.892+0000:That may well be so, but the current release should not be dropped from the mirrors until the replacement has been published.

With the new CDN it is no longer necessary to wait for 24 hours for mirrors to catch up, but there still should be some overlap."
0,CAMEL-17190,Improvement,Minor,3.11.3,3.14.0,"
None
",Resolved,Fixed,3.14.0,Claus Ibsen,Alexander Anpilov,0,3,2021-11-12 13:15:00+00:00,2021-11-14 08:26:35+00:00,"When route, consumed from quickfix, stopped (manually or by lost master status), quickfix-engine still works.


Fix messages are not processed by any camel route and there are no any exception's.


It seems that camel-quickfix-consumer should overvride doStop() like that:




@Override
protected void doStop() throws Exception {
    (QuickfixjEndpoint)getEndpoint()).getEngine().doStop();
    super.doStop(); 
}","acosentino:1636694260:2021-11-12T13:17:40.789+0000:1636694260:2021-11-12T13:17:40.789+0000:3.4.x won't be released anymore. Please switch to 3.11.x the living LTS, we can eventually fix it there, not on 3.4.x
aanpilov:1636694625:2021-11-12T13:23:45.663+0000:1636694625:2021-11-12T13:23:45.663+0000:On 3.12.0 i have the same issue
davsclaus:1636727863:2021-11-12T22:37:43.865+0000:1636727863:2021-11-12T22:37:43.865+0000:Why do you think that, the engines are managed by the component and stopped when the component stops.
An engine can be shared to other consumers / routes etc. So you cannot just stop an engine in the consumer.

However what seems to be missing is that if the consumer is stopped / started, then it should add/remove itself from the list of consumers on the endpoint, which is where the engine triggers when it has an event.
davsclaus:1636728198:2021-11-12T22:43:18.333+0000:1636729211:2021-11-12T23:00:11.983+0000:Another improvement is that if there are no more active consumers then the engine can be stopped eager, and if a consumer is started later, then the engine will be started again.
Okay that is not as easy as the producers can also use the same engine, when they need to send messages.
davsclaus:1636773946:2021-11-13T11:25:46.674+0000:1636773946:2021-11-13T11:25:46.674+0000:Engines are now stopped or start depending on any active consumer/producers using them
davsclaus:1636849595:2021-11-14T08:26:35.172+0000:1636849595:2021-11-14T08:26:35.172+0000:You can use the option eagerStopEngines on component to turn this off and have it work like before this change"
0,CAMEL-17189,Bug,Minor,None,3.14.0,"
None
",Resolved,Fixed,3.14.0,Jeremy Ross,Jesse Sightler,0,2,2021-11-11 21:43:58+00:00,2021-11-16 02:04:42+00:00,"The comment here seems to imply that there should be a way to manually create an HttpClient in SalesforceEndpointConfig: https://github.com/apache/camel/blob/main/components/camel-salesforce/camel-salesforce-component/src/main/java/org/apache/camel/component/salesforce/SalesforceComponent.java#L452


 


However, in reality, the doStart method always overrides the value provided by the configuration without first checking whether or not the config already has an HttpClient configured.


 


This seems to be a bug.","davsclaus:1636668359:2021-11-12T06:05:59.448+0000:1636668359:2021-11-12T06:05:59.448+0000:You are welcome to send a PR
davsclaus:1636926945:2021-11-15T05:55:45.392+0000:1636926945:2021-11-15T05:55:45.392+0000:[~jeremyross] maybe you can also take a look while working on this component."
0,CAMEL-17188,Test,Minor,None,3.14.0,"
None
",Resolved,Fixed,3.14.0,Otavio Rodolfo Piske,Claus Ibsen,0,2,2021-11-11 19:43:52+00:00,2021-11-12 23:03:34+00:00,"[WARNING] Flakes:
[WARNING] org.apache.camel.support.task.BackgroundTaskTest.testRunNoMoreSupplier
[ERROR]   Run 1: BackgroundTaskTest.testRunNoMoreSupplier:50 expected: <5> but was: <4>
[ERROR]   Run 2: BackgroundTaskTest.testRunNoMoreSupplier:50 expected: <5> but was: <4>
[INFO]   Run 3: PASS","davsclaus:1636631091:2021-11-11T19:44:51.289+0000:1636631091:2021-11-11T19:44:51.289+0000:[~orpiske] this test is failing often on my system. Maybe we can stabilize the test.

Sometimes it passes the 3rd time, others it fails the build, eg failing all 3 in a row.
orpiske:1636631504:2021-11-11T19:51:44.462+0000:1636631504:2021-11-11T19:51:44.462+0000:Thanks for the heads up. Tomorrow I will take a closer look at it."
0,CAMEL-17187,Improvement,Major,None,3.14.0,"
None
",Resolved,Fixed,3.14.0,Claus Ibsen,Claus Ibsen,0,1,2021-11-11 19:41:34+00:00,2021-11-12 08:34:32+00:00,You can configure this on xpath language / DSL but when you use @XPath annotation there is no configuration possible.,
0,CAMEL-17186,Task,Major,None,3.16.0,"
None
",Resolved,Fixed,3.16.0,Otavio Rodolfo Piske,Otavio Rodolfo Piske,0,1,2021-11-10 12:26:13+00:00,2022-03-03 09:27:46+00:00,No Desc,"orpiske:1646218788:2022-03-02T18:59:48.274+0000:1646218788:2022-03-02T18:59:48.274+0000:This one needs migration to Resume API V2.
orpiske:1646270866:2022-03-03T09:27:46.477+0000:1646270866:2022-03-03T09:27:46.477+0000:Merged."
0,CAMEL-17185,Improvement,Major,3.11.3,3.14.0,"
None
",Resolved,Fixed,3.14.0,Unassigned,Vincent Paturet,0,2,2021-11-10 10:30:06+00:00,2021-11-13 08:41:53+00:00,"Using Camel 3.11.3 we experience intermittent disconnections when configuring a Google PubSub endpoint in synchronous pull mode.
The application logs a warning message and then stops pulling new messages.




com.google.api.gax.rpc.DeadlineExceededException: io.grpc.StatusRuntimeException: DEADLINE_EXCEEDED: deadline exceeded after 59.985104781s. [buffered_nanos=7626625, remote_addr=pubsub.googleapis.com/74.125.140.95:443] at com.google.api.gax.rpc.ApiExceptionFactory.createException(ApiExceptionFactory.java:51) at com.google.api.gax.grpc.GrpcApiExceptionFactory.create(GrpcApiExceptionFactory.java:72) at com.google.api.gax.grpc.GrpcApiExceptionFactory.create(GrpcApiExceptionFactory.java:60) at com.google.api.gax.grpc.GrpcExceptionCallable$ExceptionTransformingFuture.onFailure(GrpcExceptionCallable.java:97) at com.google.api.core.ApiFutures$1.onFailure(ApiFutures.java:68) at com.google.common.util.concurrent.Futures$CallbackListener.run(Futures.java:1074) at com.google.common.util.concurrent.DirectExecutor.execute(DirectExecutor.java:30) at com.google.common.util.concurrent.AbstractFuture.executeListener(AbstractFuture.java:1213) at com.google.common.util.concurrent.AbstractFuture.complete(AbstractFuture.java:983) at com.google.common.util.concurrent.AbstractFuture.setException(AbstractFuture.java:771) at io.grpc.stub.ClientCalls$GrpcFuture.setException(ClientCalls.java:563) at io.grpc.stub.ClientCalls$UnaryStreamToFuture.onClose(ClientCalls.java:533) at io.grpc.internal.DelayedClientCall$DelayedListener$3.run(DelayedClientCall.java:463) at io.grpc.internal.DelayedClientCall$DelayedListener.delayOrExecute(DelayedClientCall.java:427) at io.grpc.internal.DelayedClientCall$DelayedListener.onClose(DelayedClientCall.java:460) at io.grpc.internal.ClientCallImpl.closeObserver(ClientCallImpl.java:553) at io.grpc.internal.ClientCallImpl.access$300(ClientCallImpl.java:68) at io.grpc.internal.ClientCallImpl$ClientStreamListenerImpl$1StreamClosed.runInternal(ClientCallImpl.java:739) at io.grpc.internal.ClientCallImpl$ClientStreamListenerImpl$1StreamClosed.runInContext(ClientCallImpl.java:718) at io.grpc.internal.ContextRunnable.run(ContextRunnable.java:37) at io.grpc.internal.SerializingExecutor.run(SerializingExecutor.java:123) at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Unknown Source) at java.base/java.util.concurrent.FutureTask.run(Unknown Source) at java.base/java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(Unknown Source) at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(Unknown Source) at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(Unknown Source) at java.base/java.lang.Thread.run(Unknown Source) Suppressed: com.google.api.gax.rpc.AsyncTaskException: Asynchronous task failed at com.google.api.gax.rpc.ApiExceptions.callAndTranslateApiException(ApiExceptions.java:57) at com.google.api.gax.rpc.UnaryCallable.call(UnaryCallable.java:112) at org.apache.camel.component.google.pubsub.GooglePubsubConsumer$SubscriberWrapper.synchronousPull(GooglePubsubConsumer.java:185)



 
The fix applied in CAMEL-16263 allows the SubscriberWrapper thread to recover from a retryable PubSub server error.
However the PubSub client library retries only ABORTED, UNAVAILABLE,  UNKNOWN errors by default.


Proposed fix: add a component option to specify additional retryable error codes in synchronous pull mode.
It is possible to configure custom retryable codes by using the method builder.pullSettings().setRetryableCodes() in SubscriberStubSettings.Builder


Note: The default builder SubscriberStubSettings.Builder configures retries with exponential backoff (current default settings: retrying during 1 minute).
In addition the loop in org.apache.camel.component.google.pubsub.GooglePubsubConsumer.SubscriberWrapper#synchronousPull ensures that the consumer will trigger a new request when the retries end, effectively retrying forever.",davsclaus:1636764113:2021-11-13T08:41:53.512+0000:1636764113:2021-11-13T08:41:53.512+0000:Thanks for reporting and the PR
0,CAMEL-17184,Bug,Minor,3.12.0,3.x,"
None
",Resolved,Abandoned,3.x,Unassigned,Nikhil,0,3,2021-11-10 08:14:31+00:00,2022-10-28 05:26:48+00:00,"Hello,


I am using Apache Camel 3.12.0 to communicate with Elasticsearch 7.13.0.
Elasticsearch is secured i.e. SSL HTTPs protected.


Below is the code snippet to index the data into Elasticsearch using camel.


 




ElasticsearchComponent camelESComponent = new ElasticsearchComponent();
camelESComponent.setHostAddresses(""127.0.0.1:9200"");
camelESComponent.setUser(""elastic"");
camelESComponent.setPassword(""password"");
camelESComponent.setEnableSSL(true);
camelContext.addComponent(""elasticsearch-rest"", camelESComponent); 

// route 
from(""direct:index"").to(""elasticsearch-rest://myescluster?operation=Index&indexName=twitter"");



I am getting below error while performing Index operation.




org.apache.http.ConnectionClosedException: Connection is closed
    at org.elasticsearch.client.RestClient.extractAndWrapCause(RestClient.java:871) ~[elasticsearch-rest-client-7.13.0.jar:7.13.0]
    at org.elasticsearch.client.RestClient.performRequest(RestClient.java:283) ~[elasticsearch-rest-client-7.13.0.jar:7.13.0]
    at org.elasticsearch.client.RestClient.performRequest(RestClient.java:270) ~[elasticsearch-rest-client-7.13.0.jar:7.13.0]
    at org.elasticsearch.client.RestHighLevelClient.internalPerformRequest(RestHighLevelClient.java:1654) ~[elasticsearch-rest-high-level-client-7.13.0.jar:7.13.0]
    at org.elasticsearch.client.RestHighLevelClient.performRequest(RestHighLevelClient.java:1624) ~[elasticsearch-rest-high-level-client-7.13.0.jar:7.13.0]
    at org.elasticsearch.client.RestHighLevelClient.performRequestAndParseEntity(RestHighLevelClient.java:1594) ~[elasticsearch-rest-high-level-client-7.13.0.jar:7.13.0]
    at org.elasticsearch.client.RestHighLevelClient.index(RestHighLevelClient.java:1011) ~[elasticsearch-rest-high-level-client-7.13.0.jar:7.13.0]
    at org.apache.camel.component.elasticsearch.ElasticsearchProducer.process(ElasticsearchProducer.java:170) ~[camel-elasticsearch-rest-3.12.0.jar:3.12.0]
    at org.apache.camel.support.AsyncProcessorConverterHelper$ProcessorToAsyncProcessorBridge.process(AsyncProcessorConverterHelper.java:66) ~[camel-support-3.12.0.jar:3.12.0]
    at org.apache.camel.processor.SendProcessor.process(SendProcessor.java:172) [camel-core-processor-3.12.0.jar:3.12.0]
    at org.apache.camel.processor.errorhandler.RedeliveryErrorHandler$SimpleTask.run(RedeliveryErrorHandler.java:469) [camel-core-processor-3.12.0.jar:3.12.0]
    at org.apache.camel.impl.engine.DefaultReactiveExecutor$Worker.executeFromQueue(DefaultReactiveExecutor.java:210) [camel-base-engine-3.12.0.jar:3.12.0]
    at org.apache.camel.impl.engine.DefaultReactiveExecutor.executeFromQueue(DefaultReactiveExecutor.java:74) [camel-base-engine-3.12.0.jar:3.12.0]
    at org.apache.camel.impl.engine.DefaultAsyncProcessorAwaitManager.await(DefaultAsyncProcessorAwaitManager.java:96) [camel-base-engine-3.12.0.jar:3.12.0]
    at org.apache.camel.impl.engine.DefaultAsyncProcessorAwaitManager.process(DefaultAsyncProcessorAwaitManager.java:85) [camel-base-engine-3.12.0.jar:3.12.0]
    at org.apache.camel.impl.engine.SharedCamelInternalProcessor.process(SharedCamelInternalProcessor.java:108) [camel-base-engine-3.12.0.jar:3.12.0]
    at org.apache.camel.support.cache.DefaultProducerCache.send(DefaultProducerCache.java:190) [camel-support-3.12.0.jar:3.12.0]
    at org.apache.camel.impl.engine.DefaultProducerTemplate.send(DefaultProducerTemplate.java:176) [camel-base-engine-3.12.0.jar:3.12.0]
    at org.apache.camel.impl.engine.DefaultProducerTemplate.send(DefaultProducerTemplate.java:172) [camel-base-engine-3.12.0.jar:3.12.0]
    at org.apache.camel.impl.engine.DefaultProducerTemplate.requestBody(DefaultProducerTemplate.java:413) [camel-base-engine-3.12.0.jar:3.12.0] 



 


I am getting above error when I use Camel 3.6.0 - 3.12.0 with SSL Elasticsearch. Without SSL works fine with this version.
If I downgrade component to Camel 3.2.0 / 3.4.0/ 3.5.0 then With and Without SSL both works perfectly fine.


Note: I verified complete end to end use case with Elasticsearch 7.8.0 [SSL Enabled], it is also failing with Camel 3.12.0 but working fine with Camel 3.2.0","acosentino:1636508945:2021-11-10T09:49:05.346+0000:1636508945:2021-11-10T09:49:05.346+0000:The last version supported is 7.8.0, 7.13.0 is not supported.
nikhil_khode@persistent.com:1636509502:2021-11-10T09:58:22.420+0000:1636509502:2021-11-10T09:58:22.420+0000:[~acosentino]  I will check same use case on *7.8.0* and will come back again.
Thanks a lot for you quick reply and help.
nikhil_khode@persistent.com:1636512415:2021-11-10T10:46:55.127+0000:1636512415:2021-11-10T10:46:55.127+0000:[~acosentino] I confirmed the same use case on 7.8.0.

SSL communication is working fine with Camel 3.2.0 but failing with Camel 3.12.0.
davsclaus:1636968268:2021-11-15T17:24:28.542+0000:1636968268:2021-11-15T17:24:28.542+0000:Nikhil, are you able to put together a reproducer, for example how to run elastisearch via docker where it has https/ssl turned on. So its easier to try from camel to call this ES server and reproduce this bug/issue, so we can find a way to fix it
davsclaus:1636970596:2021-11-15T18:03:16.715+0000:1636970596:2021-11-15T18:03:16.715+0000:Running ES with TLS enabled is a big pain
https://www.elastic.co/guide/en/elastic-stack-get-started/7.15/get-started-docker.html#get-started-docker-tls


davsclaus:1636970935:2021-11-15T18:08:55.344+0000:1636970935:2021-11-15T18:08:55.344+0000:i compared the source code from 3.13.0 and 3.2.0 and there is not much that would be a suspect for SSL not working.

However in Camel 3.2.0 it is an old client in use
<elasticsearch-rest-sniffer-version>7.3.2</elasticsearch-rest-sniffer-version>

So try to change the client version and test which works of them works and which does not. That would help
nikhil_khode@persistent.com:1636973731:2021-11-15T18:55:31.577+0000:1636973731:2021-11-15T18:55:31.577+0000:Hi [~davsclaus] thanks a lot for you quick response over the issue.

I am using standalone Elasticsearch binary and secured it following documentation of how to configure TLS : [https://www.elastic.co/guide/en/elasticsearch/reference/7.7/configuring-tls.html#node-certificates] 

As suggested by you, I verified below Camel Elasticsearch component version to check which version causing an issue. Below is my finding:
||Camel Version|| Status ||
|     3.2.0|OK|
|     3.4.0|OK|
|     3.5.0|OK|
|{color:#FF0000}     *3.6.0* {color}|{color:#FF0000}*NOT OK*{color}|
|     *{color:#FF0000}3.12.0{color}*|{color:#FF0000}*NOT OK*{color}|

 

I feel this has been broken since version 3.6.0. 
Do you see any change from 3.5.0 to 3.6.0 ?

Let me know if you need any help over this issue, would love to help as much as I can.
davsclaus:1637025022:2021-11-16T09:10:22.420+0000:1637025022:2021-11-16T09:10:22.420+0000:Thanks for testing the combinations. So lets see what we changed between 3.5.0 and 3.6.0. Either is due to ES client upgrade, code changes in Camel, or both of them.
davsclaus:1637026603:2021-11-16T09:36:43.600+0000:1637026603:2021-11-16T09:36:43.600+0000:Camel 3.5.0

        <elasticsearch-rest-sniffer-version>7.8.0</elasticsearch-rest-sniffer-version>
        <elasticsearch-rest-cluster-runner-version>7.8.0.0</elasticsearch-rest-cluster-runner-version>
        <elasticsearch-rest-version>7.8.0</elasticsearch-rest-version>


Camel 3.6.0

        <elasticsearch-rest-sniffer-version>7.8.0</elasticsearch-rest-sniffer-version>
        <elasticsearch-rest-cluster-runner-version>7.8.0.0</elasticsearch-rest-cluster-runner-version>
        <elasticsearch-rest-version>7.8.0</elasticsearch-rest-version>
davsclaus:1637026766:2021-11-16T09:39:26.178+0000:1637026766:2021-11-16T09:39:26.178+0000:{code}
29e1fe28ffabeccea29ad4246f10ba793f490150 (tag: camel-3.6.0) [maven-release-plugin] prepare release camel-3.6.0
cb9aafd41b8229a8b5e7c72b059c136c932fc70d CAMEL-15660: Fixed json schema generator to output default values in valid json type for boolean,int,number types.
69b2d49e49ce4d70e1894a820f3cbe7196f29ed5 CAMEL-15664: Automatically wrap secret properites with RAW when computing the URI (regen)
fb7264b740d08fb48505a467b903582d08775d92 Regen
4cdbd655adf2b50e8e09822b9ce38dc96fc1ccd4 Delete old folder name that was renamed
3f6e103b8bcf3303350dba7b4153170de837aad1 CAMEL-14499: Component verifiers require camel-core-catalog at runtime - added for testing.
44a708d7b22d16832d6c45ef22bbc5b43ec93da7 CAMEL-15579: UriFactory to know more about endpoints in the generated source code.
79a8bd5fa481bb1d85046b0c45b3078e4df288cc CAMEL-15567: components - Generate source code for creating endpoint uri via a map of properties (#4302)
ee033f612bc005b2916a459df81dd6fc2141c6a7 Re-generate the docs after changing the tooling
8afbb0cf91fcd028f1e8647818960893e5bec6c8 api-components - renamed and regen
e526a3da26c58f6109a44e96c279afc3523c2f48 CAMEL-15478: Revert back enums to use their upper cased value in component json
119fcebf6f7b32989c1a7bb7cc9a57dd40a3496e CAMEL-15478: API components overhauled (big commit)
e16d6e441aa77ffd2893c04deec35e10b67def2c Use the same ES version for docker image
0f91c82bfaef67784c3eb5b768dd28b35d277065 Revert ""Use Elasticsearch 7.9.0 docker image""
2e3f59402164d47e3b04c97caec4b38c1693ec23 CAMEL-15515: camel-core - Deprecate basicPropertyBinding
44e9ce6807ac17749cb10e98d50ea59a2b1af977 Use Elasticsearch 7.9.0 docker image
63f6be7bff3e17bd3934fac060c64b54078afab5 Regen
0323b243eae2d3d51c53180c7e15f38cdb73c590 Next is 3.6.0-SNAPSHOT
899f43c7790da6dd403cb982d6dd9ee2b9154a13 Lets include the number of enums in the documentation description. Especially for large APIs where there are hundreds it can be overwhealming.
347d8ba0a3c27bc8a1026bbe192236dadf4a3873 CAMEL-15478: Component marks which uri endpoint property name is used for selecting which api method to use for API based components.
eadfcd87a019ca4bca7d9eb722b202af31daac8e CAMEL-15478: Component metadata should mark if a component is API based or not
{code}
davsclaus:1637027683:2021-11-16T09:54:43.464+0000:1637027683:2021-11-16T09:54:43.464+0000:Okay so this is weird, they use the same ES client version, and the source code changes in the actual seems minor and unrelated to this. Its about UriFactory and to know more about options for tooling etc.
davsclaus:1637027714:2021-11-16T09:55:14.385+0000:1637027714:2021-11-16T09:55:14.385+0000:And just to be sure, you use the same Java JVM version when testing between 3.5.0 and 3.6.0? And btw what Java version do you use?
nikhil_khode@persistent.com:1637038039:2021-11-16T12:47:19.223+0000:1637038039:2021-11-16T12:47:19.223+0000:Yes, I used the same Oracle JDK 8 for all use cases.
davsclaus:1666906008:2022-10-28T05:26:48.240+0000:1666906008:2022-10-28T05:26:48.240+0000:There is a new camel-elasticsearch component using a newer library. You can give that a try"
0,CAMEL-17183,Bug,Major,3.12.0,,"
None
",Resolved,Information Provided,None,Unassigned,Nikhil,0,2,2021-11-10 07:59:30+00:00,2021-11-10 09:27:23+00:00,"I am using below stack to index a data into Elasticsearch using Camel Elasticsearch component:



Elasticsearch 7.15.0
Apache Camel 3.12.0
Spring 5.3.12
Spring Boot 2.5.6



While indexing the data into Elasticsearch 7.15.0, I am getting ClassNotFoundException: org.elasticsearch.common.CheckedConsumer


please have a look on the detailed error below:




Caused by: java.lang.ClassNotFoundException: org.elasticsearch.common.CheckedConsumer
at java.net.URLClassLoader.findClass(URLClassLoader.java:381) ~[?:1.8.0_92]
at java.lang.ClassLoader.loadClass(ClassLoader.java:424) ~[?:1.8.0_92]
at org.springframework.boot.loader.LaunchedURLClassLoader.loadClass(LaunchedURLClassLoader.java:151) ~[indexer-IPM-12.0.4-CP4D-SNAPSHOT.jar:?]
at java.lang.ClassLoader.loadClass(ClassLoader.java:357) ~[?:1.8.0_92]
at org.apache.camel.component.elasticsearch.ElasticsearchProducer$HighLevelClient.<init>(ElasticsearchProducer.java:347) ~[camel-elasticsearch-rest-3.12.0.jar:3.12.0]
at org.apache.camel.component.elasticsearch.ElasticsearchProducer$HighLevelClient.<init>(ElasticsearchProducer.java:345) ~[camel-elasticsearch-rest-3.12.0.jar:3.12.0]
at org.apache.camel.component.elasticsearch.ElasticsearchProducer.process(ElasticsearchProducer.java:124) ~[camel-elasticsearch-rest-3.12.0.jar:3.12.0]
at org.apache.camel.support.AsyncProcessorConverterHelper$ProcessorToAsyncProcessorBridge.process(AsyncProcessorConverterHelper.java:66) ~[camel-support-3.12.0.jar:3.12.0]
... 11 more 



I investigated the issue in details and came to know that package org.elasticsearch.common.CheckedConsumer is present in elasticsearch-core-7.13.0.jar but the common package is completely missing in elasticsearch-core-7.15.0.jar. This is why while talking with Elasticsearch using Apache Camel component we are getting this runtime error.


Please have a look on the attached images for the package structure and class information in respective jars.","acosentino:1636507624:2021-11-10T09:27:04.736+0000:1636507624:2021-11-10T09:27:04.736+0000:The supported version of Elasticsearch is 7.8.0.

From Elasticsearch 7.11 they changed the license of their client to something non-ASF.

It is still not completely clear if this stuff is compatible or not with ASF license, but in the meantime we choose to not update. So 7.15 is not supported. "
0,CAMEL-17182,Bug,Major,3.11.1,,"
None
",Resolved,Invalid,None,Unassigned,changzhiwin,0,2,2021-11-09 13:07:53+00:00,2021-11-10 02:36:45+00:00,"I write some Camel demo, about proxy of grpc. 
When use query parameter of routeControlledStreamObserver (official website), some special manners tack place. 
When using stream mode, the response observer  is null, and I don't know why? there is the full project at github(https://github.com/changzhiwin/grpc-test).


And I use this client to test camel project.


$ git clone -b v1.41.0 https://github.com/grpc/grpc-java.git


And I asked at https://stackoverflow.com/questions/69765267/why-response-observer-is-not-exist-in-consumer-of-camel-grpc-componet.","acosentino:1636434647:2021-11-09T13:10:47.832+0000:1636434647:2021-11-09T13:10:47.832+0000:Ask on the dev mailing list or user mailing list first. This is a JIRA for tracking issues, for questions we use other channels. Thank you.
changzhi:1636483005:2021-11-10T02:36:45.462+0000:1636483005:2021-11-10T02:36:45.462+0000:got it, thanks"
0,CAMEL-17181,Bug,Major,"3.11.3, 3.12.0","3.7.7, 3.11.4, 3.14.0","
None
",Resolved,Fixed,"3.7.7, 3.11.4, 3.14.0",Claus Ibsen,Mikael Andersson Wigander,0,3,2021-11-09 10:50:21+00:00,2021-11-26 07:52:53+00:00,"When using @XPath() annotations to bean method parameters, XPathBuilder is used and expressions are added to a pool in the init() method of the class.


These expressions are keep adding up but they are never cleared.


There's a method doStop() which has the code for cleaning but it is never used, hence a leakage of XPathExpressions.","hakuseki:1636434296:2021-11-09T13:04:56.928+0000:1636434296:2021-11-09T13:04:56.928+0000:Adding a snippet with a file to use

[^FULINS_I_20211106_01of01.zip]

Route:
{code:java}
    from(file(""<some-dir>""))
                .streamCaching()
                .unmarshal()
                .zipFile()
                .split()
                .tokenizeXML(""RefData"")
                .streaming()
                .parallelProcessing(true)
                .bean(XmlToSqlBean.class)
                .end();

{code}
Bean:
{code:java}
  public  class XmlToSqlBean {
        public String toSql(@XPath(""//FinInstrmGnlAttrbts/Id"") final String isin,
                            @XPath(""//NtnlCcy"") final String currency,
                            @XPath(""//FullNm"") final String fullName,
                            @XPath(""//TradgVnRltdAttrbts/Id"") final String venue,
                            @XPath(""//ClssfctnTp"") final String classification,
                            @XPath(""//TradgVnRltdAttrbts/TermntnDt"") final String terminationDate,
                            @XPath(""//Issr"") final String issuer,
                            @XPath(""//MtrtyDt"") String maturityDate,
                            @XPath(""//TermntdRcrd"") final String termnRecord,
                            @XPath(""//NewRcrd"") final String newRecord) {

            return null;
        }
    }

{code}
davsclaus:1636678873:2021-11-12T09:01:13.815+0000:1636678873:2021-11-12T09:01:13.815+0000:Okay I found the problem is due to pre compile is enabled and that it adds to the pool even if the pool already has an element - this is due to how @XPath annotations works differently than when you use it in the route DSL
hakuseki:1636681994:2021-11-12T09:53:14.930+0000:1636681994:2021-11-12T09:53:14.930+0000:Tried to override the preCompile using configuration property but it doesn't stick
davsclaus:1636684552:2021-11-12T10:35:52.559+0000:1636684552:2021-11-12T10:35:52.559+0000:Yeah @XPath annotation does not support this configuration, you need to patch your system yourself or wait for release with fix.
hakuseki:1637884373:2021-11-26T07:52:53.132+0000:1637884373:2021-11-26T07:52:53.132+0000:Just for my curiousity, the doStop() method in XPathBuilder.class is never executed it seems. 

In that method the Queues pool and poolLogNamespaces are clear

{code:java}
@Override
    public void doStop() throws Exception {
        pool.clear();
        poolLogNamespaces.clear();
    }
{code}

Shouldn't it be called from somewhere in Camel?"
0,CAMEL-17180,Sub-task,Major,3.13.0,,"
None
",Resolved,Fixed,None,Unassigned,Karen Lease,0,1,2021-11-08 17:22:17+00:00,2022-09-03 10:36:26+00:00,"Tests using parallel multicast processing with timeouts and/or delays frequently fail on the first run when using JUnit5 parallel processing. The multicast target threads are not always scheduled to run before the timeout is exceeded.


These tests usually succeed when rerun as there is less contention.


Annotating the tests with @org.junit.jupiter.api.parallel.Isolated resolves this issue.",
0,CAMEL-17179,Sub-task,Major,3.13.0,,"
None
",Resolved,Fixed,None,Unassigned,Karen Lease,0,1,2021-11-08 17:10:08+00:00,2022-09-03 10:36:12+00:00,"The unit tests in package org.apache.camel.issues:



SplitterParallelWithAggregationStrategyThrowingExceptionTest
MulticastParallelWithAggregationStrategyThrowingExceptionTest
RecipientListParallelWithAggregationStrategyThrowingExceptionTest



often fail even after 3 tries. The tests assume that all threads to send messages have at least been scheduled before aggregate is called for the first time which stops the processing. But under heavy parallel processing, this frequently does not occur, causing the test to fail.


In fact, the test assumption seems incorrect; there is no guarantee that any multicast destination other than the one triggering the aggregation exception will be reached.
In addition, while examining the code, I found that the multicast option stopOnAggregateException has no effect. Whether or not it is used, an exception thrown in the aggregation strategy is always causes the processing to stop and the error handler to be triggered. See linked issue.",
0,CAMEL-17178,Task,Minor,3.13.0,3.14.0,"
None
",Resolved,Fixed,3.14.0,Alex Dettinger,Alex Dettinger,0,2,2021-11-08 16:33:08+00:00,2021-11-11 19:27:56+00:00,No Desc,davsclaus:1636630076:2021-11-11T19:27:56.600+0000:1636630076:2021-11-11T19:27:56.600+0000:No need to create a JIRA for doc fixes/typos etc.
0,CAMEL-17177,Task,Minor,3.13.0,Future,"

help-wanted

",Open,Unresolved,Future,Unassigned,Otavio Rodolfo Piske,0,1,2021-11-08 09:26:28+00:00,2023-08-09 09:19:29+00:00,"These methods may be candidates for moving to the repeatable tasks implemented as part of CAMEL-17121:



org.apache.camel.component.salesforce.internal.streaming.SubscriptionHelper#performClientRestart
org.apache.camel.component.salesforce.internal.streaming.SubscriptionHelper#subscribe



I don't know much about Salesforce and it may require some more effort to test. Therefore, logging and saving for later.","orpiske:1691543954:2023-08-09T09:19:14.520+0000:1691543969:2023-08-09T09:19:29.958+0000:It would be good to perform this migration, but I have no knowledge at all about Salesforce. "
0,CAMEL-17176,Test,Major,None,None,"
None
",Resolved,Fixed,3.14.0,Federico Mariani,Claus Ibsen,0,1,2021-11-06 11:02:48+00:00,2021-11-10 14:00:07+00:00,"https://ci-builds.apache.org/job/Camel/job/Camel%20JDK11/job/main/lastCompletedBuild/testReport/org.apache.camel.component.jbpm.server/CamelKieServerExtensionTest/testCreateContainer/


org.apache.camel.component.jbpm.server.CamelKieServerExtensionTest.testCreateContainer


Failing for the past 34 builds (Since #466 )
Took 1.5 sec.
Stacktrace
java.lang.IllegalArgumentException: Service 'testContainer_CamelService' not found
	at org.jbpm.services.api.service.ServiceRegistry.service(ServiceRegistry.java:95)
	at org.apache.camel.component.jbpm.server.CamelKieServerExtensionTest.testCreateContainer(CamelKieServerExtensionTest.java:90)",
0,CAMEL-17175,Improvement,Minor,None,"3.11.4, 3.14.0","
None
",Resolved,Fixed,"3.11.4, 3.14.0",Luigi De Masi,Luigi De Masi,0,1,2021-11-05 16:30:13+00:00,2021-11-11 19:26:57+00:00,"When using option ""logPhi"" with value ""false"", does not work for exceptions. When an exception arises, the PHI data is still logged on the exception, exposing sensible health data.",
0,CAMEL-17174,Bug,Minor,"3.11.3, 3.12.0","3.11.4, 3.14.0","
None
",Resolved,Fixed,"3.11.4, 3.14.0",Claus Ibsen,marc eiro,0,2,2021-11-05 16:21:57+00:00,2021-11-13 12:22:01+00:00,"In 2.x, UnitOfWorkHelper used to remove the UoW from exchange when the job was done, however this is not the case anymore in 3.x.


Exchanges now seem to reuse UoW after work completion and thus ExchangeCreatedEvents are not created as they were before.


This is causing issues on functionality that depends on such Created events, and regressions to appear.","davsclaus:1636162672:2021-11-06T09:37:52.365+0000:1636162709:2021-11-06T09:38:29.839+0000:Do you have a reproducer or something to better highlight your problem? 
I cannot reproduce this on main branch where exchange created events are emitted correctly
davsclaus:1636240162:2021-11-07T07:09:22.059+0000:1636240162:2021-11-07T07:09:22.059+0000:Are you using exchange pooling?
m4rc3iro:1636332295:2021-11-08T08:44:55.998+0000:1636332857:2021-11-08T08:54:17.144+0000:Hi Claus,

I've been looking at the GIT history for changes in the {{UnitOfWorkHelper}} class and found that in the past the UoW was being cleared correctly (you introduced the change on the 29.01.20 - [https://github.com/apache/camel/commit/e2da037e797d64e402bc6ca526d255ad112476f2):|https://github.com/apache/camel/commit/e2da037e797d64e402bc6ca526d255ad112476f2),]
{code:java}
// MUST clear and set uow to null on exchange after done
ExtendedExchange ee = (ExtendedExchange) exchange;
ee.setUnitOfWork(null); {code}
However, this change doesn't seem to exist anymore in main, it did somehow get lost with [8c2939c45f67cc84c36e8ec2973eadda95477155|https://github.com/apache/camel/commit/8c2939c45f67cc84c36e8ec2973eadda95477155]?

The issue is reproducible in one of our RetryHanlder JUnit tests, which in a nutshell does the following:
 # Defines a simple route from A to endpoint B
 # Creates an file type exchange ({{{}testExchange.setProperty(FileComponent.{*}_FILE_EXCHANGE_FILE_{*}, testFile)){}}}
 # Sets a route interceptor that on processing throws an exception
 # Sends the created exchange from A to B (using a ProducerTemplate)
 # Sends again the same exchange from A to B
 # Asserts that our RetryHandler (which basically listens for CreatedExchangeEvents) is invoked twice
m4rc3iro:1636526178:2021-11-10T14:36:18.941+0000:1636526178:2021-11-10T14:36:18.941+0000:Hi Claus, 

could you please confirm if this is an issue in the current 3.x implementation? If not, where does the UoW get cleared upon completion?

BR,
Marc
davsclaus:1636598332:2021-11-11T10:38:52.557+0000:1636598332:2021-11-11T10:38:52.557+0000:Can you attach a reproducer, eg you say you have an unit test. Can you adapt this unit test to work with main branch.
m4rc3iro:1636669424:2021-11-12T06:23:44.262+0000:1636669424:2021-11-12T06:23:44.262+0000:Hi Claus, I will try to write a unit test and push it into a branch.
m4rc3iro:1636689993:2021-11-12T12:06:33.466+0000:1636690323:2021-11-12T12:12:03.056+0000:Hi Claus, please review and approve: [https://github.com/apache/camel/pull/6432]

Do you think this could be backported to at least 3.11?"
0,CAMEL-17143,Improvement,Major,None,3.13.0,"
None
",Resolved,Fixed,3.13.0,Claus Ibsen,Claus Ibsen,0,2,2021-10-28 14:52:58+00:00,2021-10-29 13:37:31+00:00,"If a health check is DOWN, and then a check becomes success again, we could have a threshold to make it have to be N times in a row. Similar to the failure threshold.


k8s also uses this concept.",
0,CAMEL-17142,Dependency upgrade,Minor,None,None,"
None
",Resolved,Fixed,3.x,Unassigned,Claus Ibsen,0,1,2021-10-28 14:36:16+00:00,2022-09-03 10:31:26+00:00,"There are likely some newer versions which we have not upgrade to use.


Quarkus uses these


        <!-- MicroProfile TCK versions -->
        <microprofile-health-api.version>3.1</microprofile-health-api.version>
        <microprofile-config-api.version>2.0</microprofile-config-api.version>
        <microprofile-metrics-api.version>3.0</microprofile-metrics-api.version>
        <microprofile-fault-tolerance-api.version>3.0</microprofile-fault-tolerance-api.version>
        <microprofile-reactive-messaging-api.version>2.0</microprofile-reactive-messaging-api.version>
        <microprofile-rest-client-api.version>2.0</microprofile-rest-client-api.version>
        <microprofile-open-api.version>2.0.1-RC1</microprofile-open-api.version>
        <microprofile-opentracing-api.version>2.0</microprofile-opentracing-api.version>
        <microprofile-context-propagation.version>1.0.1</microprofile-context-propagation.version>
        <microprofile-jwt-api.version>1.2</microprofile-jwt-api.version>
        <microprofile-graphql-api.version>1.1.0</microprofile-graphql-api.version>",
0,CAMEL-17141,Improvement,Major,None,3.14.0,"
None
",Resolved,Fixed,3.14.0,Claus Ibsen,Claus Ibsen,0,1,2021-10-28 09:19:21+00:00,2021-11-29 11:02:08+00:00,"For health check that check http services we should have a standard field to store the http status code, so we can better know if its 200, 401, 500 etc.","davsclaus:1638153531:2021-11-29T10:38:51.104+0000:1638153546:2021-11-29T10:39:06.075+0000:    String HTTP_RESPONSE_CODE = ""http.response.code"";

Stored in error details with that key

This only is only relevant for camel components/consumers that are HTTP based - the first implemented is for camel-telegram.
davsclaus:1638154928:2021-11-29T11:02:08.492+0000:1638154928:2021-11-29T11:02:08.492+0000:To add http status code, then its a per component basis"
0,CAMEL-17140,Improvement,Major,None,3.13.0,"
None
",Resolved,Fixed,3.13.0,Claus Ibsen,Claus Ibsen,0,1,2021-10-28 08:03:26+00:00,2021-10-29 12:19:23+00:00,"When testing or the need to lookup a route health check then we should make this easier. The logic today is a bit cumbersome, with a stream of checks, etc.


        HealthCheckRegistry hcr = context.getExtension(HealthCheckRegistry.class);
        HealthCheckRepository repo = hcr.getRepository(""routes"").get();
        HealthCheck hc = repo.stream().findFirst().get();",
0,CAMEL-17139,Wish,Minor,3.11.3,,"
None
",Closed,Fixed,None,Unassigned,Tomek,0,3,2021-10-28 06:22:28+00:00,2022-01-21 16:41:48+00:00,"In my configuration I have defined both server.servlet.context-path and camel.rest.context-path properties. Part of my application.yml file:




server:
  port: 8080
  servlet:
    context-path: /camel

camel:
  rest:
    component: servlet
    context-path: /api
    binding-mode: json
    data-format-property: { prettyPrint: ""true"" }
    api-context-path: /api-doc
    api-component: openapi
    api-property: { api.title: ""Camel Component API"",
                    api.version: ""1.0.0"",
                    api.cors: ""true"" }
    api-vendor-extension: false

servlet:
  mapping:
    context-path: ${camel.rest.context-path}/*




I've checked the generated api-doc YAML and the servers/url objects contains invalid entries, for exampe:




""servers"" : [ {
    ""url"" : ""/api""
  } ],




instead of




""servers"" : [ {
    ""url"" : ""/camel/api""
  } ],




This causes issues when using Swagger UI - all endpoint URLs are invalid and I can't use the ""Try it out"" functionality for my services.","davsclaus:1635478537:2021-10-29T11:35:37.212+0000:1635478537:2021-10-29T11:35:37.212+0000:Can you put a reproducer somewhere such as attach a .zip file to this JIRA or put the example to github somewhere.

This helps to look at this quicker
Federico Mariani:1635487415:2021-10-29T14:03:35.343+0000:1635487415:2021-10-29T14:03:35.343+0000:Hi [~davsclaus], I think the issue can be tested and verified like this [https://github.com/Croway/camel-spring-boot-examples/blob/CAMEL-17139/rest-openapi/src/test/java/sample/camel/MyCamelApplicationJUnit5Test.java] .

Seems like that camel consider only `camel.rest.context-path` as basePath.
Tomasz Seweryński:1635810033:2021-11-02T07:40:33.939+0000:1635810033:2021-11-02T07:40:33.939+0000:Hi,

I've created some simple app to reproduce the issue: [^camel-openapi.zip]

^When you start the app you can call my simple REST route by the following URL: [http://localhost:8080/camel/api/simplerest/hello/John]^

^Generated Api Doc: [http://localhost:8080/camel/api/api-doc] - the element servers/0/url contains only /api and should contain /camel/api^

^Swagger UI: [http://localhost:8080/camel/swagger-ui]^

^When you try to execute my rest from the Swagger UI you can see that the endpoint there is generated as [http://localhost:8080/api/simplerest/hello/John,] so the /camel part is missing^
davsclaus:1635851676:2021-11-02T19:14:36.658+0000:1635851689:2021-11-02T19:14:49.587+0000:You should likely set

  camel.rest.context-path: /camel/api

As you cannot get the servlet context-path it has been configured with, so you need to specify this in the rest-dsl
Tomasz Seweryński:1635978962:2021-11-04T06:36:02.636+0000:1635978962:2021-11-04T06:36:02.636+0000:Hi,

We can't apply this workaround. Our application is containerized and we need all the served URLs to have specific context path. Empty server.servlet.context-path causes a lot of further problems, f.e. with Spring Security and it's default login / logout URLs etc. We also have to change actuator configuration and a lot of other settings.

I think camel-openapi-java should use both server.servlet.context-path and camel.rest.context-path - otherwise in general it ignores the server configuration, which is a bug in my opinion.
davsclaus:1635981780:2021-11-04T07:23:00.727+0000:1635981780:2021-11-04T07:23:00.727+0000:The servlet spec does not allow to get hold of any configured servlet context-path in a standard way - hence you should set this in the camel rest-dsl configuration what this path is.

serverl.servlet-context-path is a spring boot configuration, not a Camel configuration
Tomasz Seweryński:1635982222:2021-11-04T07:30:22.632+0000:1635982222:2021-11-04T07:30:22.632+0000:I think I've found a workaround that doesn't cause any further problems:
{panel:title=application.yml}
{noformat}
server:
  port: 8080
  servlet:
    context-path: /camel

camel:
  rest:
    component: servlet
    context-path: ${server.servlet.context-path}/api
    data-format-property: { prettyPrint: ""true"" }
    api-context-path: /api-doc
    api-component: openapi
    api-property: { api.title: ""Camel Component API"",
                    api.version: ""1.0.0"",
                    api.cors: ""true""}
    api-vendor-extension: false
  servlet:
    mapping:
      context-path: /api/*

springdoc:
  swagger-ui:
    url: ${camel.rest.context-path}${camel.rest.api-context-path}
    path: /swagger-ui{noformat}
{panel}
Tomasz Seweryński:1635982527:2021-11-04T07:35:27.998+0000:1635982527:2021-11-04T07:35:27.998+0000:Closing this ticket as the workaround works"
0,CAMEL-17138,Improvement,Major,None,None,"
None
",Resolved,Fixed,3.13.0,Unassigned,Antonin Stefanutti,0,2,2021-10-27 10:03:00+00:00,2021-10-28 14:33:59+00:00,"The org.apache.camel.health.HealthCheck.Result interface exposes the Optional<Throwable> getError() method, that provides the exception information that may explain the health check result.


This can prove very useful information for users. However, it is not propagated to the MicroProfile Health response org.eclipse.microprofile.health.HealthCheckResponse, that's converted from the Camel health check result.


If the optional error is present, it should be propagated and accessible from the Optional<Map<String, Object>> HealthCheckResponse.getData() API.


Other details could also be propagated.","Federico Mariani:1635383177:2021-10-28T09:06:17.616+0000:1635383177:2021-10-28T09:06:17.616+0000:Hi, I created this POC [https://github.com/apache/camel/compare/main...Croway:CAMEL-17138?expand=1,] in order to use getData() API I had to drop the builder and use HealthCheckResponse directly. I don't fully understand how and when errors are added to Result.getError(). I couldn't reproduce any error when testing. WDYT? 
antonin.stefanutti:1635385148:2021-10-28T09:39:08.349+0000:1635385148:2021-10-28T09:39:08.349+0000:[~Federico Mariani] awesome! It looks good. My understanding is that only few use cases populate the error at the moment, mainly when an exception occurs while a route starts: https://github.com/apache/camel/blob/617e150d1d6ac6c453fbb0239960c1c5b3f1a46d/core/camel-base-engine/src/main/java/org/apache/camel/impl/engine/AbstractCamelContext.java#L1209.

Populating the error for a larger set of cases should be addressed within the scope of the following issues:

* CAMEL-16975
* CAMEL-16976
* CAMEL-16977

Federico Mariani:1635391039:2021-10-28T11:17:19.662+0000:1635391039:2021-10-28T11:17:19.662+0000:Hi [~antonin.stefanutti] I opened the PR https://github.com/apache/camel/pull/6351, I just added simple assertions that verify additional details, too bad I couldn't reproduce any exception during startup."
0,CAMEL-17137,Bug,Minor,"3.11.3, 3.12.0","3.11.6, 3.14.1, 3.15.0","
None
",Resolved,Fixed,"3.11.6, 3.14.1, 3.15.0",Unassigned,Kiryanov Vlad,0,5,2021-10-27 09:20:23+00:00,2022-02-18 14:03:09+00:00,"Hello!


In Karaf 4.3.2 while add camel-cxf an error occurs


2021-10-27T11:59:22,050 | ERROR | Karaf local console user karaf | ShellUtil | 43 - org.apache.karaf.shell.core - 4.3.2 | Exception caught while executing command
org.apache.felix.resolver.reason.ReasonException: Unable to resolve root: missing requirement [root] osgi.identity; osgi.identity=camel-cxf; type=karaf.feature; version=""[3.11.3,3.11.3]""; filter:=""(&(osgi.identity=camel-cxf)(type=karaf.feature)(version>=3.11.3)(version<=3.11.3))"" [caused by: Unable to resolve camel-cxf/3.11.3: missing requirement [camel-cxf/3.11.3] osgi.identity; osgi.identity=cxf-core; type=karaf.feature; version=""[3.3.0,4.0.0)""]
 at org.apache.felix.resolver.Candidates$MissingRequirementError.toException(Candidates.java:1341) ~[?:?]
 at org.apache.felix.resolver.ResolverImpl.doResolve(ResolverImpl.java:433) ~[?:?]
 at org.apache.felix.resolver.ResolverImpl.resolve(ResolverImpl.java:420) ~[?:?]
 at org.apache.felix.resolver.ResolverImpl.resolve(ResolverImpl.java:374) ~[?:?]
 at org.apache.karaf.features.internal.region.SubsystemResolver.resolve(SubsystemResolver.java:257) ~[?:?]
 at org.apache.karaf.features.internal.service.Deployer.deploy(Deployer.java:399) ~[?:?]
 at org.apache.karaf.features.internal.service.FeaturesServiceImpl.doProvision(FeaturesServiceImpl.java:1069) ~[?:?]
 at org.apache.karaf.features.internal.service.FeaturesServiceImpl.lambda$doProvisionInThread$13(FeaturesServiceImpl.java:1004) ~[?:?]
 at java.util.concurrent.FutureTask.run(FutureTask.java:264) ~[?:?]
 at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128) ~[?:?]
 at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628) ~[?:?]
 at java.lang.Thread.run(Thread.java:834) [?:?]
Caused by: org.apache.felix.resolver.reason.ReasonException: Unable to resolve camel-cxf/3.11.3: missing requirement [camel-cxf/3.11.3] osgi.identity; osgi.identity=cxf-core; type=karaf.feature; version=""[3.3.0,4.0.0)""
 at org.apache.felix.resolver.Candidates$MissingRequirementError.toException(Candidates.java:1341) ~[?:?]
 ... 12 more","davsclaus:1635308255:2021-10-27T12:17:35.324+0000:1635308255:2021-10-27T12:17:35.324+0000:You mean you do

feature:install camel-cxf

In a vanilla Karaf 4.3.2

And then it fails with some kind of error?

It seems to complain about CXF itself. You can try to install CXF first, and then camel-cxf afterwards
vladk:1635310125:2021-10-27T12:48:45.096+0000:1635310125:2021-10-27T12:48:45.096+0000:Yes.

I do in karaf console:

repo-add camel 3.11.3

feature:install camel

feature:install camel-cxf

and get error

I try add cxf and get error

karaf@root()> feature:install cxf
Error executing command: No matching features for cxf/0

I try to list all cxf components

karaf@root()> feature:list | grep cxf
camel-cxf │ 3.11.3 │ │ Uninstalled │ camel-3.11.3 │

---------

I try in camel 3.11.0 and get list cxf components

karaf@root()> feature:list | grep cxf
...
...
cxf │ 3.5.0.SNAPSHOT │ │ Uninstalled │ cxf-3.5.0-SNAPSHOT
cxf-sts │ 3.5.0.SNAPSHOT │ │ Uninstalled │ cxf-3.5.0-SNAPSHOT
cxf-wsn-api │ 3.5.0.SNAPSHOT │ │ Uninstalled │ cxf-3.5.0-SNAPSHOT
cxf-wsn │ 3.5.0.SNAPSHOT │ │ Uninstalled │ cxf-3.5.0-SNAPSHOT
cxf-ws-discovery-api │ 3.5.0.SNAPSHOT │ │ Uninstalled │ cxf-3.5.0-SNAPSHOT
cxf-ws-discovery │ 3.5.0.SNAPSHOT │ │ Uninstalled │ cxf-3.5.0-SNAPSHOT
cxf-bean-validation-core │ 3.5.0.SNAPSHOT │ │ Uninstalled │ cxf-3.5.0-SNAPSHOT
cxf-bean-validation │ 3.5.0.SNAPSHOT │ │ Uninstalled │ cxf-3.5.0-SNAPSHOT
cxf-jaxrs-cdi │ 3.5.0.SNAPSHOT │ │ Uninstalled │ cxf-3.5.0-SNAPSHOT
camel-cxf │ 3.11.0 │ x │ Started │ camel-3.11.0

 
davsclaus:1635478682:2021-10-29T11:38:02.084+0000:1635478682:2021-10-29T11:38:02.084+0000:Reproduced this with

{code}
karaf@root()> feature:repo-add camel 3.11.3
Adding feature url mvn:org.apache.camel.karaf/apache-camel/3.11.3/xml/features
karaf@root()> feature:install camel
karaf@root()> feature:install camel-cxf
org.apache.felix.resolver.reason.ReasonException: Unable to resolve root: missing requirement [root] osgi.identity; osgi.identity=camel-cxf; type=karaf.feature; version=""[3.11.3,3.11.3]""; filter:=""(&(osgi.identity=camel-cxf)(type=karaf.feature)(version>=3.11.3)(version<=3.11.3))"" [caused by: Unable to resolve camel-cxf/3.11.3: missing requirement [camel-cxf/3.11.3] osgi.identity; osgi.identity=cxf-core; type=karaf.feature; version=""[3.3.0,4.0.0)""]
	at org.apache.felix.resolver.Candidates$MissingRequirementError.toException(Candidates.java:1341)
	at org.apache.felix.resolver.ResolverImpl.doResolve(ResolverImpl.java:433)
	at org.apache.felix.resolver.ResolverImpl.resolve(ResolverImpl.java:420)
	at org.apache.felix.resolver.ResolverImpl.resolve(ResolverImpl.java:374)
	at org.apache.karaf.features.internal.region.SubsystemResolver.resolve(SubsystemResolver.java:257)
	at org.apache.karaf.features.internal.service.Deployer.deploy(Deployer.java:399)
	at org.apache.karaf.features.internal.service.FeaturesServiceImpl.doProvision(FeaturesServiceImpl.java:1069)
	at org.apache.karaf.features.internal.service.FeaturesServiceImpl.lambda$doProvisionInThread$13(FeaturesServiceImpl.java:1004)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)
	at java.base/java.lang.Thread.run(Thread.java:834)
Caused by: org.apache.felix.resolver.reason.ReasonException: Unable to resolve camel-cxf/3.11.3: missing requirement [camel-cxf/3.11.3] osgi.identity; osgi.identity=cxf-core; type=karaf.feature; version=""[3.3.0,4.0.0)""
	at org.apache.felix.resolver.Candidates$MissingRequirementError.toException(Candidates.java:1341)
	... 12 more
Error executing command: Unable to resolve root: missing requirement [root] osgi.identity; osgi.identity=camel-cxf; type=karaf.feature; version=""[3.11.3,3.11.3]""; filter:=""(&(osgi.identity=camel-cxf)(type=karaf.feature)(version>=3.11.3)(version<=3.11.3))"" [caused by: Unable to resolve camel-cxf/3.11.3: missing requirement [camel-cxf/3.11.3] osgi.identity; osgi.identity=cxf-core; type=karaf.feature; version=""[3.3.0,4.0.0)""]
karaf@root()>
{code}
davsclaus:1635478845:2021-10-29T11:40:45.293+0000:1635478845:2021-10-29T11:40:45.293+0000:Its like this commit causing this
https://github.com/apache/camel-karaf/commit/ed4ba2a967c67a073786390b837e7fabb6bb1ad0
davsclaus:1635478855:2021-10-29T11:40:55.676+0000:1635478855:2021-10-29T11:40:55.676+0000:It also fails with 3.12.0

{code}
karaf@root()> feature:repo-add camel 3.12.0
Adding feature url mvn:org.apache.camel.karaf/apache-camel/3.12.0/xml/features
karaf@root()> feature:install camel
karaf@root()> feature:install camel-cxf
org.apache.felix.resolver.reason.ReasonException: Unable to resolve root: missing requirement [root] osgi.identity; osgi.identity=camel-cxf; type=karaf.feature; version=""[3.12.0,3.12.0]""; filter:=""(&(osgi.identity=camel-cxf)(type=karaf.feature)(version>=3.12.0)(version<=3.12.0))"" [caused by: Unable to resolve camel-cxf/3.12.0: missing requirement [camel-cxf/3.12.0] osgi.identity; osgi.identity=cxf-core; type=karaf.feature; version=""[3.3.0,4.0.0)""]
	at org.apache.felix.resolver.Candidates$MissingRequirementError.toException(Candidates.java:1341)
	at org.apache.felix.resolver.ResolverImpl.doResolve(ResolverImpl.java:433)
	at org.apache.felix.resolver.ResolverImpl.resolve(ResolverImpl.java:420)
	at org.apache.felix.resolver.ResolverImpl.resolve(ResolverImpl.java:374)
	at org.apache.karaf.features.internal.region.SubsystemResolver.resolve(SubsystemResolver.java:257)
	at org.apache.karaf.features.internal.service.Deployer.deploy(Deployer.java:399)
	at org.apache.karaf.features.internal.service.FeaturesServiceImpl.doProvision(FeaturesServiceImpl.java:1069)
	at org.apache.karaf.features.internal.service.FeaturesServiceImpl.lambda$doProvisionInThread$13(FeaturesServiceImpl.java:1004)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)
	at java.base/java.lang.Thread.run(Thread.java:834)
Caused by: org.apache.felix.resolver.reason.ReasonException: Unable to resolve camel-cxf/3.12.0: missing requirement [camel-cxf/3.12.0] osgi.identity; osgi.identity=cxf-core; type=karaf.feature; version=""[3.3.0,4.0.0)""
	at org.apache.felix.resolver.Candidates$MissingRequirementError.toException(Candidates.java:1341)
	... 12 more
Error executing command: Unable to resolve root: missing requirement [root] osgi.identity; osgi.identity=camel-cxf; type=karaf.feature; version=""[3.12.0,3.12.0]""; filter:=""(&(osgi.identity=camel-cxf)(type=karaf.feature)(version>=3.12.0)(version<=3.12.0))"" [caused by: Unable to resolve camel-cxf/3.12.0: missing requirement [camel-cxf/3.12.0] osgi.identity; osgi.identity=cxf-core; type=karaf.feature; version=""[3.3.0,4.0.0)""]
{code}
davsclaus:1635479099:2021-10-29T11:44:59.040+0000:1635479099:2021-10-29T11:44:59.040+0000:Yes reverting that commit and then it works again

{code}
karaf@root()> feature:repo-add camel 3.13.0-SNAPSHOT
Adding feature url mvn:org.apache.camel.karaf/apache-camel/3.13.0-SNAPSHOT/xml/features
karaf@root()> feature:install camel
karaf@root()> feature:install camel-cxf
karaf@root()>
{code}
vjk001:1641941367:2022-01-12T06:49:27.806+0000:1641941367:2022-01-12T06:49:27.806+0000:[~davsclaus] It appears that using the exact steps above again reproduces the CXF issue, at least in 3.11.4. The CXF feature is resolved from a range mvn:org.apache.cxf.karaf/apache-cxf/[3,4)/xml/features and due to how the range is resolved (snapshot pre-release versions of the upper limit are included in the range), it now points to 4.0.0.SNAPSHOT which doesn't work instead of 3.5.0.SNAPSHOT which works.

Do we really want to use any upstream CXF version within the range instead of specifying the Camel-compatible version explicitly? If so, the upper range limit issue remains. 

 
davsclaus:1641942075:2022-01-12T07:01:15.088+0000:1641942075:2022-01-12T07:01:15.088+0000:That is a karaf bug/issue if it include a 4.x when the bound is set as [3,4) which should mean anything with 3.x.

But yeah the bound should be the version we build with, eg 3.4.x or 3.5.x like anything else.
vjk001:1641942936:2022-01-12T07:15:36.345+0000:1641942936:2022-01-12T07:15:36.345+0000:The range resolve logic comes directly from Maven: [https://michakutz.medium.com/legit-but-useless-maven-version-ranges-explained-d4ba66ac654]

 
davsclaus:1641947104:2022-01-12T08:25:04.778+0000:1641947104:2022-01-12T08:25:04.778+0000:You can install the CXF version you want to use first - there are cxf features for karaf.

For Camel 3.15 onwards we will set the camel version range more strict in the camel-cxf bundle
raminxp@hotmail.com:1642053968:2022-01-13T14:06:08.828+0000:1642053987:2022-01-13T14:06:27.871+0000:[~davsclaus] After the above revert, it is now failing for us in our custom karaf distribution (camel 3.11.5):
{noformat}
[WARNING] Error resolving artifact org.apache.cxf.karaf:apache-cxf:xml:features:4.0.0-SNAPSHOT: [Could not find artifact org.apache.cxf.karaf:apache-cxf:xml:features:4.0.0-SNAPSHOT in central (https://repo1.maven.org/maven2/), Could not find artifact org.apache.cxf.karaf:apache-cxf:xml:features:4.0.0-SNAPSHOT in jboss public maven repo (https://repository.jboss.org/nexus/content/groups/public-jboss/), Could not find artifact org.apache.cxf.karaf:apache-cxf:xml:features:4.0.0-SNAPSHOT in jboss-ea-repository-group (https://repository.jboss.org/nexus/content/groups/ea/)]
java.io.IOException: Error resolving artifact org.apache.cxf.karaf:apache-cxf:xml:features:4.0.0-SNAPSHOT: [Could not find artifact org.apache.cxf.karaf:apache-cxf:xml:features:4.0.0-SNAPSHOT in central (https://repo1.maven.org/maven2/), Could not find artifact org.apache.cxf.karaf:apache-cxf:xml:features:4.0.0-SNAPSHOT in jboss public maven repo (https://repository.jboss.org/nexus/content/groups/public-jboss/), Could not find artifact org.apache.cxf.karaf:apache-cxf:xml:features:4.0.0-SNAPSHOT in jboss-ea-repository-group (https://repository.jboss.org/nexus/content/groups/ea/)]
    at org.ops4j.pax.url.mvn.internal.AetherBasedResolver.configureIOException (AetherBasedResolver.java:803)
    at org.ops4j.pax.url.mvn.internal.AetherBasedResolver.resolve (AetherBasedResolver.java:774)
    at org.ops4j.pax.url.mvn.internal.AetherBasedResolver.resolve (AetherBasedResolver.java:657)
    at org.ops4j.pax.url.mvn.internal.AetherBasedResolver.resolve (AetherBasedResolver.java:598)
    at org.ops4j.pax.url.mvn.internal.AetherBasedResolver.resolve (AetherBasedResolver.java:565)
    at org.apache.karaf.tooling.utils.ReactorMavenResolver.resolve (ReactorMavenResolver.java:63)
    at org.apache.karaf.features.internal.download.impl.MavenDownloadTask.download (MavenDownloadTask.java:52)
    at org.apache.karaf.features.internal.download.impl.AbstractRetryableDownloadTask.run (AbstractRetryableDownloadTask.java:60)
    at java.util.concurrent.Executors$RunnableAdapter.call (Executors.java:511)
    at java.util.concurrent.FutureTask.run (FutureTask.java:266)
    at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201 (ScheduledThreadPoolExecutor.java:180)
    at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run (ScheduledThreadPoolExecutor.java:293)
    at java.util.concurrent.ThreadPoolExecutor.runWorker (ThreadPoolExecutor.java:1149)
    at java.util.concurrent.ThreadPoolExecutor$Worker.run (ThreadPoolExecutor.java:624)
    at java.lang.Thread.run (Thread.java:748)
Caused by: shaded.org.eclipse.aether.resolution.ArtifactResolutionException: Error resolving artifact org.apache.cxf.karaf:apache-cxf:xml:features:4.0.0-SNAPSHOT
    at shaded.org.eclipse.aether.internal.impl.DefaultArtifactResolver.resolve (DefaultArtifactResolver.java:413)
    at shaded.org.eclipse.aether.internal.impl.DefaultArtifactResolver.resolveArtifacts (DefaultArtifactResolver.java:215)
    at shaded.org.eclipse.aether.internal.impl.DefaultArtifactResolver.resolveArtifact (DefaultArtifactResolver.java:192)
    at shaded.org.eclipse.aether.internal.impl.DefaultRepositorySystem.resolveArtifact (DefaultRepositorySystem.java:247)
    at org.ops4j.pax.url.mvn.internal.AetherBasedResolver.resolve (AetherBasedResolver.java:767)
    at org.ops4j.pax.url.mvn.internal.AetherBasedResolver.resolve (AetherBasedResolver.java:657)
    at org.ops4j.pax.url.mvn.internal.AetherBasedResolver.resolve (AetherBasedResolver.java:598)
    at org.ops4j.pax.url.mvn.internal.AetherBasedResolver.resolve (AetherBasedResolver.java:565)
    at org.apache.karaf.tooling.utils.ReactorMavenResolver.resolve (ReactorMavenResolver.java:63)
    at org.apache.karaf.features.internal.download.impl.MavenDownloadTask.download (MavenDownloadTask.java:52)
    at org.apache.karaf.features.internal.download.impl.AbstractRetryableDownloadTask.run (AbstractRetryableDownloadTask.java:60)
    at java.util.concurrent.Executors$RunnableAdapter.call (Executors.java:511)
    at java.util.concurrent.FutureTask.run (FutureTask.java:266)
    at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201 (ScheduledThreadPoolExecutor.java:180)
    at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run (ScheduledThreadPoolExecutor.java:293)
    at java.util.concurrent.ThreadPoolExecutor.runWorker (ThreadPoolExecutor.java:1149)
    at java.util.concurrent.ThreadPoolExecutor$Worker.run (ThreadPoolExecutor.java:624)
    at java.lang.Thread.run (Thread.java:748)
[WARNING] Matched URI can't use version ranges: mvn:org.apache.cxf.karaf/apache-cxf/[3,4)/xml/features{noformat}
It was initially us who asked for the now reverted commit. (spoken to @ Jean-Baptiste Onofré)
davsclaus:1642058612:2022-01-13T15:23:32.972+0000:1642058612:2022-01-13T15:23:32.972+0000:It smells like you have repo to download from apache snapshot or something since maven can find 4.0.0-SNAPSHOT
davsclaus:1642059745:2022-01-13T15:42:25.144+0000:1642059745:2022-01-13T15:42:25.144+0000:The 4.0.0-SNAPSHOT is at apache snapshot repo
https://repository.apache.org/content/repositories/snapshots/org/apache/cxf/cxf-rt-features/4.0.0-SNAPSHOT/

So remove this repo from your karaf distro
raminxp@hotmail.com:1642060698:2022-01-13T15:58:18.367+0000:1642060698:2022-01-13T15:58:18.367+0000:Thank you [~davsclaus], that was exactly it. Removed the apache repository and it's working now. I think this will solve [~vjk001]'s issue too
davsclaus:1642060924:2022-01-13T16:02:04.268+0000:1642060924:2022-01-13T16:02:04.268+0000:We are backporting the strict version range to 3.11 LTS and 3.14 LTS branches.
davsclaus:1642062392:2022-01-13T16:26:32.277+0000:1642067020:2022-01-13T17:43:40.934+0000:3.11 LTS *DONE*
3.14 LTS *DONE*
rastislav.papp:1645161489:2022-02-18T13:18:09.521+0000:1645164189:2022-02-18T14:03:09.653+0000:This works when installing manually, but not when creating custom karaf-assembly (based on 4.3.6, via maven plugin). We create one with boot features from camel/3.14.1 and cxf/3.4.5, but karaf fails with:

{code}
org.apache.felix.resolver.reason.ReasonException: Unable to resolve com.sun.xml.messaging.saaj.impl/1.5.2: missing requirement [com.sun.xml.messaging.saaj.impl/1.5.2] osgi.wiring.package; filter:=""(&(osgi.wiring.package=org.jvnet.staxex)(version>=1.8.0)(!(version>=2.0.0)))""
	at org.apache.felix.resolver.Candidates$MissingRequirementError.toException(Candidates.java:1341) ~[?:?]
{code}

This is because camel-cxf 3.14.1 depends on a cxf feature using range [3.4,3.4], and somehow karaf tries to install it during boot stage, even though we define our own cxf repository+feature versions. It ends up installing cxf version 3.4.0. 

In the past we could blacklist camel's cxf feature in karaf, but now that it is defined via range, the blacklisting stopped working:

{code}
2022-02-18T13:57:35,135 | WARN  | activator-1-thread-2 |  | org.apache.karaf.features.core - 4.3.6 | LocationPattern                  |  | Matched URI can't use version ranges: mvn:org.apache.cxf.karaf/apache-cxf/[3.4,3.4]/xml/features
{code}
{code:java}
        if (other.versionRange != null) {
            LOG.warn(""Matched URI can't use version ranges: "" + otherUri);
            return false;
        }
{code}

Only solution for us is to create custom camel feature, by copying the real one, and deleting the cxf repository dependency.

cc: [~davsclaus], [~jbonofre]


furthermore, I'm not sure about the version range itself, does [3.4, 3.4] mean the same as [3.4, 3.5)? Because after creating the custom feature, it seems that camel-cxf-transport bundle requires cxf-core/3.4.0 exactly, and fails when having cxf-core/3.4.5:
{code}
Caused by: org.apache.felix.resolver.reason.ReasonException: Unable to resolve org.apache.camel.camel-cxf-transport/3.14.1: missing requirement [org.apache.camel.camel-cxf-transport/3.14.1] osgi.wiring.package; filter:=""(&(osgi.wiring.package=org.apache.cxf)(version>=3.4.0)(version<=3.4.0))""
{code}"
0,CAMEL-17136,Dependency upgrade,Major,None,None,"
None
",Resolved,Implemented,"4.0-M1, 4.0.0",Unassigned,Claus Ibsen,3,6,2021-10-27 06:54:39+00:00,2023-01-30 08:59:48+00:00,"After the 3.14.x LTS release and when we drop Java 8, then it would be a good time to migrate to Jakarta EE APIs.


We should look at Spring Boot and Quarkus if they are supporting these newer APIs as well or not. And then align when they are ready.","vbychkov:1645680726:2022-02-24T13:32:06.657+0000:1645680726:2022-02-24T13:32:06.657+0000:Updating to Jakarta EE 8 seems not a big Probem. But man usable software products are not yet compatible with Jakarta EE 9/9.1. For example ActiveMQ has limited support of JEE 9 (now only [ActiveMQ Artemis Jakarta Client|https://blogs.apache.org/activemq/entry/activemq-artemis-embraces-jakarta-ee]). Spring Framework [declares support|https://spring.io/blog/2021/09/02/a-java-17-and-jakarta-ee-9-baseline-for-spring-framework-6] in Version 6.
Jetty supports JEE 9 starting with [Version 11|https://containerjournal.com/features/jetty-project-embraces-jakarta-ee-9-specification/], but in Jett 10 Continuation support was removed. Continuation is used for example in [camel-jetty-common|https://github.com/apache/camel/blob/main/components/camel-jetty-common/src/main/java/org/apache/camel/component/jetty/CamelContinuationServlet.java#L165].
So, updating to Jakarta EE 9 seems (in common) impossible, but to Jakarta EE 8 -- I want do this, if you have nothing against.
vbychkov:1646893014:2022-03-10T14:16:54.917+0000:1646893014:2022-03-10T14:16:54.917+0000:[Pull request|https://github.com/apache/camel/pull/7116] with Jakarta EE 8 changes
vbychkov:1664381023:2022-09-29T00:03:43.879+0000:1664381023:2022-09-29T00:03:43.879+0000:As changes of this issue are delayed, migration to Jakarta EE 9.1 is performing within separate fork [apache-camel-jakarta-ee|https://github.com/bvfalcon/apache-camel-jakarta-ee].
davsclaus:1673843003:2023-01-16T12:23:23.178+0000:1673843003:2023-01-16T12:23:23.178+0000:Camel v4 will be Jakarta EE"
0,CAMEL-17135,Bug,Major,3.11.3,"3.13.0, 3.11.4","
None
",Resolved,Fixed,"3.13.0, 3.11.4",Claus Ibsen,Andrii Melashchenko,1,3,2021-10-26 19:15:18+00:00,2022-09-02 07:00:47+00:00,"When trying to build simple route


from(""debezium-mongodb:meteor"")


with spring-boot properties


```


camel.component.debezium-mongodb.mongodb-hosts=localhost:3001camel.component.debezium-mongodb.mongodb-user=testcamel.component.debezium-mongodb.mongodb-password=testcamel.component.debezium-mongodb.mongodb-name=testcamel.component.debezium-mongodb.offset-storage-file-filename=/tmp/offset-file-1.datcamel.component.debezium-mongodb.database-history-file-filename=/tmp/history-file-1.dat


```
Route fails with error 
```
Required field 'offsetStorageFileName' must be set since 'offsetStorage' is set to
```","davsclaus:1635282661:2021-10-27T05:11:01.784+0000:1635282661:2021-10-27T05:11:01.784+0000:Can you put a reproducer somewhere, either attach a .zip file to this JIRA or put a project out on github etc.
IronAlan:1635294087:2021-10-27T08:21:27.309+0000:1635294087:2021-10-27T08:21:27.309+0000:[~davsclaus] Please use this one [https://github.com/javatask/camel-debezium-spring-boot] 

I used Camel Maven Archetype with simplest possible Route
davsclaus:1635550985:2021-10-30T07:43:05.950+0000:1635550985:2021-10-30T07:43:05.950+0000:Your example is using camel 3.9.0, use the latest release 3.12.0
davsclaus:1635552719:2021-10-30T08:11:59.984+0000:1635552719:2021-10-30T08:11:59.984+0000:The option is named

camel.component.debezium-mongodb.offset-storage-filename=/tmp/offset-file-1.dat

But there is still a little bug in the component so the option is not set
IronAlan:1635553239:2021-10-30T08:20:39.133+0000:1635553239:2021-10-30T08:20:39.133+0000:Much appreciated your feedback. 
I hope it will be fixed in the next releases.
davsclaus:1635553698:2021-10-30T08:28:18.977+0000:1635553698:2021-10-30T08:28:18.977+0000:Thanks for reporting
michael992:1661316718:2022-08-24T12:51:58.597+0000:1661317609:2022-08-24T13:06:49.988+0000:It is not fixed using 3.12.0 and worse than that the component doesn't work since 3.13.0 modifications check this for more informations https://issues.apache.org/jira/browse/CAMEL-18427"
0,CAMEL-17134,Bug,Minor,"3.9.0, 3.12.0",,"
None
",Resolved,Duplicate,None,Unassigned,Hack Kampbjørn,0,1,2021-10-26 15:07:40+00:00,2021-10-26 15:37:55+00:00,"With the changes in 3.9.0 to unit of work, MDCUnitOfWork no longer clears MDC after an exchange is done.


steps to reproduce


Enable MDC logging and send a message


actual


After the exchange is completed, MDC still contains camel details like camel correlation ID


expected


That MDC is cleared after an exchange is completed


See https://bitbucket.org/worldticket/camel-mdc-logging/src/trunk/",
0,CAMEL-17133,New Feature,Major,3.12.0,3.13.0,"
None
",Resolved,Fixed,3.13.0,Unassigned,Alexey Markevich,0,2,2021-10-26 14:33:46+00:00,2022-01-09 08:41:33+00:00,"Allow to set 'triggerStartDelay' in the past to have misfire execution for cron triggers.


Existing 'fireNow' can be avoided due to new Trigger already have 'startAt' 'now'.",davsclaus:1635308146:2021-10-27T12:15:46.098+0000:1635308146:2021-10-27T12:15:46.098+0000:Thanks for the PR
0,CAMEL-17132,Bug,Minor,3.12.0,,"
None
",Closed,Invalid,None,Unassigned,Vaibhav Srivastava,0,3,2021-10-26 13:13:05+00:00,2021-10-27 07:51:04+00:00,"Hi, 


So I needed to have routes templates defined in an XML file to be discovered from camel so I'd have routes templates available to me for creation of dynamic routes on the go.


For this I used 
camel.springboot.routes-include-pattern : classpath:routes/.xml*. I even tried pushing the xml routes templates file into a folder called :


classpath:camel-template/* but didn't get a successful scenario.


These routes were picked up if you test the logic using cucumber tests , they caused problems when we deploy the jar locally .


I kept getting error: unable to find route-template : my-route-template-name.


Finally I got them to work when I added each file exact file name like this:


camel.springboot.routes-include-pattern : classpath:routes/route-template_file1.xml,classpath:routes_templates/route-template_file2.xml **


I tried with these two files in the same folder and tried to reference it using 
classpath:routes/.xml* but didn't work and they were not getting picked up.","acosentino:1635225344:2021-10-26T13:15:44.185+0000:1635225344:2021-10-26T13:15:44.185+0000:First ask on the user mailing list or dev mailing list.
davsclaus:1635292264:2021-10-27T07:51:04.951+0000:1635292264:2021-10-27T07:51:04.951+0000:We updated our example and cannot reproduce this
https://github.com/apache/camel-spring-boot-examples/commit/8d59dfd6ea0af2f2b8f0fd56962f30261641c48a"
0,CAMEL-17131,Bug,Minor,3.11.1,"3.11.4, 3.14.0","
None
",Resolved,Fixed,"3.11.4, 3.14.0",Otavio Rodolfo Piske,Xilai Dai,0,3,2021-10-26 10:01:47+00:00,2021-11-16 09:02:58+00:00,"When using camel-kafka receiving messages, InstanceAlreadyExistsException is thrown in registerAppInfo().




[thread #0 - KafkaConsumer[abc]] AppInfoParser                  WARN  Error registering AppInfo mbean
javax.management.InstanceAlreadyExistsException: kafka.consumer:type=app-info,id=789
        at java.management/com.sun.jmx.mbeanserver.Repository.addMBean(Repository.java:436)
        at java.management/com.sun.jmx.interceptor.DefaultMBeanServerInterceptor.registerWithRepository(DefaultMBeanServerInterceptor.java:1855)
        at java.management/com.sun.jmx.interceptor.DefaultMBeanServerInterceptor.registerDynamicMBean(DefaultMBeanServerInterceptor.java:955)
        at java.management/com.sun.jmx.interceptor.DefaultMBeanServerInterceptor.registerObject(DefaultMBeanServerInterceptor.java:890)
        at java.management/com.sun.jmx.interceptor.DefaultMBeanServerInterceptor.registerMBean(DefaultMBeanServerInterceptor.java:320)
        at java.management/com.sun.jmx.mbeanserver.JmxMBeanServer.registerMBean(JmxMBeanServer.java:522)
        at org.apache.kafka.common.utils.AppInfoParser.registerAppInfo(AppInfoParser.java:64)
        at org.apache.kafka.clients.consumer.KafkaConsumer.<init>(KafkaConsumer.java:814)
        at org.apache.kafka.clients.consumer.KafkaConsumer.<init>(KafkaConsumer.java:665)
        at org.apache.kafka.clients.consumer.KafkaConsumer.<init>(KafkaConsumer.java:646)
        at org.apache.kafka.clients.consumer.KafkaConsumer.<init>(KafkaConsumer.java:626)
        at org.apache.camel.component.kafka.DefaultKafkaClientFactory.getConsumer(DefaultKafkaClientFactory.java:34)
        at org.apache.camel.component.kafka.KafkaConsumer$KafkaFetchRecords.doInit(KafkaConsumer.java:267)
        at org.apache.camel.component.kafka.KafkaConsumer$KafkaFetchRecords.run(KafkaConsumer.java:215)
        at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)
        at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
        at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)
        at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)
        at java.base/java.lang.Thread.run(Thread.java:834)




Attached project test-kafka.zip for quickly reproduce this issue.


Note that there was no this kind of issue on Camel-kafka 2.24.x.","davsclaus:1635216507:2021-10-26T10:48:27.060+0000:1635216507:2021-10-26T10:48:27.060+0000:This MBean is not a Camel MBean but a Kafka MBean. 
davsclaus:1636784593:2021-11-13T14:23:13.275+0000:1636784593:2021-11-13T14:23:13.275+0000:[~orpiske] okay so it looks like the KafkaConsumer is created twice, as part of preInit, and then on 1st run because of retry = true and reconnect = true.

And because JMX is present and this example uses a hardcoded clientId then we have the JMX ObjectName clash.
davsclaus:1636785179:2021-11-13T14:32:59.263+0000:1636785179:2021-11-13T14:32:59.263+0000:Also on the initial pool due to state of either in retry or reconnect in KafkaFetchRecords then the INFO logging is

15:25:55.715 [Camel (camel-1) thread #1 - KafkaConsumer[abc]] INFO  o.a.c.c.kafka.KafkaFetchRecords - Retrying abc-Thread 0 to topic abc after 5000 ms

Since this is the 1st fetch, then saying Retrying is not entirely accurate. Maybe we can have a flag to determine the state is first fetch and then log

15:25:55.715 [Camel (camel-1) thread #1 - KafkaConsumer[abc]] INFO  o.a.c.c.kafka.KafkaFetchRecords - Consuming abc-Thread 0 from topic abc

And maybe we can make it DEBUG logging level as this is normal operation. The retry / reconnect logic is fine to have noisy logging at INFO so end users can notice that there has been some network connectivity problems and that Camel is re-establishing.
orpiske:1636785410:2021-11-13T14:36:50.493+0000:1636785410:2021-11-13T14:36:50.493+0000:I am under the impression that this has been happening prior to the refactoring as well. When I started on it I noticed that we were initializing the consumer prior to the starting the thread (1) (2). Then, when we started the thread, during the first execution, we re-initialized it again (3). I think we need to fix this for 3.14. Feel free to assign to me and I will take a look.

 
 # [https://github.com/apache/camel/blob/camel-3.7.6/components/camel-kafka/src/main/java/org/apache/camel/component/kafka/KafkaConsumer.java#L139]
 # [https://github.com/apache/camel/blob/camel-3.7.6/components/camel-kafka/src/main/java/org/apache/camel/component/kafka/KafkaConsumer.java#L228-L246]
 # [https://github.com/apache/camel/blob/camel-3.7.6/components/camel-kafka/src/main/java/org/apache/camel/component/kafka/KafkaConsumer.java#L191-L218]
davsclaus:1636785422:2021-11-13T14:37:02.425+0000:1636785422:2021-11-13T14:37:02.425+0000:[~orpiske] a quick PR to start with
https://github.com/apache/camel/pull/6438

Would you take a look, and also work on a better initial logging as mentioned above ^^^^ so that normal operation works nicely and do not log that Camel is retrying or reconnecting on 1st fetch.


davsclaus:1636785573:2021-11-13T14:39:33.938+0000:1636785573:2021-11-13T14:39:33.938+0000:I attached test-kafka-claus.tar which is updated to run with 3.14.0-SNAPSHOT and also some other adjustments to make it run (and removed OSGi stufff)
davsclaus:1636785696:2021-11-13T14:41:36.268+0000:1636785696:2021-11-13T14:41:36.268+0000:Ah yeah it can be a older problem we have not noticed due to no exception on startup.
Thanks to JMX we now know ;)
orpiske:1636786867:2021-11-13T15:01:07.300+0000:1636786867:2021-11-13T15:01:07.300+0000:[~davsclaus] absolutely. I'll be happy to take a look at that and any other thing we can improve on that one :)
davsclaus:1637024578:2021-11-16T09:02:58.008+0000:1637024578:2021-11-16T09:02:58.008+0000:Made a simpler fix on 3.11.x"
0,CAMEL-17130,Improvement,Major,None,3.x,"
None
",Resolved,Abandoned,3.x,Radovan Netuka,Guillaume LECROC,1,4,2021-10-26 08:58:16+00:00,2023-03-10 06:05:12+00:00,"Since Camel 3.x require Java 1.8, we could change camel-file to use NIO.


Benefits :



better IO errors
does not need to read all files to filter (Files.newDirectoryStream)



Do you agree and how can I contribute ?","rnetuka:1647839706:2022-03-21T13:15:06.326+0000:1647839706:2022-03-21T13:15:06.326+0000:[~gulecroc] I would like to take on this issue. Are you working on it, or is it free to take?
gulecroc:1647840042:2022-03-21T13:20:42.630+0000:1647840042:2022-03-21T13:20:42.630+0000:It is free, I was waiting for approval before starting
davsclaus:1649311762:2022-04-07T14:09:22.435+0000:1649311762:2022-04-07T14:09:22.435+0000:Randovan, you are welcome to work on it.
rnetuka:1654842077:2022-06-10T14:21:17.139+0000:1654842077:2022-06-10T14:21:17.139+0000:PR: [https://github.com/apache/camel/pull/7761]

Please, provide a review."
0,CAMEL-17129,Improvement,Major,None,Future,"
None
",Open,Unresolved,Future,Unassigned,Luca Burgazzoli,0,1,2021-10-26 08:36:25+00:00,2023-07-17 11:24:35+00:00,"While working on the YAML DSl, I've noticed that a route like:




- from: 
    uri: ""direct:start""
    steps:    
      - saga:  
        propagation: ""MANDATORY""
        completion-mode: ""MANUAL""
        steps: 
        - to: ""direct:something""
      - to: ""mock:result""




Gets re-wired to be something like:




- from: 
    uri: ""direct:start""
    steps:    
      - saga:  
        propagation: ""MANDATORY""
        completion-mode: ""MANUAL""
        steps: 
        - to: ""mock:result""
        - to: ""direct:something""




So in fact any output is moved to the saga outputs.


This happen because the saga is supposed to be a top level only feature and to be applied to the entire route (same for transacted). 


The model should have a a separate definition for route configurations so you can configure saga, tx, onException et all there only and not later in the regular route",
0,CAMEL-17128,Bug,Minor,3.13.0,3.13.0,"
None
",Resolved,Fixed,3.13.0,Freeman Yue Fang,James Netherton,0,3,2021-10-26 06:33:52+00:00,2021-11-05 21:07:20+00:00,"Seems that in the latest 3.13 SNAPSHOT it is no longer possible for the charset to be set from the HL7 message sent to the MLLP consumer. The default charset does not appear to be overridable as it's always setting the charset exchange header.


See also:


https://github.com/apache/camel-quarkus/issues/3225


Test case in camel-quarkus:


https://github.com/apache/camel-quarkus/blob/main/integration-tests/mllp/src/test/java/org/apache/camel/quarkus/component/mllp/it/MllpTest.java#L57-L78","ffang:1636027232:2021-11-04T20:00:32.324+0000:1636027274:2021-11-04T20:01:14.359+0000:If we change MllpCharsetHelper a bit to check charset firstly from the MSH 18 of the HL7 message like below, this can fix the mllp test case in camel-quarkus.

So the logic is 
1. check charset from MSH 18 of the HL7 message 
2. if not find check the charset set in the exchange
3. if not find return the default charset.

If this change(it won't break tests in camel-mllp component) is OK I will send a PR

{code}
git diff .
diff --git a/components/camel-mllp/src/main/java/org/apache/camel/component/mllp/MllpCharsetHelper.java b/components/camel-mllp/src/main/java/org/apache/camel/component/mllp/MllpCharsetHelper.java
index 52e15388eea3..b5b4faca4265 100644
--- a/components/camel-mllp/src/main/java/org/apache/camel/component/mllp/MllpCharsetHelper.java
+++ b/components/camel-mllp/src/main/java/org/apache/camel/component/mllp/MllpCharsetHelper.java
@@ -43,16 +43,6 @@ public final class MllpCharsetHelper {
     }
 
     public static Charset getCharset(Exchange exchange, byte[] hl7Bytes, Hl7Util hl7Util, Charset defaultCharset) {
-        String exchangeCharsetName = ExchangeHelper.getCharsetName(exchange, false);
-        if (exchangeCharsetName != null && !exchangeCharsetName.isEmpty()) {
-            try {
-                if (Charset.isSupported(exchangeCharsetName)) {
-                    return Charset.forName(exchangeCharsetName);
-                }
-            } catch (Exception charsetEx) {
-                // ignore
-            }
-        }
 
         String msh18 = hl7Util.findMsh18(hl7Bytes, defaultCharset);
         if (msh18 != null && !msh18.isEmpty()) {
@@ -68,6 +58,16 @@ public final class MllpCharsetHelper {
             }
         }
 
+        String exchangeCharsetName = ExchangeHelper.getCharsetName(exchange, false);
+        if (exchangeCharsetName != null && !exchangeCharsetName.isEmpty()) {
+            try {
+                if (Charset.isSupported(exchangeCharsetName)) {
+                    return Charset.forName(exchangeCharsetName);
+                }
+            } catch (Exception charsetEx) {
+                // ignore
+            }
+        }
         return defaultCharset;
     }
{code}
davsclaus:1636063156:2021-11-05T05:59:16.064+0000:1636063156:2021-11-05T05:59:16.064+0000:Yes PR is welcome
davsclaus:1636087824:2021-11-05T12:50:24.448+0000:1636087824:2021-11-05T12:50:24.448+0000:[~ffang] do you have a PR soon as we cut the release on monday?
ffang:1636088364:2021-11-05T12:59:24.917+0000:1636088364:2021-11-05T12:59:24.917+0000:Hi [~davsclaus],

Yes, I will send PR very soon.

Cheers
Freeman
ffang:1636091496:2021-11-05T13:51:36.334+0000:1636091496:2021-11-05T13:51:36.334+0000:Hi [~davsclaus],

PR against main branch
https://github.com/apache/camel/pull/6389

Thanks!
Freeman"
0,CAMEL-17127,Improvement,Major,None,3.13.0,"

help-wanted

",Resolved,Fixed,3.13.0,Jeremy Ross,Ashutosh Gupta,0,3,2021-10-25 22:13:08+00:00,2021-10-28 16:49:49+00:00,"Salesforce Bulk API v2 Get Query Job Result endpoint has provision to pass locator and maxRecords query params in url which allows pagination in case of huge data set but ""


bulk2GetQueryJobResults"" operation of camel-salesforce component have a hardcoded url which does not have these queryparam:
https://github.com/apache/camel/blob/aef037026f354bfe09f4009821a027ca535a1619/components/camel-salesforce/camel-salesforce-component/src/main/java/org/apache/camel/component/salesforce/internal/client/DefaultBulkApiV2Client.java#L204


Therefore, if a data set is too big then we can only receive data of first page/file and there is no way to get next set of data.","coolashu321@gmail.com:1635376102:2021-10-28T07:08:22.129+0000:1635376102:2021-10-28T07:08:22.129+0000:[~cibsen@e-ma.net] [~jeremyross] : I have created a PR for this : [https://github.com/apache/camel/pull/6349.] 



Unfortunately, {color:#24292f} it is failing checkstyle validation and i don't have a code formatter as this is first time I am trying to contribute in camel. Please review this PR.{color}

 

Also, can we backport this to stable version like 3.12, As I want to use it in my code.
davsclaus:1635377924:2021-10-28T07:38:44.665+0000:1635377924:2021-10-28T07:38:44.665+0000:We cannot backport - the released LTS versions is only for CVE, bug fixes etc, not new features.

The 3.13.0 release is in a few weeks
jeremyross:1635407765:2021-10-28T15:56:05.101+0000:1635407765:2021-10-28T15:56:05.101+0000:Sorry [~coolashu321@gmail.com], I'd already developed a commit yesterday. However, thank you for the report and your effort!"
0,CAMEL-17126,Improvement,Minor,3.11.3,None,"
None
",Resolved,Fixed,"3.13.0, 3.11.4",Unassigned,Henrik Karlsson,0,2,2021-10-25 17:39:09+00:00,2021-10-25 18:55:38+00:00,Found that in CAMEL-17020 the parameter for clientRequestValidation is not set on the generator in GenerateMojo.execute(),davsclaus:1635159215:2021-10-25T18:53:35.695+0000:1635159215:2021-10-25T18:53:35.695+0000:Thanks for reporting and the PR
0,CAMEL-17125,Improvement,Major,3.12.0,3.13.0,"
None
",Resolved,Fixed,3.13.0,Jeremy Ross,Jeremy Ross,0,1,2021-10-25 15:47:28+00:00,2021-10-25 16:38:06+00:00,"Salesforce has the notion of polymorphic relationships in which a particular relationship can refer to records of a set of types. E.g., The Owner relationship can often refer to a User, Group or Calendar. 


When querying for an object (record) that has a polymorphic relationship, Camel currently deserializes the related object to the superclass AbstractDescribedSObjectBase, throwing away all the subclass-specific data. However, the query result contains type information about the related object, therefore, using this type information, we should be able to deserialize to the specific subclass.",
0,CAMEL-17124,Bug,Minor,3.11.3,"3.13.0, 3.11.4","
None
",Resolved,Fixed,"3.13.0, 3.11.4",Unassigned,Henrik Karlsson,0,1,2021-10-25 08:12:16+00:00,2021-10-27 05:28:50+00:00,"When a rest api is called using the rest-openapi component query parameter headers are not filtered by HttpRestHeaderFilterStrategy. It expects that the queryParameters string is url encoded, but as you can see on the screenshot it's not. In this case all of the query parameters are flagged as required=false and therefore they also have a question mark  after the parameter name. So even if the queryParameters string had been encoded it would been filtered any way.",
0,CAMEL-17123,Dependency upgrade,Major,None,"3.13.0, 3.11.4","
None
",Resolved,Fixed,"3.13.0, 3.11.4",Andrea Cosentino,Andrea Cosentino,0,2,2021-10-25 06:36:33+00:00,2021-10-25 18:58:57+00:00,No Desc,davsclaus:1635118927:2021-10-25T07:42:07.435+0000:1635159537:2021-10-25T18:58:57.017+0000:Can we upgrade the 3.11.x LTS branch also *DONE*
0,CAMEL-17122,Improvement,Major,None,3.13.0,"
None
",Resolved,Fixed,3.13.0,Claus Ibsen,Claus Ibsen,0,1,2021-10-22 15:08:31+00:00,2021-10-24 11:47:45+00:00,This component need a little bit of work to be like others,"davsclaus:1634890609:2021-10-22T16:16:49.046+0000:1634891518:2021-10-22T16:31:58.258+0000:Oh this component is a lot of mess with some static options, and charset magic. Going to cleanup this, which means users need to migrate. Components should not be configurable using special own grown code for JVM system properties. This can be done standard now for all components.
davsclaus:1634943166:2021-10-23T06:52:46.955+0000:1634943166:2021-10-23T06:52:46.955+0000:There is a lot of mess around charset, where the component ignores if a charset is not in the JVM and just uses component configured name :("
0,CAMEL-17121,Task,Major,3.13.0,None,"
None
",Resolved,Fixed,"3.14.0, 3.x",Otavio Rodolfo Piske,Otavio Rodolfo Piske,0,1,2021-10-22 06:08:34+00:00,2022-01-11 14:43:10+00:00,"In many components we have pieces of code that resemble the following:



do some (usually remote) work
test the result
	
if failed
		
wait (usually w/ Thread.sleep)
repeat




Break loop if successful



 


We may have some potential for consolidating this logic in one of the core modules to reduce the code size and increase reuse.


 


Some likely candidates as of 3.13.0-SNAPSHOT are:


org.apache.camel.component.mllp.internal.TcpServerBindThread#doAccept
org.apache.camel.component.file.remote.strategy.FtpChangedExclusiveReadLockStrategy#acquireExclusiveReadLock
org.apache.camel.component.file.remote.SftpOperations#connect
org.apache.camel.component.file.remote.FtpOperations#doConnect
org.apache.camel.component.file.GenericFilePollingConsumer#doReceive
org.apache.camel.component.jms.reply.ReplyManagerSupport#waitForProvisionCorrelationToBeUpdated
org.apache.camel.component.couchdb.CouchDbChangesetTracker#waitForStability
org.apache.camel.component.mock.MockEndpoint#expectedFileExists(java.lang.String, java.lang.String)
org.apache.camel.component.mongodb.MongoAbstractConsumerThread#run
org.apache.camel.component.mongodb.gridfs.GridFsConsumer#run
org.apache.camel.component.optaplanner.OptaPlannerProducer#processWithXmlFile
org.apache.camel.component.rabbitmq.RabbitConsumer#handleShutdownSignal
org.apache.camel.component.rabbitmq.RabbitMQConsumer.StartConsumerCallable#call
org.apache.camel.component.rabbitmq.reply.ReplyManagerSupport#waitForProvisionCorrelationToBeUpdated
org.apache.camel.component.salesforce.internal.streaming.SubscriptionHelper#performClientRestart
org.apache.camel.component.salesforce.internal.streaming.SubscriptionHelper#subscribe
org.apache.camel.component.smpp.SmppConsumer#reconnect
org.apache.camel.component.soroushbot.utils.ExponentialBackOffStrategy
org.apache.camel.component.soroushbot.utils.FixedBackOffStrategy
org.apache.camel.component.soroushbot.utils.LinearBackOffStrategy
org.apache.camel.component.splunk.support.SplunkDataReader#savedSearch
org.apache.camel.component.splunk.support.SplunkDataReader#runQuery
org.apache.camel.component.ssh.SshHelper#getPrompt
org.apache.camel.component.stream.StreamConsumer#readFromStream
org.apache.camel.component.stream.StreamConsumer#doPromptMessage
org.apache.camel.support.cache.DefaultProducerCache#acquireProducer
org.apache.camel.test.junit4.TestSupport#deleteDirectory(java.io.File)
org.apache.camel.test.junit5.TestSupport#deleteDirectory(java.io.File)
org.apache.camel.util.FileUtil#delete
org.apache.camel.util.FileUtil#renameFile
org.apache.camel.util.FileUtil#deleteFile
org.apache.camel.component.websocket.WebsocketProducer#sendToAll
org.apache.camel.component.zookeeper.ZooKeeperConsumer.OperationsExecutor#run
org.apache.camel.component.zookeeper.cluster.ZooKeeperClusterView.CamelLeaderElectionListener#takeLeadership","orpiske:1635320785:2021-10-27T15:46:25.099+0000:1635320785:2021-10-27T15:46:25.099+0000:* org.apache.camel.component.file.GenericFilePollingConsumer#doReceive: doable but requires some care.
orpiske:1635320873:2021-10-27T15:47:53.197+0000:1635320873:2021-10-27T15:47:53.197+0000:Waiting for feedback:
 * org.apache.camel.component.mllp.internal.TcpServerBindThread#doAccept
 * org.apache.camel.component.file.remote.strategy.FtpChangedExclusiveReadLockStrategy#acquireExclusiveReadLock
 * org.apache.camel.component.file.remote.SftpOperations#connect
 * org.apache.camel.component.file.remote.FtpOperations#doConnect
orpiske:1635494694:2021-10-29T16:04:54.073+0000:1635494694:2021-10-29T16:04:54.073+0000:This one is not a good candidate for now:

* org.apache.camel.component.mongodb.MongoAbstractConsumerThread#run

 

This one was converted: 
* org.apache.camel.component.mongodb.gridfs.GridFsConsumer#run

 
orpiske:1636318753:2021-11-08T04:59:13.461+0000:1636318753:2021-11-08T04:59:13.461+0000:Converted: 
* org.apache.camel.component.optaplanner.OptaPlannerProducer#processWithXmlFile
orpiske:1636332775:2021-11-08T08:52:55.050+0000:1636333394:2021-11-08T09:03:14.703+0000:Rabbit MQ is completed, but I'm waiting for 3.13 branching to finish, so I can document a change to the shutdown behavior:
 * org.apache.camel.component.rabbitmq.RabbitConsumer#handleShutdownSignal
 * org.apache.camel.component.rabbitmq.RabbitMQConsumer.StartConsumerCallable#call

[https://github.com/orpiske/camel/tree/camel-17121-camel-rabbitmq]


org.apache.camel.component.rabbitmq.reply.ReplyManagerSupport#waitForProvisionCorrelationToBeUpdated:  I'm not updating this one, as it seems very specific to a high-performance use case.
orpiske:1636334833:2021-11-08T09:27:13.510+0000:1636334833:2021-11-08T09:27:13.510+0000:I'm not going to change Salesforce at this moment:

org.apache.camel.component.salesforce.internal.streaming.SubscriptionHelper#performClientRestart
org.apache.camel.component.salesforce.internal.streaming.SubscriptionHelper#subscribe

I logged CAMEL-17177 for this.
orpiske:1636350422:2021-11-08T13:47:02.036+0000:1636350444:2021-11-08T13:47:24.583+0000:SMPP one is done: [https://github.com/orpiske/camel/tree/camel-17121-camel-smpp]
 * org.apache.camel.component.smpp.SmppConsumer#reconnect


Waiting for dependent code to be merged, so I can proceed w/ PR.

 
orpiske:1636421487:2021-11-09T09:31:27.965+0000:1636421487:2021-11-09T09:31:27.965+0000:Soroush done: [https://github.com/orpiske/camel/tree/camel-17121-soroush]

org.apache.camel.component.soroushbot.utils.ExponentialBackOffStrategy
org.apache.camel.component.soroushbot.utils.FixedBackOffStrategy
org.apache.camel.component.soroushbot.utils.LinearBackOffStrategy

 

Waiting for dependent code to be merged in.

 
orpiske:1636423903:2021-11-09T10:11:43.752+0000:1636423903:2021-11-09T10:11:43.752+0000:Splunk done:

org.apache.camel.component.splunk.support.SplunkDataReader#savedSearch
org.apache.camel.component.splunk.support.SplunkDataReader#runQuery
orpiske:1636424408:2021-11-09T10:20:08.754+0000:1636424408:2021-11-09T10:20:08.754+0000:Ssh helper one is not a good candidate (apparently used for throttling the consumption of incoming data):

org.apache.camel.component.ssh.SshHelper#getPrompt
orpiske:1636425112:2021-11-09T10:31:52.994+0000:1636425112:2021-11-09T10:31:52.994+0000:StreamConsumer ones are not good candidates (conditionally sleeping / one shot sleep):

org.apache.camel.component.stream.StreamConsumer#readFromStream
org.apache.camel.component.stream.StreamConsumer#doPromptMessage
orpiske:1636427186:2021-11-09T11:06:26.549+0000:1636427186:2021-11-09T11:06:26.549+0000:DefaultProducerCache: done (but likely will need more reviews) ... also running larger tests for this one.

org.apache.camel.support.cache.DefaultProducerCache#acquireProducer
orpiske:1636427277:2021-11-09T11:07:57.340+0000:1636427911:2021-11-09T11:18:31.154+0000:Not changing the FileUtils and other file ones at this moment (1) they may be better served by modernizing it - but subject to further inspection and 2) I don't have a Windows machine to test).

org.apache.camel.util.FileUtil#delete
org.apache.camel.util.FileUtil#renameFile
org.apache.camel.util.FileUtil#deleteFile
org.apache.camel.test.junit4.TestSupport#deleteDirectory(java.io.File)
org.apache.camel.test.junit5.TestSupport#deleteDirectory(java.io.File)
orpiske:1636429834:2021-11-09T11:50:34.793+0000:1636429834:2021-11-09T11:50:34.793+0000:WebsocketProducer is not a good candidate since it is synchronizing work on that method:

org.apache.camel.component.websocket.WebsocketProducer#sendToAll
orpiske:1636430872:2021-11-09T12:07:52.113+0000:1636430872:2021-11-09T12:07:52.113+0000:Zookeeper done:

org.apache.camel.component.zookeeper.ZooKeeperConsumer.OperationsExecutor#run  -> skipped, because it's not a good candidate. 
org.apache.camel.component.zookeeper.cluster.ZooKeeperClusterView.CamelLeaderElectionListener#takeLeadership -> done.

 

 
orpiske:1636514606:2021-11-10T11:23:26.323+0000:1636514606:2021-11-10T11:23:26.323+0000:Pretty much all of the easy do-wait-retry logic in components were migrated. There are a few remaining that are not good candidates for conversion at this moment and we can look at them later."
0,CAMEL-17120,Test,Minor,3.12.0,3.14.0,"
None
",Resolved,Won't Fix,3.14.0,Unassigned,Ramu,0,3,2021-10-22 03:20:15+00:00,2021-11-24 12:27:22+00:00,"[ERROR] org.apache.camel.component.xmlsecurity.XmlSignatureTest.testExceptionDetachedXpathInvalid  Time elapsed: 0.038 s  <<< ERROR!
java.lang.IllegalStateException: java.lang.IllegalStateException: XSL file /org/apache/camel/component/xmlsecurity/xslt_test.xsl not found
	at org.apache.camel.component.xmlsecurity.XmlSignatureTest.getTransformsXsltXpath(XmlSignatureTest.java:1534)
	at org.apache.camel.component.xmlsecurity.XmlSignatureTest.createCamelRegistry(XmlSignatureTest.java:141)
	at org.apache.camel.test.junit5.CamelTestSupport.createCamelContext(CamelTestSupport.java:763)
	at org.apache.camel.test.junit5.CamelTestSupport.doSetUp(CamelTestSupport.java:427)
	at org.apache.camel.test.junit5.CamelTestSupport.setUp(CamelTestSupport.java:382)
	at org.apache.camel.component.xmlsecurity.XmlSignatureTest.setUp(XmlSignatureTest.java:1456)
	at sun.reflect.GeneratedMethodAccessor22.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:498)
	at org.junit.platform.commons.util.ReflectionUtils.invokeMethod(ReflectionUtils.java:688)
	at org.junit.jupiter.engine.execution.MethodInvocation.proceed(MethodInvocation.java:60)
	at org.junit.jupiter.engine.execution.InvocationInterceptorChain$ValidatingInvocation.proceed(InvocationInterceptorChain.java:131)
	at org.junit.jupiter.engine.extension.TimeoutExtension.intercept(TimeoutExtension.java:149)
	at org.junit.jupiter.engine.extension.TimeoutExtension.interceptLifecycleMethod(TimeoutExtension.java:126)
	at org.junit.jupiter.engine.extension.TimeoutExtension.interceptBeforeEachMethod(TimeoutExtension.java:76)
	at org.junit.jupiter.engine.execution.ExecutableInvoker$ReflectiveInterceptorCall.lambda$ofVoidMethod$0(ExecutableInvoker.java:115)
	at org.junit.jupiter.engine.execution.ExecutableInvoker.lambda$invoke$0(ExecutableInvoker.java:105)
	at org.junit.jupiter.engine.execution.InvocationInterceptorChain$InterceptedInvocation.proceed(InvocationInterceptorChain.java:106)
	at org.junit.jupiter.engine.execution.InvocationInterceptorChain.proceed(InvocationInterceptorChain.java:64)
	at org.junit.jupiter.engine.execution.InvocationInterceptorChain.chainAndInvoke(InvocationInterceptorChain.java:45)
	at org.junit.jupiter.engine.execution.InvocationInterceptorChain.invoke(InvocationInterceptorChain.java:37)
	at org.junit.jupiter.engine.execution.ExecutableInvoker.invoke(ExecutableInvoker.java:104)
	at org.junit.jupiter.engine.execution.ExecutableInvoker.invoke(ExecutableInvoker.java:98)
	at org.junit.jupiter.engine.descriptor.ClassBasedTestDescriptor.invokeMethodInExtensionContext(ClassBasedTestDescriptor.java:490)
	at org.junit.jupiter.engine.descriptor.ClassBasedTestDescriptor.lambda$synthesizeBeforeEachMethodAdapter$19(ClassBasedTestDescriptor.java:475)
	at org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.lambda$invokeBeforeEachMethods$2(TestMethodTestDescriptor.java:167)
	at org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.lambda$invokeBeforeMethodsOrCallbacksUntilExceptionOccurs$5(TestMethodTestDescriptor.java:195)
	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)
	at org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.invokeBeforeMethodsOrCallbacksUntilExceptionOccurs(TestMethodTestDescriptor.java:195)
	at org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.invokeBeforeEachMethods(TestMethodTestDescriptor.java:164)
	at org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.execute(TestMethodTestDescriptor.java:127)
	at org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.execute(TestMethodTestDescriptor.java:65)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$5(NodeTestTask.java:139)
	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$7(NodeTestTask.java:129)
	at org.junit.platform.engine.support.hierarchical.Node.around(Node.java:137)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$8(NodeTestTask.java:127)
	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.executeRecursively(NodeTestTask.java:126)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.execute(NodeTestTask.java:84)
	at java.util.ArrayList.forEach(ArrayList.java:1249)
	at org.junit.platform.engine.support.hierarchical.SameThreadHierarchicalTestExecutorService.invokeAll(SameThreadHierarchicalTestExecutorService.java:38)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$5(NodeTestTask.java:143)
	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$7(NodeTestTask.java:129)
	at org.junit.platform.engine.support.hierarchical.Node.around(Node.java:137)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$8(NodeTestTask.java:127)
	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.executeRecursively(NodeTestTask.java:126)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.execute(NodeTestTask.java:84)
	at java.util.ArrayList.forEach(ArrayList.java:1249)
	at org.junit.platform.engine.support.hierarchical.SameThreadHierarchicalTestExecutorService.invokeAll(SameThreadHierarchicalTestExecutorService.java:38)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$5(NodeTestTask.java:143)
	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$7(NodeTestTask.java:129)
	at org.junit.platform.engine.support.hierarchical.Node.around(Node.java:137)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$8(NodeTestTask.java:127)
	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.executeRecursively(NodeTestTask.java:126)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.execute(NodeTestTask.java:84)
	at org.junit.platform.engine.support.hierarchical.SameThreadHierarchicalTestExecutorService.submit(SameThreadHierarchicalTestExecutorService.java:32)
	at org.junit.platform.engine.support.hierarchical.HierarchicalTestExecutor.execute(HierarchicalTestExecutor.java:57)
	at org.junit.platform.engine.support.hierarchical.HierarchicalTestEngine.execute(HierarchicalTestEngine.java:51)
	at org.junit.platform.launcher.core.EngineExecutionOrchestrator.execute(EngineExecutionOrchestrator.java:108)
	at org.junit.platform.launcher.core.EngineExecutionOrchestrator.execute(EngineExecutionOrchestrator.java:88)
	at org.junit.platform.launcher.core.EngineExecutionOrchestrator.lambda$execute$0(EngineExecutionOrchestrator.java:54)
	at org.junit.platform.launcher.core.EngineExecutionOrchestrator.withInterceptedStreams(EngineExecutionOrchestrator.java:67)
	at org.junit.platform.launcher.core.EngineExecutionOrchestrator.execute(EngineExecutionOrchestrator.java:52)
	at org.junit.platform.launcher.core.DefaultLauncher.execute(DefaultLauncher.java:96)
	at org.junit.platform.launcher.core.DefaultLauncher.execute(DefaultLauncher.java:75)
	at org.apache.maven.surefire.junitplatform.JUnitPlatformProvider.invokeAllTests(JUnitPlatformProvider.java:165)
	at org.apache.maven.surefire.junitplatform.JUnitPlatformProvider.invoke(JUnitPlatformProvider.java:128)
	at org.apache.maven.surefire.booter.ForkedBooter.runSuitesInProcess(ForkedBooter.java:428)
	at org.apache.maven.surefire.booter.ForkedBooter.execute(ForkedBooter.java:162)
	at org.apache.maven.surefire.booter.ForkedBooter.run(ForkedBooter.java:562)
	at org.apache.maven.surefire.booter.ForkedBooter.main(ForkedBooter.java:548)
Caused by: java.lang.IllegalStateException: XSL file /org/apache/camel/component/xmlsecurity/xslt_test.xsl not found
	at org.apache.camel.component.xmlsecurity.api.XmlSignatureHelper.getXslTransform(XmlSignatureHelper.java:308)
	at org.apache.camel.component.xmlsecurity.XmlSignatureTest.getTransformsXsltXpath(XmlSignatureTest.java:1520)
	... 75 more

[INFO] Running org.apache.camel.component.xmlsecurity.SpringXmlSignatureTest","Federico Mariani:1634860513:2021-10-22T07:55:13.647+0000:1634860513:2021-10-22T07:55:13.647+0000:By executing XmlSignatureTest#testExceptionDetachedXpathInvalid test alone it is working on 3.13.0-SNAPSHOT, but when executing all tests of camel-xmlsecurity some of them are failing due to a new line character in the actualValue:
{code:java}
Expected: <<?xml version=""1.0"" encoding=""UTF-8""?><ns:root xmlns:ns=""http://test""><a ID=""myID""><b>bValue</b></a></ns:root>> but was: <<?xml version=""1.0"" encoding=""UTF-8""?>
<ns:root xmlns:ns=""http://test""><a ID=""myID""><b>bValue</b></a></ns:root>>{code}
Federico Mariani:1634861364:2021-10-22T08:09:24.863+0000:1634861364:2021-10-22T08:09:24.863+0000:Quick update, I noticed that tests are failing due to new line with _openjdk version ""1.8.0_275""_

otherwise all tests passes with _openjdk version ""11.0.9.1""_
davsclaus:1635159749:2021-10-25T19:02:29.315+0000:1635159749:2021-10-25T19:02:29.315+0000:Yeah its XML parser built in the JDK 8 vs JDK11 with external parsers.

And JDK8 is EOL after Camel 3.14.x so its not so important. 
davsclaus:1637728042:2021-11-24T12:27:22.546+0000:1637728042:2021-11-24T12:27:22.546+0000:Java 8 is soon EOL and 3.14.x is the last release to support Java 8"
0,CAMEL-17119,Improvement,Minor,None,None,"
None
",Resolved,Fixed,3.13.0,Luigi De Masi,Luigi De Masi,0,1,2021-10-21 15:52:02+00:00,2021-10-22 16:15:10+00:00,"When the idleTimeout occurs, the producer set the SO_LINGER to 0 and reset socket.


This can cause issues with certain external server, we can add an URI option to allow users to choose between reset or close the socket.",
0,CAMEL-17118,Bug,Minor,2.20.4,"3.14.1, 3.15.0","
None
",Resolved,Fixed,"3.14.1, 3.15.0",Claus Ibsen,Andres Oviedo,0,3,2021-10-21 14:01:22+00:00,2022-01-09 11:32:58+00:00,"Hi team,


 


Issue


The parameter mapHttpMessageFormUrlEncodedBody  is not useful


 


Root Issue


If you have a request with a POST parameter having a CR/LF in one of its values, it will be mapped to an HTTP Header, causing an Exception. CR/LF are not allowed header characters in HTTP protocol nor camel


 


Analysis


I think where the problem is.


Class:  org.apache.camel.http.common.DefaultHttpBindingComponent.java


Line: https://github.com/apache/camel/blob/005765443f3161182b78c999b9f8b43052768800/components/camel-http-common/src/main/java/org/apache/camel/http/common/DefaultHttpBinding.java#L183


 


Explanation:  The POST/GET parameters are always added as Headers in camel


There is no any flag that can avoid that mapping.


 


Proposed solution


Use the mapHttpMessageFormUrlEncodedBody to control where the GET/POST parameters should be mapped to headers


 


Kind regards


 


 


Kind regards","davsclaus:1634885668:2021-10-22T14:54:28.600+0000:1634885668:2021-10-22T14:54:28.600+0000:What version of Camel do you use?
andresoviedo:1634899013:2021-10-22T18:36:53.246+0000:1634899013:2021-10-22T18:36:53.246+0000:camel version: 2.20.4

main branch should still have same issue 

 

 
Federico Mariani:1634944403:2021-10-23T07:13:23.374+0000:1634944403:2021-10-23T07:13:23.374+0000:Hi [~andresoviedo], I tried to execute some tests, seems like that DefaultHttpBindinig.readHeaders is invoked by camel-servlet and camel-resteasy tests.
 * camel-servlet tests throws exception on ServletCamelRouterTestSupport.java:98 when using a carriage return character as parameter.
 * camel-resteasy handle the carriage return character by encoding it.

I'm probably missing something here, do you have some kind of reproducer?
davsclaus:1636785743:2021-11-13T14:42:23.125+0000:1636785743:2021-11-13T14:42:23.125+0000:Camel 2.x is EOL soon and the reported did not provide a reproducer
andresoviedo:1638231079:2021-11-30T08:11:19.721+0000:1638231079:2021-11-30T08:11:19.721+0000:Hello [~davsclaus] 

Sorry for the late response. You can reproduce the error with the following CURL request

 
{code:java}
curl --location --request POST 'https://localhost:8080/rest/my-route' \
--header 'Content-Type: application/x-www-form-urlencoded' \
--data-urlencode 'foo=bar\nbaz' {code}
What will happen is, Camel will map the Payload parameter ""foo"" to a header with the same name ""foo"".

Then it will crash because of the CR/LF character

 

I see that that the 2.x major version will reach end-of-life (EOL) by January 2022

I hope this is not anymore a bug in 3.x version

 

At your disposal 

Kind regards

 
davsclaus:1641698394:2022-01-09T11:19:54.320+0000:1641698394:2022-01-09T11:19:54.320+0000:On Camel 3.x I cannot reproduce any exception - I do get the header parsed by Camel though its value is bar\nbaz but there are no exceptions
davsclaus:1641698734:2022-01-09T11:25:34.543+0000:1641698734:2022-01-09T11:25:34.543+0000:Okay so the mapHttpMessageFormUrlEncodedBody is not set to false because you use rest-dsl where its ""fixed"". Yeah we can look at improve this so it can be re-configured.
But if you use normal camel-servlet then you can configure it
davsclaus:1641699178:2022-01-09T11:32:58.246+0000:1641699178:2022-01-09T11:32:58.246+0000:Okay the mapHttpMessageFormUrlEncodedBody is now also used in rest-dsl"
0,CAMEL-17117,Improvement,Minor,None,3.16.0,"
None
",Resolved,Fixed,3.16.0,Otavio Rodolfo Piske,Claus Ibsen,0,2,2021-10-21 07:28:23+00:00,2022-03-03 11:51:16+00:00,"Like we have change data capture, then I think it would be good to have a doc page about the new resume from offset. (ResumeStrategy)


We have support for this in some components like kafka, file etc.","orpiske:1646218551:2022-03-02T18:55:51.081+0000:1646218551:2022-03-02T18:55:51.081+0000:There is missing documentation about what components support resume. I will do this then we can close it.
orpiske:1646279476:2022-03-03T11:51:16.044+0000:1646279476:2022-03-03T11:51:16.044+0000:This should be done now."
0,CAMEL-17116,Improvement,Major,None,None,"
None
",Resolved,Fixed,3.13.0,Ramu,Claus Ibsen,0,1,2021-10-21 04:52:55+00:00,2022-01-21 09:24:21+00:00,"See CAMEL-17114


There are a number of components that load resources from classpath as:




camel-infinispan/camel-infinispan-common/src/main/java/org/apache/camel/component/infinispan/InfinispanUtil.java:        return Thread.currentThread().getContextClassLoader().getResourceAsStream(uri);
camel-jbpm/src/main/java/org/apache/camel/component/jbpm/server/CamelKieServerExtension.java:            try (InputStream is = this.getClass().getResourceAsStream(""/global-camel-routes.xml"")) {
camel-jbpm/src/main/java/org/apache/camel/component/jbpm/server/CamelKieServerExtension.java:        try (InputStream is = classloader.getResourceAsStream(""camel-routes.xml"")) {
camel-jira/src/main/java/org/apache/camel/component/jira/oauth/OAuthAsynchronousHttpClientFactory.java:            try (InputStream resourceAsStream = AuthenticationHandler.class.getResourceAsStream(pomProps)) {
camel-jslt/src/main/java/org/apache/camel/component/jslt/JsltEndpoint.java:                    stream = JsltEndpoint.class.getClassLoader().getResourceAsStream(getResourceUri());
camel-quartz/src/main/java/org/apache/camel/component/quartz/QuartzComponent.java:            InputStream is = StdSchedulerFactory.class.getClassLoader().getResourceAsStream(""org/quartz/quartz.properties"");
camel-schematron/src/main/java/org/apache/camel/component/schematron/processor/ClassPathURIResolver.java:                .getResourceAsStream(rulesDir.concat(""/"").concat(href));
camel-schematron/src/main/java/org/apache/camel/component/schematron/processor/TemplatesFactory.java:                InputStream xsl = this.getClass().getClassLoader().getResourceAsStream(path);
camel-xmlsecurity/src/main/java/org/apache/camel/component/xmlsecurity/api/XmlSignatureHelper.java:        return XmlSignatureHelper.class.getResourceAsStream(path);




Instead we should use ClassResolver API via CamelContext - This has the mehanism to load correctly in different runtimes - standalone, OSGi, spring boot, quarkus etc.",
0,CAMEL-17115,Bug,Major,None,,"
None
",Closed,Invalid,None,Tomohisa Igarashi,Shrishti Gupta,0,2,2021-10-21 04:31:47+00:00,2021-10-21 11:10:27+00:00,"I tried to use custom transformation of altasmap with 2.2.3 version. Custom transformation jar imported fine but mapping definition is null while doing XML to JSON transformation. I also tried to use 2.3.1 version but with this version Custom jar is imported but transformation is not present in drop down list.


I have attached sample project which I used for data transformation along with custom transformation project , mapping file and sample request file.


Attached zip file have :



Atlasmap demo project - (XmlToJsonTransformation) class which is used for conversion
Custom project (for creating custom transformation)
altas-map.adm ( mapping definition file for transformation)
orderxml.xsd ( sample request for conversion XML to JSON)",igarashitm:1634785782:2021-10-21T11:09:42.955+0000:1634785782:2021-10-21T11:09:42.955+0000:[~shrishtig31] AtlasMap is a separate project from Apache Camel. Please report the issues here - https://github.com/atlasmap/atlasmap/issues
0,CAMEL-17114,Bug,Major,3.11.2,None,"
None
",Resolved,Fixed,"3.13.0, 3.11.4",Unassigned,Kevin Howell,0,2,2021-10-20 21:54:23+00:00,2021-10-25 10:27:21+00:00,"See https://github.com/quarkusio/quarkus/issues/2531 ; essentially quarkus dev mode classpath resource loading only works properly if




Thread.currentThread().getContextClassLoader().getResourceAsStream(uri);



is used. Currently, JsltEndpoint uses




 JsltEndpoint.class.getClassLoader().getResourceAsStream(getResourceUri());



I've tested locally that quarkus dev mode loads the file properly w/ this change.


A simple route/jslt file are all that are needed to test this (locally, I'm simply using jslt like {""foo"":""bar""}).","davsclaus:1634763299:2021-10-21T04:54:59.492+0000:1634763299:2021-10-21T04:54:59.492+0000:Thanks [~khowell]

I created another ticket CAMEL-17116. Can you try to see if this code also works for quarkus:dev mode

{code}
stream = getCamelContext().getClassResolver().loadResourceAsStream(getResourceUri());
{code}"
0,CAMEL-17113,Task,Major,None,3.13.0,"
None
",Resolved,Fixed,3.13.0,David Jencks,Andrea Cosentino,0,1,2021-10-20 13:26:01+00:00,2021-10-26 04:52:10+00:00,https://camel.apache.org/components/latest/aws2-msk-component.html,
0,CAMEL-17112,Improvement,Major,None,3.13.0,"
None
",Resolved,Fixed,3.13.0,Claus Ibsen,Claus Ibsen,0,1,2021-10-20 12:01:48+00:00,2021-10-20 15:08:24+00:00,"You will see logs with thread #0


10:14:24.591 [Camel (AWS-S3-To-Kafka) thread #0 - aws2-s3://camel-kafka-connector] TRACE


But lets start the counter from 1, as then the number is correct, eg when you see thread #8 - then there are 8 threads, and not 9.",
0,CAMEL-17111,Improvement,Major,None,4.x,"
None
",Open,Unresolved,4.x,Andrea Cosentino,Andrea Cosentino,0,1,2021-10-20 08:52:03+00:00,2023-08-09 09:17:47+00:00,"Investigate if we could do something like internal idempotency in Aws2 s3 consumer, instead of using deleteAfterRead as default approach.",
0,CAMEL-17110,Bug,Major,3.11.3,4.x,"
None
",Open,Unresolved,4.x,Andrea Cosentino,Andrea Cosentino,0,3,2021-10-20 08:43:29+00:00,2023-08-09 09:29:40+00:00,"- route:
    from:
      uri: ""kamelet:aws-s3-source""
      parameters:
        bucketNameOrArn: ""camel-kafka-connector""
        accessKey: ""access""
        secretKey: ""secret""
        region: ""eu-west-1""
    steps:
      - to: 
          uri: ""kamelet:kafka-not-secured-sink""
          parameters:
            brokers: ""localhost:9092""
            topic: ""s3-source-topic""




In the log, if you enabled trace you may notice something like:




10:14:24.476 [Camel (AWS-S3-To-Kafka) thread #11 - KafkaProducer[s3-source-topic]] TRACE o.a.c.c.aws2.s3.AWS2S3Consumer - Deleted object from bucket camel-kafka-connector with key jkXzIEbaYyKMTMwGpNHL.txt...

10:14:24.491 [Camel (AWS-S3-To-Kafka) thread #0 - aws2-s3://camel-kafka-connector] TRACE s.a.awssdk.auth.signer.Aws4Signer - AWS4 Canonical Request: GET
/jkXzIEbaYyKMTMwGpNHL.txt

10:14:24.582 [Camel (AWS-S3-To-Kafka) thread #0 - aws2-s3://camel-kafka-connector] DEBUG software.amazon.awssdk.request - Received error response: software.amazon.awssdk.services.s3.model.NoSuchKeyException: The specified key does not exist. 




While, the get should happens before the deletions. This is happening only when using Kamelets. It looks like the exchange completed before the get operation has been done.","davsclaus:1634703066:2021-10-20T12:11:06.264+0000:1634703066:2021-10-20T12:11:06.264+0000:After digging a bit, it looks like its the aws-s3 consumer is having a race condition, where a previous poll picked up a file, that is sent to kafka, that is processed asynchronously so the current thread becomes idle, and then on next poll, the consumer thread ""sees"" the same file as on previous poll, that the kafka producer is currently sending. And so when the kafka producer is done sending, it has an on completion to delete the s3 file, which it does, at the same time as the other thread is trying to process the file (duplicate), which is then now deleted.

What the s3 consumer lacks is an in-progress repository to keep track of currently in-flight messages with files. The camel-file component have such feature.

We can add similar inflight repository as we have in camel-file to s3 - its a bit of work as you need to ensure to keep the in flight repo correctly up to date when there are exceptions / batch break before all done etc. But basically copy/paste from camel-file where you can."
0,CAMEL-17109,Bug,Major,3.12.0,3.13.0,"
None
",Resolved,Fixed,3.13.0,Andrea Cosentino,Hokutor,0,2,2021-10-19 17:08:06+00:00,2022-09-02 09:04:34+00:00,"The bom in camel-azure caused conflicting dependencies of okhttp to be downloaded and cause failure in test cases in other components. 


 


The issue has been discussed and described here -> https://camel.zulipchat.com/#narrow/stream/257298-camel/topic/Failing.20test.20cases.20in.20camel-huaweicloud-obs",acosentino:1634635725:2021-10-19T17:28:45.595+0000:1634635725:2021-10-19T17:28:45.595+0000:Let's remove the bom and use dependencies explicitly.
0,CAMEL-17108,Improvement,Major,3.12.0,3.13.0,"
None
",Resolved,Fixed,3.13.0,Otavio Rodolfo Piske,Otavio Rodolfo Piske,0,1,2021-10-19 16:04:52+00:00,2021-10-25 15:36:20+00:00,Resume strategy support ... for CouchDB,orpiske:1635147380:2021-10-25T15:36:20.157+0000:1635147380:2021-10-25T15:36:20.157+0000:The code is merged and should be available with 3.13.0.
0,CAMEL-17107,Bug,Minor,3.11.3,,"
None
",Resolved,Not A Bug,None,Unassigned,Peter Hermsdorf,0,2,2021-10-19 14:47:13+00:00,2021-10-22 08:51:26+00:00,"Maybe related to CAMEL-17015


as mentioned here:https://camel.zulipchat.com/#narrow/stream/257300-camel-karaf/topic/Problem.20with.20REST.20services.20after.20upgrading.20to.20Camel.203.2E11.2E2/near/256197689


After Update the DataSource is not found by the routes.


We initialize our runtime like this:




camelContext = new OsgiDefaultCamelContext(bundleContext) {
				@Override
				public void init() {
					final RouteBuilder routes = createRoutes();
					routes.restConfiguration().componentProperty(""servletName"", ""my.custom.servletName"").clientRequestValidation(true);
					this.addRoutes(routes);
					super.init();
				}




Our routes look like




...
.toF(""sql-stored:pwp.receive_sync(OUT VARCHAR result, BINARY ${in.body})?function=true&dataSource=%s"",	 ""DataSourceName"")




We register the DataSource as OSGI Service like this:




inal Dictionary<String, String> properties = new Hashtable<>();// NOSONAR
properties.put(Constants.SERVICE_PID, ""DataSourceName"");
registerService(javax.sql.DataSource.class, ds, properties);




After upgrading from 3.4.4 to 3.11.3 the Datasource isn't found anymore


I compared the calls to SqlComponent.setDataSource and getDatasource and the lookup of the DataSource via OsgiBeanRepository.lookupByName(String):


in 3.4.4 setDataSource and getDatasource are not called and the OsgiBeanRepository.lookupByName is called 2 or three times (always returning the service)


in 3.11.3 SqlComponent.getDataSource is called at first and multiple times always returning null because no one calls setDatasource. OsgiBeanRepository.lookupByName is called once also returning the registered service.


Route creation fails with errors like:




2021-10-19 16:41:04,760 ERROR [BlueprintContainerImpl] Unable to start container for blueprint bundle com.godyo.p5.servicemix.camel/5.0.2145.qualifier
 org.osgi.service.blueprint.container.ComponentDefinitionException: Error when instantiating bean test_artnr of class org.apache.camel.Endpoint
 at org.apache.aries.blueprint.container.BeanRecipe.wrapAsCompDefEx(BeanRecipe.java:362)
 at org.apache.aries.blueprint.container.BeanRecipe.getInstanceFromFactory(BeanRecipe.java:298)
 at org.apache.aries.blueprint.container.BeanRecipe.getInstance(BeanRecipe.java:279)
 at org.apache.aries.blueprint.container.BeanRecipe.internalCreate2(BeanRecipe.java:685)
 at org.apache.aries.blueprint.container.BeanRecipe.internalCreate(BeanRecipe.java:666)
 at org.apache.aries.blueprint.di.AbstractRecipe$1.call(AbstractRecipe.java:81)
 at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
 at org.apache.aries.blueprint.di.AbstractRecipe.create(AbstractRecipe.java:90)
 at org.apache.aries.blueprint.container.BlueprintRepository.createInstances(BlueprintRepository.java:360)
 at org.apache.aries.blueprint.container.BlueprintRepository.createAll(BlueprintRepository.java:190)
 at org.apache.aries.blueprint.container.BlueprintContainerImpl.instantiateEagerComponents(BlueprintContainerImpl.java:737)
 at org.apache.aries.blueprint.container.BlueprintContainerImpl.doRun(BlueprintContainerImpl.java:433)
 at org.apache.aries.blueprint.container.BlueprintContainerImpl.run(BlueprintContainerImpl.java:298)
 at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)
 at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
 at org.apache.aries.blueprint.container.ExecutorServiceWrapper.run(ExecutorServiceWrapper.java:106)
 at org.apache.aries.blueprint.utils.threading.impl.DiscardableRunnable.run(DiscardableRunnable.java:45)
 at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)
 at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
 at java.base/java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:304)
 at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)
 at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)
 at java.base/java.lang.Thread.run(Thread.java:834)
 Caused by: org.apache.camel.ResolveEndpointFailedException: Failed to resolve endpoint: sql://SELECT%20ARTNR%20FROM%20ARSTAMM%20WHERE%20ARTNR=rpad(':%23$%7Bheader.artnr%7D',18)?dataSource=P4-DataSource&outputHeader=foundArtnr due to: DataSource must be configured
 at org.apache.camel.impl.engine.AbstractCamelContext.doGetEndpoint(AbstractCamelContext.java:962)
 at org.apache.camel.impl.engine.AbstractCamelContext.getEndpoint(AbstractCamelContext.java:844)
 at org.apache.camel.core.xml.AbstractCamelEndpointFactoryBean.getObject(AbstractCamelEndpointFactoryBean.java:54)
 at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
 at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
 at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
 at java.base/java.lang.reflect.Method.invoke(Method.java:566)
 at org.apache.aries.blueprint.utils.ReflectionUtils.invoke(ReflectionUtils.java:337)
 at org.apache.aries.blueprint.container.BeanRecipe.invoke(BeanRecipe.java:835)
 at org.apache.aries.blueprint.container.BeanRecipe.getInstanceFromFactory(BeanRecipe.java:296)
 ... 21 common frames omitted
 Caused by: java.lang.IllegalArgumentException: DataSource must be configured
 at org.apache.camel.component.sql.SqlComponent.createEndpoint(SqlComponent.java:105)
 at org.apache.camel.support.DefaultComponent.createEndpoint(DefaultComponent.java:171)
 at org.apache.camel.impl.engine.AbstractCamelContext.doGetEndpoint(AbstractCamelContext.java:928)
 ... 30 common frames omitted
{code:java}
 



Any help is more than welcome.


Thanks,  Peter


Bonus Question:
 why is that ""workaround""(overriding init() method) for the OsgiDefaultCamelContext necessary? (otherwise the routes are not picked up)
 What would be ""the right way""(tm) to do the initialization?","davsclaus:1634633541:2021-10-19T16:52:21.820+0000:1634633541:2021-10-19T16:52:21.820+0000:Can you put together a reproducer example and either put on github or attach as .zip. And include a readme with the install steps how to reproduce, thanks.


phermsdorf:1634788604:2021-10-21T11:56:44.921+0000:1634788604:2021-10-21T11:56:44.921+0000:Some insights while building the reproducer:
 * in my setup i have mutiple datasources. in this case the ""global"" autowiring of the datasource does not take place
 * what seems to be different (and the problem cause FMPOV) SqlComponent.createEndpoint:
 ** in 3.4.4 just at the beginning of the method the datasource is found and later bound to the endpoint by it's name parameter \{dataSource=My-Datasource}: DataSource ds = resolveAndRemoveReferenceParameter(parameters, ""dataSource"", DataSource.class);
 ** in 3.11.3 this part is missing. i think setProperties(endpoint, parameters) should set that property on the endpoint, but that doesn't happen (setDataSource is called but null is passed as value). it tries to resolve/convert type javax.sql.DataSource with value My-Datasource but doesn't finds a solution to that problem...

Is there something i need to additionally register or initialize in the osgi part?

Is the reproducer still needed? (it's bit complex with target definitions and launch configurations ...)

Thanks
davsclaus:1634796187:2021-10-21T14:03:07.813+0000:1634796187:2021-10-21T14:03:07.813+0000:You need to use `#bean:` syntax, eg dataSource=#bean:myDataSource

You can also use #myDataSource as shothand, but #bean: tells Camel you want to inject a bean with that id.
phermsdorf:1634797385:2021-10-21T14:23:05.100+0000:1634797385:2021-10-21T14:23:05.100+0000:Thanks for the hint. Indeed it's working that way.

I now notice the difference in the documentation beetween _?dataSource=myDS_ in 3.7 and _?dataSource=#myDS_ in latest.

Is this change documented somewhere? I looked at the migration guide but found no hint that that needs to be adjusted.

That also leads to changes in customer specific Camel-XML's - which is not that nice because this kind of problems are just discovered at runtime....

Thanks anyway!
davsclaus:1634798450:2021-10-21T14:40:50.688+0000:1634798450:2021-10-21T14:40:50.688+0000:The standard in Camel has always been # notation.
Its just that the old sql component was built many years ago and had unfortunately special code when there was no #.

On top of that Camel now supports autowiring options if they have been marked with that. See the doc where it says Autowired in bold in the description.

In case of upgrade guides, then you are surely welcome to send a PR to update the guide.
phermsdorf:1634863886:2021-10-22T08:51:26.278+0000:1634863886:2021-10-22T08:51:26.278+0000:I created [https://github.com/apache/camel/pull/6325]

Bye Peter"
0,CAMEL-17106,Bug,Major,3.12.0,,"
None
",Resolved,Invalid,None,Otavio Rodolfo Piske,Otavio Rodolfo Piske,0,2,2021-10-19 09:28:45+00:00,2021-10-19 12:47:57+00:00,"I was looking at the CI and code trying to understand why this test  [1] runs so much slower than the others (~20 secs) and I noticed something strange. 


 


Despite being configured to use 1 sec as the timeout [2], the value seems to be ignored and the request nonetheless times out only after 20 secs. 


 


Modifying the template's requestBody call to override the timeout using the CamelJmsRequestTimeout header seems to work-around the issue (and apparently fixes the test slowness as well). 


 



https://github.com/apache/camel/blob/8cd6b34e8bc753520f3153a354beb9765e3f2741/components/camel-jms/src/test/java/org/apache/camel/component/jms/JmsRouteRequestReplyTest.java#L407




https://github.com/apache/camel/blob/8cd6b34e8bc753520f3153a354beb9765e3f2741/components/camel-jms/src/test/java/org/apache/camel/component/jms/JmsRouteRequestReplyTest.java#L409
 #","orpiske:1634608228:2021-10-19T09:50:28.236+0000:1634608251:2021-10-19T09:50:51.921+0000:This happens because there is a mismatch between the component's configuration object and the endpoint's configuration object (see attachment camel-17106-1.png).

 

When processing the InOut exchange, the endpoint's timeout configuration is taking precedence over the component configuration [1].

 

1. [https://github.com/apache/camel/blob/8cd6b34e8bc753520f3153a354beb9765e3f2741/components/camel-jms/src/main/java/org/apache/camel/component/jms/JmsProducer.java#L193]
davsclaus:1634608701:2021-10-19T09:58:21.102+0000:1634608701:2021-10-19T09:58:21.102+0000:You should set the component level timeout sooner, you cannot alter it later in the test method. As at that point routes, endpoints et all has already been created/started etc.

orpiske:1634608831:2021-10-19T10:00:31.528+0000:1634608856:2021-10-19T10:00:56.129+0000:[~davsclaus] aha, thanks for clarifying! It hasn't been touched for a while, so I guess it may have been a leftover. In this case, I guess the right fix for the slow test is to use the header instead of setting it in the component.  Let's reject this ticket and I'll send a fix for the test specifically.
orpiske:1634610355:2021-10-19T10:25:55.833+0000:1634610355:2021-10-19T10:25:55.833+0000:Closing as invalid. Only the test needs to be adjusted to avoid the default request timeout."
0,CAMEL-17105,Bug,Major,"3.11.3, 3.12.0","3.13.0, 3.11.4","
None
",Resolved,Fixed,"3.13.0, 3.11.4",Claus Ibsen,Nick Smith,0,2,2021-10-18 20:58:06+00:00,2021-10-19 09:08:27+00:00,"In Camel 3.x Exchange was refactored and markRollbackOnly was changed 
from 2.x




    public boolean isRollbackOnly() {
        return Boolean.TRUE.equals(getProperty(Exchange.ROLLBACK_ONLY)) || Boolean.TRUE.equals(getProperty(Exchange.ROLLBACK_ONLY_LAST));
    }




 to 3.x




    public boolean isRollbackOnly() {
        return rollbackOnly;
    }




Now in TransactionErrorHandler.doInTransactionTemplate() doesn't throw TransactionRollbackException, cause isRollbackOnly false.




            protected void doInTransactionWithoutResult(TransactionStatus status) {
                // wrapper exception to throw if the exchange failed
                // IMPORTANT: Must be a runtime exception to let Spring regard it as to do ""rollback""
                RuntimeException rce;

                // and now let process the exchange by the error handler
                processByErrorHandler(exchange);

                // after handling and still an exception or marked as rollback only then rollback
                if (exchange.getException() != null || exchange.isRollbackOnly()) {

                    // wrap exception in transacted exception
                    if (exchange.getException() != null) {
                        rce = RuntimeCamelException.wrapRuntimeCamelException(exchange.getException());
                    } else {
                        // create dummy exception to force spring transaction manager to rollback
                        rce = new TransactionRollbackException();
                    }

                    if (!status.isRollbackOnly()) {
                        status.setRollbackOnly();
                    }

                    // throw runtime exception to force rollback (which works best to rollback with Spring transaction manager)
                    if (LOG.isTraceEnabled()) {
                        LOG.trace(""Throwing runtime exception to force transaction to rollback on {}"",
                                transactionTemplate.getName());
                    }
                    throw rce;
                }
            }",davsclaus:1634605707:2021-10-19T09:08:27.608+0000:1634605707:2021-10-19T09:08:27.608+0000:Thanks for reporting and the PR
0,CAMEL-17104,New Feature,Major,3.13.0,None,"
None
",Resolved,Fixed,3.13.0,Unassigned,Hokutor,0,1,2021-10-18 19:34:15+00:00,2021-10-20 13:40:36+00:00,"Currently, Huaweicloud OBS component doesn't support object download via producer mode. Need to support this","hokutor:1634708418:2021-10-20T13:40:18.971+0000:1634708418:2021-10-20T13:40:18.971+0000:PR merged - [https://github.com/apache/camel/pull/6308] 
hokutor:1634708436:2021-10-20T13:40:36.762+0000:1634708436:2021-10-20T13:40:36.762+0000:Merged via PR https://github.com/apache/camel/pull/6308"
0,CAMEL-17103,New Feature,Major,3.13.0,None,"
None
",Resolved,Fixed,3.13.0,Unassigned,Hokutor,0,1,2021-10-18 19:32:02+00:00,2021-10-25 06:01:24+00:00,"Currently, Huawei cloud OBS component doesn't support object upload in producer mode. Add the support for this feature",
0,CAMEL-17102,Improvement,Major,None,3.13.0,"
None
",Resolved,Fixed,3.13.0,Claus Ibsen,Claus Ibsen,0,1,2021-10-18 14:33:06+00:00,2021-10-19 05:38:58+00:00,"Reported on chat
https://camel.zulipchat.com/#narrow/stream/257298-camel/topic/Can't.20observe.20CamelContextInitializingEvent


These 2 events are emitted soo early during bootstrap that we should allow these to propagate despite the event notifier may not be fully started this early.


You can also say false to accept the event in the isEnabled method",
0,CAMEL-17101,Improvement,Major,None,3.13.0,"
None
",Resolved,Fixed,3.13.0,Claus Ibsen,Claus Ibsen,0,1,2021-10-18 13:19:59+00:00,2021-10-18 13:37:29+00:00,"If you use a Map as the message body then split via


split(body())


will not split the map into its entries, eg Set<Map.Entry> but containing the entire map as a single entity.


That is a bit weird we haven't talked about this before, that the ObjectHelper.createIterable does not have Map support (what the split uses to split).


A user had a bit trouble with the dropbox component that returns a Map of multiple files from dropbox
https://camel.zulipchat.com/#narrow/stream/257298-camel/topic/setUpDropboxCamel",
0,CAMEL-17100,Improvement,Major,"3.11.3, 3.12.0","3.14.4, 3.18.0","
None
",Resolved,Fixed,"3.14.4, 3.18.0",Andrea Cosentino,Andrea Cosentino,0,2,2021-10-18 11:25:29+00:00,2022-06-01 04:41:25+00:00,"It's not related to the maxMessagesPerPoll, because it is set correctly. The problems seems to be in the listObject operation.","acosentino:1634529617:2021-10-18T12:00:17.252+0000:1634529617:2021-10-18T12:00:17.252+0000:The behavior seems to be correct, but the initial listing is really slow.
acosentino:1634616456:2021-10-19T12:07:36.400+0000:1634616456:2021-10-19T12:07:36.400+0000:S3 consumer doesn't behave in the same way and the code is really similar, need to dig a bit. But this is related to camel-minio only.
davsclaus:1635987478:2021-11-04T08:57:58.426+0000:1635987478:2021-11-04T08:57:58.426+0000:Okay so even if its slow its working correctly. Then lets focus this for 3.14"
0,CAMEL-17099,Dependency upgrade,Major,None,3.15.0,"
None
",Resolved,Fixed,3.15.0,Andrea Cosentino,Claus Ibsen,0,2,2021-10-17 18:23:42+00:00,2022-02-02 09:39:25+00:00,"We should check with Spring Boot, Quarkus etc if they support this release.


The camel-kubernetes latest version requires jackson 2.13.x that causes OSGi feature failure. 


[ERROR] 	Feature resolution failed for [camel-kubernetes/3.13.0.SNAPSHOT]
[ERROR] Message: Unable to resolve root: missing requirement [root] osgi.identity; osgi.identity=camel-kubernetes; type=karaf.feature; version=3.13.0.SNAPSHOT; filter:=""(&(osgi.identity=camel-kubernetes)(type=karaf.feature)(version>=3.13.0.SNAPSHOT))"" [caused by: Unable to resolve camel-kubernetes/3.13.0.SNAPSHOT: missing requirement [camel-kubernetes/3.13.0.SNAPSHOT] osgi.identity; osgi.identity=io.fabric8.openshift-model; type=osgi.bundle; version=""[5.9.0,5.9.0]""; resolution:=mandatory [caused by: Unable to resolve io.fabric8.openshift-model/5.9.0: missing requirement [io.fabric8.openshift-model/5.9.0] osgi.wiring.package; filter:=""(&(osgi.wiring.package=com.fasterxml.jackson.annotation)(version>=2.13.0)(!(version>=3.0.0)))""]]","acosentino:1634506566:2021-10-18T05:36:06.412+0000:1634506566:2021-10-18T05:36:06.412+0000:Quarkus is still at 2.12.5, for 2.4.0.CR1 too.

So we should upgrade for 3.13.0 and eventually we'll override the version with the one from Quarkus bom.
acosentino:1634518783:2021-10-18T08:59:43.381+0000:1634518783:2021-10-18T08:59:43.381+0000:There are a lot of problems while trying to update, so I'd say lets use the 2.13.0 dependency just in camel-kubernets karaf feature for the moment. It's to early to move everything to 2.13.x"
0,CAMEL-17098,Dependency upgrade,Minor,None,3.13.0,"
None
",Resolved,Fixed,3.13.0,Claus Ibsen,Claus Ibsen,0,1,2021-10-17 18:12:50+00:00,2021-10-17 18:22:28+00:00,CXF 3.4.5 is released,
0,CAMEL-17097,Improvement,Major,None,3.x,"
None
",Resolved,Fixed,3.x,Luca Burgazzoli,Marat Gubaidullin,0,3,2021-10-17 16:55:16+00:00,2022-09-03 10:28:36+00:00,"1. YAML DSL uses Camel Case for Component parameters, ex authorizationToken




- from:
    uri: ""timer://tick""
    parameters:
      period: ""1s""
    steps:
      - to:
          uri: ""telegram:bots""
          parameters:
            authorizationToken: ""XXX""




 


2. YAML DSL uses Kebab Case for EIP and EIP parameters, ex: do-catch, wire-tap, parameters etc


3. Kamelet properties are in Camel Case.


4. Kubernetes part of Integration is also in Camel Case: apiVersion: camel.apache.org/v1


I would like to propose to synchronize YAML DSL for the only one case: ex. Camel Case to be more Kubernetes standard oriented","lb:1634463199:2021-10-17T17:33:19.947+0000:1634463199:2021-10-17T17:33:19.947+0000:that's possible however it would require at least one release when we support both.
davsclaus:1634612059:2021-10-19T10:54:19.848+0000:1634612059:2021-10-19T10:54:19.848+0000:Yeah for EIPs we should maybe use same case as we do for XML, eg what they are named in the model definition classes.
So that means CamelCased, eg wireTap and so on. Then the DSL examples are more similar.

The parameters, can however be in mixed style as it uses the property binding support in camel-core that accepts all kind of styles.
marat.gubaidullin@gmail.com:1638280684:2021-11-30T21:58:04.740+0000:1638280684:2021-11-30T21:58:04.740+0000:I would be great to support parameters in camelCase as well to have some consistency "
0,CAMEL-17096,New Feature,Major,3.12.0,3.13.0,"
None
",Resolved,Fixed,3.13.0,Unassigned,Ludovic Boutros,0,2,2021-10-17 12:48:53+00:00,2021-10-19 18:19:09+00:00,"Currently it's not possible to use manual commit with aggregation's completion timeout strategies because the thread which will do the commit will not be the consumer thread.


Async commit is not implemented either.


I think implementing the async commit in the consumer loop could solve this problem.
This could fix CAMEL-16064 as well.",davsclaus:1634638749:2021-10-19T18:19:09.922+0000:1634638749:2021-10-19T18:19:09.922+0000:Thanks for the PR
0,CAMEL-17095,Bug,Major,"3.11.3, 3.12.0",None,"
None
",Resolved,Fixed,"3.13.0, 3.11.4",Claus Ibsen,Claus Ibsen,0,1,2021-10-17 12:00:42+00:00,2021-10-17 12:03:34+00:00,"Reported on user mailing list


A reproducer here
https://github.com/sys-jdi/camel-timeout-test",
0,CAMEL-17094,Improvement,Major,None,,"
None
",Resolved,Won't Fix,None,Unassigned,Marat Gubaidullin,0,2,2021-10-16 16:16:34+00:00,2023-07-17 11:25:55+00:00,"All DSLs in steps array start with DSL name field, ex: filter and to




steps:    
    - filter:  
         simple: ""${body}""
         steps: 
            - to: ""mock:filter""
    - to: ""mock:result""




but in when array WhenDefinition steps: simple and expression




when: 
    - simple: ""${body.size()} == 1""
      steps: 
          - to: ""log:when-a""
    - expression: 
        simple: ""${body.size()} == 2""
      steps: 
          - to: ""log:when-b""




Could we unified YAML DSL for arrays of Definitions? Ex.:




when: 
    - when: 
          expression: 
              simple: ""${body.size()} == 2""
          steps: 
              - to: ""log:when-a""
    - when: 
          expression: 
              simple: ""${body.size()} == 2""
          steps: 
              - to: ""log:when-b""","lb:1634428695:2021-10-17T07:58:15.770+0000:1634428695:2021-10-17T07:58:15.770+0000:{code:yaml}
when: 
    - when: 
{code}

This is not possible as it is ambiguous for the resolution and to be honest it seems ambiguous also for the developer point of view as you have the same key for two different purposes.
marat.gubaidullin@gmail.com:1634444573:2021-10-17T12:22:53.309+0000:1634444573:2021-10-17T12:22:53.309+0000:Agree. Perhaps this one works: 

{code:yaml}
clauses: 
    - when: 
          expression: 
              simple: ""${body.size()} == 2""
          steps: 
              - to: ""log:when-a""
    - when: 
          expression: 
              simple: ""${body.size()} == 2""
          steps: 
              - to: ""log:when-b""
{code}
lb:1634463122:2021-10-17T17:32:02.758+0000:1634463122:2021-10-17T17:32:02.758+0000:it can but would diverge from other dsl and would probably require some changes to the model as the code is auto generated so we need to estimate the impact


lb:1634521513:2021-10-18T09:45:13.878+0000:1634521513:2021-10-18T09:45:13.878+0000:[~davsclaus] what do you think ?"
0,CAMEL-17059,Improvement,Major,3.12.0,None,"

perfomance

",Resolved,Fixed,3.13.0,Otavio Rodolfo Piske,Otavio Rodolfo Piske,0,1,2021-10-09 09:40:17+00:00,2021-10-13 18:20:52+00:00,"The file component is performance sensitive and we have some places in the File component where the code could be optimized. 


For example, it is creating a List<File> instance [1] that could result in several thousands of objects. We could adjust it to avoid this to use native arrays or an Object type to avoid the overhead.


 


1. https://github.com/apache/camel/blob/22c7af563c067fc34c141da3de1338d7e37c3525/components/camel-file/src/main/java/org/apache/camel/component/file/FileConsumer.java#L99",orpiske:1634032555:2021-10-12T17:55:55.512+0000:1634032555:2021-10-12T17:55:55.512+0000:It should have been fixed by the linked PR for 3.13.0.
0,CAMEL-17058,Improvement,Major,None,Future,"
None
",Resolved,Abandoned,Future,Unassigned,Claus Ibsen,0,1,2021-10-09 08:37:24+00:00,2023-11-22 20:09:57+00:00,"We have started to collect icons in the kamelets and many of those icons would be the same as the camel components.
https://camel.apache.org/camel-kamelets/latest/


It may be worth to allow to have those icons in the components so they get into the camel-catalog as well. 


There is more and more tooling that can benefit from this.


The icons in kamelets are base64 encoded in the yaml spec file.",
0,CAMEL-17057,Improvement,Major,None,3.15.0,"
None
",Resolved,Fixed,3.15.0,Karen Lease,Claus Ibsen,0,2,2021-10-09 08:07:40+00:00,2022-01-17 14:38:53+00:00,"Using mongodb is not as easy to configure when you need to use that mongodb client url that has a ton of configurations in a string. 


Today you have to create that MongoDBClient instance yourself via constructors, so you end up having to write Java code.


For *** sake could they not just make their client api easier to configure.


On chat forum
https://camel.zulipchat.com/#narrow/stream/257299-camel-k/topic/MongoDB.20connection.20configuration","davsclaus:1633738134:2021-10-09T08:08:54.252+0000:1633738134:2021-10-09T08:08:54.252+0000:This is the client you need to create
https://mongodb.github.io/mongo-java-driver/3.6/javadoc/com/mongodb/MongoClient.html

And this is that client url thingy you need to create too
https://mongodb.github.io/mongo-java-driver/3.6/javadoc/com/mongodb/MongoClientURI.html
klease78:1641908731:2022-01-11T21:45:31.782+0000:1641908731:2022-01-11T21:45:31.782+0000:In current camel versions (after 3.7), if the hosts option is specified in the endpoint URL (for example ""mongodb:myDb?hosts=localhost&database=test&collection=test&operation=findAll""), then the ""myDB"" is ignored. So technically it's not necessary to write java code to create the MongoClient; but it's confusing to have a required bean which is not really required.
davsclaus:1641940737:2022-01-12T06:38:57.710+0000:1641940737:2022-01-12T06:38:57.710+0000:Ah okay, so can we can avoid the bean lookup if hosts parameter is provided, and if so then you are welcome to work on the code to make it work like that.
klease78:1642079335:2022-01-13T21:08:55.734+0000:1642079335:2022-01-13T21:08:55.734+0000:It already works like that. In fact, if you specify hosts, then you can use a URL like the one in the (working) test below with no name for the connection bean:
{code:java}
 
@Test
    void testMongoDbEndpoint() {
        MongoDbEndpoint mongoDb = context.getEndpoint(""mongodb:?hosts=localhost&database=test&collection=test&operation=findAll"",
                MongoDbEndpoint.class);
        assertNotNull(mongoDb);
        assertNotNull(mongoDb.getMongoConnection());
        assertNotNull(mongoDb.getMongoConnection().getDatabase(""test""));
        assertEquals(""test"", mongoDb.getCollection());
        assertEquals(""findAll"", mongoDb.getOperation().toString());
    }
{code}
I could add such a test to the code base and also add such a sample URL to the documentation.
 
davsclaus:1642080336:2022-01-13T21:25:36.421+0000:1642080336:2022-01-13T21:25:36.421+0000:Yes that would be good, thanks Karen"
0,CAMEL-17056,Improvement,Major,None,3.13.0,"
None
",Resolved,Fixed,3.13.0,Claus Ibsen,Claus Ibsen,0,1,2021-10-09 07:54:17+00:00,2021-10-09 07:59:09+00:00,The -starter has some special customizer code that was before we have component customizer api directly in camel-core,
0,CAMEL-17055,Bug,Minor,3.12.0,3.13.0,"
None
",Resolved,Fixed,3.13.0,Claus Ibsen,David Jencks,0,2,2021-10-09 05:57:32+00:00,2021-10-09 08:01:58+00:00,"The hazelcast spring boot autoconfigure info have two  duplicate options/properties.


In the hazelcast.json file:


```


{
      ""name"": ""camel.component.hazelcast-topic.customizer.hazelcast-instance.enabled"",
      ""type"": ""java.lang.Boolean"",
      ""description"": ""Enable or disable the cache-manager customizer."",
      ""sourceType"": ""org.apache.camel.component.hazelcast.instance.springboot.customizer.HazelcastInstanceCustomizerConfiguration"",
      ""defaultValue"": true
    }

,


{
      ""name"": ""camel.component.hazelcast-topic.customizer.hazelcast-instance.enabled"",
      ""type"": ""java.lang.Boolean"",
      ""description"": ""Enable or disable the cache-manager customizer."",
      ""sourceType"": ""org.apache.camel.component.hazelcast.topic.springboot.customizer.HazelcastInstanceCustomizerConfiguration"",
      ""defaultValue"": true
    }

,


{
      ""name"": ""camel.component.hazelcast-topic.customizer.hazelcast-instance.override"",
      ""type"": ""java.lang.Boolean"",
      ""description"": ""Configure if the cache manager eventually set on the component should be overridden by the customizer."",
      ""sourceType"": ""org.apache.camel.component.hazelcast.instance.springboot.customizer.HazelcastInstanceCustomizerConfiguration"",
      ""defaultValue"": false
    }

,


{
      ""name"": ""camel.component.hazelcast-topic.customizer.hazelcast-instance.override"",
      ""type"": ""java.lang.Boolean"",
      ""description"": ""Configure if the cache manager eventually set on the component should be overridden by the customizer."",
      ""sourceType"": ""org.apache.camel.component.hazelcast.topic.springboot.customizer.HazelcastInstanceCustomizerConfiguration"",
      ""defaultValue"": false
    }

,
```
(lines 755-782)


I haven't located where this is generated from.","davsclaus:1633735585:2021-10-09T07:26:25.959+0000:1633735585:2021-10-09T07:26:25.959+0000:Yeah for some reason the topic has duplicates, the others do not
davsclaus:1633736601:2021-10-09T07:43:21.861+0000:1633736601:2021-10-09T07:43:21.861+0000:Its likely a bug in spring boot that generates this file
davsclaus:1633737718:2021-10-09T08:01:58.546+0000:1633737718:2021-10-09T08:01:58.546+0000:Fixed by CAMEL-17056"
0,CAMEL-17054,New Feature,Major,None,3.13.0,"
None
",Resolved,Fixed,3.13.0,Unassigned,Guillaume,0,3,2021-10-08 09:25:25+00:00,2021-10-09 06:16:43+00:00,"Support nats headers in the camel consumer and producer, by forwarding the ones provided.


nats sdk: https://nats.io/blog/headers-java-client/


nats server: https://docs.nats.io/whats_new_22","acosentino:1633656472:2021-10-08T09:27:52.162+0000:1633656472:2021-10-08T09:27:52.162+0000:You're welcome to provide a PR.
Doussin:1633658586:2021-10-08T10:03:06.444+0000:1633658586:2021-10-08T10:03:06.444+0000:Thanks, PR opened :)
davsclaus:1633731403:2021-10-09T06:16:43.184+0000:1633731403:2021-10-09T06:16:43.184+0000:Thanks for the PR"
0,CAMEL-17053,Dependency upgrade,Minor,None,3.13.0,"
None
",Resolved,Fixed,3.13.0,Andrea Cosentino,Claus Ibsen,0,1,2021-10-08 08:55:13+00:00,2021-10-08 14:57:36+00:00,No Desc,
0,CAMEL-17052,Task,Minor,"3.11.3, 3.12.0",None,"
None
",Resolved,Fixed,"3.13.0, 3.11.4",James Netherton,James Netherton,0,2,2021-10-08 08:41:03+00:00,2021-10-12 09:33:10+00:00,"In camel-parent, azure-bom is imported before netty-bom. This has the effect of azure managing the version of all netty dependencies in the project.


If you run mvn dependency:tree -Dincludes=io.netty from the project root, all of the netty dependencies show as being version 4.1.63.Final. It should be 4.1.68.Final as per the <netty-version> property.","acosentino:1633653841:2021-10-08T08:44:01.619+0000:1633653841:2021-10-08T08:44:01.619+0000:For completeness. If you run versions:display-dependency-updates the output will be influenced by this order
jamesnetherton:1633655124:2021-10-08T09:05:24.500+0000:1633655124:2021-10-08T09:05:24.500+0000:Maybe we should wait for Netty 4.1.69.Final before fixing this? 4.1.68 requires an annoying workaround because netty-bom is broken:

https://github.com/netty/netty/issues/11691
acosentino:1633655212:2021-10-08T09:06:52.916+0000:1633655212:2021-10-08T09:06:52.916+0000:Sounds good.
acosentino:1633992578:2021-10-12T06:49:38.026+0000:1633992578:2021-10-12T06:49:38.026+0000:Netty is out and I updated the version, you can go ahead [~jamesnetherton]"
0,CAMEL-17051,New Feature,Minor,3.12.0,3.17.0,"
None
",Resolved,Fixed,3.17.0,Otavio Rodolfo Piske,Zachariah Young,0,3,2021-10-07 13:31:24+00:00,2022-05-18 15:02:42+00:00,"When handling transient errors that have exhausted retry limits, sometimes pausing the Kafka consumer is the best way to handle an outage.  A great example of this would be the Facebook outage that happen this week.


One might suggest that stopping the consumer work would for this use case.  This would of course work but would require a manual restart.  Also, you want to try to avoid a rebalance of the consumer.


I would like to see a new strategy be created that would allow for pause and resume to be configured.


Ideally, the resume could be configured based on a health check.


 


Example code: https://github.com/jeanlouisboudart/retriable-consumer/blob/master/consumer/src/main/java/com/sample/InfiniteRetriesConsumer.java","orpiske:1633587172:2021-10-07T14:12:52.294+0000:1633587172:2021-10-07T14:12:52.294+0000:At first sight there may be a small overlap in the restart/resume part of this ticket, which could be covered on the SPI to be introduced by CAMEL-15562. Therefore, I am marking it as related - but subject to further analysis.
orpiske:1634113399:2021-10-13T16:23:19.884+0000:1634113399:2021-10-13T16:23:19.884+0000:Linking some reference code from [~zachariahyoung]: https://github.com/zachariahyoung/camel-kafka-examples
orpiske:1649811901:2022-04-13T09:05:01.593+0000:1649811901:2022-04-13T09:05:01.593+0000:Implemented, therefore closing. If there's any feedback about the feature, please let us know."
0,CAMEL-17050,Bug,Major,"2.4.0, 3.4.6, 3.7.2, 3.11.0",,"
None
",Resolved,Not A Bug,None,Unassigned,Alex Mattern,0,2,2021-10-07 12:50:57+00:00,2021-10-07 12:57:21+00:00,"What: Oracle AQ JMS transaction and the Oracle INSERT transaction are separate. These should be committed in the same transaction.


Why: possible duplicate row insert. Each consumer thread is borrowing two database connections from the pool instead of one.


Recreate: When the routes are running under load I can kill -9 the camel process. The result is that the in-flight message rolls back, but the INSERTed row remains.




// Example Route Java code
from(getInputAQ())
.routeId(""AQ_ROUTE"")
.autoStartup(true)
.transacted(""PROPAGATION_REQUIRED"")
.process(""OracleInsertProcessor"")
.to(getOutputAQ())






// Example Database Insert Java code
@Autowired
private JdbcTemplate jdbcTemplate;

public int save(List<T> list)
{
    int[] insertCountArray = getJdbcTemplate().batchUpdate(getInsertQuery(), new BatchPreparedStatementSetter()
    {
        @Override
        public void setValues(PreparedStatement ps, int i) throws SQLException
        {
            buildInsertParameters(ps, list.get(i));
        }

        @Override
        public int getBatchSize()
        {
            return list.size();
        }
    });
    return getTotalCount(insertCountArray);
}






 // Example Context file
<!-- oracle aq set up --> <bean id=""jdbcTemplate"" class=""org.springframework.jdbc.core.JdbcTemplate""> <property name=""dataSource"" ref=""dataSource""/> </bean> <bean id=""dataSource"" class=""oracle.ucp.jdbc.PoolDataSourceFactory"" factory-method=""getPoolDataSource""> <property name=""URL"" value=""${jdbc.url}"" /> <property name=""user"" value=""${jdbc.username}"" /> <property name=""password"" value=""${jdbc.pwd}')}"" /> <property name=""connectionFactoryClassName"" value=""oracle.jdbc.pool.OracleDataSource"" /> <property name=""connectionPoolName"" value=""ORACLE_POOL"" /> <property name=""minPoolSize"" value=""${minPoolSize}"" /> <property name=""maxPoolSize"" value=""${maxPoolSize}"" /> <property name=""initialPoolSize"" value=""${initialPoolSize}"" /> <property name=""queryTimeout"" value=""${queryTimeout}"" /> <property name=""inactiveConnectionTimeout"" value=""${inactiveConnectionTimeout}"" /> <property name=""validateConnectionOnBorrow"" value=""true"" /> <property name=""secondsToTrustIdleConnection"" value=""${secondsToTrustIdleConnection}"" /> <property name=""timeToLiveConnectionTimeout"" value=""${timeToLiveConnectionTimeout}"" /> <property name=""maxStatements"" value=""10"" /> </bean> <bean id=""dbTransactionManager"" class=""org.springframework.jdbc.datasource.DataSourceTransactionManager""> <property name=""dataSource"" ref=""dataSource"" /> <property name=""defaultTimeout"" value = ""60""/> </bean> <bean id=""PROPAGATION_REQUIRED"" class=""org.apache.camel.spring.spi.SpringTransactionPolicy""> <property name=""transactionManager"" ref=""dbTransactionManager"" /> <property name=""propagationBehaviorName"" value=""PROPAGATION_REQUIRED"" /> </bean> <bean id=""PROPAGATION_REQUIRES_NEW"" class=""org.apache.camel.spring.spi.SpringTransactionPolicy""> <property name=""transactionManager"" ref=""dbTransactionManager"" /> <property name=""propagationBehaviorName"" value=""PROPAGATION_REQUIRES_NEW"" /> </bean> <bean id=""PROPAGATION_SUPPORTS"" class=""org.apache.camel.spring.spi.SpringTransactionPolicy""> <property name=""transactionManager"" ref=""dbTransactionManager"" /> <property name=""propagationBehaviorName"" value=""PROPAGATION_SUPPORTS"" /> </bean> <bean id=""aqJmsConnectionFactory"" class=""oracle.jms.AQjmsConnectionFactory""> <property name=""datasource"" ref=""dataSource""/> </bean> <bean id=""aqjms"" class=""org.apache.camel.component.jms.JmsComponent""> <property name=""connectionFactory"" ref=""aqJmsConnectionFactory"" /> <property name=""transacted"" value=""true"" /> <property name=""transactionManager"" ref=""dbTransactionManager"" /> </bean>




Acceptance Criteria:



Single consumer thread using camel-jms with Oracle AQ only uses one database connection for JMS and CRUD operations.
JMS and CRUD operations on a single Oracle database operate within the same transaction to prevent duplicate messages.","davsclaus:1633582641:2021-10-07T12:57:21.637+0000:1633582641:2021-10-07T12:57:21.637+0000:The auto wired jdbc template is not a Camel component or Camel doing this, its your own custom code.

To make transactions work, then you need to setup spring transaction so it autowrie that jdbc template as a transactional resource and whatnot.

Get help first on the mailing list / chat room."
0,CAMEL-17049,Bug,Minor,"3.11.1, 3.11.2, 3.11.0","3.13.0, 3.11.4","
None
",Resolved,Fixed,"3.13.0, 3.11.4",Unassigned,Henrik Karlsson,0,1,2021-10-07 08:30:32+00:00,2021-10-17 00:42:16+00:00,"This is related to CAMEL-17043. The parameters authUsername and authPassword needs to be available then the endpoints is created which the aren't even after the changes in CAMEL-17043. In the method createProducer in HttpComponent the endpoint is created like this:




HttpEndpoint endpoint = camelContext.getEndpoint(url, HttpEndpoint.class);
setProperties(endpoint, parameters);




Then setProperties is called it's to late because the authentication is already set on the endpoint. The signature of the getEndpoint used looks like this:




<T extends Endpoint> T getEndpoint(String name, Class<T> endpointType);




It feels a bit strange to use the url as name for the endpoint. So I found this variant for getEndpoint:




Endpoint getEndpoint(String uri, Map<String, Object> parameters);




Replacing the two lines above with this one solves the problem:




HttpEndpoint endpoint = (HttpEndpoint) camelContext.getEndpoint(url, parameters);",
0,CAMEL-17048,Bug,Minor,3.12.0,3.13.0,"
None
",Resolved,Fixed,3.13.0,Claus Ibsen,Andre,0,2,2021-10-07 07:20:53+00:00,2021-10-08 07:55:13+00:00,"After upgrading camel from 3.11.2 to 3.12.0 I notice that a header I set in a processor is not being available ""later on"" anymore.


It looks as follows:


Route



from(source)
  .process(myprocessor::setHeader)
  ...
  .process(anotherprocessor)
  ..
  .to(target)
;




where myprocessor.setHeader does sth like



void setHeader(Exchange exchange) {
  exchange.getIn().setHeader(""my-header"", 1234);
}




and anotherprocessor wants to access this header, e.g.



@Override
void process(Exchange exchange) {
  ...
  Long value = exchange.getIn().getHeader(""my-header"", Long.class);
  if (value == null) { 
    throw ..
  }
}




While with 3.11.x this works fine it stopped with 3.12.0.","davsclaus:1633565525:2021-10-07T08:12:05.358+0000:1633565563:2021-10-07T08:12:43.628+0000:Can you debug / trace to see if that header is set at all. Also can you build an unit test that reproduce this.

And how do you run Camel.
adoser:1633578684:2021-10-07T11:51:24.373+0000:1633578684:2021-10-07T11:51:24.373+0000:h3. Example

Camel is run in a springboot service:
{noformat}
spring boot: 2.5.5
...
org.apache.camel.springboot:camel-ftp-starter:3.12.0
org.apache.camel.springboot:camel-zipfile-starter:3.12.0
org.apache.camel.springboot:camel-log-starter:3.12.0
{noformat}
I narrowed it down to the ""transacted"" statement I have in my route, see the following example:
{noformat}
@Component
public class MyRoute extends EndpointRouteBuilder {

    @Component
    private static class ProcessorSet implements Processor {

        @Override
        public void process(Exchange exchange) throws Exception {
            exchange.getIn().setHeader(""my-header"", 1234L);
            exchange.getIn().setBody(List.of(""a"", ""b""));
            System.out.println(""Set body and header"");
        }

    }

    @Component
    private static class ProcessorGet implements Processor {

        @Override
        public void process(Exchange exchange) throws Exception {
            Object body = exchange.getIn().getBody();
            Long header = exchange.getIn().getHeader(""my-header"", Long.class);
            System.out.println(""Got body="" + body + "" and header="" + header);
        }

    }

    @Autowired
    ProcessorSet processorSet;
    @Autowired
    ProcessorGet processorGet;

    @Override
    public void configure() throws Exception {
        from(""file:./data"").routeId(""test"")
                           .process(processorSet)
                           .transacted()
                           .split(bodyAs(Iterator.class))
                           .streaming()
                           .process(processorGet)
                           .to(""log:foo"");
    }

}

{noformat}
and my very basic unit test
{noformat}
@SpringBootTest
public class MainTest {

    @Test
    public void test() throws InterruptedException {
        while(true) {

        }
    }
}
{noformat}
by just putting a random file into the {{./data}} folder.
h3. Outcome
h3. With 3.12 and ""transacted""
{noformat}
Got body=GenericFile[test] and header=null
Set body and header
{noformat}
h3. With 3.12 and not transacted
{noformat}
Set body and header
Got body=a and header=1234
Got body=b and header=1234
{noformat}
h3. With 3.11.2 and ""transacted""
{noformat}
Set body and header
Got body=a and header=1234
Got body=b and header=1234
{noformat}
h3. With 3.11.2 and not transacted
{noformat}
Set body and header
Got body=a and header=1234
Got body=b and header=1234
{noformat}
h3. Observations

If I change the code to put the {{transacted}} *before* the processor it seems to work - so therefore this bug here is most likely invalid.
 Yet I would still be very interested in *why* this is happening or more if this was a bug in 3.11.x ?

Thanks.
davsclaus:1633580500:2021-10-07T12:21:40.158+0000:1633580500:2021-10-07T12:21:40.158+0000:Ah okay, transacted should always be first. Unfortunately the model dont have a nice enforcement of this. Thought we do have some code that validates the order and it seems not to detect this.
davsclaus:1633650832:2021-10-08T07:53:52.708+0000:1633650832:2021-10-08T07:53:52.708+0000:Thanks for the test cases"
0,CAMEL-17047,Dependency upgrade,Major,3.11.2,"3.11.3, 3.13.0","
None
",Resolved,Fixed,"3.11.3, 3.13.0",Freeman Yue Fang,Freeman Yue Fang,0,1,2021-10-06 17:59:01+00:00,2021-10-07 05:16:32+00:00,currently it's 1.1.1 so can't work with JDK11,"ffang:1633514703:2021-10-06T18:05:03.143+0000:1633514769:2021-10-06T18:06:09.546+0000:This is the related discussion from karaf mailling list
http://mail-archives.apache.org/mod_mbox/karaf-user/202110.mbox/browser
with title ""camel-karaf : IllegalArgumentException: Invalid Java version 55 at"""
0,CAMEL-17046,Bug,Minor,"3.11.1, 3.11.2, 3.11.0",None,"
None
",Resolved,Fixed,3.13.0,Unassigned,Henrik Karlsson,0,2,2021-10-06 11:57:40+00:00,2021-10-12 06:45:32+00:00,"According to the documentation you should be able to specify the body and output media type using the convenience methods bodyMediaType() and outputMediaType(). But these methods aren't available in the Java DSL. Trying to use bodyMediaType() the IDE (Eclipse) reports this error:
""The method bodyMediaType(String) is undefined for the type ValueBuilder""
Compiling gives this error:
""Compilation failure: 
[ERROR] Routes.java:[37,85] cannot find symbol
[ERROR]   symbol:   method bodyMediaType(java.lang.String)
[ERROR]   location: class org.apache.camel.builder.ValueBuilder""","henka-rl:1633499051:2021-10-06T13:44:11.039+0000:1633499051:2021-10-06T13:44:11.039+0000:I've created a test class that uses Java DSL to show this. Should I create a PR with that class?
henka-rl:1633501407:2021-10-06T14:23:27.784+0000:1633501407:2021-10-06T14:23:27.784+0000:Think I found the problem. There is no DatasonnetBuilder implementation that has bodyMediaType or outputMediaType. I'm submitting a PR with a DatasonnetBuilder
davsclaus:1633554967:2021-10-07T05:16:07.167+0000:1633554967:2021-10-07T05:16:07.167+0000:As workaround you can create the DataSonnetExpression where you can set those types and use in the DSL
henka-rl:1633556920:2021-10-07T05:48:40.963+0000:1633556957:2021-10-07T05:49:17.880+0000:Could this be included in 3.11.3 as well?
henka-rl:1633991734:2021-10-12T06:35:34.840+0000:1633991734:2021-10-12T06:35:34.840+0000:As CAMEL-17067 is fixed in 3.11.4 shouldn't this be in 3.11.4 as well?
davsclaus:1633992332:2021-10-12T06:45:32.774+0000:1633992332:2021-10-12T06:45:32.774+0000:No there is a workaround"
0,CAMEL-17045,Improvement,Major,None,None,"
None
",Resolved,Fixed,3.13.0,Otavio Rodolfo Piske,Otavio Rodolfo Piske,0,1,2021-10-05 13:41:02+00:00,2021-10-13 18:31:09+00:00,Add support for the resume strategy on the file component,"orpiske:1634020840:2021-10-12T14:40:40.577+0000:1634020840:2021-10-12T14:40:40.577+0000:Mostly done. It's still missing the unit test.
orpiske:1634113245:2021-10-13T16:20:45.975+0000:1634113245:2021-10-13T16:20:45.975+0000:Merged to main with unit tests."
0,CAMEL-17044,Dependency upgrade,Major,None,3.13.0,"
None
",Resolved,Fixed,3.13.0,Andrea Cosentino,Claus Ibsen,0,1,2021-10-05 07:30:38+00:00,2021-10-05 08:01:22+00:00,No Desc,
0,CAMEL-17043,Bug,Minor,"3.11.1, 3.11.2, 3.11.0","3.11.3, 3.13.0","
None
",Resolved,Fixed,"3.11.3, 3.13.0",Unassigned,Henrik Karlsson,0,2,2021-10-05 06:41:36+00:00,2021-10-07 08:31:21+00:00,When using camel-rest-openapi to call a rest api any endpoint query parameters (ex. throwExceptionOnFailure) isn't used when the producer is created with the underlaying component (ex. http),"davsclaus:1633388646:2021-10-05T07:04:06.828+0000:1633388646:2021-10-05T07:04:06.828+0000:Can you provide more details, code samples, reproducer etc to better understand this
henka-rl:1633393389:2021-10-05T08:23:09.112+0000:1633393389:2021-10-05T08:23:09.112+0000:https://github.com/apache/camel/pull/6211
henka-rl:1633393837:2021-10-05T08:30:37.998+0000:1633393837:2021-10-05T08:30:37.998+0000:I've setup a RestOpenApiComponent like this:

    <*bean* id=_""s-keycloak""_ class=_""org.apache.camel.component.rest.openapi.RestOpenApiComponent""_>

        <*property* name=_""specificationUri""_ value=_""classpath:api/s-keycloak-v1.json""_/>

        <*property* name=_""componentName""_ value=_""https""_/>

        <*property* name=_""useGlobalSslContextParameters""_ value=_""true""_/>

        <*property* name=_""host""_ value=_""${s-keycloak.host}""_/>

        <*property* name=_""basePath""_ value=_""${s-keycloak.path}""_/>

    </*bean*>

And when I call a method using this:

.to(""s-keycloak:GetUsers?throwExceptionOnFailure=false"")

If the method returns 404 I get an exception as throwExceptionOnFailure isn't set on the endpoint created with the 'https' component.

With the change in my PR these properties will be set when setting up the 'https' component endpoint.
davsclaus:1633394700:2021-10-05T08:45:00.787+0000:1633394700:2021-10-05T08:45:00.787+0000:Thanks for reporting and the PR"
0,CAMEL-17042,Task,Minor,None,3.13.0,"
None
",Resolved,Fixed,3.13.0,Unassigned,Claus Ibsen,0,1,2021-10-04 20:08:44+00:00,2021-10-04 20:40:52+00:00,"maven 3.8.3 has been released, we should upgrade our wrapper to this version",
0,CAMEL-17041,New Feature,Major,None,3.13.0,"
None
",Resolved,Fixed,3.13.0,Unassigned,Claus Ibsen,0,1,2021-10-04 19:39:29+00:00,2021-10-06 17:30:47+00:00,"Today you have to use the full FQN class name, so if you have com.foo.bar.Company class, then you have to use that long name.


In Java you can then use string concat such as


to(""jpa:"" + Company.class.getName() + ""...""


But it would be nice if we can configure alias on the component, so you can do


to(""jpa:Company?...""


Where Company is the alias name.


Since the classes have JPA annotations such as @Entity then camel-quarkus could have a build step that scans the project and find all these classes and can automatic do the alias by the shorthand class name.",
0,CAMEL-17040,Improvement,Major,None,4.2.0,"
None
",Resolved,Fixed,4.2.0,Unassigned,Claus Ibsen,0,2,2021-10-04 19:35:30+00:00,2023-10-11 13:27:48+00:00,"For example if you have a json response as an empty list, then you can get a 200 OK with [] as response.


Or with an XML then it may be an empty xml root object.


It may be desirable to have an option you can set to true to let Camel auto-detect this and return no body and 204 instead.","neoxu9999:1644897413:2022-02-15T11:56:53.141+0000:1644897413:2022-02-15T11:56:53.141+0000:If it is json response, can it be three different cases [], {}, """"?
davsclaus:1644900073:2022-02-15T12:41:13.659+0000:1644900073:2022-02-15T12:41:13.659+0000:Yeah an empty string or null body etc
neoxu9999:1644979448:2022-02-16T10:44:08.293+0000:1644979567:2022-02-16T10:46:07.817+0000:Is RestProducerBindingProcessor the out point to check enableAutoDetect and set 204?

org.apache.camel.component.rest.RestProducerBindingProcessor.RestProducerBindingUnmarshalCallback#doDone 

By the way, I have added enableAutoDetect to the following files. I need some help to check the out point. 
{code:java}
core/camel-api/src/main/java/org/apache/camel/spi/RestConfiguration.java
core/camel-core-engine/src/generated/java/org/apache/camel/impl/RestConfigurationConfigurer.java
core/camel-core-model/src/generated/resources/org/apache/camel/model/rest/delete.json
core/camel-core-model/src/generated/resources/org/apache/camel/model/rest/get.json
core/camel-core-model/src/generated/resources/org/apache/camel/model/rest/head.json
core/camel-core-model/src/generated/resources/org/apache/camel/model/rest/patch.json
core/camel-core-model/src/generated/resources/org/apache/camel/model/rest/post.json
core/camel-core-model/src/generated/resources/org/apache/camel/model/rest/put.json
core/camel-core-model/src/generated/resources/org/apache/camel/model/rest/restBinding.json
core/camel-core-model/src/generated/resources/org/apache/camel/model/rest/restConfiguration.json
core/camel-core-model/src/generated/resources/org/apache/camel/model/rest/verb.json
core/camel-core-model/src/main/java/org/apache/camel/model/rest/RestBindingDefinition.java
core/camel-core-model/src/main/java/org/apache/camel/model/rest/RestConfigurationDefinition.java
core/camel-core-model/src/main/java/org/apache/camel/model/rest/RestDefinition.java
core/camel-core-model/src/main/java/org/apache/camel/model/rest/VerbDefinition.java
core/camel-core-processor/src/main/java/org/apache/camel/processor/RestBindingAdvice.java
core/camel-core-reifier/src/main/java/org/apache/camel/reifier/rest/RestBindingReifier.java
core/camel-main/src/generated/java/org/apache/camel/main/RestConfigurationPropertiesConfigurer.java
core/camel-xml-io/src/generated/java/org/apache/camel/xml/in/ModelParser.java
dsl/camel-yaml-dsl/camel-yaml-dsl-deserializers/src/generated/java/org/apache/camel/dsl/yaml/deserializers/ModelDeserializers.java  {code}
neoxu9999:1645065116:2022-02-17T10:31:56.101+0000:1645066221:2022-02-17T10:50:21.474+0000:I think it should be the place since [RestProducer.java] pass values to [RestProducerBindingProcessor.java] 

Found the actual code line 326 in RestProducerBindingProcessor
// is the body empty
if (exchange.hasOut() && exchange.getOut().getBody() == null
|| !exchange.hasOut() && exchange.getIn().getBody() == null) {
return;
}"
0,CAMEL-17039,Bug,Major,None,"3.11.3, 3.13.0","
None
",Resolved,Fixed,"3.11.3, 3.13.0",Andrea Cosentino,Andrea Cosentino,0,1,2021-10-04 11:08:42+00:00,2021-10-04 11:52:39+00:00,Related to comments in CAMEL-15714,
0,CAMEL-17038,Improvement,Major,None,Future,"
None
",Open,Unresolved,Future,Claus Ibsen,Claus Ibsen,0,3,2021-10-04 09:30:36+00:00,2023-07-17 11:27:05+00:00,"EIPs that support thread pools for parallel processing such as splitter, wire-tap etc uses a JDK thread pool. The default sized thread pool in Camel has a backlog of 1000 slots, so the pools has capacity to process tasks as they come.


And in case a pool is full then they by default allows to steal the caller thread to run the task.


However this model has some flaws now


a) The EIPs are going parallel and then the task is executed on current thread via caller runs (blocking)
b) The other rejections discard, discard oldest, (abort) will cause problems as the task has an exchange callback that should be called to continue that inflight exchange


For (a) it adds complexity and we have a bug such as CAMEL-16829


For EIPs then we should consider not allowing custom rejections, and only have a default behaviour that is if a task is rejected then the exchange fails. Or we can add a strategy that will block (with timeout) until a slot is free.","spadou:1637732588:2021-11-24T13:43:08.789+0000:1637732588:2021-11-24T13:43:08.789+0000:Regarding the proposed solution, I'm not sure that losing the callers run capability for EIPs thread pools is the best solution. In the context of CAMEL-16829 I specifically rely on the caller runs policy, to be able to use a small thread pool without a queue for performances optimisation of the splitter processing, but without completely blocking the incoming route if the poll is full.

Not sure if helpful to fix the issue globally, but for my use-case I have a workaround that allow me to use the caller runs policy without blocking the route. I've replaced the default caller runs implementation by one that schedule the task synchronously on the reactive executor instead of running it directly, this way it is run synchronously in the current thread but integrate to the reactive context and avoid blocking it. It works well in my case but I'm not sure of all the implications of doing that in different contexts, specifically the schedule sync will run everything enqueued in the reactive context which may cause unexpected side effects in some cases.

Here a snippet of the rejected execution implementation that I use instead of the default caller runs one:
{code:java}
public void rejectedExecution(Runnable r, ThreadPoolExecutor executor) {
  if (!executor.isShutdown()) {
    camelContext.adapt(ExtendedCamelContext.class).getReactiveExecutor().scheduleSync(r);
  }
}
{code}"
0,CAMEL-17037,New Feature,Minor,None,3.13.0,"
None
",Resolved,Fixed,3.13.0,Unassigned,Michael Rambichler,0,1,2021-10-02 17:40:00+00:00,2021-10-04 09:33:43+00:00,"The SFTP component does not support the chmodDirectory parameter.  (like the file-component https://camel.apache.org/components/3.11.x/file-component.html)


The sftp api as able to set the permission on directory.",rambichler:1633168321:2021-10-02T17:52:01.829+0000:1633168321:2021-10-02T17:52:01.829+0000:I am going to take a look on this. If successfull create a pull request
0,CAMEL-17036,Improvement,Minor,3.11.0,3.13.0,"
None
",Resolved,Fixed,3.13.0,Jeremy Ross,Jeremy Ross,0,1,2021-10-02 16:24:38+00:00,2021-10-03 18:12:29+00:00,"When certain salesforce operations (such as updateSObject) fail, they don't preserve the body, therefore the body can't be logged in a downstream logging operation or error handler.


Also, operations that don't have a body to return should pass along the in body.",
0,CAMEL-17035,Improvement,Major,None,3.13.0,"
None
",Resolved,Fixed,3.13.0,Claus Ibsen,Claus Ibsen,0,1,2021-10-02 05:42:46+00:00,2021-10-02 05:50:21+00:00,"So when you have to do today


responseMessage().code(400).message(""does not work"").endResponseMessage()


You should be able to do


responseMessage(400, ""does not work"")",
0,CAMEL-17034,Bug,Major,3.11.2,None,"
None
",Resolved,Fixed,"3.11.3, 3.13.0",Andrea Cosentino,Andrea Cosentino,0,1,2021-10-01 16:45:37+00:00,2021-10-04 08:33:52+00:00,"This is visible from the test: https://github.com/apache/camel/blob/main/components/camel-github/src/test/java/org/apache/camel/component/github/consumer/CommitConsumerBeginningTest.java


It's just an annotation to change and regen.",
0,CAMEL-17033,Improvement,Major,None,3.13.0,"
None
",Resolved,Fixed,3.13.0,Claus Ibsen,Claus Ibsen,0,1,2021-10-01 12:55:47+00:00,2021-10-02 07:57:04+00:00,"Related to CAMEL-17031


We should optimize in DefaultManagementStrategy to keep track of notifiers that are started or not, to be returned, then the event helper is fast as it can be",
0,CAMEL-17032,Improvement,Minor,None,"4.0-M3, 4.0.0","
None
",Resolved,Fixed,"4.0-M3, 4.0.0",Unassigned,Otavio Rodolfo Piske,0,2,2021-10-01 12:17:43+00:00,2023-04-14 12:13:36+00:00,"In some places in the JDBC code, we have to leave the resources open (statements, connections, resultsets, etc) in order to allow them to be post-processed.


 


I am opening this ticket so that we can investigate this in the future.


 


Ref.:  https://github.com/apache/camel/pull/6192",davsclaus:1644021067:2022-02-05T08:31:07.359+0000:1644021067:2022-02-05T08:31:07.359+0000:We should add an onCompletion on the exchange that will close when the uow is done
0,CAMEL-17031,Improvement,Major,None,None,"
None
",Resolved,Fixed,"3.11.3, 3.13.0",Andrea Cosentino,Andrea Cosentino,0,1,2021-10-01 10:21:44+00:00,2021-10-01 16:25:30+00:00,"https://github.com/apache/camel/blob/main/core/camel-support/src/main/java/org/apache/camel/support/EventHelper.java#L1303


This is just a little finding, but we could improve allocation and performance a lot by focusing on some profiling work.",
0,CAMEL-17030,Improvement,Major,3.11.1,"3.11.3, 3.13.0","
None
",Resolved,Fixed,"3.11.3, 3.13.0",Claus Ibsen,Claus Ibsen,0,1,2021-10-01 05:40:43+00:00,2021-10-01 07:24:48+00:00,"If there is a socket closed exception or something, we should just ignore it.


User reported a problem of some sort of that at
https://camel.zulipchat.com/#narrow/stream/257301-camel-spring-boot/topic/SFTP.20setup.20improvements",
0,CAMEL-17029,Improvement,Major,None,3.13.0,"
None
",Resolved,Fixed,3.13.0,Claus Ibsen,Claus Ibsen,0,1,2021-10-01 05:27:26+00:00,2021-10-01 08:44:01+00:00,If the message body is File then aws has a file based upload method we should use instead of input stream.,
0,CAMEL-17028,Improvement,Minor,None,3.x,"
None
",Resolved,Won't Fix,3.x,Unassigned,Claus Ibsen,0,1,2021-09-30 17:49:07+00:00,2022-09-03 10:22:54+00:00,"By default the 300 seconds can sometimes be too low a value.
For example some of the aws tests runs longer. For example 14 min took it once on my laptop.


In the component/pom.xml  I have to do this



<forkedProcessTimeoutInSeconds>300</forkedProcessTimeoutInSeconds>
+                        <forkedProcessTimeoutInSeconds>900</forkedProcessTimeoutInSeconds>



Maybe that 300 can be some kind of property placeholder, which you can then specify as -D or some way when running mvn verify",
0,CAMEL-17027,Improvement,Major,None,4.1.0,"
None
",Resolved,Fixed,4.1.0,Unassigned,Claus Ibsen,0,4,2021-09-30 15:54:23+00:00,2023-09-04 06:50:28+00:00,"We should look at the streaming mode as it loads the stream into memory to copy to the s3 client.


We can maybe do this a bit smarter, to write in chunks.","davsclaus:1692134749:2023-08-16T05:25:49.060+0000:1692134813:2023-08-16T05:26:53.189+0000:We need to make AWS2S3StreamUploadProducer able to read the InputStream from the message body in chuncks, instead of reading it all into memory. It needs still to send big payloads to AWS in chuncks.

But something about having an internal buffer of N size (add new option to set size), and then keep reading into the buffer until InputStream is EOL.
davsclaus:1692184265:2023-08-16T19:11:05.219+0000:1692184265:2023-08-16T19:11:05.219+0000:Also the AWS2S3StreamUploadProducer is not thread-safe, so we need to move that state to be per exchange (index, etc) so it can be used concurrently.
jono.morris@xtra.co.nz:1693709878:2023-09-03T10:57:58.873+0000:1693709878:2023-09-03T10:57:58.873+0000:Code changes provided to read the message body in chunks instead of reading the entire body into memory to better handle large payloads, and to make AWS2S3StreamUploadProducer thread-safe.   

Please let me know if there are any further requirements.
acosentino:1693781420:2023-09-04T06:50:20.968+0000:1693781420:2023-09-04T06:50:20.968+0000:should be fine. Thanks for all your work."
0,CAMEL-17026,New Feature,Major,None,3.14.0,"
None
",Resolved,Delivered,3.14.0,Otavio Rodolfo Piske,Otavio Rodolfo Piske,0,1,2021-09-30 14:50:30+00:00,2021-12-02 11:21:22+00:00,This continues the work on CAMEL-15955 and CAMEL-15562 include the resume support on the Kafka producer. It should serve as the model for us to implement the same feature on other components producer's (TDB).,"orpiske:1633412556:2021-10-05T13:42:36.604+0000:1633412556:2021-10-05T13:42:36.604+0000:Not much to be done on the producer end for now, so putting this one on hold."
0,CAMEL-17025,Improvement,Minor,None,4.x,"
None
",Open,Unresolved,4.x,Andrea Cosentino,Fabio Zani,1,3,2021-09-30 11:38:49+00:00,2023-08-09 09:18:10+00:00,"Using the AWS2 S3 component it would be nice to have a way to move a file inside a different subfolder in the same bucket after reading it.


AS IS


With the current implementation, the moveAfterRead option requires to specify the destination bucket and eventually a prefix and/or suffix.


As it is not intended for moving into a different folder in the same bucket, trying to specify the original bucket as destination and the path to the subfolder as a prefix has an ugly result, as shown in the following example.


Original bucket: myBucket
 File path: /path/to/foloder/run/test.txt


moveAfterRead=true
destinationBucket=myBucket
destinationBucketPrefix=/path/to/folder/done


Result:  file is moved, but file key is /path/to/folder/done/path/to/folder/test.txt


TO BE


Allow moving the file under a different folder in the same bucket.


An option would be to recognize if the destination bucket is the same as the original bucket, requiring the destinationBuketPrefix to be set, moving the file (with the filename extracted from the CamelAwsS3Key) under the specified prefix.


Another option would be to introduce a new option designed specifically to move the file within the same bucket. The moveAfterRead option would then require either the destinationBucket option or the destinationSubfolderPrefix to be set.


In case the second solution is chosen, the destinationBucketSuffix option could be renamed in destinationSuffix to be used with both moving within the bucket or to another bucket or a new option (destinationSubfolderSuffix) should be introduced.",acosentino:1632985205:2021-09-30T15:00:05.837+0000:1632985205:2021-09-30T15:00:05.837+0000:Feel free to propose a PR if you want to
0,CAMEL-17024,Improvement,Major,None,3.13.0,"
None
",Resolved,Fixed,3.13.0,Claus Ibsen,Claus Ibsen,0,1,2021-09-30 10:31:11+00:00,2021-10-01 05:28:10+00:00,The content-length is often calculated by copying the message body into a byte array that reside in-memory. We can determine this smarter.,
0,CAMEL-17023,Improvement,Major,3.11.0,"3.11.3, 3.13.0","
None
",Resolved,Fixed,"3.11.3, 3.13.0",Tomohisa Igarashi,Rafal Korytkowski,0,3,2021-09-30 10:12:01+00:00,2021-09-30 12:03:58+00:00,"The DFDL module in Atlasmap is a POC and should not be shipped by default with the component. We decided to scope it as provided so we can continue to test it, but have the user include it manually when needed.","davsclaus:1632973784:2021-09-30T11:49:44.357+0000:1632973784:2021-09-30T11:49:44.357+0000:Would this be good to backport into the 3.11 LTS release? I assume end users of atlasmap would normally not need this JAR. And if so they can add it to their dependency set.
igarashitm:1632974194:2021-09-30T11:56:34.144+0000:1632974194:2021-09-30T11:56:34.144+0000:+1 it's just an extra dependency most user won't use ATM.
davsclaus:1632974638:2021-09-30T12:03:58.504+0000:1632974638:2021-09-30T12:03:58.504+0000:Ok backported"
0,CAMEL-17022,Improvement,Major,None,"3.11.3, 3.13.0","
None
",Resolved,Fixed,"3.11.3, 3.13.0",Unassigned,christian ohr,0,2,2021-09-30 09:18:48+00:00,2021-10-06 04:16:12+00:00,"This is basically a follow up on CAMEL-5404.


If the ""disconnect"" parameter is not set on true, the same problem occurs as described in CAMEL-5404 in case of a timeout, i.e. a delayed response may be incorrectly associated with a subsequent request, which leads to disaster.


To avoid this behavior, ""disconnect"" could be set to ""true"" - however, this would close the connection also after each response successfully delivered in time. This causes unnecessary overhead when reopening connections every time.


Proposal:




        if (sync) {
            // wait for response, consider timeout
            LOG.debug(""Waiting for response using timeout {} millis."", timeout);
            boolean done = responseLatch.await(timeout, TimeUnit.MILLISECONDS);
            if (!done) {
                # NEW: Force session to be closed on timeouts
                closeSessionIfNeededAndAwaitCloseInHandler(session);
                throw new ExchangeTimedOutException(exchange, timeout);
            } 



Maybe this behavior can also be tied to a producer-side disconnectOnNoReply parameter.","davsclaus:1632968865:2021-09-30T10:27:45.907+0000:1632968865:2021-09-30T10:27:45.907+0000:Yes you are welcome to submit a PR
davsclaus:1633072904:2021-10-01T15:21:44.284+0000:1633072904:2021-10-01T15:21:44.284+0000:Thanks for the PR
christian.ohr:1633406708:2021-10-05T12:05:08.906+0000:1633406708:2021-10-05T12:05:08.906+0000:Please also consider this for 3.11.3. Thank you."
0,CAMEL-17021,Improvement,Major,None,3.13.0,"
None
",Resolved,Fixed,3.13.0,Claus Ibsen,Claus Ibsen,0,1,2021-09-30 08:53:13+00:00,2021-09-30 10:32:19+00:00,The content-length is often calculated by copying the message body into a byte array that reside in-memory. We can determine this smarter.,
0,CAMEL-17020,Improvement,Minor,"3.11.1, 3.11.2, 3.11.0","3.11.3, 3.13.0","
None
",Resolved,Fixed,"3.11.3, 3.13.0",Unassigned,Henrik Karlsson,0,2,2021-09-30 07:06:15+00:00,2021-10-25 17:40:13+00:00,"camel-restdsl-openapi-plugin and camel-restdsl-swagger-plugin doesn't set apiContextPath on the generator for xml and yaml (openapi).


The camel-restdsl-openapi-plugin is also missing the parameter clientRequestValidation that camel-restdsl-swagger-plugin has","davsclaus:1632957161:2021-09-30T07:12:41.601+0000:1632957161:2021-09-30T07:12:41.601+0000:You are welcome to send a PR adding them
henka-rl:1632958156:2021-09-30T07:29:16.871+0000:1632958156:2021-09-30T07:29:16.871+0000:Just did ;)
https://github.com/apache/camel/pull/6182
davsclaus:1632968787:2021-09-30T10:26:27.579+0000:1632968787:2021-09-30T10:26:27.579+0000:Thanks for reporting and the PR"
0,CAMEL-17019,Task,Minor,3.11.1,,"
None
",Resolved,Information Provided,None,Unassigned,Julien Greffe,0,2,2021-09-30 07:05:54+00:00,2021-11-18 05:42:45+00:00,"Hello,


during some performances tests, we noticed a difference between camel-xslt 2.24.2 & 3.11.1.


Here is a simplified repo to reproduce: https://github.com/jgreffe/camel-perf-xslt-test


Please execute:



using JDK8: mvn clean test -Dcamel.test=2.24.2
using JDK11: mvn clean test -Dcamel.test=3.11.1



We have these results:




[INFO] ********************************************************************************
[INFO] Testing done: testMock(XSLTTest)
[INFO] Took: 0.295 seconds (295 millis)
[INFO] ********************************************************************************
[INFO] Apache Camel 2.24.2 (CamelContext: camel-1) is shutting down






[INFO] ********************************************************************************
[INFO] Testing done: testMock (XSLTTest)
[INFO] Took: 344ms (344 millis)
[INFO] ********************************************************************************
[INFO] Apache Camel 3.11.1 (camel-1) shutting down (timeout:10s)




Do you have an idea of root cause?","dkulp:1637131270:2021-11-17T14:41:10.218+0000:1637131270:2021-11-17T14:41:10.218+0000:I don't think this is an issue in Camel but more of an issue with the XSLT transform engine in the JDK.  If you run with 3.11.1 and JDK8 (the xslt component in Camel 3.11 still works with Java8 for now), you see a similar performance difference which implies it's JDK related, not Camel.    My gut feeling is all the ""Secure Processing"" stuff add to the JDK for XML processing/parsing/etc... has caused a bit of a performance degradation to increase security.     I'm not 100% sure on that yet, but it does look like this isn't strictly a Camel issue. 
dkulp:1637134068:2021-11-17T15:27:48.435+0000:1637134068:2021-11-17T15:27:48.435+0000:I did some more testing and it looks like it's just the JDK/JIT ramp up time.   If I increase the count in the test to 2000 (to make sure the JIT triggers) and copy the enter testMock() method to a second testMock2() method (so the entire test runs twice), you can see that the first run is definitely longer on Java11 than Java8 with both Camel 3.11.1 and 2.24.2.   However, the second run is very close between Java11 and Java8.   "
0,CAMEL-17018,Bug,Major,3.12.0,3.13.0,"
None
",Resolved,Fixed,3.13.0,Otavio Rodolfo Piske,Otavio Rodolfo Piske,0,2,2021-09-29 16:13:55+00:00,2021-10-13 18:33:59+00:00,"The references to Camel dependencies should have been changed during the release build, but it did not happen.","davsclaus:1633994008:2021-10-12T07:13:28.281+0000:1633994008:2021-10-12T07:13:28.281+0000:Otavio you have a possible fix already for this?
orpiske:1633994114:2021-10-12T07:15:14.092+0000:1633994114:2021-10-12T07:15:14.092+0000:[~davsclaus] not yet. I know what I have to do to fix it, but I haven't coded it yet. I'll take care of it as soon as finish the camel-file ones.
orpiske:1634032438:2021-10-12T17:53:58.230+0000:1634032438:2021-10-12T17:53:58.230+0000:It should have been fixed by the linked PR for 3.13.0."
0,CAMEL-17017,Bug,Minor,"3.11.2, 3.12.0","3.11.3, 3.13.0","
None
",Resolved,Fixed,"3.11.3, 3.13.0",Claus Ibsen,Claus Ibsen,0,1,2021-09-29 12:37:12+00:00,2021-09-29 12:43:35+00:00,"[ERROR] camelinaction.MetricsTest.testMetrics  Time elapsed: 0.006 s  <<< ERROR!
java.lang.NoClassDefFoundError: com/fasterxml/jackson/core/util/JacksonFeature
Caused by: java.lang.ClassNotFoundException: com.fasterxml.jackson.core.util.JacksonFeature",
0,CAMEL-17016,Bug,Major,3.12.0,3.13.0,"
None
",Resolved,Fixed,3.13.0,Claus Ibsen,Claus Ibsen,0,1,2021-09-29 11:40:05+00:00,2021-09-29 11:43:57+00:00,"java.lang.NoClassDefFoundError: Could not initialize class org.fusesource.leveldbjni.JniDBFactory


	at java.base/jdk.internal.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)
	at java.base/jdk.internal.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45)
	at java.base/java.lang.reflect.Constructor.newInstance(Constructor.java:490)
	at java.base/java.lang.Class.newInstance(Class.java:584)
	at org.apache.camel.component.leveldb.LevelDBFile.getFactory(LevelDBFile.java:196)
	at org.apache.camel.component.leveldb.LevelDBFile.start(LevelDBFile.java:181)
	at org.apache.camel.support.service.ServiceHelper.startService(ServiceHelper.java:113)",
0,CAMEL-17015,Bug,Minor,3.11.2,"3.11.3, 3.13.0, 3.7.7","
None
",Resolved,Fixed,"3.11.3, 3.13.0, 3.7.7",Claus Ibsen,Peter Hermsdorf,0,2,2021-09-29 07:40:18+00:00,2021-10-21 14:29:10+00:00,"After updating from Camel 3.4.4 to 3.11.2 our REST Services aren'T working anymore.


Already discussed here: https://camel.zulipchat.com/#narrow/stream/257298-camel/topic/Problem.20with.20REST.20services.20after.20upgrading.20to.20Camel.203.2E11.2E2/near/255227937


Debugging revealed the following:


we create a Osgi Camel Context and register Routes like this:




camelContext = new OsgiDefaultCamelContext(bundleContext) {
				@Override
				public void init() {
					final RouteBuilder routes = createRoutes();
					routes.restConfiguration().componentProperty(""servletName"", ""my.custom.servletName"").clientRequestValidation(true);
					this.addRoutes(routes);
					super.init();
				}
 



 
In org.apache.camel.component.servlet.ServletComponent.connect(HttpConsumer) 




sc.getEndpoint().getServletName()




returns the Default Servlet Name 



CamelServlet



 and not my 



my.custom.servletName



 because 



org.apache.camel.component.servlet.ServletEndpoint.setServletName(String)



 is called with  



CamelServlet



 and not with my custom servletname.


Seems like no one is setting the correct value on 



org.apache.camel.component.servlet.ServletComponent.setServletName(String)","davsclaus:1632876175:2021-09-29T08:42:55.041+0000:1632876175:2021-09-29T08:42:55.041+0000:Hmm okay so you do a bit unsupported with that custom OsgiCamelContext trick, so that can be a problem for you.

What are you doing in createRoutes() ?
phermsdorf:1632876779:2021-09-29T08:52:59.225+0000:1632876779:2021-09-29T08:52:59.225+0000:Basically returning something like this:
{code}
class P4Routes extends RouteBuilder {

	@Override
	public void configure() throws Exception {
		addHello();
	}

	private void addHello() {
		rest(""/say"")
				.get(""/hello"").to(""direct:hello"");

		from(""direct:hello"")
				.transform().constant(""Hello World"");
	}
}
{code}

The little 'trick' with the OsgiDefaultCamelContext.init method is necessary because otherwise the routes are not picked up.

davsclaus:1632876982:2021-09-29T08:56:22.729+0000:1632876982:2021-09-29T08:56:22.729+0000:Ah have reproduced this with camel-servlet
phermsdorf:1632886750:2021-09-29T11:39:10.085+0000:1632886750:2021-09-29T11:39:10.085+0000:Thank you!
Is there a release date for version 3.11.3?"
0,CAMEL-17014,New Feature,Major,None,Future,"
None
",Open,Unresolved,Future,Unassigned,Claus Ibsen,0,1,2021-09-28 17:06:13+00:00,2023-07-17 11:29:03+00:00,"Some components have their own thread pool for worker threads that they use. For example salesforce, kafka, jms, and others.


They use this continue routing in Camel when the component has received a response or ack from the underlying 3rd party (kafka, jms, salesforce etc.)


We should consider a API with a SPI so we can use a shared worker pool from camel-core that has a fixed set of worker threads. Then its easier to control total number of threads / pools etc.


And with a SPI then we can delegate this to another runtime such as vertx, quarkus etc that has such concept.",
0,CAMEL-17013,Improvement,Minor,None,Future,"
None
",Resolved,Won't Fix,Future,Unassigned,Claus Ibsen,0,1,2021-09-28 16:20:10+00:00,2023-07-17 11:29:34+00:00,"camel-redis only has a agg repo. And it was before we had spring-redis. Lets merge them together into camel-spring-redis.


So we deprecate the old camel-redis","davsclaus:1662175550:2022-09-03T11:25:50.863+0000:1662175550:2022-09-03T11:25:50.863+0000:camel-redis uses a vanilla redis client, and spring use its template and their apis are not compatible so it requires some effort to migrate"
0,CAMEL-17012,Bug,Minor,3.12.0,3.13.0,"
None
",Resolved,Fixed,3.13.0,Unassigned,Alex Dettinger,0,1,2021-09-28 11:11:16+00:00,2021-09-29 05:43:31+00:00,"The listAliases operation unduly fails in aws lambda.


The underlying request is not built in the Lambda2Producer class and the functionVersion parameter is unduly required.


From the doc https://docs.aws.amazon.com/lambda/latest/dg/API_ListAliases.html, the functionVersion should not be required. From the history I've been able to grab, it seems it was never required in which case I guess it should be fine to relax the constraint.


 


A workaround is to use pojoRequest and define the request explicitly by hand.","aldettinger:1632811337:2021-09-28T14:42:17.874+0000:1632811357:2021-09-28T14:42:37.209+0000:Okay, this one can't be backported to 3.11.x without raising the localstack version. So, better keep the 3.11.x branch stable."
0,CAMEL-17011,Bug,Major,None,"3.7.6, 3.11.3, 3.13.0","
None
",Resolved,Fixed,"3.7.6, 3.11.3, 3.13.0",Claus Ibsen,Claus Ibsen,0,1,2021-09-28 10:08:02+00:00,2021-09-28 10:20:43+00:00,Noticed due working on CAMEL-16916,
0,CAMEL-17010,Task,Minor,None,3.x,"
None
",Resolved,Information Provided,3.x,Unassigned,Claus Ibsen,0,2,2021-09-28 05:31:53+00:00,2021-09-28 08:21:16+00:00,"[WARNING]
[WARNING] Some problems were encountered while building the effective model for org.apache.camel:camel-dependencies:pom:3.12.0-SNAPSHOT
[WARNING] 'parent.relativePath' of POM org.apache.camel:camel-dependencies:3.12.0-SNAPSHOT (/Users/davsclaus/workspace/camel/camel-dependencies/pom.xml) points at org.apache.camel:camel instead of org.apache:apache, please verify your project structure @ line 23, column 11
[WARNING]
[WARNING] It is highly recommended to fix these problems because they threaten the stability of your build.
[WARNING]
[WARNING] For this reason, future Maven versions might no longer support building such malformed projects.
[WARNING]","acosentino:1632778568:2021-09-28T05:36:08.262+0000:1632778568:2021-09-28T05:36:08.262+0000:This is done by design for having an independent set of versions to re-use in the subprojects without the specific settings of org.apache.camel:camel, so I don't think there is a way to avoid the warn"
0,CAMEL-16979,New Feature,Major,None,None,"
None
",Resolved,Duplicate,3.12.0,Unassigned,Hokutor,0,1,2021-09-16 17:25:43+00:00,2021-09-16 17:39:38+00:00,"Image Recognition uses deep learning technologies to accurately identify objects, scenes, and concepts in images using a pool of visual content tags.


 


Develop a camel component to integrate with this cloud service. More details on the service is here - https://www.huaweicloud.com/en-us/product/image.html","hokutor:1631785133:2021-09-16T17:38:53.026+0000:1631785133:2021-09-16T17:38:53.026+0000:This is opened by mistake and it is a dup of https://issues.apache.org/jira/browse/CAMEL-16944 
hokutor:1631785178:2021-09-16T17:39:38.252+0000:1631785178:2021-09-16T17:39:38.252+0000:dup of https://issues.apache.org/jira/browse/CAMEL-16944"
0,CAMEL-16978,Bug,Minor,None,None,"
None
",Resolved,Fixed,3.14.0,Claus Ibsen,James Netherton,0,1,2021-09-15 14:37:18+00:00,2021-11-14 09:54:25+00:00,"It seems reasonable to have a route like:




from(""direct:binance"")
.to(""xchange:binance"");

from(""direct:kraken"")
.to(""xchange:kraken"");




Unfortunately, this only seems possible by creating a dedicated component instance for each crypto exchange. The xchange instance is cached in the component, so the first endpoint to initialize it 'wins'.


https://github.com/apache/camel/blob/main/components/camel-xchange/src/main/java/org/apache/camel/component/xchange/XChangeComponent.java#L55-L68


I guess it should be cached per crypto exchange used on the endpoint(s).",
0,CAMEL-16977,New Feature,Major,None,Future,"
None
",Open,Unresolved,Future,Unassigned,Claus Ibsen,0,2,2021-09-15 08:51:08+00:00,2023-07-24 18:28:18+00:00,"We should have some logic in camel-support / camel-core that allows to determine if an exception is transient or business.


A transient is a networking error, where you may want to try again in a bit later.
A business error is UserNotFoundException or something of that sorts.


We could have some shared logic in camel-support that attempts to categorize a Exception. And allow end users to plugin custom logic if needed.


This can be used in health-checks to determine if a Camel app is healthy or not.",
0,CAMEL-16976,New Feature,Major,None,4.x,"
None
",Open,Unresolved,4.x,Claus Ibsen,Claus Ibsen,1,3,2021-09-15 08:44:17+00:00,2023-10-23 09:21:57+00:00,"The health checks
https://camel.apache.org/manual/latest/health-check.html


For routes with failure thresholds etc are currently for readiness checks, eg when starting up the routes.


However after this fact, then at runtime, we may want to be able to say that if a route consumer have failed X times in a row, then its unhealthy. And to filter by exception and whatnot. So this can get a bit tricky, but we may want to have some SPI interface that end users can implement for custom logic.",
0,CAMEL-16975,New Feature,Major,None,None,"
None
",Resolved,Fixed,3.13.0,Claus Ibsen,Claus Ibsen,1,2,2021-09-15 08:37:52+00:00,2023-07-26 08:58:29+00:00,"We should make components able to provide their own health checks.
And discover them using the factory finder mechanism.


The component should be able to have its health check injected into its consumer / producer so they can change the state.","davsclaus:1635544213:2021-10-30T05:50:13.274+0000:1636011950:2021-11-04T15:45:50.384+0000:- scheduled polling consumer *DONE*
- default consumer *DONE* but there are none out of the box so they must be custom implemented when needed"
0,CAMEL-16974,Improvement,Major,None,3.12.0,"
None
",Resolved,Fixed,3.12.0,Otavio Rodolfo Piske,Otavio Rodolfo Piske,0,1,2021-09-15 06:39:17+00:00,2021-09-22 09:56:57+00:00,"With the changes from CAMEL-16949, the resume strategy is more easily configurable. We should expose this SPI, document it and make it configurable for the users.",orpiske:1632275817:2021-09-22T09:56:57.380+0000:1632275817:2021-09-22T09:56:57.380+0000:The changes were merged. Closing.
0,CAMEL-16973,Bug,Major,None,,"
None
",Resolved,Fixed,None,Otavio Rodolfo Piske,Otavio Rodolfo Piske,0,1,2021-09-15 05:23:09+00:00,2021-09-16 06:50:58+00:00,"The fetch record class calls Kafka's Client wakeup method [1]. By calling this method, it causes blocking code to throw the WakeUpException if they are blocked or on the next call that would block. Ideally, this exception should be handled cleanly, as it indicates a preemptive reaction to a call that would block [2] and not the usual case of an error condition.


 


There are some circumstances that may cause the code to skip commits or lose messages. For example:


1. If the code is using Manual commit and the shutdown is called while the exchange is being processed [3], this would cause the WakeUpException to be handled as normal exception [4].


2. It could also happen in similar circumstances the commit section of the code later on.


 


As such, if the stop or shutdown procedure is started while the code is in


 


1. https://github.com/apache/camel/blob/main/components/camel-kafka/src/main/java/org/apache/camel/component/kafka/KafkaFetchRecords.java#L478-L488
 2. https://kafka.apache.org/21/javadoc/?org/apache/kafka/common/errors/WakeupException.html


3. https://github.com/apache/camel/blob/main/components/camel-kafka/src/main/java/org/apache/camel/component/kafka/KafkaFetchRecords.java#L275-L279  


4. https://github.com/apache/camel/blob/main/components/camel-kafka/src/main/java/org/apache/camel/component/kafka/KafkaFetchRecords.java#L350",orpiske:1631746258:2021-09-16T06:50:58.990+0000:1631746258:2021-09-16T06:50:58.990+0000:Should have been resolved the PR
0,CAMEL-16972,Sub-task,Major,None,3.15.0,"
None
",Resolved,Fixed,3.15.0,Freeman Yue Fang,Freeman Yue Fang,0,2,2021-09-14 19:34:36+00:00,2022-01-12 06:47:24+00:00,"Caused by: java.lang.IllegalAccessException: class org.jboss.weld.util.bytecode.ClassFileUtils cannot access a member of class java.lang.ClassLoader (in module java.base) with modifiers ""protected final""
        at java.base/jdk.internal.reflect.Reflection.newIllegalAccessException(Reflection.java:392)
        at java.base/java.lang.reflect.AccessibleObject.checkAccess(AccessibleObject.java:674)
        at java.base/java.lang.reflect.Method.invoke(Method.java:560)
        at org.jboss.weld.util.bytecode.ClassFileUtils.toClass2(ClassFileUtils.java:165)
        at org.jboss.weld.util.bytecode.ClassFileUtils.toClass(ClassFileUtils.java:134)
        ... 11 more





And this also affects camel-archetypes-cdi/camel-itest-cdi/camel-xml-jaxb-dsl-test-cdi","ffang:1632980370:2021-09-30T13:39:30.235+0000:1632980370:2021-09-30T13:39:30.235+0000:This is fixed  by weld 3.1.7.Final, tracked by 
https://issues.redhat.com/browse/WELD-2581
ffang:1632989259:2021-09-30T16:07:39.918+0000:1632989259:2021-09-30T16:07:39.918+0000:With weld 3.1.7.Final, few tests failed here
{code}
[ERROR] org.apache.camel.cdi.test.UnstoppedCamelContextProducerFieldTest  Time elapsed: 0.053 s  <<< ERROR!
org.jboss.weld.exceptions.DeploymentException: WELD-001524: Unable to load proxy class for bean Producer Field [CamelContext] with qualifiers [@Any @Default] declared as [[BackedAnnotatedField] @Produces @ApplicationScoped private static org.apache.camel.cdi.test.UnstoppedCamelContextProducerFieldTest.context] with class class java.lang.Object
	at org.jboss.weld.bootstrap.events.AbstractDeploymentContainerEvent.fire(AbstractDeploymentContainerEvent.java:38)
	at org.jboss.weld.bootstrap.events.AfterDeploymentValidationImpl.fire(AfterDeploymentValidationImpl.java:28)
	at org.jboss.weld.bootstrap.WeldStartup.validateBeans(WeldStartup.java:510)
	at org.jboss.weld.bootstrap.WeldBootstrap.validateBeans(WeldBootstrap.java:93)
	at org.jboss.arquillian.container.weld.embedded.mock.TestContainer.startContainer(TestContainer.java:242)
	at org.jboss.arquillian.container.weld.embedded.WeldMockContainer.deploy(WeldMockContainer.java:115)
	at org.jboss.arquillian.container.impl.client.container.ContainerDeployController$3.call(ContainerDeployController.java:151)
	at org.jboss.arquillian.container.impl.client.container.ContainerDeployController$3.call(ContainerDeployController.java:118)
	at org.jboss.arquillian.container.impl.client.container.ContainerDeployController.executeOperation(ContainerDeployController.java:239)
	at org.jboss.arquillian.container.impl.client.container.ContainerDeployController.deploy(ContainerDeployController.java:118)
	at jdk.internal.reflect.GeneratedMethodAccessor48.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.jboss.arquillian.core.impl.ObserverImpl.invoke(ObserverImpl.java:86)
	at org.jboss.arquillian.core.impl.EventContextImpl.invokeObservers(EventContextImpl.java:103)
	at org.jboss.arquillian.core.impl.EventContextImpl.proceed(EventContextImpl.java:90)
	at org.jboss.arquillian.container.impl.client.ContainerDeploymentContextHandler.createDeploymentContext(ContainerDeploymentContextHandler.java:71)
	at jdk.internal.reflect.GeneratedMethodAccessor18.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.jboss.arquillian.core.impl.ObserverImpl.invoke(ObserverImpl.java:86)
	at org.jboss.arquillian.core.impl.EventContextImpl.proceed(EventContextImpl.java:95)
	at org.jboss.arquillian.container.impl.client.ContainerDeploymentContextHandler.createContainerContext(ContainerDeploymentContextHandler.java:54)
	at jdk.internal.reflect.GeneratedMethodAccessor16.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.jboss.arquillian.core.impl.ObserverImpl.invoke(ObserverImpl.java:86)
	at org.jboss.arquillian.core.impl.EventContextImpl.proceed(EventContextImpl.java:95)
	at org.jboss.arquillian.container.impl.client.container.DeploymentExceptionHandler.verifyExpectedExceptionDuringDeploy(DeploymentExceptionHandler.java:47)
	at jdk.internal.reflect.GeneratedMethodAccessor47.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.jboss.arquillian.core.impl.ObserverImpl.invoke(ObserverImpl.java:86)
	at org.jboss.arquillian.core.impl.EventContextImpl.proceed(EventContextImpl.java:95)
	at org.jboss.arquillian.core.impl.ManagerImpl.fire(ManagerImpl.java:133)
	at org.jboss.arquillian.core.impl.ManagerImpl.fire(ManagerImpl.java:105)
	at org.jboss.arquillian.core.impl.EventImpl.fire(EventImpl.java:62)
	at org.jboss.arquillian.container.impl.client.container.ContainerDeployController$1.perform(ContainerDeployController.java:92)
	at org.jboss.arquillian.container.impl.client.container.ContainerDeployController$1.perform(ContainerDeployController.java:77)
	at org.jboss.arquillian.container.impl.client.container.ContainerDeployController.forEachDeployment(ContainerDeployController.java:232)
	at org.jboss.arquillian.container.impl.client.container.ContainerDeployController.forEachManagedDeployment(ContainerDeployController.java:212)
	at org.jboss.arquillian.container.impl.client.container.ContainerDeployController.deployManaged(ContainerDeployController.java:77)
	at jdk.internal.reflect.GeneratedMethodAccessor46.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.jboss.arquillian.core.impl.ObserverImpl.invoke(ObserverImpl.java:86)
	at org.jboss.arquillian.core.impl.EventContextImpl.invokeObservers(EventContextImpl.java:103)
	at org.jboss.arquillian.core.impl.EventContextImpl.proceed(EventContextImpl.java:90)
	at org.jboss.arquillian.core.impl.ManagerImpl.fire(ManagerImpl.java:133)
	at org.jboss.arquillian.core.impl.ManagerImpl.fire(ManagerImpl.java:105)
	at org.jboss.arquillian.core.impl.EventImpl.fire(EventImpl.java:62)
	at org.jboss.arquillian.container.test.impl.client.ContainerEventController.execute(ContainerEventController.java:96)
	at jdk.internal.reflect.GeneratedMethodAccessor43.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.jboss.arquillian.core.impl.ObserverImpl.invoke(ObserverImpl.java:86)
	at org.jboss.arquillian.core.impl.EventContextImpl.invokeObservers(EventContextImpl.java:103)
	at org.jboss.arquillian.core.impl.EventContextImpl.proceed(EventContextImpl.java:90)
	at org.jboss.arquillian.test.impl.TestContextHandler.createClassContext(TestContextHandler.java:83)
	at jdk.internal.reflect.GeneratedMethodAccessor7.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.jboss.arquillian.core.impl.ObserverImpl.invoke(ObserverImpl.java:86)
	at org.jboss.arquillian.core.impl.EventContextImpl.proceed(EventContextImpl.java:95)
	at org.jboss.arquillian.test.impl.TestContextHandler.createSuiteContext(TestContextHandler.java:69)
	at jdk.internal.reflect.GeneratedMethodAccessor6.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.jboss.arquillian.core.impl.ObserverImpl.invoke(ObserverImpl.java:86)
	at org.jboss.arquillian.core.impl.EventContextImpl.proceed(EventContextImpl.java:95)
	at org.jboss.arquillian.core.impl.ManagerImpl.fire(ManagerImpl.java:133)
	at org.jboss.arquillian.core.impl.ManagerImpl.fire(ManagerImpl.java:105)
	at org.jboss.arquillian.test.impl.EventTestRunnerAdaptor.beforeClass(EventTestRunnerAdaptor.java:89)
	at org.jboss.arquillian.junit.Arquillian$2.evaluate(Arquillian.java:163)
	at org.jboss.arquillian.junit.Arquillian.multiExecute(Arquillian.java:350)
	at org.jboss.arquillian.junit.Arquillian.access$200(Arquillian.java:54)
	at org.jboss.arquillian.junit.Arquillian$3.evaluate(Arquillian.java:177)
	at org.junit.rules.Verifier$1.evaluate(Verifier.java:35)
	at org.junit.rules.RunRules.evaluate(RunRules.java:20)
	at org.junit.runners.ParentRunner$3.evaluate(ParentRunner.java:306)
	at org.junit.runners.ParentRunner.run(ParentRunner.java:413)
	at org.jboss.arquillian.junit.Arquillian.run(Arquillian.java:115)
	at org.apache.maven.surefire.junit4.JUnit4Provider.execute(JUnit4Provider.java:364)
	at org.apache.maven.surefire.junit4.JUnit4Provider.executeWithRerun(JUnit4Provider.java:272)
	at org.apache.maven.surefire.junit4.JUnit4Provider.executeTestSet(JUnit4Provider.java:237)
	at org.apache.maven.surefire.junit4.JUnit4Provider.invoke(JUnit4Provider.java:158)
	at org.apache.maven.surefire.booter.ForkedBooter.runSuitesInProcess(ForkedBooter.java:428)
	at org.apache.maven.surefire.booter.ForkedBooter.execute(ForkedBooter.java:162)
	at org.apache.maven.surefire.booter.ForkedBooter.run(ForkedBooter.java:562)
	at org.apache.maven.surefire.booter.ForkedBooter.main(ForkedBooter.java:548)
Caused by: org.jboss.weld.exceptions.WeldException: WELD-001524: Unable to load proxy class for bean Producer Field [CamelContext] with qualifiers [@Any @Default] declared as [[BackedAnnotatedField] @Produces @ApplicationScoped private static org.apache.camel.cdi.test.UnstoppedCamelContextProducerFieldTest.context] with class class java.lang.Object
	at org.jboss.weld.bean.proxy.ProxyFactory.getProxyClass(ProxyFactory.java:381)
	at org.jboss.weld.bean.proxy.ProxyFactory.run(ProxyFactory.java:334)
	at org.jboss.weld.bean.proxy.ProxyFactory.create(ProxyFactory.java:326)
	at org.jboss.weld.bean.proxy.ClientProxyFactory.create(ClientProxyFactory.java:83)
	at org.jboss.weld.bean.proxy.ClientProxyProvider.createClientProxy(ClientProxyProvider.java:205)
	at org.jboss.weld.bean.proxy.ClientProxyProvider.createClientProxy(ClientProxyProvider.java:195)
	at org.jboss.weld.bean.proxy.ClientProxyProvider.access$100(ClientProxyProvider.java:44)
	at org.jboss.weld.bean.proxy.ClientProxyProvider$CreateClientProxy.apply(ClientProxyProvider.java:52)
	at org.jboss.weld.bean.proxy.ClientProxyProvider$CreateClientProxy.apply(ClientProxyProvider.java:48)
	at org.jboss.weld.util.cache.ReentrantMapBackedComputingCache.lambda$new$0(ReentrantMapBackedComputingCache.java:55)
	at org.jboss.weld.util.LazyValueHolder$1.computeValue(LazyValueHolder.java:32)
	at org.jboss.weld.util.LazyValueHolder.get(LazyValueHolder.java:46)
	at org.jboss.weld.util.cache.ReentrantMapBackedComputingCache.getValue(ReentrantMapBackedComputingCache.java:72)
	at org.jboss.weld.util.cache.ReentrantMapBackedComputingCache.getCastValue(ReentrantMapBackedComputingCache.java:78)
	at org.jboss.weld.bean.proxy.ClientProxyProvider.getClientProxy(ClientProxyProvider.java:229)
	at org.jboss.weld.manager.BeanManagerImpl.getReference(BeanManagerImpl.java:688)
	at org.jboss.weld.manager.BeanManagerImpl.getReference(BeanManagerImpl.java:717)
	at org.jboss.weld.util.ForwardingBeanManager.getReference(ForwardingBeanManager.java:64)
	at org.jboss.weld.bean.builtin.BeanManagerProxy.getReference(BeanManagerProxy.java:87)
	at org.apache.camel.cdi.BeanManagerHelper.getReference(BeanManagerHelper.java:53)
	at org.apache.camel.cdi.CdiCamelExtension.afterDeploymentValidation(CdiCamelExtension.java:376)
	at jdk.internal.reflect.GeneratedMethodAccessor57.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.jboss.weld.injection.StaticMethodInjectionPoint.invoke(StaticMethodInjectionPoint.java:95)
	at org.jboss.weld.injection.MethodInvocationStrategy$SpecialParamPlusBeanManagerStrategy.invoke(MethodInvocationStrategy.java:187)
	at org.jboss.weld.event.ObserverMethodImpl.sendEvent(ObserverMethodImpl.java:330)
	at org.jboss.weld.event.ExtensionObserverMethodImpl.sendEvent(ExtensionObserverMethodImpl.java:123)
	at org.jboss.weld.event.ObserverMethodImpl.sendEvent(ObserverMethodImpl.java:308)
	at org.jboss.weld.event.ObserverMethodImpl.notify(ObserverMethodImpl.java:286)
	at javax.enterprise.inject.spi.ObserverMethod.notify(ObserverMethod.java:124)
	at org.jboss.weld.util.Observers.notify(Observers.java:166)
	at org.jboss.weld.event.ObserverNotifier.notifySyncObservers(ObserverNotifier.java:285)
	at org.jboss.weld.event.ObserverNotifier.notify(ObserverNotifier.java:273)
	at org.jboss.weld.event.ObserverNotifier.fireEvent(ObserverNotifier.java:177)
	at org.jboss.weld.event.ObserverNotifier.fireEvent(ObserverNotifier.java:171)
	at org.jboss.weld.bootstrap.events.AbstractContainerEvent.fire(AbstractContainerEvent.java:53)
	at org.jboss.weld.bootstrap.events.AbstractDeploymentContainerEvent.fire(AbstractDeploymentContainerEvent.java:35)
	... 89 more
Caused by: java.lang.IllegalArgumentException: org.apache.camel.AutoCloseable$CamelContext$CamelContextLifecycle$RuntimeConfiguration1087082815$Proxy$_$$_WeldClientProxy not in same package as lookup class
	at java.base/java.lang.invoke.MethodHandleStatics.newIllegalArgumentException(MethodHandleStatics.java:167)
	at java.base/java.lang.invoke.MethodHandles$Lookup$ClassFile.newInstance(MethodHandles.java:2283)
	at java.base/java.lang.invoke.MethodHandles$Lookup.makeClassDefiner(MethodHandles.java:2318)
	at java.base/java.lang.invoke.MethodHandles$Lookup.defineClass(MethodHandles.java:1843)
	at org.jboss.weld.bean.proxy.util.WeldDefaultProxyServices.defineWithMethodLookup(WeldDefaultProxyServices.java:163)
	at org.jboss.weld.bean.proxy.util.WeldDefaultProxyServices.defineClass(WeldDefaultProxyServices.java:69)
	at org.jboss.weld.bean.proxy.ProxyFactory.toClass(ProxyFactory.java:909)
	at org.jboss.weld.bean.proxy.ProxyFactory.createProxyClass(ProxyFactory.java:467)
	at org.jboss.weld.bean.proxy.ProxyFactory.getProxyClass(ProxyFactory.java:373)
	... 126 more

[INFO] Running org.apache.camel.cdi.test.UnstoppedCamelContextProducerMethodTest
[ERROR] Tests run: 1, Failures: 0, Errors: 1, Skipped: 0, Time elapsed: 0.036 s <<< FAILURE! - in org.apache.camel.cdi.test.UnstoppedCamelContextProducerMethodTest
{code}
But with weld 3.1.8.Final this ""not in same package as lookup class"" issue is gone. So I'm gonna upgrade the weld version to 3.1.8.Final (the latest 3.1.x)
davsclaus:1641777108:2022-01-10T09:11:48.349+0000:1641777108:2022-01-10T09:11:48.349+0000:There is a weld 4.x
ffang:1641804627:2022-01-10T16:50:27.318+0000:1641804627:2022-01-10T16:50:27.318+0000:Thanks [~davsclaus]!

Yes, but weld 4.x uses jakarta. package names prefix(instead of the javax. and it's not compatible with the javax. packages). I think we should hold this upgrade for Camel 3.x and put it into a bigger map to align with all other dependencies which also need to use  jakarta. packages(Like in Camel 4.0).

Btw, I've already upgraded to weld 3.1.8.Final  so that camel-cdi can work with JDK17.

Best Regards
Freeman

"
0,CAMEL-16971,Sub-task,Major,None,,"
None
",Resolved,Fixed,None,Freeman Yue Fang,Freeman Yue Fang,0,1,2021-09-14 19:32:33+00:00,2022-04-19 13:36:22+00:00,"caused by




Caused by: java.lang.IllegalStateException: Cannot get Unsafe.defineClass or equivalent
        at org.apache.webbeans.proxy.Unsafe.lambda$unsafeDefineClass$3(Unsafe.java:217)
        at java.base/java.security.AccessController.doPrivileged(AccessController.java:318)
        at org.apache.webbeans.proxy.Unsafe.unsafeDefineClass(Unsafe.java:209)
        at org.apache.webbeans.proxy.Unsafe.defineAndLoadClass(Unsafe.java:175)
        ... 82 more






Caused by: java.lang.NoSuchMethodException: java.lang.Class.defineClass(java.lang.String,[B,int,int,java.lang.ClassLoader,java.security.ProtectionDomain)
        at java.base/java.lang.Class.getDeclaredMethod(Class.java:2675)
        at org.apache.webbeans.proxy.Unsafe.lambda$unsafeDefineClass$3(Unsafe.java:212)",
0,CAMEL-16970,Sub-task,Major,None,,"
None
",Resolved,Fixed,None,Freeman Yue Fang,Freeman Yue Fang,0,1,2021-09-14 19:25:55+00:00,2022-04-19 13:36:16+00:00,"caused by




[ERROR] WARNING: Illegal reflective access by org.apache.spark.unsafe.Platform (file:/Users/ffang/.m2/repository/org/apache/spark/spark-unsafe_2.12/3.1.2/spark-unsafe_2.12-3.1.2.jar) to constructor java.nio.DirectByteBuffer(long,int)","ffang:1631618939:2021-09-14T19:28:59.818+0000:1631618939:2021-09-14T19:28:59.818+0000:after getting rid of Illegal reflective access, see another error
{code}
java.io.InvalidObjectException: ReflectiveOperationException during deserialization
        at java.base/java.lang.invoke.SerializedLambda.readResolve(SerializedLambda.java:280)
        at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
        at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
        at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
        at java.base/java.lang.reflect.Method.invoke(Method.java:568)
        at java.base/java.io.ObjectStreamClass.invokeReadResolve(ObjectStreamClass.java:1321)
        at java.base/java.io.ObjectInputStream.readOrdinaryObject(ObjectInputStream.java:2251)
        at java.base/java.io.ObjectInputStream.readObject0(ObjectInputStream.java:1742)
        at java.base/java.io.ObjectInputStream$FieldValues.<init>(ObjectInputStream.java:2584)
        at java.base/java.io.ObjectInputStream.readSerialData(ObjectInputStream.java:2442)
        at java.base/java.io.ObjectInputStream.readOrdinaryObject(ObjectInputStream.java:2242)
        at java.base/java.io.ObjectInputStream.readObject0(ObjectInputStream.java:1742)
        at java.base/java.io.ObjectInputStream$FieldValues.<init>(ObjectInputStream.java:2584)
        at java.base/java.io.ObjectInputStream.readSerialData(ObjectInputStream.java:2442)
        at java.base/java.io.ObjectInputStream.readOrdinaryObject(ObjectInputStream.java:2242)
        at java.base/java.io.ObjectInputStream.readObject0(ObjectInputStream.java:1742)
        at java.base/java.io.ObjectInputStream$FieldValues.<init>(ObjectInputStream.java:2584)
        at java.base/java.io.ObjectInputStream.readSerialData(ObjectInputStream.java:2442)
        at java.base/java.io.ObjectInputStream.readOrdinaryObject(ObjectInputStream.java:2242)
        at java.base/java.io.ObjectInputStream.readObject0(ObjectInputStream.java:1742)
        at java.base/java.io.ObjectInputStream.readObject(ObjectInputStream.java:514)
        at java.base/java.io.ObjectInputStream.readObject(ObjectInputStream.java:472)
        at scala.collection.immutable.List$SerializationProxy.readObject(List.scala:527)
        at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
        at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
        at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)

{code}
ffang:1631776360:2021-09-16T15:12:40.878+0000:1631776360:2021-09-16T15:12:40.878+0000:On Apache Spark side, 
SPARK-35557 tracks the JDK internal API usage(Illegal reflective access) and SPARK-33772 tracks JDK17 support as a whole"
0,CAMEL-16969,Sub-task,Major,None,,"
None
",Resolved,Fixed,None,Freeman Yue Fang,Freeman Yue Fang,0,1,2021-09-14 19:23:30+00:00,2022-04-19 13:35:57+00:00,"caused by




java.lang.IllegalAccessError: superclass access check failed: class com.sun.xml.messaging.saaj.soap.SOAPDocumentImpl (in unnamed module @0xbf20622) cannot access class com.sun.org.apache.xerces.internal.dom.DocumentImpl (in module java.xml) because module java.xml does not export com.sun.org.apache.xerces.internal.dom to unnamed module @0xbf20622",
0,CAMEL-16968,Sub-task,Major,None,3.12.0,"
None
",Resolved,Fixed,3.12.0,Freeman Yue Fang,Freeman Yue Fang,0,1,2021-09-14 19:22:39+00:00,2021-09-23 14:23:15+00:00,"caused by




[ERROR] WARNING: Illegal reflective access by com.thoughtworks.xstream.converters.reflection.PureJavaReflectionProvider$Reflections (file:/Users/ffang/.m2/repository/com/thoughtworks/xstream/xstream/1.4.18/xstream-1.4.18.jar) to method java.io.ObjectStreamClass.newInstance()","ffang:1632378168:2021-09-23T14:22:48.800+0000:1632378195:2021-09-23T14:23:15.723+0000:Luckily, we don't have issues with JDK17 anymore after CAMEL-16388 is fixed
{code}
commit ce6f09f918a944fdc3eac7b7a1d483ab852b8ce2
Author: Jeremy Ross <jeremy.g.ross@gmail.com>
Date:   Tue Sep 21 11:55:27 2021 -0500

    CAMEL-16388: camel-salesforce: remove XML format.
{code}"
0,CAMEL-16967,Sub-task,Major,None,None,"
None
",Resolved,Fixed,None,Freeman Yue Fang,Freeman Yue Fang,0,1,2021-09-14 19:20:13+00:00,2022-04-19 13:35:36+00:00,"caused by




[ERROR] WARNING: Illegal reflective access by org.python.core.io.StreamIO (file:/Users/ffang/.m2/repository/org/robotframework/robotframework/4.1/robotframework-4.1.jar) to field java.io.FilterOutputStream.out","ffang:1631618478:2021-09-14T19:21:18.283+0000:1631618478:2021-09-14T19:21:18.283+0000:And even after getting ride of Illegal reflective access, another error pups up
{code}
ImportError: cannot import name setitimer

        at org.python.core.Py.ImportError(Py.java:329)
        at org.python.core.imp.importFromAs(imp.java:1632)
        at org.python.core.imp.importFrom(imp.java:1595)
        at robot.running.timeouts.posix$py.f$0(/Users/juhosaarinen/git/robotframework/build/Lib/robot/running/timeouts/posix.py:19)
        at robot.running.timeouts.posix$py.call_function(/Users/juhosaarinen/git/robotframework/build/Lib/robot/running/timeouts/posix.py)
        at org.python.core.PyTableCode.call(PyTableCode.java:173)
        at org.python.core.PyCode.call(PyCode.java:18)
        at org.python.core.imp.createFromCode(imp.java:630)
        at org.python.core.util.importer.importer_load_module(importer.java:120)
        at org.python.modules.zipimport.zipimporter.zipimporter_load_module(zipimporter.java:175)
        at org.python.modules.zipimport.zipimporter$zipimporter_load_module_exposer.__call__(Unknown Source)
{code}
and this error also exists for JDK16
ffang:1632819165:2021-09-28T16:52:45.459+0000:1632930587:2021-09-29T23:49:47.272+0000:Eventually I figured out what's going on here.

""setitimer"" is an posix API, but this shouldn't be used when using JDK, the java implementation should be used instead.

The reason is from robotframework codebase, the src/robot/utils/platform.py
The way to determine if java is used is like
{code}
java_match = re.match(r'java(\d+)\.(\d+)\.(\d+)', sys.platform)
if java_match:
    JYTHON = True
    JAVA_VERSION = tuple(int(i) for i in java_match.groups())
{code}
This works while java version is like ""11.0.12"" or ""1.8.0_261"". However this doesn't work while java version is ""17"" (or something like 18-ea), which is the latest JDK17 release version. This will cause JYTHON = false and hence can't load JYTHON lib when using JAVA

raised a ticket in robotframework here
https://github.com/robotframework/robotframework/issues/4099
This is quickly fixed at robotframework and the coming robotfamework 4.1.2 will contain the fix.

ffang:1634747216:2021-10-21T00:26:56.960+0000:1634747216:2021-10-21T00:26:56.960+0000:The robotfamework 4.1.2 is out, upgrade to this version to pick up the fix there."
0,CAMEL-16966,Sub-task,Major,None,,"
None
",Resolved,Fixed,None,Freeman Yue Fang,Freeman Yue Fang,0,1,2021-09-14 19:16:27+00:00,2022-04-19 13:35:27+00:00,"caused by




[ERROR] WARNING: Illegal reflective access by org.apache.camel.component.printer.PrinterPrintTest (file:/Users/ffang/projects/camel/components/camel-printer/target/test-classes/) to method javax.print.PrintServiceLookup.initListOfLookupServices()","ffang:1631772547:2021-09-16T14:09:07.668+0000:1631772547:2021-09-16T14:09:07.668+0000:It's only the test code PrinterPrintTest tries to access the sun.awt.AppContext to hack/mock/restore print service
sun.awt.AppContext.getAppContext().put(printServiceLookupServicesClass, printServiceLookup);

and I can't find a replacement public API can do the same, so a profile to configure maven-surefire-plugin(--add-opens) with JDK17 should be sufficient for now IMO"
0,CAMEL-16965,Sub-task,Major,None,,"
None
",Resolved,Fixed,None,Freeman Yue Fang,Freeman Yue Fang,0,1,2021-09-14 19:05:53+00:00,2022-04-19 13:35:21+00:00,"caused by




[ERROR] WARNING: Illegal reflective access by com.fasterxml.jackson.databind.util.ClassUtil (file:/Users/ffang/.m2/repository/com/fasterxml/jackson/core/jackson-databind/2.12.4/jackson-databind-2.12.4.jar) to field java.lang.Throwable.detailMessage","ffang:1632209993:2021-09-21T15:39:53.829+0000:1632209993:2021-09-21T15:39:53.829+0000:The root cause is from fasterxml jackson-databinding and there is a known issue to track it
https://github.com/FasterXML/jackson-databind/issues/3275

We need to use add-opens explicitly in camel-leveldb test for now"
0,CAMEL-16964,Sub-task,Major,None,,"
None
",Resolved,Fixed,None,Freeman Yue Fang,Freeman Yue Fang,0,1,2021-09-14 19:04:44+00:00,2022-04-19 13:35:08+00:00,"caused by




[ERROR] WARNING: Illegal reflective access by com.google.inject.internal.cglib.core.$ReflectUtils$2 (file:/Users/ffang/.m2/repository/com/google/inject/guice/3.0/guice-3.0.jar) to method java.lang.ClassLoader.defineClass(java.lang.String,byte[],int,int,java.security.ProtectionDomain)","ffang:1632208069:2021-09-21T15:07:49.088+0000:1632208069:2021-09-21T15:07:49.088+0000:There is a known issue to track it in Apache Jclouds(JCLOUDS-1402), and actually the root cause is from google guice
https://github.com/google/guice/issues/1133

And seems guice gets rid of it since 5.0.1, so until there is a jclouds version with guice fix available, we need to explicitly use add-opens in camel-jclouds test"
0,CAMEL-16963,Sub-task,Major,None,,"
None
",Resolved,Fixed,None,Freeman Yue Fang,Freeman Yue Fang,0,1,2021-09-14 19:00:59+00:00,2022-04-19 13:34:23+00:00,[ERROR] WARNING: Illegal reflective access by org.apache.ignite.internal.util.GridUnsafe$2 (file:/Users/ffang/.m2/repository/org/apache/ignite/ignite-core/2.10.0/ignite-core-2.10.0.jar) to field java.nio.Buffer.address,"ffang:1631617391:2021-09-14T19:03:11.169+0000:1631617391:2021-09-14T19:03:11.169+0000:And even with 
--add-opens java.base/java.nio=ALL-UNNAMED
to get rid of the Illegal reflective access issue, the JVM still exits
{code}
[ERROR] Failed to execute goal org.apache.maven.plugins:maven-surefire-plugin:3.0.0-M5:test (default-test) on project camel-ignite: There are test failures.
[ERROR] 
[ERROR] Please refer to /Users/ffang/projects/camel/components/camel-ignite/target/surefire-reports for the individual test results.
[ERROR] Please refer to dump files (if any exist) [date].dump, [date]-jvmRun[N].dump and [date].dumpstream.
[ERROR] The forked VM terminated without properly saying goodbye. VM crash or System.exit called?
[ERROR] Command was /bin/sh -c cd /Users/ffang/projects/camel/components/camel-ignite && /Library/Java/JavaVirtualMachines/jdk-17.jdk/Contents/Home/bin/java --add-opens java.base/java.nio=ALL-UNNAMED -jar /Users/ffang/projects/camel/components/camel-ignite/target/surefire/surefirebooter16612101021437560053.jar /Users/ffang/projects/camel/components/camel-ignite/target/surefire 2021-09-14T15-01-39_006-jvmRun1 surefire15289566757747289034tmp surefire_04498906657607238731tmp
[ERROR] Error occurred in starting fork, check output in log
[ERROR] Process Exit Code: 130
[ERROR] Crashed tests:
[ERROR] org.apache.camel.component.ignite.IgniteCacheContinuousQueryTest
[ERROR] org.apache.maven.surefire.booter.SurefireBooterForkException: The forked VM terminated without properly saying goodbye. VM crash or System.exit called?
[ERROR] Command was /bin/sh -c cd /Users/ffang/projects/camel/components/camel-ignite && /Library/Java/JavaVirtualMachines/jdk-17.jdk/Contents/Home/bin/java --add-opens java.base/java.nio=ALL-UNNAMED -jar /Users/ffang/projects/camel/components/camel-ignite/target/surefire/surefirebooter16612101021437560053.jar /Users/ffang/projects/camel/components/camel-ignite/target/surefire 2021-09-14T15-01-39_006-jvmRun1 surefire15289566757747289034tmp surefire_04498906657607238731tmp
[ERROR] Error occurred in starting fork, check output in log
[ERROR] Process Exit Code: 130
[ERROR] Crashed tests:
[ERROR] org.apache.camel.component.ignite.IgniteCacheContinuousQueryTest
[ERROR] 	at org.apache.maven.plugin.surefire.booterclient.ForkStarter.fork(ForkStarter.java:748)
[ERROR] 	at org.apache.maven.plugin.surefire.booterclient.ForkStarter.run(ForkStarter.java:305)
[ERROR] 	at org.apache.maven.plugin.surefire.booterclient.ForkStarter.run(ForkStarter.java:265)
[ERROR] 	at org.apache.maven.plugin.surefire.AbstractSurefireMojo.executeProvider(AbstractSurefireMojo.java:1314)
[ERROR] 	at org.apache.maven.plugin.surefire.AbstractSurefireMojo.executeAfterPreconditionsChecked(AbstractSurefireMojo.java:1159)
[ERROR] 	at org.apache.maven.plugin.surefire.AbstractSurefireMojo.execute(AbstractSurefireMojo.java:932)
[ERROR] 	at org.apache.maven.plugin.DefaultBuildPluginManager.executeMojo(DefaultBuildPluginManager.java:137)
[ERROR] 	at org.apache.maven.lifecycle.internal.MojoExecutor.execute(MojoExecutor.java:210)
[ERROR] 	at org.apache.maven.lifecycle.internal.MojoExecutor.execute(MojoExecutor.java:156)
[ERROR] 	at org.apache.maven.lifecycle.internal.MojoExecutor.execute(MojoExecutor.java:148)
[ERROR] 	at org.apache.maven.lifecycle.internal.LifecycleModuleBuilder.buildProject(LifecycleModuleBuilder.java:117)
{code}
ffang:1631803171:2021-09-16T22:39:31.496+0000:1631803171:2021-09-16T22:39:31.496+0000:The org.apache.ignite.internal.processors.cache.GridCachePartitionExchangeManager line 867
{code}
new IgniteThread(cctx.igniteInstanceName(), ""exchange-worker"", exchWorker).start();
{code}
somehow cause the JVM exit on JDK17
ffang:1632829721:2021-09-28T19:48:41.274+0000:1632830932:2021-09-28T20:08:52.162+0000:I installed apache-ignite-2.10.0-bin kit, and I tried to start standalone ignite service with the script bin/ignite.sh, where can give me more informative error message so that I can tune the necessary JVM flags with JDK17.  And I 
figured these flags are necessary
{code}
elif [ $version -ge 17 ] ; then
    JVM_OPTS=""\
        --add-exports=java.base/jdk.internal.misc=ALL-UNNAMED \
        --add-exports=java.base/sun.nio.ch=ALL-UNNAMED \
        --add-exports=java.management/com.sun.jmx.mbeanserver=ALL-UNNAMED \
        --add-exports=jdk.internal.jvmstat/sun.jvmstat.monitor=ALL-UNNAMED \
        --add-exports=java.base/sun.reflect.generics.reflectiveObjects=ALL-UNNAMED \
        --add-opens jdk.management/com.sun.management.internal=ALL-UNNAMED \
        --add-opens java.base/java.nio=ALL-UNNAMED \
        --add-opens java.base/java.util=ALL-UNNAMED \
        --add-opens java.base/java.lang=ALL-UNNAMED \
        ${JVM_OPTS}""
fi
{code}

Besides fix this up in camel-ignite test, I will also send a PR to fix this up in bin/ignite.sh(tracked by IGNITE-15635)"
0,CAMEL-16962,Sub-task,Major,None,,"
None
",Resolved,Fixed,None,Freeman Yue Fang,Freeman Yue Fang,0,1,2021-09-14 18:58:49+00:00,2022-04-19 13:34:12+00:00,[ERROR] WARNING: Illegal reflective access by org.apache.flink.api.java.ClosureCleaner (file:/Users/ffang/.m2/repository/org/apache/flink/flink-core/1.13.2/flink-core-1.13.2.jar) to field java.lang.String.value,"ffang:1632206537:2021-09-21T14:42:17.441+0000:1632206537:2021-09-21T14:42:17.441+0000:There is a know issue(FLINK-17530) in Apache Flink to track it, so until it's fixed in Apache Flink, we need to explicitly use add-opens in camel-flink tests.

"
0,CAMEL-16961,Sub-task,Major,None,3.12.0,"
None
",Resolved,Fixed,3.12.0,Freeman Yue Fang,Freeman Yue Fang,0,1,2021-09-14 18:56:31+00:00,2021-09-15 15:20:41+00:00,"get error like




2021-09-14 14:53:52,800 [erExecutorGroup] WARN  NettyConsumer                  - Closing channel as an exception was thrown from Netty. Caused by: [java.lang.UnsupportedOperationException - This method is deprecated and marked for removal. Use the getPeerCertificates() method instead.]
java.lang.UnsupportedOperationException: This method is deprecated and marked for removal. Use the getPeerCertificates() method instead.
        at javax.net.ssl.SSLSession.getPeerCertificateChain(SSLSession.java:295) ~[?:?]
        at org.apache.camel.component.netty.NettyEndpoint.enrichWithClientCertInformation(NettyEndpoint.java:141) ~[classes/:?]
        at org.apache.camel.component.netty.NettyEndpoint.updateMessageHeader(NettyEndpoint.java:126) ~[classes/:?]
        at org.apache.camel.component.netty.handlers.ServerChannelHandler.createExchange(ServerChannelHandler.java:119) ~[classes/:?]
        at org.apache.camel.component.netty.handlers.ServerChannelHandler.channelRead0(ServerChannelHandler.java:90) ~[classes/:?]
        at io.netty.channel.SimpleChannelInboundHandler.channelRead(SimpleChannelInboundHandler.java:99) ~[netty-transport-4.1.63.Final.jar:4.1.63.Final]
        at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379) [netty-transport-4.1.63.Final.jar:4.1.63.Final]
        at io.netty.channel.AbstractChannelHandlerContext.access$600(AbstractChannelHandlerContext.java:61) [netty-transport-4.1.63.Final.jar:4.1.63.Final]
        at io.netty.channel.AbstractChannelHandlerContext$7.run(AbstractChannelHandlerContext.java:370) [netty-transport-4.1.63.Final.jar:4.1.63.Final]
        at io.netty.util.concurrent.DefaultEventExecutor.run(DefaultEventExecutor.java:66) [netty-common-4.1.63.Final.jar:4.1.63.Final]
        at io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:989) [netty-common-4.1.63.Final.jar:4.1.63.Final]
        at io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74) [netty-common-4.1.63.Final.jar:4.1.63.Final]
        at java.lang.Thread.run(Thread.java:833) [?:?]","ffang:1631617037:2021-09-14T18:57:17.775+0000:1631617037:2021-09-14T18:57:17.775+0000:This test actually failed since JDK15, and caused by the JDK change tracked here
https://bugs.openjdk.java.net/browse/JDK-8241039"
0,CAMEL-16960,Sub-task,Major,None,,"
None
",Resolved,Fixed,None,Freeman Yue Fang,Freeman Yue Fang,0,1,2021-09-14 18:33:43+00:00,2022-04-19 13:34:05+00:00,No Desc,"ffang:1631616217:2021-09-14T18:43:37.716+0000:1631616217:2021-09-14T18:43:37.716+0000:errors like
{code}
java.lang.IllegalAccessError: superclass access check failed: class com.sun.xml.messaging.saaj.soap.SOAPDocumentImpl (in unnamed module @0x1da51a35) cannot access class com.sun.org.apache.xerces.internal.dom.DocumentImpl (in module java.xml) because module java.xml does not export com.sun.org.apache.xerces.internal.dom to unnamed module
{code}

{code}
[ERROR] WARNING: Illegal reflective access by net.sf.cglib.core.ReflectUtils$1 (file:/Users/ffang/.m2/repository/cglib/cglib-nodep/3.2.12/cglib-nodep-3.2.12.jar) to method java.lang.ClassLoader.defineClass(java.lang.String,byte[],int,int,java.security.ProtectionDomain)
[ERROR] WARNING: Please consider reporting this to the maintainers of net.sf.cglib.core.ReflectUtils$1
{code}"
0,CAMEL-16959,Sub-task,Major,None,3.12.0,"
None
",Resolved,Fixed,3.12.0,Freeman Yue Fang,Freeman Yue Fang,0,1,2021-09-14 18:16:41+00:00,2021-09-16 13:10:48+00:00,"we can see from the log




java.security.SignatureException: java.security.InvalidAlgorithmParameterException: Legacy SunEC curve disabled:  sect409r1 [NIST B-409] (1.3.132.0.37)
        at sun.security.ec.ECDSASignature.engineSign(ECDSASignature.java:472) ~[jdk.crypto.ec:?]
        at java.security.Signature$Delegate.engineSign(Signature.java:1424) ~[?:?]
        at java.security.Signature.sign(Signature.java:713) ~[?:?]
        at org.apache.camel.component.crypto.processor.SigningProcessor.process(SigningProcessor.java:42) ~[classes/:?]
        at org.apache.camel.component.crypto.DigitalSignatureProducer.process(DigitalSignatureProducer.java:37) ~[classes/:?]
        at org.apache.camel.support.AsyncProcessorConverterHelper$ProcessorToAsyncProcessorBridge.process(AsyncProcessorConverterHelper.java:66) ~[camel-support-3.12.0-SNAPSHOT.jar:3.12.0-SNAPSHOT]
        at org.apache.camel.processor.SendProcessor.process(SendProcessor.java:172) ~[camel-core-processor-3.12.0-SNAPSHOT.jar:3.12.0-SNAPSHOT]
        at org.apache.camel.processor.errorhandler.RedeliveryErrorHandler$SimpleTask.run(RedeliveryErrorHandler.java:469) ~[camel-core-processor-3.12.0-SNAPSHOT.jar:3.12.0-SNAPSHOT]





this error actually exists since JDK16, and I believe this is caused by the JDK change(Remove the legacy elliptic curves) tracked by
https://bugs.openjdk.java.net/browse/JDK-8251547","ffang:1631724510:2021-09-16T00:48:30.472+0000:1631724609:2021-09-16T00:50:09.307+0000:Currently the test is using keystore ecdsa.jks, which uses elliptic curves(EC) sect409r1  , and sect409r1 is r[emoved from the SunEC provider since JDK16|https://bugs.openjdk.java.net/browse/JDK-8251547]. SunEC will continue to support curves secp256r1, secp384r1, secp521r1, x25519, x448, ed25519, and ed448, so if we generate keystore with supported elliptic curves(such as secp384r1), we should be good with JDK17

and this cli
keytool -genkeypair -keyalg EC -groupname secp384r1  -alias ECDSA -keystore ecdsa.jks -storepass security -validity 1600
seems can fix the broken test.
The parameter ""-groupname secp384r1 "" matters here

"
0,CAMEL-16958,Task,Major,None,None,"
None
",Resolved,Fixed,3.17.0,Freeman Yue Fang,Freeman Yue Fang,1,4,2021-09-14 16:28:42+00:00,2022-04-19 13:33:32+00:00,to ensure we can build and pass all tests with JDK17,"acosentino:1631608188:2021-09-14T16:29:48.478+0000:1631608188:2021-09-14T16:29:48.478+0000:I've done some build with JDK 17 EA and at least the build was in good shape.
ffang:1631608829:2021-09-14T16:40:29.139+0000:1631608829:2021-09-14T16:40:29.139+0000:I just did a quick run on latest camel code with JDK17, and I noticed about 20 components have failed tests.

More of those failed tests are from the fact that since JDK17 , --illegal-access jvm flag is removed and we need to either explicitly use --add-opens modules to enable ""deep"" reflection for JDK internal code or we need to get rid of the way to use JDK Internals. And this problem exists in both camel codebase(less) and 3rd party dependencies(more). To fix this from 3rd party dependencies, we need to reach out and create issues in other communities, and before they are fixed, we can use --add-opens temporarily in camel.

Some other failed tests and caused by that in JDK17, some legacy cryptographic cipher are removed.

I'm going to create sub jira issues to track problem we've hit separately for components with JDK17, and put more details there. 


ffang:1631608918:2021-09-14T16:41:58.874+0000:1631608918:2021-09-14T16:41:58.874+0000:[~acosentino], yes, more about fixing up the broken tests with JDK17
acosentino:1631664383:2021-09-15T08:06:23.376+0000:1631664383:2021-09-15T08:06:23.376+0000:I created a jenkins job using the latest EA build of JDK 17 https://ci-builds.apache.org/job/Camel/job/Camel%20JDK16/job/main/128/console
ffang:1631676026:2021-09-15T11:20:26.359+0000:1631676026:2021-09-15T11:20:26.359+0000:Thanks [~acosentino]!
orange-buffalo:1647899062:2022-03-22T05:44:22.355+0000:1647899062:2022-03-22T05:44:22.355+0000:Hi guys, is there any roadmap or understanding when Camel version compatible with JDK 17 is released? 
davsclaus:1647931369:2022-03-22T14:42:49.548+0000:1647931369:2022-03-22T14:42:49.548+0000:You are welcome to run it on JDK17 and provide feedvback. There is a few components that wont work on JDK17 but almost all of the others seems to work and pass on CI servers.
davsclaus:1650344315:2022-04-19T12:58:35.013+0000:1650344315:2022-04-19T12:58:35.013+0000:[~ffang] - I think all the sub JIRAs is resolved as all these tests run on JDK17 now.
davsclaus:1650344339:2022-04-19T12:58:59.961+0000:1650344339:2022-04-19T12:58:59.961+0000:camel-servlet and camel-infinispan still have JDK17 problems
ffang:1650344626:2022-04-19T13:03:46.241+0000:1650344626:2022-04-19T13:03:46.241+0000:Thanks [~davsclaus] for the update, I will take a close look at the failed tests with JDK17.
davsclaus:1650344705:2022-04-19T13:05:05.589+0000:1650344705:2022-04-19T13:05:05.589+0000:Lets try to make this for 3.17 so we have a release out before the LTS where users can test this on Java 17 and give feedback before the LTS. We are very close.
ffang:1650346403:2022-04-19T13:33:23.260+0000:1650346403:2022-04-19T13:33:23.260+0000:Hi [~davsclaus],

camel-servlet and camel-infinispan on jdk17 are fixed by this commit
https://github.com/apache/camel/commit/31eed8be75a94ed71398fd12dff2ed9962936929

Cheers
Freeman"
0,CAMEL-16957,Bug,Major,3.11.0,"3.7.6, 3.11.3, 3.12.0","
None
",Resolved,Fixed,"3.7.6, 3.11.3, 3.12.0",Andrea Cosentino,Sergey Zhemzhitsky,0,2,2021-09-14 12:28:19+00:00,2021-09-24 20:17:29+00:00,"NettyHttpHelper appends slash to an URI in case of empty CamelHttpPath possibly leading to 404/NOT_FOUND errors.


Test to reproduce




    @Test
    public void testEmptyPathDoesNotEndsWithSlash() throws Exception {
        MockEndpoint input = getMockEndpoint(""mock:input"");
        input.expectedBodiesReceived(""Hello World"");
        input.expectedHeaderReceived(Exchange.HTTP_PATH, """");
        input.expectedHeaderReceived(Exchange.HTTP_URI, ""/foo"");

        template.request(""netty-http:http://localhost:{{port}}/foo"", exchange -> {
            Message in = exchange.getIn();
            in.setBody(""Hello World"");
            in.setHeader(Exchange.HTTP_PATH, """");
        });

        assertMockEndpointsSatisfied();
    }




... fails with




java.lang.AssertionError: mock://input Header with name CamelHttpPath for message: 0. Expected: <> but was: </>
Expected :<>
Actual   :</>
<Click to see difference>

	at org.apache.camel.component.mock.MockEndpoint.fail(MockEndpoint.java:1782)
	at org.apache.camel.component.mock.MockEndpoint.assertEquals(MockEndpoint.java:1759)
	at org.apache.camel.component.mock.MockEndpoint$4.assertOnIndex(MockEndpoint.java:608)
	at org.apache.camel.component.mock.MockEndpoint.onExchange(MockEndpoint.java:1599)","davsclaus:1631787798:2021-09-16T18:23:18.164+0000:1631787798:2021-09-16T18:23:18.164+0000:I suspect this caused some other tests to fail in endpoint-dsl and camel-servlet.
https://ci-builds.apache.org/job/Camel/job/Camel%20JDK11/job/main/lastCompletedBuild/testReport/

Though not completely sure, but this could be. So just opening this ticket to not forget and look into those failures and if its this PR or not.
davsclaus:1632466518:2021-09-24T14:55:18.341+0000:1632466518:2021-09-24T14:55:18.341+0000:Okay this is only in camel-netty, but there are some general http problems. Darn then need to dive into what commits caused this
davsclaus:1632485849:2021-09-24T20:17:29.883+0000:1632485849:2021-09-24T20:17:29.883+0000:Okay so it seems it was CAMEL-16906  that caused some other http tests to fail and not specific this one"
0,CAMEL-16956,Improvement,Major,None,4.x,"
None
",Open,Unresolved,4.x,Andrea Cosentino,Andrea Cosentino,2,3,2021-09-14 11:41:34+00:00,2023-08-09 09:18:17+00:00,"At the moment the concurrent consumers value is set on the consumer scheduler. We need to do something like we are doing in camel-nats, where we define a poolSize for the executor Services and spin up concurrent consumers based on this value and an executor service.","ben-pensionarchitects:1631594264:2021-09-14T12:37:44.024+0000:1631594264:2021-09-14T12:37:44.024+0000:Current workaround I used to fix this:
{code:java}
from(aws2Sqs(""input.fifo""))
.to(seda(""test"").blockWhenFull(true));

from(seda(""test"").size(1).concurrentConsumers(5))
to(""slow"");
{code}
acosentino:1631866737:2021-09-17T16:18:57.135+0000:1631866737:2021-09-17T16:18:57.135+0000:Probably it makes sense to have a second type of consumer and leaving the batch one, which makes still sense.
smox:1673761038:2023-01-15T13:37:18.547+0000:1673761038:2023-01-15T13:37:18.547+0000:Another solution which only uses a single route:
{code:java}
from(aws2Sqs(""input.fifo"")).threads(1,5,200).to(""slow"");
{code}
This achieves same as above workaround. This can be used together with extendMessageVisibility and maxMessagesPerPoll to increase throughput.

The consumer will immediately forward the message(s) to the threads EIP and begin the next poll."
0,CAMEL-16955,Improvement,Major,None,None,"
None
",Resolved,Fixed,3.12.0,Unassigned,Hokutor,0,1,2021-09-14 09:56:39+00:00,2021-09-18 08:41:41+00:00,"At present, Camel HuaweiCloud components, including dms, functiongraph, iam, obs and smn, uses  'authenticationKey' as a security authentication parameter, while in HuaweiCloud, this parameter is called 'accessKey'. To correspond with HuaweiCloud, we should rename this parameter from authenticationKey to accessKey.",
0,CAMEL-16954,Test,Major,3.12.0,3.12.0,"
None
",Resolved,Fixed,3.12.0,Karen Lease,Karen Lease,0,2,2021-09-13 19:58:35+00:00,2021-09-27 13:20:06+00:00,"The test org.apache.camel.spring.cloud.CamelSpringCloudServiceCallRibbonTest.testServiceCall() fails to load the application context:




Caused by: org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'configurationPropertiesBeans' defined in class path resource [org/springframework/cloud/autoconfigure/ConfigurationPropertiesRebinderAutoConfiguration.class]: Post-processing of merged bean definition failed; nested exception is java.lang.IllegalStateException: Failed to introspect Class [org.springframework.cloud.context.properties.ConfigurationPropertiesBeans]
...
Caused by: java.lang.ClassNotFoundException: org.springframework.boot.context.properties.ConfigurationBeanFactoryMetadata




Some other tests using spring-cloud and spring-boot also fail with this exception.","klease78:1631534652:2021-09-13T20:04:12.993+0000:1631534652:2021-09-13T20:04:12.993+0000:The current spring-cloud pom uses spring-cloud 2.2.6.RELEASE and spring-boot 2.5.4. This version of spring-cloud references ConfigurationBeanFactoryMetadata which was removed in spring-boot 2.4.0.
To fix this we'd need to upgrade to spring-cloud 3.0.x.
This causes test failures but presumably would also cause failures in applications using these dependencies.
davsclaus:1631925868:2021-09-18T08:44:28.799+0000:1631925868:2021-09-18T08:44:28.799+0000:Karen you are welcome to work on this
klease78:1631968917:2021-09-18T20:41:57.092+0000:1631973199:2021-09-18T21:53:19.742+0000:[~davsclaus] I did have a look at it. If I upgrade the pom versions of the springframework cloud artifacts to 3.0.x then there are compile errors in some of the camel spring-boot cloud classes because they reference some classes like ConsulServer & ZookeeperServer which are no longer present in the Spring jars. In fact, the 3.0.x versions of Spring cloud removed dependencies on several spring-cloud-netflix components such as Ribbon and related classes.
I'm not familiar with those components to decide if the related camel classes, for example org.apache.camel.spring.cloud.zookeeper.ZookeeperServerToServiceDefinition are no longer necessary or if it should be replaced by something else.
Unfortunately none of the current camel-spring-boot-examples actually use the camel spring cloud components so I don't have a more realistic use case to play with.
Since the Camel Spring Boot Cloud modules are all marked as deprecated, is it intended that they should be removed completely at some point?
davsclaus:1632093263:2021-09-20T07:14:23.066+0000:1632093263:2021-09-20T07:14:23.066+0000:Hmm all those SB cloud components in camel-spring-boot are deprecated anyway. They are using old tech that are outdated, and as you say even SB stopped supporting them such as ZK and Ribbon.

So lets just remove all of those instead. And add a note in the 3.12 upgrade guide.
https://camel.apache.org/manual/latest/camel-3x-upgrade-guide-3_12.html
davsclaus:1632649364:2021-09-26T17:42:44.457+0000:1632649364:2021-09-26T17:42:44.457+0000:Karen would you be able to work on this, otherwise we may need to move this to the next 3.13 release, as we want to release 3.12 soon.
klease78:1632659767:2021-09-26T20:36:07.140+0000:1632663997:2021-09-26T21:46:37.309+0000:Yes, I think I should be able to put in a PR tomorrow to remove all the spring-boot-cloud components in both camel-spring-boot/core and camel-spring-boot/components-starter, if that was your intention with ""let's just remove all of those instead"".
davsclaus:1632687533:2021-09-27T04:18:53.711+0000:1632687533:2021-09-27T04:18:53.711+0000:Yes that is correct
klease78:1632704753:2021-09-27T09:05:53.206+0000:1632704753:2021-09-27T09:05:53.206+0000:https://github.com/apache/camel-spring-boot/pull/373
davsclaus:1632705488:2021-09-27T09:18:08.394+0000:1632705488:2021-09-27T09:18:08.394+0000:Thanks Karen

Can you add a note about this removal in the 3.12 upgrade doc
https://github.com/apache/camel/blob/main/docs/user-manual/modules/ROOT/pages/camel-3x-upgrade-guide-3_12.adoc
klease78:1632709227:2021-09-27T10:20:27.752+0000:1632709227:2021-09-27T10:20:27.752+0000:Done: https://github.com/apache/camel/pull/6161"
0,CAMEL-16953,Improvement,Major,3.11.0,None,"
None
",Resolved,Fixed,3.12.0,Claus Ibsen,Roman Vottner,0,2,2021-09-13 17:03:48+00:00,2021-09-24 08:29:02+00:00,"ZulipChat-Discussion: https://camel.zulipchat.com/#narrow/stream/257298-camel/topic/tar.2Egz.20unmarshalling


In a very simple route setup that just reads any tar.gz archives found in the provided directory and prints the names of the files within that archive to the log, this code fails on processing larger tar.gz archives.


PreProcessingRoute.java

from(file(""archiveFile""))
 .routeId(""pre-processing"")
 .process(exchange -> {
 LOG.info(""Processing archive: {}"", exchange.getIn().getHeader(Exchange.FILE_NAME, String.class));
 })
 .unmarshal().gzipDeflater()
 .split(new TarSplitter()).streaming()
 .process(exchange -> {
 final String name = exchange.getIn().getHeader(Exchange.FILE_NAME, String.class); 
 LOG.debug(""name: {}"", name);
 })
 .end();




The JVM quickly runs out of memory as it probably copies over the bytes from the original stream to a stream that should take care of decompressing the files, as indicated by the exception being thrown in the `hugeCapacity(...)` method of the `ByteArrayOutputStream`class:


StackTrace

org.apache.camel.CamelExecutionException: Exception occurred during execution on the exchange: Exchange[]
 at org.apache.camel.CamelExecutionException.wrapCamelExecutionException(CamelExecutionException.java:45)
 at org.apache.camel.support.AbstractExchange.setException(AbstractExchange.java:589)
 at org.apache.camel.support.DefaultExchange.setException(DefaultExchange.java:27)
 at org.apache.camel.support.processor.UnmarshalProcessor.process(UnmarshalProcessor.java:81)
 at org.apache.camel.processor.errorhandler.RedeliveryErrorHandler$SimpleTask.run(RedeliveryErrorHandler.java:463)
 at org.apache.camel.impl.engine.DefaultReactiveExecutor$Worker.schedule(DefaultReactiveExecutor.java:179)
 at org.apache.camel.impl.engine.DefaultReactiveExecutor.scheduleMain(DefaultReactiveExecutor.java:64)
 at org.apache.camel.processor.Pipeline.process(Pipeline.java:184)
 at org.apache.camel.impl.engine.CamelInternalProcessor.process(CamelInternalProcessor.java:398)
 at org.apache.camel.component.file.GenericFileConsumer.processExchange(GenericFileConsumer.java:492)
 at org.apache.camel.component.file.GenericFileConsumer.processBatch(GenericFileConsumer.java:245)
 at org.apache.camel.component.file.GenericFileConsumer.poll(GenericFileConsumer.java:206)
 at org.apache.camel.support.ScheduledPollConsumer.doRun(ScheduledPollConsumer.java:190)
 at org.apache.camel.support.ScheduledPollConsumer.run(ScheduledPollConsumer.java:107)
 at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)
 at java.util.concurrent.FutureTask.runAndReset$$$capture(FutureTask.java:308)
 at java.util.concurrent.FutureTask.runAndReset(FutureTask.java)
 at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$301(ScheduledThreadPoolExecutor.java:180)
 at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:294)
 at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)
 at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
 at java.lang.Thread.run(Thread.java:748)
Caused by: java.lang.OutOfMemoryError: null
 at java.io.ByteArrayOutputStream.hugeCapacity(ByteArrayOutputStream.java:123)
 at java.io.ByteArrayOutputStream.grow(ByteArrayOutputStream.java:117)
 at java.io.ByteArrayOutputStream.ensureCapacity(ByteArrayOutputStream.java:93)
 at java.io.ByteArrayOutputStream.write(ByteArrayOutputStream.java:153)
 at org.apache.camel.support.builder.OutputStreamBuilder.write(OutputStreamBuilder.java:58)
 at org.apache.camel.util.IOHelper.copy(IOHelper.java:193)
 at org.apache.camel.util.IOHelper.copy(IOHelper.java:148)
 at org.apache.camel.util.IOHelper.copy(IOHelper.java:143)
 at org.apache.camel.util.IOHelper.copy(IOHelper.java:139)
 at org.apache.camel.dataformat.deflater.GzipDeflaterDataFormat.unmarshal(GzipDeflaterDataFormat.java:63)
 at org.apache.camel.support.processor.UnmarshalProcessor.process(UnmarshalProcessor.java:64)
 ... 18 common frames omitted




If I instead use a custom DataFormat class that looks like this:


PreProcessingRoute.java

import org.apache.camel.Exchange;
import org.apache.camel.spi.DataFormat;
import org.apache.camel.util.IOHelper;
import org.apache.commons.compress.compressors.gzip.GzipCompressorInputStream;
import org.apache.commons.compress.compressors.gzip.GzipCompressorOutputStream;

import java.io.InputStream;
import java.io.OutputStream;

public class GZipDataFormat implements DataFormat {

@Override
 public void marshal(Exchange exchange, Object graph, OutputStream stream) throws Exception {
 InputStream is = exchange.getContext().getTypeConverter().mandatoryConvertTo(InputStream.class, exchange, graph);

GzipCompressorOutputStream zipOutput = new GzipCompressorOutputStream(stream);
 try {
 IOHelper.copy(is, zipOutput);
 } finally {
 // must close all input streams
 IOHelper.close(is, zipOutput);
 }
 }

@Override
 public Object unmarshal(Exchange exchange, InputStream stream) throws Exception {
 return new GzipCompressorInputStream(exchange.getIn().getMandatoryBody(InputStream.class));
 }

@Override
 public void start() {

}

@Override
 public void stop() {

}
}




and change the `unmarshal().gzipDeflater()` to `unmarshal(new GZipDataFormat())` implementation, Camel is able to decompress the bytes correctly and pass the stream on so that the `TarSplitter` can iterate over the entries of that archive.","davsclaus:1631567256:2021-09-14T05:07:36.915+0000:1631567256:2021-09-14T05:07:36.915+0000:Yeah you are welcome to make camel-zip-deflater use the apache commons compress. PR is welcome
davsclaus:1632443342:2021-09-24T08:29:02.312+0000:1632443342:2021-09-24T08:29:02.312+0000:Thanks we now use commons-compress"
0,CAMEL-16952,Sub-task,Minor,None,3.13.0,"
None
",Resolved,Fixed,3.13.0,Karen Lease,Karen Lease,0,1,2021-09-13 14:06:11+00:00,2021-10-14 12:17:27+00:00,"Add a section to
https://github.com/apache/camel/blob/main/components/camel-test/camel-test-spring-junit5/src/main/docs/test-spring-junit5.adoc about testing with camel on spring boot.  Put it before the existing doc about testing spring.",
0,CAMEL-16951,Improvement,Major,3.11.0,3.12.0,"
None
",Resolved,Not A Problem,3.12.0,Claus Ibsen,Claus Ibsen,0,1,2021-09-13 12:52:44+00:00,2021-09-27 09:15:54+00:00,"Created a ticket to not forget.


It seems that you cannot use the options some languages have like


result-type on simple
suppress-exceptions on jsonpath: https://camel.apache.org/components/latest/languages/jsonpath-language.html


And so on.","davsclaus:1632702352:2021-09-27T08:25:52.520+0000:1632702352:2021-09-27T08:25:52.520+0000:Added an unit test in camel-yaml-dsl JSonPathSuppressTest

davsclaus:1632705354:2021-09-27T09:15:54.181+0000:1632705354:2021-09-27T09:15:54.181+0000:Thanks to Luca we found the correct yaml. Added example to the docs"
0,CAMEL-16950,Improvement,Major,3.11.0,3.12.0,"
None
",Resolved,Fixed,3.12.0,Unassigned,Avinash Dongre,0,2,2021-09-13 11:26:26+00:00,2021-09-18 08:16:07+00:00,"This test results in the following error.




java.lang.IllegalStateException: UT010057: multipart config was not present on Servlet
	at io.undertow.servlet.spec.HttpServletRequestImpl.verifyMultipartServlet(HttpServletRequestImpl.java:541)
	at io.undertow.servlet.spec.HttpServletRequestImpl.getPart(HttpServletRequestImpl.java:547)
	at org.apache.camel.component.servlet.springboot.test.ServletMultiPartTest$1.lambda$configure$0(ServletMultiPartTest.java:63)
	at org.apache.camel.support.processor.DelegateSyncProcessor.process(DelegateSyncProcessor.java:66)
	at org.apache.camel.processor.errorhandler.RedeliveryErrorHandler$SimpleTask.run(RedeliveryErrorHandler.java:469)
	at org.apache.camel.impl.engine.DefaultReactiveExecutor$Worker.schedule(DefaultReactiveExecutor.java:179)
	at org.apache.camel.impl.engine.DefaultReactiveExecutor.scheduleMain(DefaultReactiveExecutor.java:64)
	at org.apache.camel.processor.Pipeline.process(Pipeline.java:184)




The only workaround here is to disable  auto configuration:


camel.component.servlet.mapping.enabled=false


And create a custom servlet auto configuration class:




@Configuration
@EnableConfigurationProperties(ServletMappingConfiguration.class)
public class CustomAutoConfiguration {

    @Bean
    ServletRegistrationBean servletRegistrationBean(ServletMappingConfiguration config) {
        ServletRegistrationBean mapping = new ServletRegistrationBean();
        mapping.setServlet(new CamelHttpTransportServlet());
        mapping.addUrlMappings(config.getContextPath());
        mapping.setName(config.getServletName());
        mapping.setLoadOnStartup(1);
        mapping.setMultipartConfig(new MultipartConfigElement(""/tmp""));

        return mapping;
    }

}","avi5kdon@gmail.com:1631503864:2021-09-13T11:31:04.587+0000:1631503864:2021-09-13T11:31:04.587+0000:Can we inherit spring boot's [multipart properties|https://docs.spring.io/spring-boot/docs/current/api/org/springframework/boot/autoconfigure/web/servlet/MultipartProperties.html] to enable the multipart configuration for camel servlet (as done in the attached patch) ?
avi5kdon@gmail.com:1631854202:2021-09-17T12:50:02.604+0000:1631854202:2021-09-17T12:50:02.604+0000:PR: https://github.com/apache/camel-spring-boot/pull/367
davsclaus:1631924167:2021-09-18T08:16:07.635+0000:1631924167:2021-09-18T08:16:07.635+0000:Thanks for the PR"
0,CAMEL-16949,Task,Major,None,3.12.0,"
None
",Resolved,Fixed,3.12.0,Otavio Rodolfo Piske,Otavio Rodolfo Piske,0,1,2021-09-13 09:15:45+00:00,2021-09-20 18:03:11+00:00,"The record fetch is using Thread.sleep. I think it would be good to investigate if we can replace that with a more elegant mechanism.



https://github.com/apache/camel/blob/c0def695648fe93623d393950f8c06f8c526630f/components/camel-kafka/src/main/java/org/apache/camel/component/kafka/KafkaFetchRecords.java#L97",orpiske:1631746298:2021-09-16T06:51:38.212+0000:1631746298:2021-09-16T06:51:38.212+0000:Should have been resolved by the PR.
0,CAMEL-16948,Bug,Major,3.11.0,None,"
None
",Resolved,Duplicate,None,Unassigned,Christian Müller,0,3,2021-09-13 08:58:13+00:00,2021-09-13 09:01:11+00:00,"Reproduce 
0.) activate logmasking by setting the logMask flag to true as described in https://camel.apache.org/components/3.11.x/eips/log-eip.html
camelContext.setLogMask(true);
1.) log the body of the message with .log(body())
2.) if the message is big enough (a few hundred lines are enough!) the logprocessor throws an stackoverflow exception",acosentino:1631494811:2021-09-13T09:00:11.934+0000:1631494811:2021-09-13T09:00:11.934+0000:This is fixed already through https://issues.apache.org/jira/browse/CAMEL-16895
0,CAMEL-16947,Improvement,Major,None,3.12.0,"
None
",Resolved,Fixed,3.12.0,Claus Ibsen,Claus Ibsen,0,1,2021-09-13 07:46:39+00:00,2021-09-13 08:42:23+00:00,"In XML/YAML DSL then using constant will set the value as a string type, but we should allow to use result-type so you can say its a boolean / integer etc.


The simple language can do that.",
0,CAMEL-16946,Improvement,Major,None,3.13.0,"
None
",Resolved,Fixed,3.13.0,Unassigned,Tom Cassimon,0,1,2021-09-13 06:56:41+00:00,2021-10-06 04:14:16+00:00,It would be a nice improvement to allow the bean-validator component to also validate beans when the body of the exchange contains a collection of beans. Every bean in the collection should be validated then.,
0,CAMEL-16945,Task,Minor,3.11.0,3.13.0,"

pull-request-available

",Resolved,Fixed,3.13.0,Karen Lease,Karen Lease,0,2,2021-09-11 20:23:43+00:00,2021-10-26 19:27:55+00:00,"A lot of tests in the camel-spring-boot project use Junit4. Currently because of the lack of the  junit-vintage-engine dependency in the pom the tests are ignored by Maven.
They should be upgraded to Junit5 and checked for correct behavior.","davsclaus:1631404404:2021-09-12T07:53:24.086+0000:1631404404:2021-09-12T07:53:24.086+0000:If you want to help with better documentation, then we need to add a section to
https://github.com/apache/camel/blob/main/components/camel-test/camel-test-spring-junit5/src/main/docs/test-spring-junit5.adoc

about testing with camel on spring boot. Today we only have docs for classic spring XML (before spring boot).

With the work you will do for the junit 5 upgrade then you get hands into this subject and then would be able to help with the doc.

Since spring boot is the choice today then I think the spring boot testing section should come first, and then the existing classic spring can be below.
For updating the docs, you are welcome to create another JIRA (maybe as a sub jira for https://issues.apache.org/jira/browse/CAMEL-16861)
klease78:1631513264:2021-09-13T14:07:44.404+0000:1631513264:2021-09-13T14:07:44.404+0000:OK, I'll take that on when I finish updating the tests. I'm working on it.
klease78:1632723239:2021-09-27T14:13:59.593+0000:1632723239:2021-09-27T14:13:59.593+0000:This is done except for the integration tests which use Arquillian. The documentation update should be done in CAMEL-16952.
davsclaus:1635159694:2021-10-25T19:01:34.167+0000:1635159694:2021-10-25T19:01:34.167+0000:Karen, did you not upgrade everything in camel-spring-boot, so that its all done now?
klease78:1635247675:2021-10-26T19:27:55.349+0000:1635247675:2021-10-26T19:27:55.349+0000:Yes, the integration tests are done now too."
0,CAMEL-16944,New Feature,Major,None,None,"
None
",Resolved,Fixed,3.12.0,Unassigned,Hokutor,0,1,2021-09-11 08:45:10+00:00,2021-09-22 04:42:37+00:00,New camel component to integrate with Huawei Cloud Image Recognition service - [Image Recognition](https://www.huaweicloud.com/intl/en-us/product/image.html),
0,CAMEL-16943,Sub-task,Major,None,Future,"
None
",Resolved,Fixed,Future,Freeman Yue Fang,Freeman Yue Fang,0,1,2021-09-10 17:41:27+00:00,2022-04-19 13:36:32+00:00,"get exception like




Suppressed: java.lang.reflect.InaccessibleObjectException: Unable to make field private final java.util.Map java.util.Collections$UnmodifiableMap.m accessible: module java.base does not ""opens java.util"" to unnamed module @bf20622
		at java.base/java.lang.reflect.AccessibleObject.checkCanSetAccessible(AccessibleObject.java:354)
		at java.base/java.lang.reflect.AccessibleObject.checkCanSetAccessible(AccessibleObject.java:297)
		at java.base/java.lang.reflect.Field.checkCanSetAccessible(Field.java:178)
		at java.base/java.lang.reflect.Field.setAccessible(Field.java:172)
		at org.apache.camel.main.MainPropertyPlaceholderWithEnvTest.getFieldValue(MainPropertyPlaceholderWithEnvTest.java:276)
		at org.apache.camel.main.MainPropertyPlaceholderWithEnvTest.getEditableMapOfVariables(MainPropertyPlaceholderWithEnvTest.java:226)
		at org.apache.camel.main.MainPropertyPlaceholderWithEnvTest.doEnvVariable(MainPropertyPlaceholderWithEnvTest.java:206)
		at org.apache.camel.main.MainPropertyPlaceholderWithEnvTest.tearDown(MainPropertyPlaceholderWithEnvTest.java:182)
		at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
		at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
		at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
		at java.base/java.lang.reflect.Method.invoke(Method.java:568)





This is because System.getEnv() returns a java.util.Collections$UnmodifiableMap which isn't supposed to be changed during runtime code. To workaround this, normally we need to use reflection way to make a private field in java.util.Collections$UnmodifiableMap accessible.


But this is kind of against the encapsulation(Strongly Encapsulate JDK Internals ) rule of java Modules since JDK9. Before JDK17,  it is it  possible to access internal APIs via the --illegal-access command line option which is enabled by default. However, since JDK17 this --illegal-access is removed and we need to either explicitly use --add-opens modules to enable deep reflection for JDK internal code, or we need to get rid of the way to use JDK Internals","ffang:1631267163:2021-09-10T17:46:03.997+0000:1631267163:2021-09-10T17:46:03.997+0000:I tried to use System Stubs Library JUnit5 extension which normally is used for System.getEnv() mock, but it turned out that it also use the pretty much the same way to reflectively access a JDK internel private field
{code}
Suppressed: java.lang.reflect.InaccessibleObjectException: Unable to make field private final java.util.Map java.util.Collections$UnmodifiableMap.m accessible: module java.base does not ""opens java.util"" to unnamed module @bf20622
		at java.base/java.lang.reflect.AccessibleObject.checkCanSetAccessible(AccessibleObject.java:354)
		at java.base/java.lang.reflect.AccessibleObject.checkCanSetAccessible(AccessibleObject.java:297)
		at java.base/java.lang.reflect.Field.checkCanSetAccessible(Field.java:178)
		at java.base/java.lang.reflect.Field.setAccessible(Field.java:172)
		at uk.org.webcompere.systemstubs.environment.EnvironmentVariables.getFieldValue(EnvironmentVariables.java:243)
		at uk.org.webcompere.systemstubs.environment.EnvironmentVariables.getEditableMapOfVariables(EnvironmentVariables.java:205)
		at uk.org.webcompere.systemstubs.environment.EnvironmentVariables.restoreOriginalVariables(EnvironmentVariables.java:187)
		at uk.org.webcompere.systemstubs.environment.EnvironmentVariables.doTeardown(EnvironmentVariables.java:158)
		at uk.org.webcompere.systemstubs.resource.SingularTestResource.teardown(SingularTestResource.java:26)
		at uk.org.webcompere.systemstubs.resource.Resources.executeCleanup(Resources.java:59)
		at uk.org.webcompere.systemstubs.jupiter.SystemStubsExtension.cleanupFields(SystemStubsExtension.java:124)
		at uk.org.webcompere.systemstubs.jupiter.SystemStubsExtension.preDestroyTestInstance(SystemStubsExtension.java:38)
		at org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.lambda$invokeAllAfterMethodsOrCallbacks$12(TestMethodTestDescriptor.java:269)
		at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)
		at org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.lambda$invokeAllAfterMethodsOrCallbacks$13(TestMethodTestDescriptor.java:269)
		at java.base/java.util.ArrayList.forEach(ArrayList.java:1511)
{code}
ffang:1632484675:2021-09-24T19:57:55.649+0000:1632484675:2021-09-24T19:57:55.649+0000:Use add-opens for now"
0,CAMEL-16942,Bug,Minor,3.11.1,,"
None
",Resolved,Information Provided,None,Unassigned,Julien Greffe,0,3,2021-09-10 14:34:46+00:00,2021-09-14 08:28:49+00:00,"Hello,


when using Karaf 4.2.11 + camel 3.11.1
and dropping a blueprint which fails, status is Active whereas it should be Failure.


To reproduce:



start karaf 4.2.11
execute:


karaf@root()> feature:repo-add mvn:org.apache.camel.karaf/apache-camel/3.11.1/xml/features
karaf@root()> feature:install camel-blueprint






in deploy dir, drop log.xml
check logs:


16:31:34.160 INFO [fileinstall-C:\_PROGRAMS\apache-karaf-4.2.11/deploy] Installing bundle log.xml / 0.0.0
16:31:59.985 INFO [fileinstall-C:\_PROGRAMS\apache-karaf-4.2.11/deploy] Karaf BundleStateService not accessible. Bundle state won't reflect Camel context state
16:32:00.000 INFO [fileinstall-C:\_PROGRAMS\apache-karaf-4.2.11/deploy] Blueprint bundle log.xml/0.0.0 has been started
16:32:00.001 INFO [Blueprint Event Dispatcher: 1] Attempting to start CamelContext: camel-3
16:32:00.006 INFO [Blueprint Event Dispatcher: 1] JMX is enabled
16:32:00.016 WARN [Blueprint Event Dispatcher: 1] Changing Camel state for bundle 334 to Failure
16:32:00.016 ERROR [Blueprint Event Dispatcher: 1] Error occurred during starting CamelContext: camel-3
org.apache.camel.FailedToCreateRouteException: Failed to create route route3: Route(route3)[From[log://test?fixedRate=true&period=2000] ->... because of Failed to resolve endpoint: log://test?fixedRate=true&period=2000 due to: Failed to resolve endpoint: log://test?fixedRate=true&period=2000 due to: There are 2 parameters that couldn't be set on the endpoint. Check the uri if the parameters are spelt correctly and that they are properties of the endpoint. Unknown parameters=[{fixedRate=true, period=2000}]





Check bundle status:




karaf@root()> list | grep log.xml
334 | Active |  80 | 0.0.0   | log.xml




Seems related to this specific log:




16:31:59.985 INFO [fileinstall-C:\_PROGRAMS\apache-karaf-4.2.11/deploy] Karaf BundleStateService not accessible. Bundle state won't reflect Camel context state




Did we miss something, another feature to install before?","davsclaus:1631404544:2021-09-12T07:55:44.417+0000:1631404544:2021-09-12T07:55:44.417+0000:Camel 3.11 is Karaf 4.3 what is being tested and supported. So can you try with newer Karaf. Also suggest to not use deploy dir deployment as its bad practice.
jgreffe:1631575051:2021-09-14T07:17:31.767+0000:1631575065:2021-09-14T07:17:45.885+0000:Hello [~davsclaus],

tried with Karaf 4.3.3 and it works.

I guess issue with Karaf 4.2.11 is due to camel-blueprint headers having:
{code}
Import-Package: 
...
 org.apache.karaf.bundle.core;version=""[4.3,5)"";resolution:=optional,
...
{code}

Therefore it can't work within a Karaf < 4.3
davsclaus:1631576628:2021-09-14T07:43:48.594+0000:1631576628:2021-09-14T07:43:48.594+0000:Yes Camel 3.11 requires Karaf 4.3, eg the karaf version we test and build with.
Karaf 4.2, is older version of Camel.
jgreffe:1631579201:2021-09-14T08:26:41.176+0000:1631579201:2021-09-14T08:26:41.176+0000:Wrapped camel-blueprint to have:
{code}
<feature name='camel-blueprint' version='3.11.1' start-level='50'>
    <feature version='3.11.1'>camel-core</feature>
    <bundle>mvn:org.apache.camel/camel-core-xml/3.11.1</bundle>
    <bundle>wrap:mvn:org.apache.camel.karaf/camel-blueprint/3.11.1$overwrite=merge&amp;Import-Package=org.apache.karaf.bundle.core;version=""[4.2,5)"";resolution:=optional,*</bundle>
    <feature>aries-blueprint</feature>
  </feature>
{code}

Wasn't aware Camel 3.11 required Karaf 4.3 ?
acosentino:1631579329:2021-09-14T08:28:49.249+0000:1631579329:2021-09-14T08:28:49.249+0000:We tested Camel 3.11.x only on Karaf 4.3.x"
0,CAMEL-16941,Improvement,Major,None,3.x,"
None
",Closed,Won't Fix,3.x,Zheng Feng,Zheng Feng,0,2,2021-09-10 13:30:06+00:00,2021-09-28 09:24:25+00:00,When we upload a large size file especailly > partSize ( the default is 25M and the limit is 5M accroding to https://docs.aws.amazon.com/AmazonS3/latest/API/API_UploadPart.html). The getObject operation after uploading returns a result which contains chunck_signature. So this should be handled by componet to strip it or check the integrity of chunck ?,"acosentino:1631252176:2021-09-10T13:36:16.496+0000:1631252176:2021-09-10T13:36:16.496+0000:The limit is lowerbound, so it is at least 5 MB.
I think we can leave the chunk signature, up to the user to do what he wants with it.
acosentino:1631252285:2021-09-10T13:38:05.720+0000:1631252285:2021-09-10T13:38:05.720+0000:Or we should enable/disable the chunk encoding or signing
acosentino:1631252474:2021-09-10T13:41:14.813+0000:1631252474:2021-09-10T13:41:14.813+0000:i need to check the javadoc to see what we have available.
zhfeng:1632767098:2021-09-28T02:24:58.820+0000:1632767809:2021-09-28T02:36:49.221+0000:OK, I think it should be good to introude two options in camel-aws2-s3
 # [checksum_validation|https://sdk.amazonaws.com/java/api/latest/software/amazon/awssdk/services/s3/S3Configuration.Builder.html#checksumValidationEnabled-java.lang.Boolean-] 
 # [chuncked_encoding|https://sdk.amazonaws.com/java/api/latest/software/amazon/awssdk/services/s3/S3Configuration.Builder.html#chunkedEncodingEnabled-java.lang.Boolean-]
 
Or introduce all of options of [S3Configuration|https://sdk.amazonaws.com/java/api/latest/software/amazon/awssdk/services/s3/S3Configuration.Builder.html].
acosentino:1632784624:2021-09-28T07:17:04.185+0000:1632784624:2021-09-28T07:17:04.185+0000:I don't think is a good idea to over-engineer the configuration. If you need to set specific stuff on the client, just create your own instance of it and use it. 
zhfeng:1632790369:2021-09-28T08:52:49.186+0000:1632790369:2021-09-28T08:52:49.186+0000:yeah, so does it make sense to introduce these two options now ? or maybe improve the documentation to describe the chunk signature with the partSize option (if the user set it lower) ?
acosentino:1632790535:2021-09-28T08:55:35.748+0000:1632790535:2021-09-28T08:55:35.748+0000:No, it doens't make sense. If you need to use this option, create your client instance, put it in the registry and reference it in the configuration with #
zhfeng:1632790976:2021-09-28T09:02:56.763+0000:1632790976:2021-09-28T09:02:56.763+0000:OK, I'll close it with ""Won't Fix""."
0,CAMEL-16940,Improvement,Major,3.4.6,,"
None
",Resolved,Abandoned,None,Unassigned,Claus Ibsen,0,1,2021-09-10 07:14:34+00:00,2021-09-10 07:18:48+00:00,"Reported on user mailing list


Alexander A anpilov.av@gmail.com via camel.apache.org 
Sep 1, 2021, 7:06 PM (9 days ago)
to users


Hi!


I have 2 camel routes from quickfix consumers.
Camel version is 3.4.4 but behaviour is the same with greater versions too.
2 sessions are described in fix.properties file.
Second route is .autoStartup(false).


When camel starts a quickfix consumer for the active route, it starts
second quickfix session (for disabled route) too.


This happens in org.apache.camel.component.quickfixj.doStart()
-> quickfix.SocketInitiator


private void initialize() throws ConfigError {
        if (isStarted.equals(Boolean.FALSE)) {
            eventHandlingStrategy.setExecutor(longLivedExecutor);
            createSessionInitiators();
            for (Session session : getSessionMap().values()) 

{
                Session.registerSession(session);
            }

 startInitiators();
            eventHandlingStrategy.blockInThread();
            isStarted = Boolean.TRUE;
        } else 

{
            log.warn(""Ignored attempt to start already running
SocketInitiator."");
        }

    }


One possible workaround - store sessions in different files.


QuickFixJ approach for independen sessions startup described here:
https://stackoverflow.com/questions/61611047/how-to-manage-and-reload-multiple-quickfix-j-sessions-independently
.


How can I implement independent sessions startup with Camel using single
config file?","davsclaus:1631229528:2021-09-10T07:18:48.081+0000:1631229528:2021-09-10T07:18:48.081+0000:Ah okay this is more of an advanced problem and you would need to do
some custom coding or whatnot.
The nature of this seems that quickfix should be improved to have
independent configurations per session and then allow to only load the
configuration for which session is being started.

So at this point there is not something we can do in camel-quickfix."
0,CAMEL-16939,Test,Minor,3.11.1,"3.11.2, 3.12.0","
None
",Resolved,Fixed,"3.11.2, 3.12.0",Freeman Yue Fang,Freeman Yue Fang,0,1,2021-09-09 19:35:14+00:00,2021-09-09 19:37:13+00:00,It's broken when the JDK ea version isn't 16-ea. For example when JDK is 15-ea or 17-ea the test is broken,
0,CAMEL-16938,Bug,Major,3.11.0,3.13.0,"
None
",Resolved,Fixed,3.13.0,Claus Ibsen,Wojciech Strzałka,1,4,2021-09-09 10:25:35+00:00,2022-07-25 07:20:10+00:00,"After migration from Camel 2.25.x to 3.11.0 there is issue with redelivery logic causing stack trace overflow eventually.


See the stack trace:


Caused by: java.lang.StackOverflowError
at com.google.common.util.concurrent.AbstractFuture.setException(AbstractFuture.java:769)
at com.google.common.util.concurrent.SettableFuture.setException(SettableFuture.java:53)
at com.google.common.cache.LocalCache$LoadingValueReference.setException(LocalCache.java:3503)
at com.google.common.cache.LocalCache$LoadingValueReference.loadFuture(LocalCache.java:3549)
at com.google.common.cache.LocalCache$Segment.loadSync(LocalCache.java:2278)
at com.google.common.cache.LocalCache$Segment.lockedGetOrLoad(LocalCache.java:2155)
at com.google.common.cache.LocalCache$Segment.get(LocalCache.java:2045)
at com.google.common.cache.LocalCache.get(LocalCache.java:3951)
at com.google.common.cache.LocalCache.getOrLoad(LocalCache.java:3974)
at com.google.common.cache.LocalCache$LocalLoadingCache.get(LocalCache.java:4935)
at com.google.common.cache.LocalCache$LocalLoadingCache.getUnchecked(LocalCache.java:4941)
at com.foo.bar.AtomicCache.get(AtomicCache.java:34)
at com.foo.bar.CachingZoneServiceRegistry.findWithZoneId(CachingZoneServiceRegistry.java:55)
at com.foo.bar.PersistenceBasedRoutingsLoader.lambda$getDestinationFunction$1(PersistenceBasedRoutingsLoader.java:34)
at com.foo.bar.RoutingDestination.getTargetDestinationsFor(RoutingDestination.java:66)
at com.foo.bar.RoutingDestination.getClientCamelUris(RoutingDestination.java:59)
at sun.reflect.GeneratedMethodAccessor461.invoke(Unknown Source)
at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
at java.lang.reflect.Method.invoke(Method.java:498)
at org.apache.camel.support.ObjectHelper.invokeMethodSafe(ObjectHelper.java:380)
at org.apache.camel.component.bean.MethodInfo.invoke(MethodInfo.java:494)
at org.apache.camel.component.bean.MethodInfo$1.doProceed(MethodInfo.java:316)
at org.apache.camel.component.bean.MethodInfo$1.proceed(MethodInfo.java:286)
at org.apache.camel.component.bean.AbstractBeanProcessor.process(AbstractBeanProcessor.java:146)
at org.apache.camel.impl.engine.DefaultAsyncProcessorAwaitManager.process(DefaultAsyncProcessorAwaitManager.java:83)
at org.apache.camel.support.AsyncProcessorSupport.process(AsyncProcessorSupport.java:41)
at org.apache.camel.language.bean.BeanExpression.invokeBean(BeanExpression.java:347)
at org.apache.camel.language.bean.BeanExpression.evaluate(BeanExpression.java:202)
at org.apache.camel.language.bean.BeanExpression.evaluate(BeanExpression.java:214)
at org.apache.camel.processor.SetPropertyProcessor.process(SetPropertyProcessor.java:47)
at org.apache.camel.impl.engine.DefaultAsyncProcessorAwaitManager.process(DefaultAsyncProcessorAwaitManager.java:83)
at org.apache.camel.support.AsyncProcessorSupport.process(AsyncProcessorSupport.java:41)
at org.apache.camel.impl.engine.CamelInternalProcessor.process(CamelInternalProcessor.java:369)
at org.apache.camel.processor.Pipeline$PipelineTask.run(Pipeline.java:109)
at org.apache.camel.impl.engine.DefaultReactiveExecutor$Worker.schedule(DefaultReactiveExecutor.java:179)
at org.apache.camel.impl.engine.DefaultReactiveExecutor.schedule(DefaultReactiveExecutor.java:59)
at org.apache.camel.impl.engine.CamelInternalProcessor$AsyncAfterTask.done(CamelInternalProcessor.java:274)
at org.apache.camel.impl.engine.CamelInternalProcessor.process(CamelInternalProcessor.java:377)
at org.apache.camel.processor.Pipeline$PipelineTask.run(Pipeline.java:109)
at org.apache.camel.impl.engine.DefaultReactiveExecutor$Worker.schedule(DefaultReactiveExecutor.java:179)
at org.apache.camel.impl.engine.DefaultReactiveExecutor.schedule(DefaultReactiveExecutor.java:59)
at org.apache.camel.impl.engine.CamelInternalProcessor$AsyncAfterTask.done(CamelInternalProcessor.java:274)
at org.apache.camel.impl.engine.CamelInternalProcessor.process(CamelInternalProcessor.java:377)
at org.apache.camel.processor.Pipeline$PipelineTask.run(Pipeline.java:109)
at org.apache.camel.impl.engine.DefaultReactiveExecutor$Worker.schedule(DefaultReactiveExecutor.java:179)
at org.apache.camel.impl.engine.DefaultReactiveExecutor.schedule(DefaultReactiveExecutor.java:59)
at org.apache.camel.impl.engine.CamelInternalProcessor$AsyncAfterTask.done(CamelInternalProcessor.java:274)
at org.apache.camel.impl.engine.CamelInternalProcessor.process(CamelInternalProcessor.java:377)
at org.apache.camel.processor.Pipeline$PipelineTask.run(Pipeline.java:109)
at org.apache.camel.impl.engine.DefaultReactiveExecutor$Worker.schedule(DefaultReactiveExecutor.java:179)
at org.apache.camel.impl.engine.DefaultReactiveExecutor.scheduleSync(DefaultReactiveExecutor.java:69)
at org.apache.camel.processor.Pipeline.process(Pipeline.java:182)
at org.apache.camel.processor.TryProcessor$TryState.run(TryProcessor.java:109)
at org.apache.camel.impl.engine.DefaultReactiveExecutor$Worker.schedule(DefaultReactiveExecutor.java:179)
at org.apache.camel.impl.engine.DefaultReactiveExecutor.schedule(DefaultReactiveExecutor.java:59)
at org.apache.camel.processor.TryProcessor.process(TryProcessor.java:78)
at org.apache.camel.management.DefaultInstrumentationProcessor.process(DefaultInstrumentationProcessor.java:90)
at org.apache.camel.processor.errorhandler.RedeliveryErrorHandler$RedeliveryTask.redeliver(RedeliveryErrorHandler.java:870)
at org.apache.camel.impl.engine.DefaultReactiveExecutor$Worker.schedule(DefaultReactiveExecutor.java:179)
at org.apache.camel.impl.engine.DefaultReactiveExecutor.schedule(DefaultReactiveExecutor.java:59)
at org.apache.camel.impl.engine.CamelInternalProcessor$AsyncAfterTask.done(CamelInternalProcessor.java:274)
at org.apache.camel.impl.engine.CamelInternalProcessor.process(CamelInternalProcessor.java:377)
at org.apache.camel.processor.Pipeline$PipelineTask.run(Pipeline.java:109)
at org.apache.camel.impl.engine.DefaultReactiveExecutor$Worker.schedule(DefaultReactiveExecutor.java:179)
at org.apache.camel.impl.engine.DefaultReactiveExecutor.scheduleSync(DefaultReactiveExecutor.java:69)
at org.apache.camel.processor.Pipeline.process(Pipeline.java:182)
at org.apache.camel.processor.CatchProcessor.process(CatchProcessor.java:119)
at org.apache.camel.processor.TryProcessor$TryState.run(TryProcessor.java:109)
at org.apache.camel.impl.engine.DefaultReactiveExecutor$Worker.schedule(DefaultReactiveExecutor.java:179)
at org.apache.camel.impl.engine.DefaultReactiveExecutor.schedule(DefaultReactiveExecutor.java:59)
at org.apache.camel.impl.engine.CamelInternalProcessor$AsyncAfterTask.done(CamelInternalProcessor.java:274)
at org.apache.camel.impl.engine.CamelInternalProcessor.process(CamelInternalProcessor.java:377)
at org.apache.camel.processor.Pipeline$PipelineTask.run(Pipeline.java:109)
at org.apache.camel.impl.engine.DefaultReactiveExecutor$Worker.schedule(DefaultReactiveExecutor.java:179)
at org.apache.camel.impl.engine.DefaultReactiveExecutor.schedule(DefaultReactiveExecutor.java:59)
at org.apache.camel.impl.engine.CamelInternalProcessor$AsyncAfterTask.done(CamelInternalProcessor.java:274)
at org.apache.camel.impl.engine.CamelInternalProcessor.process(CamelInternalProcessor.java:377)
at org.apache.camel.processor.Pipeline$PipelineTask.run(Pipeline.java:109)
at org.apache.camel.impl.engine.DefaultReactiveExecutor$Worker.schedule(DefaultReactiveExecutor.java:179)
at org.apache.camel.impl.engine.DefaultReactiveExecutor.schedule(DefaultReactiveExecutor.java:59)
at org.apache.camel.impl.engine.CamelInternalProcessor$AsyncAfterTask.done(CamelInternalProcessor.java:274)
at org.apache.camel.impl.engine.CamelInternalProcessor.process(CamelInternalProcessor.java:377)
at org.apache.camel.processor.Pipeline$PipelineTask.run(Pipeline.java:109)
at org.apache.camel.impl.engine.DefaultReactiveExecutor$Worker.schedule(DefaultReactiveExecutor.java:179)
at org.apache.camel.impl.engine.DefaultReactiveExecutor.schedule(DefaultReactiveExecutor.java:59)
at org.apache.camel.impl.engine.CamelInternalProcessor$AsyncAfterTask.done(CamelInternalProcessor.java:274)
at org.apache.camel.impl.engine.CamelInternalProcessor.process(CamelInternalProcessor.java:377)
at org.apache.camel.processor.Pipeline$PipelineTask.run(Pipeline.java:109)
at org.apache.camel.impl.engine.DefaultReactiveExecutor$Worker.schedule(DefaultReactiveExecutor.java:179)
at org.apache.camel.impl.engine.DefaultReactiveExecutor.scheduleSync(DefaultReactiveExecutor.java:69)
at org.apache.camel.processor.Pipeline.process(Pipeline.java:182)
at org.apache.camel.processor.TryProcessor$TryState.run(TryProcessor.java:109)
at org.apache.camel.impl.engine.DefaultReactiveExecutor$Worker.schedule(DefaultReactiveExecutor.java:179)
at org.apache.camel.impl.engine.DefaultReactiveExecutor.schedule(DefaultReactiveExecutor.java:59)
at org.apache.camel.processor.TryProcessor.process(TryProcessor.java:78)
at org.apache.camel.management.DefaultInstrumentationProcessor.process(DefaultInstrumentationProcessor.java:90)
at org.apache.camel.processor.errorhandler.RedeliveryErrorHandler$RedeliveryTask.redeliver(RedeliveryErrorHandler.java:870)
at org.apache.camel.impl.engine.DefaultReactiveExecutor$Worker.schedule(DefaultReactiveExecutor.java:179)
at org.apache.camel.impl.engine.DefaultReactiveExecutor.schedule(DefaultReactiveExecutor.java:59)
at org.apache.camel.impl.engine.CamelInternalProcessor$AsyncAfterTask.done(CamelInternalProcessor.java:274)
at org.apache.camel.impl.engine.CamelInternalProcessor.process(CamelInternalProcessor.java:377)
at org.apache.camel.processor.Pipeline$PipelineTask.run(Pipeline.java:109)
at org.apache.camel.impl.engine.DefaultReactiveExecutor$Worker.schedule(DefaultReactiveExecutor.java:179)
at org.apache.camel.impl.engine.DefaultReactiveExecutor.scheduleSync(DefaultReactiveExecutor.java:69)
at org.apache.camel.processor.Pipeline.process(Pipeline.java:182)
at org.apache.camel.processor.CatchProcessor.process(CatchProcessor.java:119)
at org.apache.camel.processor.TryProcessor$TryState.run(TryProcessor.java:109)
at org.apache.camel.impl.engine.DefaultReactiveExecutor$Worker.schedule(DefaultReactiveExecutor.java:179)
at org.apache.camel.impl.engine.DefaultReactiveExecutor.schedule(DefaultReactiveExecutor.java:59)
at org.apache.camel.impl.engine.CamelInternalProcessor$AsyncAfterTask.done(CamelInternalProcessor.java:274)
at org.apache.camel.impl.engine.CamelInternalProcessor.process(CamelInternalProcessor.java:377)
at org.apache.camel.processor.Pipeline$PipelineTask.run(Pipeline.java:109)
at org.apache.camel.impl.engine.DefaultReactiveExecutor$Worker.schedule(DefaultReactiveExecutor.java:179)
at org.apache.camel.impl.engine.DefaultReactiveExecutor.schedule(DefaultReactiveExecutor.java:59)
at org.apache.camel.impl.engine.CamelInternalProcessor$AsyncAfterTask.done(CamelInternalProcessor.java:274)
at org.apache.camel.impl.engine.CamelInternalProcessor.process(CamelInternalProcessor.java:377)
at org.apache.camel.processor.Pipeline$PipelineTask.run(Pipeline.java:109)
at org.apache.camel.impl.engine.DefaultReactiveExecutor$Worker.schedule(DefaultReactiveExecutor.java:179)
at org.apache.camel.impl.engine.DefaultReactiveExecutor.schedule(DefaultReactiveExecutor.java:59)
at org.apache.camel.impl.engine.CamelInternalProcessor$AsyncAfterTask.done(CamelInternalProcessor.java:274)
at org.apache.camel.impl.engine.CamelInternalProcessor.process(CamelInternalProcessor.java:377)
at org.apache.camel.processor.Pipeline$PipelineTask.run(Pipeline.java:109)
at org.apache.camel.impl.engine.DefaultReactiveExecutor$Worker.schedule(DefaultReactiveExecutor.java:179)
at org.apache.camel.impl.engine.DefaultReactiveExecutor.schedule(DefaultReactiveExecutor.java:59)
at org.apache.camel.impl.engine.CamelInternalProcessor$AsyncAfterTask.done(CamelInternalProcessor.java:274)
at org.apache.camel.impl.engine.CamelInternalProcessor.process(CamelInternalProcessor.java:377)
at org.apache.camel.processor.Pipeline$PipelineTask.run(Pipeline.java:109)
at org.apache.camel.impl.engine.DefaultReactiveExecutor$Worker.schedule(DefaultReactiveExecutor.java:179)
at org.apache.camel.impl.engine.DefaultReactiveExecutor.scheduleSync(DefaultReactiveExecutor.java:69)
at org.apache.camel.processor.Pipeline.process(Pipeline.java:182)
at org.apache.camel.processor.TryProcessor$TryState.run(TryProcessor.java:109)
at org.apache.camel.impl.engine.DefaultReactiveExecutor$Worker.schedule(DefaultReactiveExecutor.java:179)
at org.apache.camel.impl.engine.DefaultReactiveExecutor.schedule(DefaultReactiveExecutor.java:59)
at org.apache.camel.processor.TryProcessor.process(TryProcessor.java:78)
at org.apache.camel.management.DefaultInstrumentationProcessor.process(DefaultInstrumentationProcessor.java:90)
at org.apache.camel.processor.errorhandler.RedeliveryErrorHandler$RedeliveryTask.redeliver(RedeliveryErrorHandler.java:870)
at org.apache.camel.impl.engine.DefaultReactiveExecutor$Worker.schedule(DefaultReactiveExecutor.java:179)
at org.apache.camel.impl.engine.DefaultReactiveExecutor.schedule(DefaultReactiveExecutor.java:59)\n
at org.apache.camel.impl.engine.CamelInternalProcessor$AsyncAfterTask.done(CamelInternalProcessor.java:274)\n
at org.apache.camel.impl.engine.CamelInternalProcessor.process(CamelInternalProcessor.java:377)\n
at org.apache.camel.processor.Pipeline$PipelineTask.run(Pipeline.java:109)
at org.apache.camel.impl.engine.DefaultReactiveExecutor$Worker.schedule(DefaultReactiveExecutor.java:179)
at org.apache.camel.impl.engine.DefaultReactiveExecutor.scheduleSync(DefaultReactiveExecutor.java:69)
at org.apache.camel.processor.Pipeline.process(Pipeline.java:182)
at org.apache.camel.processor.CatchProcessor.process(CatchProcessor.java:119)
at org.apache.camel.processor.TryProcessor$TryState.run(TryProcessor.java:109)
at org.apache.camel.impl.engine.DefaultReactiveExecutor$Worker.schedule(DefaultReactiveExecutor.java:179)
at org.apache.camel.impl.engine.DefaultReactiveExecutor.schedule(DefaultReactiveExecutor.java:59)
at org.apache.camel.impl.engine.CamelInternalProcessor$AsyncAfterTask.done(CamelInternalProcessor.java:274)
at org.apache.camel.impl.engine.CamelInternalProcessor.process(CamelInternalProcessor.java:377)
at org.apache.camel.processor.Pipeline$PipelineTask.run(Pipeline.java:109)
at org.apache.camel.impl.engine.DefaultReactiveExecutor$Worker.schedule(DefaultReactiveExecutor.java:179)
at org.apache.camel.impl.engine.DefaultReactiveExecutor.schedule(DefaultReactiveExecutor.java:59)
at org.apache.camel.impl.engine.CamelInternalProcessor$AsyncAfterTask.done(CamelInternalProcessor.java:274)
at org.apache.camel.impl.engine.CamelInternalProcessor.process(CamelInternalProcessor.java:377)
at org.apache.camel.processor.Pipeline$PipelineTask.run(Pipeline.java:109)
at org.apache.camel.impl.engine.DefaultReactiveExecutor$Worker.schedule(DefaultReactiveExecutor.java:179)
at org.apache.camel.impl.engine.DefaultReactiveExecutor.schedule(DefaultReactiveExecutor.java:59)
at org.apache.camel.impl.engine.CamelInternalProcessor$AsyncAfterTask.done(CamelInternalProcessor.java:274)
at org.apache.camel.impl.engine.CamelInternalProcessor.process(CamelInternalProcessor.java:377)
at org.apache.camel.processor.Pipeline$PipelineTask.run(Pipeline.java:109)
at org.apache.camel.impl.engine.DefaultReactiveExecutor$Worker.schedule(DefaultReactiveExecutor.java:179)
at org.apache.camel.impl.engine.DefaultReactiveExecutor.schedule(DefaultReactiveExecutor.java:59)
at org.apache.camel.impl.engine.CamelInternalProcessor$AsyncAfterTask.done(CamelInternalProcessor.java:274)
at org.apache.camel.impl.engine.CamelInternalProcessor.process(CamelInternalProcessor.java:377)
at org.apache.camel.processor.Pipeline$PipelineTask.run(Pipeline.java:109)
at org.apache.camel.impl.engine.DefaultReactiveExecutor$Worker.schedule(DefaultReactiveExecutor.java:179)
at org.apache.camel.impl.engine.DefaultReactiveExecutor.scheduleSync(DefaultReactiveExecutor.java:69)
at org.apache.camel.processor.Pipeline.process(Pipeline.java:182)
at org.apache.camel.processor.TryProcessor$TryState.run(TryProcessor.java:109)
at org.apache.camel.impl.engine.DefaultReactiveExecutor$Worker.schedule(DefaultReactiveExecutor.java:179)
at org.apache.camel.impl.engine.DefaultReactiveExecutor.schedule(DefaultReactiveExecutor.java:59)
at org.apache.camel.processor.TryProcessor.process(TryProcessor.java:78)
at org.apache.camel.management.DefaultInstrumentationProcessor.process(DefaultInstrumentationProcessor.java:90)
at org.apache.camel.processor.errorhandler.RedeliveryErrorHandler$RedeliveryTask.redeliver(RedeliveryErrorHandler.java:870)
at org.apache.camel.impl.engine.DefaultReactiveExecutor$Worker.schedule(DefaultReactiveExecutor.java:179)
at org.apache.camel.impl.engine.DefaultReactiveExecutor.schedule(DefaultReactiveExecutor.java:59)
at org.apache.camel.impl.engine.CamelInternalProcessor$AsyncAfterTask.done(CamelInternalProcessor.java:274)
at org.apache.camel.impl.engine.CamelInternalProcessor.process(CamelInternalProcessor.java:377)
at org.apache.camel.processor.Pipeline$PipelineTask.run(Pipeline.java:109)
at org.apache.camel.impl.engine.DefaultReactiveExecutor$Worker.schedule(DefaultReactiveExecutor.java:179)
at org.apache.camel.impl.engine.DefaultReactiveExecutor.scheduleSync(DefaultReactiveExecutor.java:69)
at org.apache.camel.processor.Pipeline.process(Pipeline.java:182)
at org.apache.camel.processor.CatchProcessor.process(CatchProcessor.java:119)
at org.apache.camel.processor.TryProcessor$TryState.run(TryProcessor.java:109)
at org.apache.camel.impl.engine.DefaultReactiveExecutor$Worker.schedule(DefaultReactiveExecutor.java:179)
at org.apache.camel.impl.engine.DefaultReactiveExecutor.schedule(DefaultReactiveExecutor.java:59)
at org.apache.camel.impl.engine.CamelInternalProcessor$AsyncAfterTask.done(CamelInternalProcessor.java:274)
at org.apache.camel.impl.engine.CamelInternalProcessor.process(CamelInternalProcessor.java:377)
at org.apache.camel.processor.Pipeline$PipelineTask.run(Pipeline.java:109)
at org.apache.camel.impl.engine.DefaultReactiveExecutor$Worker.schedule(DefaultReactiveExecutor.java:179)
at org.apache.camel.impl.engine.DefaultReactiveExecutor.schedule(DefaultReactiveExecutor.java:59)
at org.apache.camel.impl.engine.CamelInternalProcessor$AsyncAfterTask.done(CamelInternalProcessor.java:274)
at org.apache.camel.impl.engine.CamelInternalProcessor.process(CamelInternalProcessor.java:377)
at org.apache.camel.processor.Pipeline$PipelineTask.run(Pipeline.java:109)
at org.apache.camel.impl.engine.DefaultReactiveExecutor$Worker.schedule(DefaultReactiveExecutor.java:179)
at org.apache.camel.impl.engine.DefaultReactiveExecutor.schedule(DefaultReactiveExecutor.java:59)
at org.apache.camel.impl.engine.CamelInternalProcessor$AsyncAfterTask.done(CamelInternalProcessor.java:274)
at org.apache.camel.impl.engine.CamelInternalProcessor.process(CamelInternalProcessor.java:377)
at org.apache.camel.processor.Pipeline$PipelineTask.run(Pipeline.java:109)
at org.apache.camel.impl.engine.DefaultReactiveExecutor$Worker.schedule(DefaultReactiveExecutor.java:179)
at org.apache.camel.impl.engine.DefaultReactiveExecutor.schedule(DefaultReactiveExecutor.java:59)
at org.apache.camel.impl.engine.CamelInternalProcessor$AsyncAfterTask.done(CamelInternalProcessor.java:274)
at org.apache.camel.impl.engine.CamelInternalProcessor.process(CamelInternalProcessor.java:377)
at org.apache.camel.processor.Pipeline$PipelineTask.run(Pipeline.java:109)
at org.apache.camel.impl.engine.DefaultReactiveExecutor$Worker.schedule(DefaultReactiveExecutor.java:179)
at org.apache.camel.impl.engine.DefaultReactiveExecutor.scheduleSync(DefaultReactiveExecutor.java:69)
at org.apache.camel.processor.Pipeline.process(Pipeline.java:182)
at org.apache.camel.processor.TryProcessor$TryState.run(TryProcessor.java:109)
at org.apache.camel.impl.engine.DefaultReactiveExecutor$Worker.schedule(DefaultReactiveExecutor.java:179)
at org.apache.camel.impl.engine.DefaultReactiveExecutor.schedule(DefaultReactiveExecutor.java:59)
at org.apache.camel.processor.TryProcessor.process(TryProcessor.java:78)
at org.apache.camel.management.DefaultInstrumentationProcessor.process(DefaultInstrumentationProcessor.java:90)
at org.apache.camel.processor.errorhandler.RedeliveryErrorHandler$RedeliveryTask.redeliver(RedeliveryErrorHandler.java:870)
at org.apache.camel.impl.engine.DefaultReactiveExecutor$Worker.schedule(DefaultReactiveExecutor.java:179)
at org.apache.camel.impl.engine.DefaultReactiveExecutor.schedule(DefaultReactiveExecutor.java:59)
at org.apache.camel.impl.engine.CamelInternalProcessor$AsyncAfterTask.done(CamelInternalProcessor.java:274)
at org.apache.camel.impl.engine.CamelInternalProcessor.process(CamelInternalProcessor.java:377)
at org.apache.camel.processor.Pipeline$PipelineTask.run(Pipeline.java:109)
at org.apache.camel.impl.engine.DefaultReactiveExecutor$Worker.schedule(DefaultReactiveExecutor.java:179)
at org.apache.camel.impl.engine.DefaultReactiveExecutor.scheduleSync(DefaultReactiveExecutor.java:69)
at org.apache.camel.processor.Pipeline.process(Pipeline.java:182)
at org.apache.camel.processor.CatchProcessor.process(CatchProcessor.java:119)
at org.apache.camel.processor.TryProcessor$TryState.run(TryProcessor.java:109)
at org.apache.camel.impl.engine.DefaultReactiveExecutor$Worker.schedule(DefaultReactiveExecutor.java:179)
at org.apache.camel.impl.engine.DefaultReactiveExecutor.schedule(DefaultReactiveExecutor.java:59)
at org.apache.camel.impl.engine.CamelInternalProcessor$AsyncAfterTask.done(CamelInternalProcessor.java:274)
at org.apache.camel.impl.engine.CamelInternalProcessor.process(CamelInternalProcessor.java:377)
at org.apache.camel.processor.Pipeline$PipelineTask.run(Pipeline.java:109)
at org.apache.camel.impl.engine.DefaultReactiveExecutor$Worker.schedule(DefaultReactiveExecutor.java:179)
at org.apache.camel.impl.engine.DefaultReactiveExecutor.schedule(DefaultReactiveExecutor.java:59)
at org.apache.camel.impl.engine.CamelInternalProcessor$AsyncAfterTask.done(CamelInternalProcessor.java:274)
at org.apache.camel.impl.engine.CamelInternalProcessor.process(CamelInternalProcessor.java:377)
at org.apache.camel.processor.Pipeline$PipelineTask.run(Pipeline.java:109)
at org.apache.camel.impl.engine.DefaultReactiveExecutor$Worker.schedule(DefaultReactiveExecutor.java:179)
at org.apache.camel.impl.engine.DefaultReactiveExecutor.schedule(DefaultReactiveExecutor.java:59)
at org.apache.camel.impl.engine.CamelInternalProcessor$AsyncAfterTask.done(CamelInternalProcessor.java:274)
at org.apache.camel.impl.engine.CamelInternalProcessor.process(CamelInternalProcessor.java:377)
at org.apache.camel.processor.Pipeline$PipelineTask.run(Pipeline.java:109)
at org.apache.camel.impl.engine.DefaultReactiveExecutor$Worker.schedule(DefaultReactiveExecutor.java:179)
at org.apache.camel.impl.engine.DefaultReactiveExecutor.schedule(DefaultReactiveExecutor.java:59)
at org.apache.camel.impl.engine.CamelInternalProcessor$AsyncAfterTask.done(CamelInternalProcessor.java:274)
at org.apache.camel.impl.engine.CamelInternalProcessor.process(CamelInternalProcessor.java:377)
at org.apache.camel.processor.Pipeline$PipelineTask.run(Pipeline.java:109)
at org.apache.camel.impl.engine.DefaultReactiveExecutor$Worker.schedule(DefaultReactiveExecutor.java:179)
at org.apache.camel.impl.engine.DefaultReactiveExecutor.scheduleSync(DefaultReactiveExecutor.java:69)
at org.apache.camel.processor.Pipeline.process(Pipeline.java:182)
at org.apache.camel.processor.TryProcessor$TryState.run(TryProcessor.java:109)
at org.apache.camel.impl.engine.DefaultReactiveExecutor$Worker.schedule(DefaultReactiveExecutor.java:179)
at org.apache.camel.impl.engine.DefaultReactiveExecutor.schedule(DefaultReactiveExecutor.java:59)
at org.apache.camel.processor.TryProcessor.process(TryProcessor.java:78)
at org.apache.camel.management.DefaultInstrumentationProcessor.process(DefaultInstrumentationProcessor.java:90)
at org.apache.camel.processor.errorhandler.RedeliveryErrorHandler$RedeliveryTask.redeliver(RedeliveryErrorHandler.java:870)
at org.apache.camel.impl.engine.DefaultReactiveExecutor$Worker.schedule(DefaultReactiveExecutor.java:179)
at org.apache.camel.impl.engine.DefaultReactiveExecutor.schedule(DefaultReactiveExecutor.java:59)
at org.apache.camel.impl.engine.CamelInternalProcessor$AsyncAfterTask.done(CamelInternalProcessor.java:274)
at org.apache.camel.impl.engine.CamelInternalProcessor.process(CamelInternalProcessor.java:377)
at org.apache.camel.processor.Pipeline$PipelineTask.run(Pipeline.java:109)
at org.apache.camel.impl.engine.DefaultReactiveExecutor$Worker.schedule(DefaultReactiveExecutor.java:179)
at org.apache.camel.impl.engine.DefaultReactiveExecutor.scheduleSync(DefaultReactiveExecutor.java:69)
at org.apache.camel.processor.Pipeline.process(Pipeline.java:182)
at org.apache.camel.processor.CatchProcessor.process(CatchProcessor.java:119)
at org.apache.camel.processor.TryProcessor$TryState.run(TryProcessor.java:109)
at org.apache.camel.impl.engine.DefaultReactiveExecutor$Worker.schedule(DefaultReactiveExecutor.java:179)
at org.apache.camel.impl.engine.DefaultReactiveExecutor.schedule(DefaultReactiveExecutor.java:59)
at org.apache.camel.impl.engine.CamelInternalProcessor$AsyncAfterTask.done(CamelInternalProcessor.java:274)
at org.apache.camel.impl.engine.CamelInternalProcessor.process(CamelInternalProcessor.java:377)
at org.apache.camel.processor.Pipeline$PipelineTask.run(Pipeline.java:109)
at org.apache.camel.impl.engine.DefaultReactiveExecutor$Worker.schedule(DefaultReactiveExecutor.java:179)
at org.apache.camel.impl.engine.DefaultReactiveExecutor.schedule(DefaultReactiveExecutor.java:59)
at org.apache.camel.impl.engine.CamelInternalProcessor$AsyncAfterTask.done(CamelInternalProcessor.java:274)
at org.apache.camel.impl.engine.CamelInternalProcessor.process(CamelInternalProcessor.java:377)
at org.apache.camel.processor.Pipeline$PipelineTask.run(Pipeline.java:109)
at org.apache.camel.impl.engine.DefaultReactiveExecutor$Worker.schedule(DefaultReactiveExecutor.java:179)
at org.apache.camel.impl.engine.DefaultReactiveExecutor.schedule(DefaultReactiveExecutor.java:59)
at org.apache.camel.impl.engine.CamelInternalProcessor$AsyncAfterTask.done(CamelInternalProcessor.java:274)
at org.apache.camel.impl.engine.CamelInternalProcessor.process(CamelInternalProcessor.java:377)
at org.apache.camel.processor.Pipeline$PipelineTask.run(Pipeline.java:109)
at org.apache.camel.impl.engine.DefaultReactiveExecutor$Worker.schedule(DefaultReactiveExecutor.java:179)
at org.apache.camel.impl.engine.DefaultReactiveExecutor.schedule(DefaultReactiveExecutor.java:59)
at org.apache.camel.impl.engine.CamelInternalProcessor$AsyncAfterTask.done(CamelInternalProcessor.java:274)
at org.apache.camel.impl.engine.CamelInternalProcessor.process(CamelInternalProcessor.java:377)
at org.apache.camel.processor.Pipeline$PipelineTask.run(Pipeline.java:109)
at org.apache.camel.impl.engine.DefaultReactiveExecutor$Worker.schedule(DefaultReactiveExecutor.java:179)
at org.apache.camel.impl.engine.DefaultReactiveExecutor.scheduleSync(DefaultReactiveExecutor.java:69)
at org.apache.camel.processor.Pipeline.process(Pipeline.java:182)
at org.apache.camel.processor.TryProcessor$TryState.run(TryProcessor.java:109)
at org.apache.camel.impl.engine.DefaultReactiveExecutor$Worker.schedule(DefaultReactiveExecutor.java:179)
at org.apache.camel.impl.engine.DefaultReactiveExecutor.schedule(DefaultReactiveExecutor.java:59)
at org.apache.camel.processor.TryProcessor.process(TryProcessor.java:78)
at org.apache.camel.management.DefaultInstrumentationProcessor.process(DefaultInstrumentationProcessor.java:90)
at org.apache.camel.processor.errorhandler.RedeliveryErrorHandler$RedeliveryTask.redeliver(RedeliveryErrorHandler.java:870)
at org.apache.camel.impl.engine.DefaultReactiveExecutor$Worker.schedule(DefaultReactiveExecutor.java:179)
at org.apache.camel.impl.engine.DefaultReactiveExecutor.schedule(DefaultReactiveExecutor.java:59)
at org.apache.camel.impl.engine.CamelInternalProcessor$AsyncAfterTask.done(CamelInternalProcessor.java:274)
at org.apache.camel.impl.engine.CamelInternalProcessor.process(CamelInternalProcessor.java:377)
at org.apache.camel.processor.Pipeline$PipelineTask.run(Pipeline.java:109)
at org.apache.camel.impl.engine.DefaultReactiveExecutor$Worker.schedule(DefaultReactiveExecutor.java:179)
at org.apache.camel.impl.engine.DefaultReactiveExecutor.scheduleSync(DefaultReactiveExecutor.java:69)
at org.apache.camel.processor.Pipeline.process(Pipeline.java:182)
at org.apache.camel.processor.CatchProcessor.process(CatchProcessor.java:119)
at org.apache.camel.processor.TryProcessor$TryState.run(TryProcessor.java:109)
at org.apache.camel.impl.engine.DefaultReactiveExecutor$Worker.schedule(DefaultReactiveExecutor.java:179)\n
at org.apache.camel.impl.engine.DefaultReactiveExecutor.schedule(DefaultReactiveExecutor.java:59)\n
at org.apache.camel.impl.engine.CamelInternalProcessor$AsyncAfterTask.done(CamelInternalProcessor.java:274)\n
at org.apache.camel.impl.engine.CamelInternalProcessor.process(CamelInternalProcessor.java:377)
at org.apache.camel.processor.Pipeline$PipelineTask.run(Pipeline.java:109)
at org.apache.camel.impl.engine.DefaultReactiveExecutor$Worker.schedule(DefaultReactiveExecutor.java:179)
at org.apache.camel.impl.engine.DefaultReactiveExecutor.schedule(DefaultReactiveExecutor.java:59)
at org.apache.camel.impl.engine.CamelInternalProcessor$AsyncAfterTask.done(CamelInternalProcessor.java:274)
at org.apache.camel.impl.engine.CamelInternalProcessor.process(CamelInternalProcessor.java:377)
at org.apache.camel.processor.Pipeline$PipelineTask.run(Pipeline.java:109)
at org.apache.camel.impl.engine.DefaultReactiveExecutor$Worker.schedule(DefaultReactiveExecutor.java:179)
at org.apache.camel.impl.engine.DefaultReactiveExecutor.schedule(DefaultReactiveExecutor.java:59)
at org.apache.camel.impl.engine.CamelInternalProcessor$AsyncAfterTask.done(CamelInternalProcessor.java:274)
at org.apache.camel.impl.engine.CamelInternalProcessor.process(CamelInternalProcessor.java:377)
at org.apache.camel.processor.Pipeline$PipelineTask.run(Pipeline.java:109)
at org.apache.camel.impl.engine.DefaultReactiveExecutor$Worker.schedule(DefaultReactiveExecutor.java:179)
at org.apache.camel.impl.engine.DefaultReactiveExecutor.schedule(DefaultReactiveExecutor.java:59)
at org.apache.camel.impl.engine.CamelInternalProcessor$AsyncAfterTask.done(CamelInternalProcessor.java:274)
at org.apache.camel.impl.engine.CamelInternalProcessor.process(CamelInternalProcessor.java:377)
at org.apache.camel.processor.Pipeline$PipelineTask.run(Pipeline.java:109)
at org.apache.camel.impl.engine.DefaultReactiveExecutor$Worker.schedule(DefaultReactiveExecutor.java:179)
at org.apache.camel.impl.engine.DefaultReactiveExecutor.scheduleSync(DefaultReactiveExecutor.java:69)
at org.apache.camel.processor.Pipeline.process(Pipeline.java:182)
at org.apache.camel.processor.TryProcessor$TryState.run(TryProcessor.java:109)
at org.apache.camel.impl.engine.DefaultReactiveExecutor$Worker.schedule(DefaultReactiveExecutor.java:179)
at org.apache.camel.impl.engine.DefaultReactiveExecutor.schedule(DefaultReactiveExecutor.java:59)
at org.apache.camel.processor.TryProcessor.process(TryProcessor.java:78)
at org.apache.camel.management.DefaultInstrumentationProcessor.process(DefaultInstrumentationProcessor.java:90)
at org.apache.camel.processor.errorhandler.RedeliveryErrorHandler$RedeliveryTask.redeliver(RedeliveryErrorHandler.java:870)
at org.apache.camel.impl.engine.DefaultReactiveExecutor$Worker.schedule(DefaultReactiveExecutor.java:179)
at org.apache.camel.impl.engine.DefaultReactiveExecutor.schedule(DefaultReactiveExecutor.java:59)
at org.apache.camel.impl.engine.CamelInternalProcessor$AsyncAfterTask.done(CamelInternalProcessor.java:274)
at org.apache.camel.impl.engine.CamelInternalProcessor.process(CamelInternalProcessor.java:377)
at org.apache.camel.processor.Pipeline$PipelineTask.run(Pipeline.java:109)
at org.apache.camel.impl.engine.DefaultReactiveExecutor$Worker.schedule(DefaultReactiveExecutor.java:179)
at org.apache.camel.impl.engine.DefaultReactiveExecutor.scheduleSync(DefaultReactiveExecutor.java:69)
at org.apache.camel.processor.Pipeline.process(Pipeline.java:182)
at org.apache.camel.processor.CatchProcessor.process(CatchProcessor.java:119)
at org.apache.camel.processor.TryProcessor$TryState.run(TryProcessor.java:109)
at org.apache.camel.impl.engine.DefaultReactiveExecutor$Worker.schedule(DefaultReactiveExecutor.java:179)
at org.apache.camel.impl.engine.DefaultReactiveExecutor.schedule(DefaultReactiveExecutor.java:59)
at org.apache.camel.impl.engine.CamelInternalProcessor$AsyncAfterTask.done(CamelInternalProcessor.java:274)
at org.apache.camel.impl.engine.CamelInternalProcessor.process(CamelInternalProcessor.java:377)
at org.apache.camel.processor.Pipeline$PipelineTask.run(Pipeline.java:109)
at org.apache.camel.impl.engine.DefaultReactiveExecutor$Worker.schedule(DefaultReactiveExecutor.java:179)
at org.apache.camel.impl.engine.DefaultReactiveExecutor.schedule(DefaultReactiveExecutor.java:59)
at org.apache.camel.impl.engine.CamelInternalProcessor$AsyncAfterTask.done(CamelInternalProcessor.java:274)
at org.apache.camel.impl.engine.CamelInternalProcessor.process(CamelInternalProcessor.java:377)
at org.apache.camel.processor.Pipeline$PipelineTask.run(Pipeline.java:109)
at org.apache.camel.impl.engine.DefaultReactiveExecutor$Worker.schedule(DefaultReactiveExecutor.java:179)
at org.apache.camel.impl.engine.DefaultReactiveExecutor.schedule(DefaultReactiveExecutor.java:59)
at org.apache.camel.impl.engine.CamelInternalProcessor$AsyncAfterTask.done(CamelInternalProcessor.java:274)
at org.apache.camel.impl.engine.CamelInternalProcessor.process(CamelInternalProcessor.java:377)
at org.apache.camel.processor.Pipeline$PipelineTask.run(Pipeline.java:109)
at org.apache.camel.impl.engine.DefaultReactiveExecutor$Worker.schedule(DefaultReactiveExecutor.java:179)
at org.apache.camel.impl.engine.DefaultReactiveExecutor.schedule(DefaultReactiveExecutor.java:59)
at org.apache.camel.impl.engine.CamelInternalProcessor$AsyncAfterTask.done(CamelInternalProcessor.java:274)
at org.apache.camel.impl.engine.CamelInternalProcessor.process(CamelInternalProcessor.java:377)
at org.apache.camel.processor.Pipeline$PipelineTask.run(Pipeline.java:109)
at org.apache.camel.impl.engine.DefaultReactiveExecutor$Worker.schedule(DefaultReactiveExecutor.java:179)
at org.apache.camel.impl.engine.DefaultReactiveExecutor.scheduleSync(DefaultReactiveExecutor.java:69)
at org.apache.camel.processor.Pipeline.process(Pipeline.java:182)
at org.apache.camel.processor.TryProcessor$TryState.run(TryProcessor.java:109)
at org.apache.camel.impl.engine.DefaultReactiveExecutor$Worker.schedule(DefaultReactiveExecutor.java:179)
at org.apache.camel.impl.engine.DefaultReactiveExecutor.schedule(DefaultReactiveExecutor.java:59)
at org.apache.camel.processor.TryProcessor.process(TryProcessor.java:78)
at org.apache.camel.management.DefaultInstrumentationProcessor.process(DefaultInstrumentationProcessor.java:90)
at org.apache.camel.processor.errorhandler.RedeliveryErrorHandler$RedeliveryTask.redeliver(RedeliveryErrorHandler.java:870)
at org.apache.camel.impl.engine.DefaultReactiveExecutor$Worker.schedule(DefaultReactiveExecutor.java:179)
at org.apache.camel.impl.engine.DefaultReactiveExecutor.schedule(DefaultReactiveExecutor.java:59)
at org.apache.camel.impl.engine.CamelInternalProcessor$AsyncAfterTask.done(CamelInternalProcessor.java:274)
at org.apache.camel.impl.engine.CamelInternalProcessor.process(CamelInternalProcessor.java:377)
at org.apache.camel.processor.Pipeline$PipelineTask.run(Pipeline.java:109)
at org.apache.camel.impl.engine.DefaultReactiveExecutor$Worker.schedule(DefaultReactiveExecutor.java:179)
at org.apache.camel.impl.engine.DefaultReactiveExecutor.scheduleSync(DefaultReactiveExecutor.java:69)
at org.apache.camel.processor.Pipeline.process(Pipeline.java:182)
at org.apache.camel.processor.CatchProcessor.process(CatchProcessor.java:119)
at org.apache.camel.processor.TryProcessor$TryState.run(TryProcessor.java:109)
at org.apache.camel.impl.engine.DefaultReactiveExecutor$Worker.schedule(DefaultReactiveExecutor.java:179)
at org.apache.camel.impl.engine.DefaultReactiveExecutor.schedule(DefaultReactiveExecutor.java:59)
at org.apache.camel.impl.engine.CamelInternalProcessor$AsyncAfterTask.done(CamelInternalProcessor.java:274)
at org.apache.camel.impl.engine.CamelInternalProcessor.process(CamelInternalProcessor.java:377)
at org.apache.camel.processor.Pipeline$PipelineTask.run(Pipeline.java:109)
at org.apache.camel.impl.engine.DefaultReactiveExecutor$Worker.schedule(DefaultReactiveExecutor.java:179)
at org.apache.camel.impl.engine.DefaultReactiveExecutor.schedule(DefaultReactiveExecutor.java:59)
at org.apache.camel.impl.engine.CamelInternalProcessor$AsyncAfterTask.done(CamelInternalProcessor.java:274)
at org.apache.camel.impl.engine.CamelInternalProcessor.process(CamelInternalProcessor.java:377)
at org.apache.camel.processor.Pipeline$PipelineTask.run(Pipeline.java:109)
at org.apache.camel.impl.engine.DefaultReactiveExecutor$Worker.schedule(DefaultReactiveExecutor.java:179)
at org.apache.camel.impl.engine.DefaultReactiveExecutor.schedule(DefaultReactiveExecutor.java:59)
at org.apache.camel.impl.engine.CamelInternalProcessor$AsyncAfterTask.done(CamelInternalProcessor.java:274)
at org.apache.camel.impl.engine.CamelInternalProcessor.process(CamelInternalProcessor.java:377)
at org.apache.camel.processor.Pipeline$PipelineTask.run(Pipeline.java:109)
at org.apache.camel.impl.engine.DefaultReactiveExecutor$Worker.schedule(DefaultReactiveExecutor.java:179)
at org.apache.camel.impl.engine.DefaultReactiveExecutor.schedule(DefaultReactiveExecutor.java:59)
at org.apache.camel.impl.engine.CamelInternalProcessor$AsyncAfterTask.done(CamelInternalProcessor.java:274)
at org.apache.camel.impl.engine.CamelInternalProcessor.process(CamelInternalProcessor.java:377)
at org.apache.camel.processor.Pipeline$PipelineTask.run(Pipeline.java:109)
at org.apache.camel.impl.engine.DefaultReactiveExecutor$Worker.schedule(DefaultReactiveExecutor.java:179)
at org.apache.camel.impl.engine.DefaultReactiveExecutor.scheduleSync(DefaultReactiveExecutor.java:69)
at org.apache.camel.processor.Pipeline.process(Pipeline.java:182)
at org.apache.camel.processor.TryProcessor$TryState.run(TryProcessor.java:109)
at org.apache.camel.impl.engine.DefaultReactiveExecutor$Worker.schedule(DefaultReactiveExecutor.java:179)
at org.apache.camel.impl.engine.DefaultReactiveExecutor.schedule(DefaultReactiveExecutor.java:59)
at org.apache.camel.processor.TryProcessor.process(TryProcessor.java:78)
at org.apache.camel.management.DefaultInstrumentationProcessor.process(DefaultInstrumentationProcessor.java:90)
at org.apache.camel.processor.errorhandler.RedeliveryErrorHandler$RedeliveryTask.redeliver(RedeliveryErrorHandler.java:870)
at org.apache.camel.impl.engine.DefaultReactiveExecutor$Worker.schedule(DefaultReactiveExecutor.java:179)
at org.apache.camel.impl.engine.DefaultReactiveExecutor.schedule(DefaultReactiveExecutor.java:59)
at org.apache.camel.impl.engine.CamelInternalProcessor$AsyncAfterTask.done(CamelInternalProcessor.java:274)
at org.apache.camel.impl.engine.CamelInternalProcessor.process(CamelInternalProcessor.java:377)
at org.apache.camel.processor.Pipeline$PipelineTask.run(Pipeline.java:109)
at org.apache.camel.impl.engine.DefaultReactiveExecutor$Worker.schedule(DefaultReactiveExecutor.java:179)
at org.apache.camel.impl.engine.DefaultReactiveExecutor.scheduleSync(DefaultReactiveExecutor.java:69)
at org.apache.camel.processor.Pipeline.process(Pipeline.java:182)
at org.apache.camel.processor.CatchProcessor.process(CatchProcessor.java:119)
at org.apache.camel.processor.TryProcessor$TryState.run(TryProcessor.java:109)
at org.apache.camel.impl.engine.DefaultReactiveExecutor$Worker.schedule(DefaultReactiveExecutor.java:179)
at org.apache.camel.impl.engine.DefaultReactiveExecutor.schedule(DefaultReactiveExecutor.java:59)
at org.apache.camel.impl.engine.CamelInternalProcessor$AsyncAfterTask.done(CamelInternalProcessor.java:274)
at org.apache.camel.impl.engine.CamelInternalProcessor.process(CamelInternalProcessor.java:377)
at org.apache.camel.processor.Pipeline$PipelineTask.run(Pipeline.java:109)
at org.apache.camel.impl.engine.DefaultReactiveExecutor$Worker.schedule(DefaultReactiveExecutor.java:179)
at org.apache.camel.impl.engine.DefaultReactiveExecutor.schedule(DefaultReactiveExecutor.java:59)
at org.apache.camel.impl.engine.CamelInternalProcessor$AsyncAfterTask.done(CamelInternalProcessor.java:274)
at org.apache.camel.impl.engine.CamelInternalProcessor.process(CamelInternalProcessor.java:377)
at org.apache.camel.processor.Pipeline$PipelineTask.run(Pipeline.java:109)
at org.apache.camel.impl.engine.DefaultReactiveExecutor$Worker.schedule(DefaultReactiveExecutor.java:179)
at org.apache.camel.impl.engine.DefaultReactiveExecutor.schedule(DefaultReactiveExecutor.java:59)
at org.apache.camel.impl.engine.CamelInternalProcessor$AsyncAfterTask.done(CamelInternalProcessor.java:274)
at org.apache.camel.impl.engine.CamelInternalProcessor.process(CamelInternalProcessor.java:377)
at org.apache.camel.processor.Pipeline$PipelineTask.run(Pipeline.java:109)
at org.apache.camel.impl.engine.DefaultReactiveExecutor$Worker.schedule(DefaultReactiveExecutor.java:179)
at org.apache.camel.impl.engine.DefaultReactiveExecutor.schedule(DefaultReactiveExecutor.java:59)
at org.apache.camel.impl.engine.CamelInternalProcessor$AsyncAfterTask.done(CamelInternalProcessor.java:274)
at org.apache.camel.impl.engine.CamelInternalProcessor.process(CamelInternalProcessor.java:377)
at org.apache.camel.processor.Pipeline$PipelineTask.run(Pipeline.java:109)
at org.apache.camel.impl.engine.DefaultReactiveExecutor$Worker.schedule(DefaultReactiveExecutor.java:179)
at org.apache.camel.impl.engine.DefaultReactiveExecutor.scheduleSync(DefaultReactiveExecutor.java:69)
at org.apache.camel.processor.Pipeline.process(Pipeline.java:182)
at org.apache.camel.processor.TryProcessor$TryState.run(TryProcessor.java:109)
at org.apache.camel.impl.engine.DefaultReactiveExecutor$Worker.schedule(DefaultReactiveExecutor.java:179)
at org.apache.camel.impl.engine.DefaultReactiveExecutor.schedule(DefaultReactiveExecutor.java:59)
at org.apache.camel.processor.TryProcessor.process(TryProcessor.java:78)
at org.apache.camel.management.DefaultInstrumentationProcessor.process(DefaultInstrumentationProcessor.java:90)
at org.apache.camel.processor.errorhandler.RedeliveryErrorHandler$RedeliveryTask.redeliver(RedeliveryErrorHandler.java:870)
at org.apache.camel.impl.engine.DefaultReactiveExecutor$Worker.schedule(DefaultReactiveExecutor.java:179)
at org.apache.camel.impl.engine.DefaultReactiveExecutor.schedule(DefaultReactiveExecutor.java:59)
at org.apache.camel.impl.engine.CamelInternalProcessor$AsyncAfterTask.done(CamelInternalProcessor.java:274)
at org.apache.camel.impl.engine.CamelInternalProcessor.process(CamelInternalProcessor.java:377)
at org.apache.camel.processor.Pipeline$PipelineTask.run(Pipeline.java:109)
at org.apache.camel.impl.engine.DefaultReactiveExecutor$Worker.schedule(DefaultReactiveExecutor.java:179)
at org.apache.camel.impl.engine.DefaultReactiveExecutor.scheduleSync(DefaultReactiveExecutor.java:69)
at org.apache.camel.processor.Pipeline.process(Pipeline.java:182)
at org.apache.camel.processor.CatchProcessor.process(CatchProcessor.java:119)
at org.apache.camel.processor.TryProcessor$TryState.run(TryProcessor.java:109)
at org.apache.camel.impl.engine.DefaultReactiveExecutor$Worker.schedule(DefaultReactiveExecutor.java:179)
at org.apache.camel.impl.engine.DefaultReactiveExecutor.schedule(DefaultReactiveExecutor.java:59)
at org.apache.camel.impl.engine.CamelInternalProcessor$AsyncAfterTask.done(CamelInternalProcessor.java:274)
at org.apache.camel.impl.engine.CamelInternalProcessor.process(CamelInternalProcessor.java:377)
at org.apache.camel.processor.Pipeline$PipelineTask.run(Pipeline.java:109)
at org.apache.camel.impl.engine.DefaultReactiveExecutor$Worker.schedule(DefaultReactiveExecutor.java:179)
at org.apache.camel.impl.engine.DefaultReactiveExecutor.schedule(DefaultReactiveExecutor.java:59)
at org.apache.camel.impl.engine.CamelInternalProcessor$AsyncAfterTask.done(CamelInternalProcessor.java:274)
at org.apache.camel.impl.engine.CamelInternalProcessor.process(CamelInternalProcessor.java:377)
at org.apache.camel.processor.Pipeline$PipelineTask.run(Pipeline.java:109)
at org.apache.camel.impl.engine.DefaultReactiveExecutor$Worker.schedule(DefaultReactiveExecutor.java:179)
at org.apache.camel.impl.engine.DefaultReactiveExecutor.schedule(DefaultReactiveExecutor.java:59)\n
at org.apache.camel.impl.engine.CamelInternalProcessor$AsyncAfterTask.done(CamelInternalProcessor.java:274)\n
at org.apache.camel.impl.engine.CamelInternalProcessor.process(CamelInternalProcessor.java:377)
at org.apache.camel.processor.Pipeline$PipelineTask.run(Pipeline.java:109)
at org.apache.camel.impl.engine.DefaultReactiveExecutor$Worker.schedule(DefaultReactiveExecutor.java:179)
at org.apache.camel.impl.engine.DefaultReactiveExecutor.schedule(DefaultReactiveExecutor.java:59)
at org.apache.camel.impl.engine.CamelInternalProcessor$AsyncAfterTask.done(CamelInternalProcessor.java:274)
at org.apache.camel.impl.engine.CamelInternalProcessor.process(CamelInternalProcessor.java:377)
at org.apache.camel.processor.Pipeline$PipelineTask.run(Pipeline.java:109)
at org.apache.camel.impl.engine.DefaultReactiveExecutor$Worker.schedule(DefaultReactiveExecutor.java:179)
at org.apache.camel.impl.engine.DefaultReactiveExecutor.scheduleSync(DefaultReactiveExecutor.java:69)
at org.apache.camel.processor.Pipeline.process(Pipeline.java:182)
at org.apache.camel.processor.TryProcessor$TryState.run(TryProcessor.java:109)
at org.apache.camel.impl.engine.DefaultReactiveExecutor$Worker.schedule(DefaultReactiveExecutor.java:179)
at org.apache.camel.impl.engine.DefaultReactiveExecutor.schedule(DefaultReactiveExecutor.java:59)
at org.apache.camel.processor.TryProcessor.process(TryProcessor.java:78)
at org.apache.camel.management.DefaultInstrumentationProcessor.process(DefaultInstrumentationProcessor.java:90)
at org.apache.camel.processor.errorhandler.RedeliveryErrorHandler$RedeliveryTask.redeliver(RedeliveryErrorHandler.java:870)
at org.apache.camel.impl.engine.DefaultReactiveExecutor$Worker.schedule(DefaultReactiveExecutor.java:179)
at org.apache.camel.impl.engine.DefaultReactiveExecutor.schedule(DefaultReactiveExecutor.java:59)
at org.apache.camel.impl.engine.CamelInternalProcessor$AsyncAfterTask.done(CamelInternalProcessor.java:274)
at org.apache.camel.impl.engine.CamelInternalProcessor.process(CamelInternalProcessor.java:377)
at org.apache.camel.processor.Pipeline$PipelineTask.run(Pipeline.java:109)
at org.apache.camel.impl.engine.DefaultReactiveExecutor$Worker.schedule(DefaultReactiveExecutor.java:179)
at org.apache.camel.impl.engine.DefaultReactiveExecutor.scheduleSync(DefaultReactiveExecutor.java:69)
at org.apache.camel.processor.Pipeline.process(Pipeline.java:182)
at org.apache.camel.processor.CatchProcessor.process(CatchProcessor.java:119)
at org.apache.camel.processor.TryProcessor$TryState.run(TryProcessor.java:109)
at org.apache.camel.impl.engine.DefaultReactiveExecutor$Worker.schedule(DefaultReactiveExecutor.java:179)
at org.apache.camel.impl.engine.DefaultReactiveExecutor.schedule(DefaultReactiveExecutor.java:59)
at org.apache.camel.impl.engine.CamelInternalProcessor$AsyncAfterTask.done(CamelInternalProcessor.java:274)
at org.apache.camel.impl.engine.CamelInternalProcessor.process(CamelInternalProcessor.java:377)
at org.apache.camel.processor.Pipeline$PipelineTask.run(Pipeline.java:109)
at org.apache.camel.impl.engine.DefaultReactiveExecutor$Worker.schedule(DefaultReactiveExecutor.java:179)
at org.apache.camel.impl.engine.DefaultReactiveExecutor.schedule(DefaultReactiveExecutor.java:59)
at org.apache.camel.impl.engine.CamelInternalProcessor$AsyncAfterTask.done(CamelInternalProcessor.java:274)
at org.apache.camel.impl.engine.CamelInternalProcessor.process(CamelInternalProcessor.java:377)
at org.apache.camel.processor.Pipeline$PipelineTask.run(Pipeline.java:109)
at org.apache.camel.impl.engine.DefaultReactiveExecutor$Worker.schedule(DefaultReactiveExecutor.java:179)
at org.apache.camel.impl.engine.DefaultReactiveExecutor.schedule(DefaultReactiveExecutor.java:59)
at org.apache.camel.impl.engine.CamelInternalProcessor$AsyncAfterTask.done(CamelInternalProcessor.java:274)
at org.apache.camel.impl.engine.CamelInternalProcessor.process(CamelInternalProcessor.java:377)
at org.apache.camel.processor.Pipeline$PipelineTask.run(Pipeline.java:109)
at org.apache.camel.impl.engine.DefaultReactiveExecutor$Worker.schedule(DefaultReactiveExecutor.java:179)
at org.apache.camel.impl.engine.DefaultReactiveExecutor.schedule(DefaultReactiveExecutor.java:59)
at org.apache.camel.impl.engine.CamelInternalProcessor$AsyncAfterTask.done(CamelInternalProcessor.java:274)
at org.apache.camel.impl.engine.CamelInternalProcessor.process(CamelInternalProcessor.java:377)
at org.apache.camel.processor.Pipeline$PipelineTask.run(Pipeline.java:109)
at org.apache.camel.impl.engine.DefaultReactiveExecutor$Worker.schedule(DefaultReactiveExecutor.java:179)
at org.apache.camel.impl.engine.DefaultReactiveExecutor.scheduleSync(DefaultReactiveExecutor.java:69)
at org.apache.camel.processor.Pipeline.process(Pipeline.java:182)
at org.apache.camel.processor.TryProcessor$TryState.run(TryProcessor.java:109)
at org.apache.camel.impl.engine.DefaultReactiveExecutor$Worker.schedule(DefaultReactiveExecutor.java:179)
at org.apache.camel.impl.engine.DefaultReactiveExecutor.schedule(DefaultReactiveExecutor.java:59)
at org.apache.camel.processor.TryProcessor.process(TryProcessor.java:78)
at org.apache.camel.management.DefaultInstrumentationProcessor.process(DefaultInstrumentationProcessor.java:90)
at org.apache.camel.processor.errorhandler.RedeliveryErrorHandler$RedeliveryTask.redeliver(RedeliveryErrorHandler.java:870)
at org.apache.camel.impl.engine.DefaultReactiveExecutor$Worker.schedule(DefaultReactiveExecutor.java:179)
at org.apache.camel.impl.engine.DefaultReactiveExecutor.schedule(DefaultReactiveExecutor.java:59)
at org.apache.camel.impl.engine.CamelInternalProcessor$AsyncAfterTask.done(CamelInternalProcessor.java:274)
at org.apache.camel.impl.engine.CamelInternalProcessor.process(CamelInternalProcessor.java:377)
at org.apache.camel.processor.Pipeline$PipelineTask.run(Pipeline.java:109)
at org.apache.camel.impl.engine.DefaultReactiveExecutor$Worker.schedule(DefaultReactiveExecutor.java:179)
at org.apache.camel.impl.engine.DefaultReactiveExecutor.scheduleSync(DefaultReactiveExecutor.java:69)
at org.apache.camel.processor.Pipeline.process(Pipeline.java:182)
at org.apache.camel.processor.CatchProcessor.process(CatchProcessor.java:119)
at org.apache.camel.processor.TryProcessor$TryState.run(TryProcessor.java:109)
at org.apache.camel.impl.engine.DefaultReactiveExecutor$Worker.schedule(DefaultReactiveExecutor.java:179)
at org.apache.camel.impl.engine.DefaultReactiveExecutor.schedule(DefaultReactiveExecutor.java:59)
at org.apache.camel.impl.engine.CamelInternalProcessor$AsyncAfterTask.done(CamelInternalProcessor.java:274)
at org.apache.camel.impl.engine.CamelInternalProcessor.process(CamelInternalProcessor.java:377)
at org.apache.camel.processor.Pipeline$PipelineTask.run(Pipeline.java:109)
at org.apache.camel.impl.engine.DefaultReactiveExecutor$Worker.schedule(DefaultReactiveExecutor.java:179)
at org.apache.camel.impl.engine.DefaultReactiveExecutor.schedule(DefaultReactiveExecutor.java:59)
at org.apache.camel.impl.engine.CamelInternalProcessor$AsyncAfterTask.done(CamelInternalProcessor.java:274)
at org.apache.camel.impl.engine.CamelInternalProcessor.process(CamelInternalProcessor.java:377)
at org.apache.camel.processor.Pipeline$PipelineTask.run(Pipeline.java:109)
at org.apache.camel.impl.engine.DefaultReactiveExecutor$Worker.schedule(DefaultReactiveExecutor.java:179)
at org.apache.camel.impl.engine.DefaultReactiveExecutor.schedule(DefaultReactiveExecutor.java:59)
at org.apache.camel.impl.engine.CamelInternalProcessor$AsyncAfterTask.done(CamelInternalProcessor.java:274)
at org.apache.camel.impl.engine.CamelInternalProcessor.process(CamelInternalProcessor.java:377)
at org.apache.camel.processor.Pipeline$PipelineTask.run(Pipeline.java:109)
at org.apache.camel.impl.engine.DefaultReactiveExecutor$Worker.schedule(DefaultReactiveExecutor.java:179)
at org.apache.camel.impl.engine.DefaultReactiveExecutor.schedule(DefaultReactiveExecutor.java:59)
at org.apache.camel.impl.engine.CamelInternalProcessor$AsyncAfterTask.done(CamelInternalProcessor.java:274)
at org.apache.camel.impl.engine.CamelInternalProcessor.process(CamelInternalProcessor.java:377)
at org.apache.camel.processor.Pipeline$PipelineTask.run(Pipeline.java:109)
at org.apache.camel.impl.engine.DefaultReactiveExecutor$Worker.schedule(DefaultReactiveExecutor.java:179)
at org.apache.camel.impl.engine.DefaultReactiveExecutor.scheduleSync(DefaultReactiveExecutor.java:69)
at org.apache.camel.processor.Pipeline.process(Pipeline.java:182)
at org.apache.camel.processor.TryProcessor$TryState.run(TryProcessor.java:109)
at org.apache.camel.impl.engine.DefaultReactiveExecutor$Worker.schedule(DefaultReactiveExecutor.java:179)
at org.apache.camel.impl.engine.DefaultReactiveExecutor.schedule(DefaultReactiveExecutor.java:59)
at org.apache.camel.processor.TryProcessor.process(TryProcessor.java:78)
at org.apache.camel.management.DefaultInstrumentationProcessor.process(DefaultInstrumentationProcessor.java:90)
at org.apache.camel.processor.errorhandler.RedeliveryErrorHandler$RedeliveryTask.redeliver(RedeliveryErrorHandler.java:870)
at org.apache.camel.impl.engine.DefaultReactiveExecutor$Worker.schedule(DefaultReactiveExecutor.java:179)
at org.apache.camel.impl.engine.DefaultReactiveExecutor.schedule(DefaultReactiveExecutor.java:59)
at org.apache.camel.impl.engine.CamelInternalProcessor$AsyncAfterTask.done(CamelInternalProcessor.java:274)
at org.apache.camel.impl.engine.CamelInternalProcessor.process(CamelInternalProcessor.java:377)
at org.apache.camel.processor.Pipeline$PipelineTask.run(Pipeline.java:109)
at org.apache.camel.impl.engine.DefaultReactiveExecutor$Worker.schedule(DefaultReactiveExecutor.java:179)
at org.apache.camel.impl.engine.DefaultReactiveExecutor.scheduleSync(DefaultReactiveExecutor.java:69)
at org.apache.camel.processor.Pipeline.process(Pipeline.java:182)
at org.apache.camel.processor.CatchProcessor.process(CatchProcessor.java:119)
at org.apache.camel.processor.TryProcessor$TryState.run(TryProcessor.java:109)
at org.apache.camel.impl.engine.DefaultReactiveExecutor$Worker.schedule(DefaultReactiveExecutor.java:179)
at org.apache.camel.impl.engine.DefaultReactiveExecutor.schedule(DefaultReactiveExecutor.java:59)
at org.apache.camel.impl.engine.CamelInternalProcessor$AsyncAfterTask.done(CamelInternalProcessor.java:274)
at org.apache.camel.impl.engine.CamelInternalProcessor.process(CamelInternalProcessor.java:377)
at org.apache.camel.processor.Pipeline$PipelineTask.run(Pipeline.java:109)
at org.apache.camel.impl.engine.DefaultReactiveExecutor$Worker.schedule(DefaultReactiveExecutor.java:179)
at org.apache.camel.impl.engine.DefaultReactiveExecutor.schedule(DefaultReactiveExecutor.java:59)
at org.apache.camel.impl.engine.CamelInternalProcessor$AsyncAfterTask.done(CamelInternalProcessor.java:274)
at org.apache.camel.impl.engine.CamelInternalProcessor.process(CamelInternalProcessor.java:377)
at org.apache.camel.processor.Pipeline$PipelineTask.run(Pipeline.java:109)
at org.apache.camel.impl.engine.DefaultReactiveExecutor$Worker.schedule(DefaultReactiveExecutor.java:179)
at org.apache.camel.impl.engine.DefaultReactiveExecutor.schedule(DefaultReactiveExecutor.java:59)
at org.apache.camel.impl.engine.CamelInternalProcessor$AsyncAfterTask.done(CamelInternalProcessor.java:274)
at org.apache.camel.impl.engine.CamelInternalProcessor.process(CamelInternalProcessor.java:377)
at org.apache.camel.processor.Pipeline$PipelineTask.run(Pipeline.java:109)
at org.apache.camel.impl.engine.DefaultReactiveExecutor$Worker.schedule(DefaultReactiveExecutor.java:179)
at org.apache.camel.impl.engine.DefaultReactiveExecutor.schedule(DefaultReactiveExecutor.java:59)
at org.apache.camel.impl.engine.CamelInternalProcessor$AsyncAfterTask.done(CamelInternalProcessor.java:274)
at org.apache.camel.impl.engine.CamelInternalProcessor.process(CamelInternalProcessor.java:377)
at org.apache.camel.processor.Pipeline$PipelineTask.run(Pipeline.java:109)
at org.apache.camel.impl.engine.DefaultReactiveExecutor$Worker.schedule(DefaultReactiveExecutor.java:179)
at org.apache.camel.impl.engine.DefaultReactiveExecutor.scheduleSync(DefaultReactiveExecutor.java:69)
at org.apache.camel.processor.Pipeline.process(Pipeline.java:182)
at org.apache.camel.processor.TryProcessor$TryState.run(TryProcessor.java:109)
at org.apache.camel.impl.engine.DefaultReactiveExecutor$Worker.schedule(DefaultReactiveExecutor.java:179)
at org.apache.camel.impl.engine.DefaultReactiveExecutor.schedule(DefaultReactiveExecutor.java:59)
at org.apache.camel.processor.TryProcessor.process(TryProcessor.java:78)
at org.apache.camel.management.DefaultInstrumentationProcessor.process(DefaultInstrumentationProcessor.java:90)
at org.apache.camel.processor.errorhandler.RedeliveryErrorHandler$RedeliveryTask.redeliver(RedeliveryErrorHandler.java:870)
at org.apache.camel.impl.engine.DefaultReactiveExecutor$Worker.schedule(DefaultReactiveExecutor.java:179)
at org.apache.camel.impl.engine.DefaultReactiveExecutor.schedule(DefaultReactiveExecutor.java:59)
at org.apache.camel.impl.engine.CamelInternalProcessor$AsyncAfterTask.done(CamelInternalProcessor.java:274)
at org.apache.camel.impl.engine.CamelInternalProcessor.process(CamelInternalProcessor.java:377)
at org.apache.camel.processor.Pipeline$PipelineTask.run(Pipeline.java:109)
at org.apache.camel.impl.engine.DefaultReactiveExecutor$Worker.schedule(DefaultReactiveExecutor.java:179)
at org.apache.camel.impl.engine.DefaultReactiveExecutor.scheduleSync(DefaultReactiveExecutor.java:69)
at org.apache.camel.processor.Pipeline.process(Pipeline.java:182)
at org.apache.camel.processor.CatchProcessor.process(CatchProcessor.java:119)
at org.apache.camel.processor.TryProcessor$TryState.run(TryProcessor.java:109)
at org.apache.camel.impl.engine.DefaultReactiveExecutor$Worker.schedule(DefaultReactiveExecutor.java:179)
at org.apache.camel.impl.engine.DefaultReactiveExecutor.schedule(DefaultReactiveExecutor.java:59)
at org.apache.camel.impl.engine.CamelInternalProcessor$AsyncAfterTask.done(CamelInternalProcessor.java:274)
at org.apache.camel.impl.engine.CamelInternalProcessor.process(CamelInternalProcessor.java:377)
at org.apache.camel.processor.Pipeline$PipelineTask.run(Pipeline.java:109)
at org.apache.camel.impl.engine.DefaultReactiveExecutor$Worker.schedule(DefaultReactiveExecutor.java:179)
at org.apache.camel.impl.engine.DefaultReactiveExecutor.schedule(DefaultReactiveExecutor.java:59)
at org.apache.camel.impl.engine.CamelInternalProcessor$AsyncAfterTask.done(CamelInternalProcessor.java:274)
at org.apache.camel.impl.engine.CamelInternalProcessor.process(CamelInternalProcessor.java:377)
at org.apache.camel.processor.Pipeline$PipelineTask.run(Pipeline.java:109)
at org.apache.camel.impl.engine.DefaultReactiveExecutor$Worker.schedule(DefaultReactiveExecutor.java:179)
at org.apache.camel.impl.engine.DefaultReactiveExecutor.schedule(DefaultReactiveExecutor.java:59)
at org.apache.camel.impl.engine.CamelInternalProcessor$AsyncAfterTask.done(CamelInternalProcessor.java:274)
at org.apache.camel.impl.engine.CamelInternalProcessor.process(CamelInternalProcessor.java:377)
at org.apache.camel.processor.Pipeline$PipelineTask.run(Pipeline.java:109)
at org.apache.camel.impl.engine.DefaultReactiveExecutor$Worker.schedule(DefaultReactiveExecutor.java:179)
at org.apache.camel.impl.engine.DefaultReactiveExecutor.schedule(DefaultReactiveExecutor.java:59)
at org.apache.camel.impl.engine.CamelInternalProcessor$AsyncAfterTask.done(CamelInternalProcessor.java:274)
at org.apache.camel.impl.engine.CamelInternalProcessor.process(CamelInternalProcessor.java:377)
at org.apache.camel.processor.Pipeline$PipelineTask.run(Pipeline.java:109)
at org.apache.camel.impl.engine.DefaultReactiveExecutor$Worker.schedule(DefaultReactiveExecutor.java:179)
at org.apache.camel.impl.engine.DefaultReactiveExecutor.scheduleSync(DefaultReactiveExecutor.java:69)
at org.apache.camel.processor.Pipeline.process(Pipeline.java:182)
at org.apache.camel.processor.TryProcessor$TryState.run(TryProcessor.java:109)\n
at org.apache.camel.impl.engine.DefaultReactiveExecutor$Worker.schedule(DefaultReactiveExecutor.java:179)\n
at org.apache.camel.impl.engine.DefaultReactiveExecutor.schedule(DefaultReactiveExecutor.java:59)
at org.apache.camel.processor.TryProcessor.process(TryProcessor.java:78)
at org.apache.camel.management.DefaultInstrumentationProcessor.process(DefaultInstrumentationProcessor.java:90)
at org.apache.camel.processor.errorhandler.RedeliveryErrorHandler$RedeliveryTask.redeliver(RedeliveryErrorHandler.java:870)
at org.apache.camel.impl.engine.DefaultReactiveExecutor$Worker.schedule(DefaultReactiveExecutor.java:179)
at org.apache.camel.impl.engine.DefaultReactiveExecutor.schedule(DefaultReactiveExecutor.java:59)
at org.apache.camel.impl.engine.CamelInternalProcessor$AsyncAfterTask.done(CamelInternalProcessor.java:274)
at org.apache.camel.impl.engine.CamelInternalProcessor.process(CamelInternalProcessor.java:377)
at org.apache.camel.processor.Pipeline$PipelineTask.run(Pipeline.java:109)
at org.apache.camel.impl.engine.DefaultReactiveExecutor$Worker.schedule(DefaultReactiveExecutor.java:179)
at org.apache.camel.impl.engine.DefaultReactiveExecutor.scheduleSync(DefaultReactiveExecutor.java:69)
at org.apache.camel.processor.Pipeline.process(Pipeline.java:182)
at org.apache.camel.processor.CatchProcessor.process(CatchProcessor.java:119)
at org.apache.camel.processor.TryProcessor$TryState.run(TryProcessor.java:109)
at org.apache.camel.impl.engine.DefaultReactiveExecutor$Worker.schedule(DefaultReactiveExecutor.java:179)
at org.apache.camel.impl.engine.DefaultReactiveExecutor.schedule(DefaultReactiveExecutor.java:59)
at org.apache.camel.impl.engine.CamelInternalProcessor$AsyncAfterTask.done(CamelInternalProcessor.java:274)
at org.apache.camel.impl.engine.CamelInternalProcessor.process(CamelInternalProcessor.java:377)
at org.apache.camel.processor.Pipeline$PipelineTask.run(Pipeline.java:109)
at org.apache.camel.impl.engine.DefaultReactiveExecutor$Worker.schedule(DefaultReactiveExecutor.java:179)
at org.apache.camel.impl.engine.DefaultReactiveExecutor.schedule(DefaultReactiveExecutor.java:59)
at org.apache.camel.impl.engine.CamelInternalProcessor$AsyncAfterTask.done(CamelInternalProcessor.java:274)
at org.apache.camel.impl.engine.CamelInternalProcessor.process(CamelInternalProcessor.java:377)
at org.apache.camel.processor.Pipeline$PipelineTask.run(Pipeline.java:109)
at org.apache.camel.impl.engine.DefaultReactiveExecutor$Worker.schedule(DefaultReactiveExecutor.java:179)
at org.apache.camel.impl.engine.DefaultReactiveExecutor.schedule(DefaultReactiveExecutor.java:59)
at org.apache.camel.impl.engine.CamelInternalProcessor$AsyncAfterTask.done(CamelInternalProcessor.java:274)
at org.apache.camel.impl.engine.CamelInternalProcessor.process(CamelInternalProcessor.java:377)
at org.apache.camel.processor.Pipeline$PipelineTask.run(Pipeline.java:109)
at org.apache.camel.impl.engine.DefaultReactiveExecutor$Worker.schedule(DefaultReactiveExecutor.java:179)
at org.apache.camel.impl.engine.DefaultReactiveExecutor.schedule(DefaultReactiveExecutor.java:59)
at org.apache.camel.impl.engine.CamelInternalProcessor$AsyncAfterTask.done(CamelInternalProcessor.java:274)
at org.apache.camel.impl.engine.CamelInternalProcessor.process(CamelInternalProcessor.java:377)
at org.apache.camel.processor.Pipeline$PipelineTask.run(Pipeline.java:109)
at org.apache.camel.impl.engine.DefaultReactiveExecutor$Worker.schedule(DefaultReactiveExecutor.java:179)
at org.apache.camel.impl.engine.DefaultReactiveExecutor.scheduleSync(DefaultReactiveExecutor.java:69)
at org.apache.camel.processor.Pipeline.process(Pipeline.java:182)
at org.apache.camel.processor.TryProcessor$TryState.run(TryProcessor.java:109)
at org.apache.camel.impl.engine.DefaultReactiveExecutor$Worker.schedule(DefaultReactiveExecutor.java:179)
at org.apache.camel.impl.engine.DefaultReactiveExecutor.schedule(DefaultReactiveExecutor.java:59)
at org.apache.camel.processor.TryProcessor.process(TryProcessor.java:78)
at org.apache.camel.management.DefaultInstrumentationProcessor.process(DefaultInstrumentationProcessor.java:90)
at org.apache.camel.processor.errorhandler.RedeliveryErrorHandler$RedeliveryTask.redeliver(RedeliveryErrorHandler.java:870)
at org.apache.camel.impl.engine.DefaultReactiveExecutor$Worker.schedule(DefaultReactiveExecutor.java:179)
at org.apache.camel.impl.engine.DefaultReactiveExecutor.schedule(DefaultReactiveExecutor.java:59)
at org.apache.camel.impl.engine.CamelInternalProcessor$AsyncAfterTask.done(CamelInternalProcessor.java:274)
at org.apache.camel.impl.engine.CamelInternalProcessor.process(CamelInternalProcessor.java:377)
at org.apache.camel.processor.Pipeline$PipelineTask.run(Pipeline.java:109)
at org.apache.camel.impl.engine.DefaultReactiveExecutor$Worker.schedule(DefaultReactiveExecutor.java:179)
at org.apache.camel.impl.engine.DefaultReactiveExecutor.scheduleSync(DefaultReactiveExecutor.java:69)
at org.apache.camel.processor.Pipeline.process(Pipeline.java:182)
at org.apache.camel.processor.CatchProcessor.process(CatchProcessor.java:119)
at org.apache.camel.processor.TryProcessor$TryState.run(TryProcessor.java:109)
at org.apache.camel.impl.engine.DefaultReactiveExecutor$Worker.schedule(DefaultReactiveExecutor.java:179)
at org.apache.camel.impl.engine.DefaultReactiveExecutor.schedule(DefaultReactiveExecutor.java:59)
at org.apache.camel.impl.engine.CamelInternalProcessor$AsyncAfterTask.done(CamelInternalProcessor.java:274)
at org.apache.camel.impl.engine.CamelInternalProcessor.process(CamelInternalProcessor.java:377)
at org.apache.camel.processor.Pipeline$PipelineTask.run(Pipeline.java:109)
at org.apache.camel.impl.engine.DefaultReactiveExecutor$Worker.schedule(DefaultReactiveExecutor.java:179)
at org.apache.camel.impl.engine.DefaultReactiveExecutor.schedule(DefaultReactiveExecutor.java:59)
at org.apache.camel.impl.engine.CamelInternalProcessor$AsyncAfterTask.done(CamelInternalProcessor.java:274)
at org.apache.camel.impl.engine.CamelInternalProcessor.process(CamelInternalProcessor.java:377)
at org.apache.camel.processor.Pipeline$PipelineTask.run(Pipeline.java:109)
at org.apache.camel.impl.engine.DefaultReactiveExecutor$Worker.schedule(DefaultReactiveExecutor.java:179)
at org.apache.camel.impl.engine.DefaultReactiveExecutor.schedule(DefaultReactiveExecutor.java:59)
at org.apache.camel.impl.engine.CamelInternalProcessor$AsyncAfterTask.done(CamelInternalProcessor.java:274)
at org.apache.camel.impl.engine.CamelInternalProcessor.process(CamelInternalProcessor.java:377)
at org.apache.camel.processor.Pipeline$PipelineTask.run(Pipeline.java:109)
at org.apache.camel.impl.engine.DefaultReactiveExecutor$Worker.schedule(DefaultReactiveExecutor.java:179)
at org.apache.camel.impl.engine.DefaultReactiveExecutor.schedule(DefaultReactiveExecutor.java:59)
at org.apache.camel.impl.engine.CamelInternalProcessor$AsyncAfterTask.done(CamelInternalProcessor.java:274)
at org.apache.camel.impl.engine.CamelInternalProcessor.process(CamelInternalProcessor.java:377)
at org.apache.camel.processor.Pipeline$PipelineTask.run(Pipeline.java:109)
at org.apache.camel.impl.engine.DefaultReactiveExecutor$Worker.schedule(DefaultReactiveExecutor.java:179)
at org.apache.camel.impl.engine.DefaultReactiveExecutor.scheduleSync(DefaultReactiveExecutor.java:69)
at org.apache.camel.processor.Pipeline.process(Pipeline.java:182)
at org.apache.camel.processor.TryProcessor$TryState.run(TryProcessor.java:109)
at org.apache.camel.impl.engine.DefaultReactiveExecutor$Worker.schedule(DefaultReactiveExecutor.java:179)
at org.apache.camel.impl.engine.DefaultReactiveExecutor.schedule(DefaultReactiveExecutor.java:59)
at org.apache.camel.processor.TryProcessor.process(TryProcessor.java:78)
at org.apache.camel.management.DefaultInstrumentationProcessor.process(DefaultInstrumentationProcessor.java:90)
at org.apache.camel.processor.errorhandler.RedeliveryErrorHandler$RedeliveryTask.redeliver(RedeliveryErrorHandler.java:870)
at org.apache.camel.impl.engine.DefaultReactiveExecutor$Worker.schedule(DefaultReactiveExecutor.java:179)
at org.apache.camel.impl.engine.DefaultReactiveExecutor.schedule(DefaultReactiveExecutor.java:59)
at org.apache.camel.impl.engine.CamelInternalProcessor$AsyncAfterTask.done(CamelInternalProcessor.java:274)
at org.apache.camel.impl.engine.CamelInternalProcessor.process(CamelInternalProcessor.java:377)
at org.apache.camel.processor.Pipeline$PipelineTask.run(Pipeline.java:109)
at org.apache.camel.impl.engine.DefaultReactiveExecutor$Worker.schedule(DefaultReactiveExecutor.java:179)
at org.apache.camel.impl.engine.DefaultReactiveExecutor.scheduleSync(DefaultReactiveExecutor.java:69)
at org.apache.camel.processor.Pipeline.process(Pipeline.java:182)
at org.apache.camel.processor.CatchProcessor.process(CatchProcessor.java:119)
at org.apache.camel.processor.TryProcessor$TryState.run(TryProcessor.java:109)
at org.apache.camel.impl.engine.DefaultReactiveExecutor$Worker.schedule(DefaultReactiveExecutor.java:179)
at org.apache.camel.impl.engine.DefaultReactiveExecutor.schedule(DefaultReactiveExecutor.java:59)
at org.apache.camel.impl.engine.CamelInternalProcessor$AsyncAfterTask.done(CamelInternalProcessor.java:274)
at org.apache.camel.impl.engine.CamelInternalProcessor.process(CamelInternalProcessor.java:377)
at org.apache.camel.processor.Pipeline$PipelineTask.run(Pipeline.java:109)
at org.apache.camel.impl.engine.DefaultReactiveExecutor$Worker.schedule(DefaultReactiveExecutor.java:179)
at org.apache.camel.impl.engine.DefaultReactiveExecutor.schedule(DefaultReactiveExecutor.java:59)
at org.apache.camel.impl.engine.CamelInternalProcessor$AsyncAfterTask.done(CamelInternalProcessor.java:274)
at org.apache.camel.impl.engine.CamelInternalProcessor.process(CamelInternalProcessor.java:377)
at org.apache.camel.processor.Pipeline$PipelineTask.run(Pipeline.java:109)
at org.apache.camel.impl.engine.DefaultReactiveExecutor$Worker.schedule(DefaultReactiveExecutor.java:179)
at org.apache.camel.impl.engine.DefaultReactiveExecutor.schedule(DefaultReactiveExecutor.java:59)
at org.apache.camel.impl.engine.CamelInternalProcessor$AsyncAfterTask.done(CamelInternalProcessor.java:274)
at org.apache.camel.impl.engine.CamelInternalProcessor.process(CamelInternalProcessor.java:377)
at org.apache.camel.processor.Pipeline$PipelineTask.run(Pipeline.java:109)
at org.apache.camel.impl.engine.DefaultReactiveExecutor$Worker.schedule(DefaultReactiveExecutor.java:179)
at org.apache.camel.impl.engine.DefaultReactiveExecutor.schedule(DefaultReactiveExecutor.java:59)
at org.apache.camel.impl.engine.CamelInternalProcessor$AsyncAfterTask.done(CamelInternalProcessor.java:274)
at org.apache.camel.impl.engine.CamelInternalProcessor.process(CamelInternalProcessor.java:377)
at org.apache.camel.processor.Pipeline$PipelineTask.run(Pipeline.java:109)
at org.apache.camel.impl.engine.DefaultReactiveExecutor$Worker.schedule(DefaultReactiveExecutor.java:179)
at org.apache.camel.impl.engine.DefaultReactiveExecutor.scheduleSync(DefaultReactiveExecutor.java:69)
at org.apache.camel.processor.Pipeline.process(Pipeline.java:182)
at org.apache.camel.processor.TryProcessor$TryState.run(TryProcessor.java:109)
at org.apache.camel.impl.engine.DefaultReactiveExecutor$Worker.schedule(DefaultReactiveExecutor.java:179)
at org.apache.camel.impl.engine.DefaultReactiveExecutor.schedule(DefaultReactiveExecutor.java:59)
at org.apache.camel.processor.TryProcessor.process(TryProcessor.java:78)
at org.apache.camel.management.DefaultInstrumentationProcessor.process(DefaultInstrumentationProcessor.java:90)
at org.apache.camel.processor.errorhandler.RedeliveryErrorHandler$RedeliveryTask.redeliver(RedeliveryErrorHandler.java:870)
at org.apache.camel.impl.engine.DefaultReactiveExecutor$Worker.schedule(DefaultReactiveExecutor.java:179)
at org.apache.camel.impl.engine.DefaultReactiveExecutor.schedule(DefaultReactiveExecutor.java:59)
at org.apache.camel.impl.engine.CamelInternalProcessor$AsyncAfterTask.done(CamelInternalProcessor.java:274)
at org.apache.camel.impl.engine.CamelInternalProcessor.process(CamelInternalProcessor.java:377)
at org.apache.camel.processor.Pipeline$PipelineTask.run(Pipeline.java:109)
at org.apache.camel.impl.engine.DefaultReactiveExecutor$Worker.schedule(DefaultReactiveExecutor.java:179)
at org.apache.camel.impl.engine.DefaultReactiveExecutor.scheduleSync(DefaultReactiveExecutor.java:69)
at org.apache.camel.processor.Pipeline.process(Pipeline.java:182)
at org.apache.camel.processor.CatchProcessor.process(CatchProcessor.java:119)
at org.apache.camel.processor.TryProcessor$TryState.run(TryProcessor.java:109)
at org.apache.camel.impl.engine.DefaultReactiveExecutor$Worker.schedule(DefaultReactiveExecutor.java:179)
at org.apache.camel.impl.engine.DefaultReactiveExecutor.schedule(DefaultReactiveExecutor.java:59)
at org.apache.camel.impl.engine.CamelInternalProcessor$AsyncAfterTask.done(CamelInternalProcessor.java:274)
at org.apache.camel.impl.engine.CamelInternalProcessor.process(CamelInternalProcessor.java:377)
at org.apache.camel.processor.Pipeline$PipelineTask.run(Pipeline.java:109)
at org.apache.camel.impl.engine.DefaultReactiveExecutor$Worker.schedule(DefaultReactiveExecutor.java:179)
at org.apache.camel.impl.engine.DefaultReactiveExecutor.schedule(DefaultReactiveExecutor.java:59)
at org.apache.camel.impl.engine.CamelInternalProcessor$AsyncAfterTask.done(CamelInternalProcessor.java:274)
at org.apache.camel.impl.engine.CamelInternalProcessor.process(CamelInternalProcessor.java:377)
at org.apache.camel.processor.Pipeline$PipelineTask.run(Pipeline.java:109)
at org.apache.camel.impl.engine.DefaultReactiveExecutor$Worker.schedule(DefaultReactiveExecutor.java:179)
at org.apache.camel.impl.engine.DefaultReactiveExecutor.schedule(DefaultReactiveExecutor.java:59)
at org.apache.camel.impl.engine.CamelInternalProcessor$AsyncAfterTask.done(CamelInternalProcessor.java:274)
at org.apache.camel.impl.engine.CamelInternalProcessor.process(CamelInternalProcessor.java:377)
at org.apache.camel.processor.Pipeline$PipelineTask.run(Pipeline.java:109)
at org.apache.camel.impl.engine.DefaultReactiveExecutor$Worker.schedule(DefaultReactiveExecutor.java:179)
at org.apache.camel.impl.engine.DefaultReactiveExecutor.schedule(DefaultReactiveExecutor.java:59)
at org.apache.camel.impl.engine.CamelInternalProcessor$AsyncAfterTask.done(CamelInternalProcessor.java:274)
at org.apache.camel.impl.engine.CamelInternalProcessor.process(CamelInternalProcessor.java:377)
at org.apache.camel.processor.Pipeline$PipelineTask.run(Pipeline.java:109)
at org.apache.camel.impl.engine.DefaultReactiveExecutor$Worker.schedule(DefaultReactiveExecutor.java:179)
at org.apache.camel.impl.engine.DefaultReactiveExecutor.scheduleSync(DefaultReactiveExecutor.java:69)
at org.apache.camel.processor.Pipeline.process(Pipeline.java:182)
at org.apache.camel.processor.TryProcessor$TryState.run(TryProcessor.java:109)
at org.apache.camel.impl.engine.DefaultReactiveExecutor$Worker.schedule(DefaultReactiveExecutor.java:179)
at org.apache.camel.impl.engine.DefaultReactiveExecutor.schedule(DefaultReactiveExecutor.java:59)
at org.apache.camel.processor.TryProcessor.process(TryProcessor.java:78)
at org.apache.camel.management.DefaultInstrumentationProcessor.process(DefaultInstrumentationProcessor.java:90)
at org.apache.camel.processor.errorhandler.RedeliveryErrorHandler$RedeliveryTask.redeliver(RedeliveryErrorHandler.java:870)
at org.apache.camel.impl.engine.DefaultReactiveExecutor$Worker.schedule(DefaultReactiveExecutor.java:179)
at org.apache.camel.impl.engine.DefaultReactiveExecutor.schedule(DefaultReactiveExecutor.java:59)
at org.apache.camel.impl.engine.CamelInternalProcessor$AsyncAfterTask.done(CamelInternalProcessor.java:274)
at org.apache.camel.impl.engine.CamelInternalProcessor.process(CamelInternalProcessor.java:377)
at org.apache.camel.processor.Pipeline$PipelineTask.run(Pipeline.java:109)\n
at org.apache.camel.impl.engine.DefaultReactiveExecutor$Worker.schedule(DefaultReactiveExecutor.java:179)\n
at org.apache.camel.impl.engine.DefaultReactiveExecutor.scheduleSync(DefaultReactiveExecutor.java:69)
at org.apache.camel.processor.Pipeline.process(Pipeline.java:182)
at org.apache.camel.processor.CatchProcessor.process(CatchProcessor.java:119)
at org.apache.camel.processor.TryProcessor$TryState.run(TryProcessor.java:109)
at org.apache.camel.impl.engine.DefaultReactiveExecutor$Worker.schedule(DefaultReactiveExecutor.java:179)
at org.apache.camel.impl.engine.DefaultReactiveExecutor.schedule(DefaultReactiveExecutor.java:59)
at org.apache.camel.impl.engine.CamelInternalProcessor$AsyncAfterTask.done(CamelInternalProcessor.java:274)
at org.apache.camel.impl.engine.CamelInternalProcessor.process(CamelInternalProcessor.java:377)
at org.apache.camel.processor.Pipeline$PipelineTask.run(Pipeline.java:109)
at org.apache.camel.impl.engine.DefaultReactiveExecutor$Worker.schedule(DefaultReactiveExecutor.java:179)
at org.apache.camel.impl.engine.DefaultReactiveExecutor.schedule(DefaultReactiveExecutor.java:59)
at org.apache.camel.impl.engine.CamelInternalProcessor$AsyncAfterTask.done(CamelInternalProcessor.java:274)
at org.apache.camel.impl.engine.CamelInternalProcessor.process(CamelInternalProcessor.java:377)
at org.apache.camel.processor.Pipeline$PipelineTask.run(Pipeline.java:109)
at org.apache.camel.impl.engine.DefaultReactiveExecutor$Worker.schedule(DefaultReactiveExecutor.java:179)
at org.apache.camel.impl.engine.DefaultReactiveExecutor.schedule(DefaultReactiveExecutor.java:59)
at org.apache.camel.impl.engine.CamelInternalProcessor$AsyncAfterTask.done(CamelInternalProcessor.java:274)
at org.apache.camel.impl.engine.CamelInternalProcessor.process(CamelInternalProcessor.java:377)
at org.apache.camel.processor.Pipeline$PipelineTask.run(Pipeline.java:109)
at org.apache.camel.impl.engine.DefaultReactiveExecutor$Worker.schedule(DefaultReactiveExecutor.java:179)
at org.apache.camel.impl.engine.DefaultReactiveExecutor.schedule(DefaultReactiveExecutor.java:59)
at org.apache.camel.impl.engine.CamelInternalProcessor$AsyncAfterTask.done(CamelInternalProcessor.java:274)
at org.apache.camel.impl.engine.CamelInternalProcessor.process(CamelInternalProcessor.java:377)
at org.apache.camel.processor.Pipeline$PipelineTask.run(Pipeline.java:109)
at org.apache.camel.impl.engine.DefaultReactiveExecutor$Worker.schedule(DefaultReactiveExecutor.java:179)
at org.apache.camel.impl.engine.DefaultReactiveExecutor.scheduleSync(DefaultReactiveExecutor.java:69)
at org.apache.camel.processor.Pipeline.process(Pipeline.java:182)
at org.apache.camel.processor.TryProcessor$TryState.run(TryProcessor.java:109)
at org.apache.camel.impl.engine.DefaultReactiveExecutor$Worker.schedule(DefaultReactiveExecutor.java:179)
at org.apache.camel.impl.engine.DefaultReactiveExecutor.schedule(DefaultReactiveExecutor.java:59)
at org.apache.camel.processor.TryProcessor.process(TryProcessor.java:78)
at org.apache.camel.management.DefaultInstrumentationProcessor.process(DefaultInstrumentationProcessor.java:90)
at org.apache.camel.processor.errorhandler.RedeliveryErrorHandler$RedeliveryTask.redeliver(RedeliveryErrorHandler.java:870)
at org.apache.camel.impl.engine.DefaultReactiveExecutor$Worker.schedule(DefaultReactiveExecutor.java:179)
at org.apache.camel.impl.engine.DefaultReactiveExecutor.schedule(DefaultReactiveExecutor.java:59)
at org.apache.camel.impl.engine.CamelInternalProcessor$AsyncAfterTask.done(CamelInternalProcessor.java:274)
at org.apache.camel.impl.engine.CamelInternalProcessor.process(CamelInternalProcessor.java:377)
at org.apache.camel.processor.Pipeline$PipelineTask.run(Pipeline.java:109)
at org.apache.camel.impl.engine.DefaultReactiveExecutor$Worker.schedule(DefaultReactiveExecutor.java:179)
at org.apache.camel.impl.engine.DefaultReactiveExecutor.scheduleSync(DefaultReactiveExecutor.java:69)
at org.apache.camel.processor.Pipeline.process(Pipeline.java:182)
at org.apache.camel.processor.CatchProcessor.process(CatchProcessor.java:119)
at org.apache.camel.processor.TryProcessor$TryState.run(TryProcessor.java:109)
at org.apache.camel.impl.engine.DefaultReactiveExecutor$Worker.schedule(DefaultReactiveExecutor.java:179)
at org.apache.camel.impl.engine.DefaultReactiveExecutor.schedule(DefaultReactiveExecutor.java:59)
at org.apache.camel.impl.engine.CamelInternalProcessor$AsyncAfterTask.done(CamelInternalProcessor.java:274)
at org.apache.camel.impl.engine.CamelInternalProcessor.process(CamelInternalProcessor.java:377)
at org.apache.camel.processor.Pipeline$PipelineTask.run(Pipeline.java:109)
at org.apache.camel.impl.engine.DefaultReactiveExecutor$Worker.schedule(DefaultReactiveExecutor.java:179)
at org.apache.camel.impl.engine.DefaultReactiveExecutor.schedule(DefaultReactiveExecutor.java:59)
at org.apache.camel.impl.engine.CamelInternalProcessor$AsyncAfterTask.done(CamelInternalProcessor.java:274)
at org.apache.camel.impl.engine.CamelInternalProcessor.process(CamelInternalProcessor.java:377)
at org.apache.camel.processor.Pipeline$PipelineTask.run(Pipeline.java:109)
at org.apache.camel.impl.engine.DefaultReactiveExecutor$Worker.schedule(DefaultReactiveExecutor.java:179)
at org.apache.camel.impl.engine.DefaultReactiveExecutor.schedule(DefaultReactiveExecutor.java:59)
at org.apache.camel.impl.engine.CamelInternalProcessor$AsyncAfterTask.done(CamelInternalProcessor.java:274)
at org.apache.camel.impl.engine.CamelInternalProcessor.process(CamelInternalProcessor.java:377)
at org.apache.camel.processor.Pipeline$PipelineTask.run(Pipeline.java:109)
at org.apache.camel.impl.engine.DefaultReactiveExecutor$Worker.schedule(DefaultReactiveExecutor.java:179)
at org.apache.camel.impl.engine.DefaultReactiveExecutor.schedule(DefaultReactiveExecutor.java:59)
at org.apache.camel.impl.engine.CamelInternalProcessor$AsyncAfterTask.done(CamelInternalProcessor.java:274)
at org.apache.camel.impl.engine.CamelInternalProcessor.process(CamelInternalProcessor.java:377)
at org.apache.camel.processor.Pipeline$PipelineTask.run(Pipeline.java:109)
at org.apache.camel.impl.engine.DefaultReactiveExecutor$Worker.schedule(DefaultReactiveExecutor.java:179)
at org.apache.camel.impl.engine.DefaultReactiveExecutor.scheduleSync(DefaultReactiveExecutor.java:69)
at org.apache.camel.processor.Pipeline.process(Pipeline.java:182)
at org.apache.camel.processor.TryProcessor$TryState.run(TryProcessor.java:109)
at org.apache.camel.impl.engine.DefaultReactiveExecutor$Worker.schedule(DefaultReactiveExecutor.java:179)
at org.apache.camel.impl.engine.DefaultReactiveExecutor.schedule(DefaultReactiveExecutor.java:59)
at org.apache.camel.processor.TryProcessor.process(TryProcessor.java:78)
at org.apache.camel.management.DefaultInstrumentationProcessor.process(DefaultInstrumentationProcessor.java:90)
at org.apache.camel.processor.errorhandler.RedeliveryErrorHandler$RedeliveryTask.redeliver(RedeliveryErrorHandler.java:870)
at org.apache.camel.impl.engine.DefaultReactiveExecutor$Worker.schedule(DefaultReactiveExecutor.java:179)
at org.apache.camel.impl.engine.DefaultReactiveExecutor.schedule(DefaultReactiveExecutor.java:59)
at org.apache.camel.impl.engine.CamelInternalProcessor$AsyncAfterTask.done(CamelInternalProcessor.java:274)
at org.apache.camel.impl.engine.CamelInternalProcessor.process(CamelInternalProcessor.java:377)
at org.apache.camel.processor.Pipeline$PipelineTask.run(Pipeline.java:109)
at org.apache.camel.impl.engine.DefaultReactiveExecutor$Worker.schedule(DefaultReactiveExecutor.java:179)
at org.apache.camel.impl.engine.DefaultReactiveExecutor.scheduleSync(DefaultReactiveExecutor.java:69)
at org.apache.camel.processor.Pipeline.process(Pipeline.java:182)
at org.apache.camel.processor.CatchProcessor.process(CatchProcessor.java:119)
at org.apache.camel.processor.TryProcessor$TryState.run(TryProcessor.java:109)
at org.apache.camel.impl.engine.DefaultReactiveExecutor$Worker.schedule(DefaultReactiveExecutor.java:179)
at org.apache.camel.impl.engine.DefaultReactiveExecutor.schedule(DefaultReactiveExecutor.java:59)
at org.apache.camel.impl.engine.CamelInternalProcessor$AsyncAfterTask.done(CamelInternalProcessor.java:274)
at org.apache.camel.impl.engine.CamelInternalProcessor.process(CamelInternalProcessor.java:377)
at org.apache.camel.processor.Pipeline$PipelineTask.run(Pipeline.java:109)
at org.apache.camel.impl.engine.DefaultReactiveExecutor$Worker.schedule(DefaultReactiveExecutor.java:179)
at org.apache.camel.impl.engine.DefaultReactiveExecutor.schedule(DefaultReactiveExecutor.java:59)
at org.apache.camel.impl.engine.CamelInternalProcessor$AsyncAfterTask.done(CamelInternalProcessor.java:274)
at org.apache.camel.impl.engine.CamelInternalProcessor.process(CamelInternalProcessor.java:377)
at org.apache.camel.processor.Pipeline$PipelineTask.run(Pipeline.java:109)
at org.apache.camel.impl.engine.DefaultReactiveExecutor$Worker.schedule(DefaultReactiveExecutor.java:179)
at org.apache.camel.impl.engine.DefaultReactiveExecutor.schedule(DefaultReactiveExecutor.java:59)
at org.apache.camel.impl.engine.CamelInternalProcessor$AsyncAfterTask.done(CamelInternalProcessor.java:274)
at org.apache.camel.impl.engine.CamelInternalProcessor.process(CamelInternalProcessor.java:377)
at org.apache.camel.processor.Pipeline$PipelineTask.run(Pipeline.java:109)
at org.apache.camel.impl.engine.DefaultReactiveExecutor$Worker.schedule(DefaultReactiveExecutor.java:179)
at org.apache.camel.impl.engine.DefaultReactiveExecutor.schedule(DefaultReactiveExecutor.java:59)
at org.apache.camel.impl.engine.CamelInternalProcessor$AsyncAfterTask.done(CamelInternalProcessor.java:274)
at org.apache.camel.impl.engine.CamelInternalProcessor.process(CamelInternalProcessor.java:377)
at org.apache.camel.processor.Pipeline$PipelineTask.run(Pipeline.java:109)
at org.apache.camel.impl.engine.DefaultReactiveExecutor$Worker.schedule(DefaultReactiveExecutor.java:179)
at org.apache.camel.impl.engine.DefaultReactiveExecutor.scheduleSync(DefaultReactiveExecutor.java:69)
at org.apache.camel.processor.Pipeline.process(Pipeline.java:182)
at org.apache.camel.processor.TryProcessor$TryState.run(TryProcessor.java:109)
at org.apache.camel.impl.engine.DefaultReactiveExecutor$Worker.schedule(DefaultReactiveExecutor.java:179)
at org.apache.camel.impl.engine.DefaultReactiveExecutor.schedule(DefaultReactiveExecutor.java:59)
at org.apache.camel.processor.TryProcessor.process(TryProcessor.java:78)
at org.apache.camel.management.DefaultInstrumentationProcessor.process(DefaultInstrumentationProcessor.java:90)
at org.apache.camel.processor.errorhandler.RedeliveryErrorHandler$RedeliveryTask.redeliver(RedeliveryErrorHandler.java:870)
at org.apache.camel.impl.engine.DefaultReactiveExecutor$Worker.schedule(DefaultReactiveExecutor.java:179)
at org.apache.camel.impl.engine.DefaultReactiveExecutor.schedule(DefaultReactiveExecutor.java:59)
at org.apache.camel.impl.engine.CamelInternalProcessor$AsyncAfterTask.done(CamelInternalProcessor.java:274)
at org.apache.camel.impl.engine.CamelInternalProcessor.process(CamelInternalProcessor.java:377)
at org.apache.camel.processor.Pipeline$PipelineTask.run(Pipeline.java:109)
at org.apache.camel.impl.engine.DefaultReactiveExecutor$Worker.schedule(DefaultReactiveExecutor.java:179)
at org.apache.camel.impl.engine.DefaultReactiveExecutor.scheduleSync(DefaultReactiveExecutor.java:69)
at org.apache.camel.processor.Pipeline.process(Pipeline.java:182)
at org.apache.camel.processor.CatchProcessor.process(CatchProcessor.java:119)
at org.apache.camel.processor.TryProcessor$TryState.run(TryProcessor.java:109)
at org.apache.camel.impl.engine.DefaultReactiveExecutor$Worker.schedule(DefaultReactiveExecutor.java:179)
at org.apache.camel.impl.engine.DefaultReactiveExecutor.schedule(DefaultReactiveExecutor.java:59)
at org.apache.camel.impl.engine.CamelInternalProcessor$AsyncAfterTask.done(CamelInternalProcessor.java:274)
at org.apache.camel.impl.engine.CamelInternalProcessor.process(CamelInternalProcessor.java:377)
at org.apache.camel.processor.Pipeline$PipelineTask.run(Pipeline.java:109)
at org.apache.camel.impl.engine.DefaultReactiveExecutor$Worker.schedule(DefaultReactiveExecutor.java:179)
at org.apache.camel.impl.engine.DefaultReactiveExecutor.schedule(DefaultReactiveExecutor.java:59)
at org.apache.camel.impl.engine.CamelInternalProcessor$AsyncAfterTask.done(CamelInternalProcessor.java:274)
at org.apache.camel.impl.engine.CamelInternalProcessor.process(CamelInternalProcessor.java:377)
at org.apache.camel.processor.Pipeline$PipelineTask.run(Pipeline.java:109)
at org.apache.camel.impl.engine.DefaultReactiveExecutor$Worker.schedule(DefaultReactiveExecutor.java:179)
at org.apache.camel.impl.engine.DefaultReactiveExecutor.schedule(DefaultReactiveExecutor.java:59)
at org.apache.camel.impl.engine.CamelInternalProcessor$AsyncAfterTask.done(CamelInternalProcessor.java:274)
at org.apache.camel.impl.engine.CamelInternalProcessor.process(CamelInternalProcessor.java:377)
at org.apache.camel.processor.Pipeline$PipelineTask.run(Pipeline.java:109)
at org.apache.camel.impl.engine.DefaultReactiveExecutor$Worker.schedule(DefaultReactiveExecutor.java:179)
at org.apache.camel.impl.engine.DefaultReactiveExecutor.schedule(DefaultReactiveExecutor.java:59)
at org.apache.camel.impl.engine.CamelInternalProcessor$AsyncAfterTask.done(CamelInternalProcessor.java:274)
at org.apache.camel.impl.engine.CamelInternalProcessor.process(CamelInternalProcessor.java:377)
at org.apache.camel.processor.Pipeline$PipelineTask.run(Pipeline.java:109)
at org.apache.camel.impl.engine.DefaultReactiveExecutor$Worker.schedule(DefaultReactiveExecutor.java:179)
at org.apache.camel.impl.engine.DefaultReactiveExecutor.scheduleSync(DefaultReactiveExecutor.java:69)
at org.apache.camel.processor.Pipeline.process(Pipeline.java:182)
at org.apache.camel.processor.TryProcessor$TryState.run(TryProcessor.java:109)
at org.apache.camel.impl.engine.DefaultReactiveExecutor$Worker.schedule(DefaultReactiveExecutor.java:179)
at org.apache.camel.impl.engine.DefaultReactiveExecutor.schedule(DefaultReactiveExecutor.java:59)
at org.apache.camel.processor.TryProcessor.process(TryProcessor.java:78)
at org.apache.camel.management.DefaultInstrumentationProcessor.process(DefaultInstrumentationProcessor.java:90)
at org.apache.camel.processor.errorhandler.RedeliveryErrorHandler$RedeliveryTask.redeliver(RedeliveryErrorHandler.java:870)
at org.apache.camel.impl.engine.DefaultReactiveExecutor$Worker.schedule(DefaultReactiveExecutor.java:179)
at org.apache.camel.impl.engine.DefaultReactiveExecutor.schedule(DefaultReactiveExecutor.java:59)
at org.apache.camel.impl.engine.CamelInternalProcessor$AsyncAfterTask.done(CamelInternalProcessor.java:274)
at org.apache.camel.impl.engine.CamelInternalProcessor.process(CamelInternalProcessor.java:377)
at org.apache.camel.processor.Pipeline$PipelineTask.run(Pipeline.java:109)
at org.apache.camel.impl.engine.DefaultReactiveExecutor$Worker.schedule(DefaultReactiveExecutor.java:179)
at org.apache.camel.impl.engine.DefaultReactiveExecutor.scheduleSync(DefaultReactiveExecutor.java:69)
at org.apache.camel.processor.Pipeline.process(Pipeline.java:182)
at org.apache.camel.processor.CatchProcessor.process(CatchProcessor.java:119)
at org.apache.camel.processor.TryProcessor$TryState.run(TryProcessor.java:109)
at org.apache.camel.impl.engine.DefaultReactiveExecutor$Worker.schedule(DefaultReactiveExecutor.java:179)
at org.apache.camel.impl.engine.DefaultReactiveExecutor.schedule(DefaultReactiveExecutor.java:59)
at org.apache.camel.impl.engine.CamelInternalProcessor$AsyncAfterTask.done(CamelInternalProcessor.java:274)
at org.apache.camel.impl.engine.CamelInternalProcessor.process(CamelInternalProcessor.java:377)
at org.apache.camel.processor.Pipeline$PipelineTask.run(Pipeline.java:109)
at org.apache.camel.impl.engine.DefaultReactiveExecutor$Worker.schedule(DefaultReactiveExecutor.java:179)
at org.apache.camel.impl.engine.DefaultReactiveExecutor.schedule(DefaultReactiveExecutor.java:59)\n
at org.apache.camel.impl.engine.CamelInternalProcessor$AsyncAfterTask.done(CamelInternalProcessor.java:274)
at org.apache.camel.impl.engine.CamelInternalProcessor.process(CamelInternalProcessor.java:377)
at org.apache.camel.processor.Pipeline$PipelineTask.run(Pipeline.java:109)
at org.apache.camel.impl.engine.DefaultReactiveExecutor$Worker.schedule(DefaultReactiveExecutor.java:179)
at org.apache.camel.impl.engine.DefaultReactiveExecutor.schedule(DefaultReactiveExecutor.java:59)
at org.apache.camel.impl.engine.CamelInternalProcessor$AsyncAfterTask.done(CamelInternalProcessor.java:274)
at org.apache.camel.impl.engine.CamelInternalProcessor.process(CamelInternalProcessor.java:377)
at org.apache.camel.processor.Pipeline$PipelineTask.run(Pipeline.java:109)
at org.apache.camel.impl.engine.DefaultReactiveExecutor$Worker.schedule(DefaultReactiveExecutor.java:179)
at org.apache.camel.impl.engine.DefaultReactiveExecutor.schedule(DefaultReactiveExecutor.java:59)
at org.apache.camel.impl.engine.CamelInternalProcessor$AsyncAfterTask.done(CamelInternalProcessor.java:274)
at org.apache.camel.impl.engine.CamelInternalProcessor.process(CamelInternalProcessor.java:377)
at org.apache.camel.processor.Pipeline$PipelineTask.run(Pipeline.java:109)
at org.apache.camel.impl.engine.DefaultReactiveExecutor$Worker.schedule(DefaultReactiveExecutor.java:179)
at org.apache.camel.impl.engine.DefaultReactiveExecutor.scheduleSync(DefaultReactiveExecutor.java:69)
at org.apache.camel.processor.Pipeline.process(Pipeline.java:182)
at org.apache.camel.processor.TryProcessor$TryState.run(TryProcessor.java:109)
at org.apache.camel.impl.engine.DefaultReactiveExecutor$Worker.schedule(DefaultReactiveExecutor.java:179)
at org.apache.camel.impl.engine.DefaultReactiveExecutor.schedule(DefaultReactiveExecutor.java:59)
at org.apache.camel.processor.TryProcessor.process(TryProcessor.java:78)
at org.apache.camel.management.DefaultInstrumentationProcessor.process(DefaultInstrumentationProcessor.java:90)
at org.apache.camel.processor.errorhandler.RedeliveryErrorHandler$RedeliveryTask.redeliver(RedeliveryErrorHandler.java:870)
at org.apache.camel.impl.engine.DefaultReactiveExecutor$Worker.schedule(DefaultReactiveExecutor.java:179)
at org.apache.camel.impl.engine.DefaultReactiveExecutor.schedule(DefaultReactiveExecutor.java:59)
at org.apache.camel.impl.engine.CamelInternalProcessor$AsyncAfterTask.done(CamelInternalProcessor.java:274)
at org.apache.camel.impl.engine.CamelInternalProcessor.process(CamelInternalProcessor.java:377)
at org.apache.camel.processor.Pipeline$PipelineTask.run(Pipeline.java:109)
at org.apache.camel.impl.engine.DefaultReactiveExecutor$Worker.schedule(DefaultReactiveExecutor.java:179)
at org.apache.camel.impl.engine.DefaultReactiveExecutor.scheduleSync(DefaultReactiveExecutor.java:69)
at org.apache.camel.processor.Pipeline.process(Pipeline.java:182)
at org.apache.camel.processor.CatchProcessor.process(CatchProcessor.java:119)
at org.apache.camel.processor.TryProcessor$TryState.run(TryProcessor.java:109)
at org.apache.camel.impl.engine.DefaultReactiveExecutor$Worker.schedule(DefaultReactiveExecutor.java:179)
at org.apache.camel.impl.engine.DefaultReactiveExecutor.schedule(DefaultReactiveExecutor.java:59)
at org.apache.camel.impl.engine.CamelInternalProcessor$AsyncAfterTask.done(CamelInternalProcessor.java:274)
at org.apache.camel.impl.engine.CamelInternalProcessor.process(CamelInternalProcessor.java:377)
at org.apache.camel.processor.Pipeline$PipelineTask.run(Pipeline.java:109)
at org.apache.camel.impl.engine.DefaultReactiveExecutor$Worker.schedule(DefaultReactiveExecutor.java:179)
at org.apache.camel.impl.engine.DefaultReactiveExecutor.schedule(DefaultReactiveExecutor.java:59)
at org.apache.camel.impl.engine.CamelInternalProcessor$AsyncAfterTask.done(CamelInternalProcessor.java:274)
at org.apache.camel.impl.engine.CamelInternalProcessor.process(CamelInternalProcessor.java:377)
at org.apache.camel.processor.Pipeline$PipelineTask.run(Pipeline.java:109)
at org.apache.camel.impl.engine.DefaultReactiveExecutor$Worker.schedule(DefaultReactiveExecutor.java:179)
at org.apache.camel.impl.engine.DefaultReactiveExecutor.schedule(DefaultReactiveExecutor.java:59)
at org.apache.camel.impl.engine.CamelInternalProcessor$AsyncAfterTask.done(CamelInternalProcessor.java:274)
at org.apache.camel.impl.engine.CamelInternalProcessor.process(CamelInternalProcessor.java:377)
at org.apache.camel.processor.Pipeline$PipelineTask.run(Pipeline.java:109)
at org.apache.camel.impl.engine.DefaultReactiveExecutor$Worker.schedule(DefaultReactiveExecutor.java:179)
at org.apache.camel.impl.engine.DefaultReactiveExecutor.schedule(DefaultReactiveExecutor.java:59)
at org.apache.camel.impl.engine.CamelInternalProcessor$AsyncAfterTask.done(CamelInternalProcessor.java:274)
at org.apache.camel.impl.engine.CamelInternalProcessor.process(CamelInternalProcessor.java:377)
at org.apache.camel.processor.Pipeline$PipelineTask.run(Pipeline.java:109)","davsclaus:1631156165:2021-09-09T10:56:05.878+0000:1631156165:2021-09-09T10:56:05.878+0000:Can you add a sample project that reproduces this, or anyway provide more details what you do that is causing this. Otherwise we cannot really help 
wstrzalka:1631225932:2021-09-10T06:18:52.315+0000:1631225932:2021-09-10T06:18:52.315+0000:Will do ...
kmackowiak:1631625272:2021-09-14T21:14:32.232+0000:1631625272:2021-09-14T21:14:32.232+0000:Hi. I've just added a test that reproduces the problem. StackOverflowError is thrown during processing of a JMS message.
kmackowiak:1631625340:2021-09-14T21:15:40.646+0000:1631625340:2021-09-14T21:15:40.646+0000:This test is passing with Camel 2.25.3
davsclaus:1631925807:2021-09-18T08:43:27.356+0000:1631925807:2021-09-18T08:43:27.356+0000:Ah okay so you use transactions with retryWhile that potentially runs forever. That is not a good practice. If you use transactions, then you dont really should use Camel error handler to keep retrying, instead you let the TX rollback and let the broker do the redeliveries (it has settings for that).
kmackowiak:1632185640:2021-09-21T08:54:00.535+0000:1632185640:2021-09-21T08:54:00.535+0000:Hi. This test is a very simplified version of code that my team is using.
Generally we use it to redeliver messages when external HTTP service is not available (for example it returns 503). Then we want to check every few seconds if the service is still down. 
Important thing is that we don't want to exhaust broker redelivery attempts (our broker redelivery policy has maximum 50 redeliveries with exponential backoff). That is why we use retryWhile inside a JMS transaction.
davsclaus:1633137460:2021-10-02T09:17:40.147+0000:1633137460:2021-10-02T09:17:40.147+0000:If the recipient list is only sending to one destination, then use toD instead - that is optimized and you likely wont have this overflow
davsclaus:1633138721:2021-10-02T09:38:41.257+0000:1633138721:2021-10-02T09:38:41.257+0000:Okay have a potential fix, but need to do more investigation and testing as it changes the ordering of how transacted tasks are scheduled in the reactive executor.
cgiera:1657516193:2022-07-11T13:09:53.894+0000:1657516193:2022-07-11T13:09:53.894+0000:Can we have a downgrade to 3.11? We also have this problem and we can't upgrade now.
davsclaus:1658704810:2022-07-25T07:20:10.519+0000:1658704810:2022-07-25T07:20:10.519+0000:Camel 3.11 is EOL"
0,CAMEL-16937,Improvement,Minor,3.11.0,3.12.0,"
None
",Resolved,Fixed,3.12.0,Claus Ibsen,Florian Eckhard,0,1,2021-09-09 09:51:25+00:00,2021-09-09 14:43:35+00:00,"Currently, the SessionExpiryInterval parameter cannot be set for Paho. 
 The parameter can be used in mqtt 5 to keep the session alive when connecting, so that messages are queued.


Therefore, in this ticket, the parameter should be included as an option and set in PhaoMqqt5Endpoint (https://github.com/apache/camel/blob/80b92e3624ae5db59a1a24a441f1b10b39eaa1a5/components/camel-paho-mqtt5/src/main/java/org/apache/camel/component/paho/mqtt5/PahoMqtt5Endpoint.java#L85.


If possible please include this extension in the 3.11.x LTS release.",
0,CAMEL-16936,Bug,Major,3.11.0,"3.7.6, 3.11.3, 3.12.0","
None
",Resolved,Fixed,"3.7.6, 3.11.3, 3.12.0",Andrea Cosentino,Dylan Sale,0,1,2021-09-09 08:57:33+00:00,2021-09-30 10:34:29+00:00,"I can't upload files to S3 when the bucket has an object lock because it requires the CONTENT-MD5 header to be set on the message.


The AWS2S3Producer seems to have a bug where it only sets ""Content-Md5"" in the objectMetadata, but I think it needs to do something like:


putObjectRequest.contentMD5(exchange.getIn().getHeader(AWS2S3Constants.CONTENT_MD5, String.class))


when building the putRequest, similar to how the cannedACL is handled here: https://github.com/apache/camel/blob/main/components/camel-aws/camel-aws2-s3/src/main/java/org/apache/camel/component/aws2/s3/AWS2S3Producer.java#L296 rather than just putting it in the objectMetadata.


I have a workaround for now, I'm creating a bean that overrides the S3Client and configures it to always generate the MD5 hash.


My workaround: 




bean() {
        S3Client.builder()                            
            .credentialsProvider(StaticCredentialsProvider.create(AwsBasicCredentials.create(accessKey, secretKey)))
            .region(Region.of(region))
            .overrideConfiguration(ClientOverrideConfiguration.builder().putExecutionAttribute(
                SdkInternalExecutionAttribute.HTTP_CHECKSUM_REQUIRED, HttpChecksumRequired.create()
            ).build())
            .build()
}",
0,CAMEL-16935,Task,Major,3.11.1,"3.11.2, 3.12.0","
None
",Resolved,Fixed,"3.11.2, 3.12.0",Jean-Baptiste Onofré,Jean-Baptiste Onofré,0,3,2021-09-09 08:07:25+00:00,2021-09-09 09:18:23+00:00,"Due to the following commit:


https://github.com/apache/camel/commit/a010b1486bb0668708cc2b04ddf12c9cb6e835a3#diff-07a341b074a4f0b518090873308d53d3e2cbf08ba1cb94bc83be8516c412eea7


both camel-main and camel-base-engine exports org.apache.camel.main package (which is wrong).","davsclaus:1631147204:2021-09-09T08:26:44.067+0000:1631147204:2021-09-09T08:26:44.067+0000:Its already been fixed, as quarkus also reported this dual package ""problem"".
https://github.com/apache/camel/commit/6c3b40bac491b6a7704501d2ddeacbc854552113

davsclaus:1631147335:2021-09-09T08:28:55.770+0000:1631147335:2021-09-09T08:28:55.770+0000:And the backport
https://github.com/apache/camel/commit/6f6fcedc573747b51439dec85f6eb951dcbdca94
jbonofre:1631147395:2021-09-09T08:29:55.340+0000:1631147395:2021-09-09T08:29:55.340+0000:Thanks for the update, I'm verifying the OSGi headers to confirm it's OK now.
jbonofre:1631150303:2021-09-09T09:18:23.679+0000:1631150303:2021-09-09T09:18:23.679+0000:I confirm that it's fine now, thanks !"
0,CAMEL-16934,Bug,Minor,None,3.13.0,"
None
",Resolved,Fixed,3.13.0,Claus Ibsen,James Netherton,0,2,2021-09-09 07:41:04+00:00,2021-10-29 13:20:45+00:00,"Seems there's no test coverage for this feature, so it not working has gone unnoticed:


https://camel.apache.org/components/latest/others/openapi-java.html#_contextidlisting_enabled


If you add the relevant XML parser components to the classpath and try to specify the context to fetch the OpenApi spec for, then you get an exception.


Since Camel 3 moved to mandating a single CamelContext per 'deployment', I wonder how useful this feature is and whether it should be removed? It maybe has some use in containers where there could be multiple deployments, but otherwise I don't see a use for it.


I've not checked camel-swagger-java but I assume the same issue is present there too.




org.apache.camel.xml.io.XmlPullParserException: Unexpected attribute '{http://camel.apache.org/schema/spring}rest'
        at org.apache.camel.xml.in.BaseParser.handleUnexpectedAttribute(BaseParser.java:183) ~[camel-xml-io-3.12.0-20210909.030146-274.jar:3.12.0-SNAPSHOT]
        at org.apache.camel.xml.in.BaseParser.doParse(BaseParser.java:90) ~[camel-xml-io-3.12.0-20210909.030146-274.jar:3.12.0-SNAPSHOT]
        at org.apache.camel.xml.in.ModelParser.doParseRouteDefinition(ModelParser.java:997) ~[camel-xml-io-3.12.0-20210909.030146-274.jar:3.12.0-SNAPSHOT]
        at org.apache.camel.xml.in.ModelParser.lambda$verbDefinitionElementHandler$190(ModelParser.java:2751) ~[camel-xml-io-3.12.0-20210909.030146-274.jar:3.12.0-SNAPSHOT]
        at org.apache.camel.xml.in.BaseParser.doParse(BaseParser.java:106) ~[camel-xml-io-3.12.0-20210909.030146-274.jar:3.12.0-SNAPSHOT]
        at org.apache.camel.xml.in.ModelParser.doParseGetVerbDefinition(ModelParser.java:2813) ~[camel-xml-io-3.12.0-20210909.030146-274.jar:3.12.0-SNAPSHOT]
        at org.apache.camel.xml.in.ModelParser.lambda$doParseRestDefinition$72(ModelParser.java:1047) ~[camel-xml-io-3.12.0-20210909.030146-274.jar:3.12.0-SNAPSHOT]
        at org.apache.camel.xml.in.BaseParser.doParse(BaseParser.java:106) ~[camel-xml-io-3.12.0-20210909.030146-274.jar:3.12.0-SNAPSHOT]
        at org.apache.camel.xml.in.ModelParser.doParseRestDefinition(ModelParser.java:1029) ~[camel-xml-io-3.12.0-20210909.030146-274.jar:3.12.0-SNAPSHOT]
        at org.apache.camel.xml.in.ModelParser.lambda$doParseRestsDefinition$209(ModelParser.java:3022) ~[camel-xml-io-3.12.0-20210909.030146-274.jar:3.12.0-SNAPSHOT]
        at org.apache.camel.xml.in.BaseParser.doParse(BaseParser.java:106) ~[camel-xml-io-3.12.0-20210909.030146-274.jar:3.12.0-SNAPSHOT]
        at org.apache.camel.xml.in.ModelParser.doParseRestsDefinition(ModelParser.java:3019) ~[camel-xml-io-3.12.0-20210909.030146-274.jar:3.12.0-SNAPSHOT]
        at org.apache.camel.xml.in.ModelParser.parseRestsDefinition(ModelParser.java:3000) ~[camel-xml-io-3.12.0-20210909.030146-274.jar:3.12.0-SNAPSHOT]
        at org.apache.camel.dsl.xml.io.XmlRoutesDefinitionLoader.loadRestsDefinition(XmlRoutesDefinitionLoader.java:51) ~[camel-xml-io-dsl-3.12.0-20210909.052526-248.jar:3.12.0-SNAPSHOT]
        at org.apache.camel.openapi.jmx.JmxRestDefinitionsResolver.getRestDefinitions(JmxRestDefinitionsResolver.java:72) ~[classes/:?]","davsclaus:1631145041:2021-09-09T07:50:41.192+0000:1631145041:2021-09-09T07:50:41.192+0000:Yes its for classic app servers like jboss, tomcat, karaf where you can deploy war/bundles etc in the same JVM.
It requires to have JMX enabled to function.
davsclaus:1634774306:2021-10-21T07:58:26.990+0000:1634774306:2021-10-21T07:58:26.990+0000:Removed support for rendering API DOCs from other CamelContext discovered in the same JVM via JMX."
0,CAMEL-16933,Improvement,Minor,None,3.12.0,"
None
",Resolved,Fixed,3.12.0,James Netherton,James Netherton,0,1,2021-09-09 06:34:03+00:00,2021-09-09 07:55:39+00:00,"Thought it best to create a ticket to track this removal.


From what I can see, jackson-dataformat-xml is not needed in camel-openapi-java. It was probably an unwanted carry over from the swagger-java component.",
0,CAMEL-16932,Bug,Minor,3.11.0,3.12.0,"
None
",Resolved,Fixed,3.12.0,Claus Ibsen,Dmitrii Kriukov,0,3,2021-09-08 18:02:18+00:00,2021-09-27 14:22:28+00:00,"Code snippet - creation of endpoint:




private Endpoint configureAs2ClientEndpoint() throws Exception {

org.apache.http.entity.ContentType contentTypeEdifact =
 org.apache.http.entity.ContentType.create(""application/edifact"", (Charset) null);

String methodName = ""send"";
 AS2ApiName as2ApiNameClient = AS2ApiName.CLIENT;

AS2Configuration endpointConfiguration = new AS2Configuration();
 endpointConfiguration.setApiName(as2ApiNameClient);
 endpointConfiguration.setMethodName(methodName);
 endpointConfiguration.setRequestUri(""/as2/HttpReceiver"");
 endpointConfiguration.setAs2MessageStructure(AS2MessageStructure.PLAIN);

endpointConfiguration.setAs2Version(as2Version);
 endpointConfiguration.setAs2To(""mendelsontestAS2"");
 endpointConfiguration.setAs2From(""mycompanyAS2"");
 endpointConfiguration.setEdiMessageType(contentTypeEdifact);
 endpointConfiguration.setFrom(""dk2kEdi"");
 //endpointConfiguration.setTargetPortNumber(8080);
 //endpointConfiguration.setTargetHostname(""testas2.mendelson-e-c.com"");

AS2Component as2Component = new AS2Component();
 as2Component.setCamelContext(camelContext);
 as2Component.setConfiguration(endpointConfiguration);

Endpoint clientEndpoint = as2Component.createEndpoint(""as2://client/send?targetHostName=testas2.mendelson-e-c.com"" +
 ""&targetPortNumber=8080"" + // http
 ""&inBody=ediMessage"" +
 ""&requestUri=/as2/HttpReceiver"");

return clientEndpoint;
 }




When I invoke this endpoint in a route, I get an exception:




org.apache.camel.RuntimeCamelException: Missing properties for send, need one or more from [as2MessageStructure, subject, ediMessageTransferEncoding, encryptingCertificateChain, ediMessageContentType, encryptingAlgorithm, requestUri, signingPrivateKey, signedReceiptMicAlgorithms, as2To, as2From, signingAlgorithm, compressionAlgorithm, from, signingCertificateChain, dispositionNotificationTo]
 at org.apache.camel.support.component.AbstractApiProducer.findMethod(AbstractApiProducer.java:151)
 at org.apache.camel.support.component.AbstractApiProducer.process(AbstractApiProducer.java:71)
 at org.apache.camel.processor.SendProcessor.process(SendProcessor.java:172)
 at org.apache.camel.processor.errorhandler.RedeliveryErrorHandler$SimpleTask.run(RedeliveryErrorHandler.java:463)
 at org.apache.camel.impl.engine.DefaultReactiveExecutor$Worker.schedule(DefaultReactiveExecutor.java:179)
 at org.apache.camel.impl.engine.DefaultReactiveExecutor.scheduleMain(DefaultReactiveExecutor.java:64)
 at org.apache.camel.processor.Pipeline.process(Pipeline.java:184)
 at org.apache.camel.impl.engine.CamelInternalProcessor.process(CamelInternalProcessor.java:398)
 at org.apache.camel.component.jetty.CamelContinuationServlet.doService(CamelContinuationServlet.java:245)
 at org.apache.camel.http.common.CamelServlet.service(CamelServlet.java:130)
 at javax.servlet.http.HttpServlet.service(HttpServlet.java:733)
 at org.eclipse.jetty.servlet.ServletHolder.handle(ServletHolder.java:791)
 at org.eclipse.jetty.servlet.ServletHandler$ChainEnd.doFilter(ServletHandler.java:1626)
 at org.apache.camel.component.jetty.MultiPartFilter.doFilter(MultiPartFilter.java:50)
 at org.apache.camel.component.jetty.CamelFilterWrapper.doFilter(CamelFilterWrapper.java:45)
 at org.eclipse.jetty.servlet.FilterHolder.doFilter(FilterHolder.java:193)
 at org.eclipse.jetty.servlet.ServletHandler$Chain.doFilter(ServletHandler.java:1601)
 at org.eclipse.jetty.servlet.ServletHandler.doHandle(ServletHandler.java:548)
 at org.eclipse.jetty.server.handler.ScopedHandler.nextHandle(ScopedHandler.java:233)
 at org.eclipse.jetty.server.handler.ContextHandler.doHandle(ContextHandler.java:1435)
 at org.eclipse.jetty.server.handler.ScopedHandler.nextScope(ScopedHandler.java:188)
 at org.eclipse.jetty.servlet.ServletHandler.doScope(ServletHandler.java:501)
 at org.eclipse.jetty.server.handler.ScopedHandler.nextScope(ScopedHandler.java:186)
 at org.eclipse.jetty.server.handler.ContextHandler.doScope(ContextHandler.java:1350)
 at org.eclipse.jetty.server.handler.ScopedHandler.handle(ScopedHandler.java:141)
 at org.eclipse.jetty.server.handler.HandlerWrapper.handle(HandlerWrapper.java:127)
 at org.eclipse.jetty.server.Server.handle(Server.java:516)
 at org.eclipse.jetty.server.HttpChannel.lambda$handle$1(HttpChannel.java:388)
 at org.eclipse.jetty.server.HttpChannel.dispatch(HttpChannel.java:633)
 at org.eclipse.jetty.server.HttpChannel.handle(HttpChannel.java:380)
 at org.eclipse.jetty.server.HttpConnection.onFillable(HttpConnection.java:273)
 at org.eclipse.jetty.io.AbstractConnection$ReadCallback.succeeded(AbstractConnection.java:311)
 at org.eclipse.jetty.io.FillInterest.fillable(FillInterest.java:105)
 at org.eclipse.jetty.io.ChannelEndPoint$1.run(ChannelEndPoint.java:104)
 at org.eclipse.jetty.util.thread.QueuedThreadPool.runJob(QueuedThreadPool.java:773)
 at org.eclipse.jetty.util.thread.QueuedThreadPool$Runner.run(QueuedThreadPool.java:905)
 at java.base/java.lang.Thread.run(Thread.java:832)
 



Do I miss some configuration steps in the code snippet? I guess the entire endpointConfiguration is ignored and only a couple of settings from the uri aren't reported missing.","davsclaus:1631140102:2021-09-09T06:28:22.857+0000:1631140102:2021-09-09T06:28:22.857+0000:Can you maybe post a bit better how to reproduce this
dkryukov:1631148765:2021-09-09T08:52:45.852+0000:1631148765:2021-09-09T08:52:45.852+0000:Posting sample route in gist, hope it helps https://gist.github.com/dk2k/45bcab5574ca2145c25a6944b2b937c6
davsclaus:1631169916:2021-09-09T14:45:16.800+0000:1631169916:2021-09-09T14:45:16.800+0000:Ah you are creating the endpoint yourself from your own code. That is not a good idea

Use the endpoint-dsl or normal way of doing this.
davsclaus:1631170617:2021-09-09T14:56:57.683+0000:1631170768:2021-09-09T14:59:28.770+0000:You should also register the component you created yourself to camel 

context.addComponent(""as2"", as2component);

And do that before you create the endpoint as a component must be in the right phase/state before it can creates endpoints.

But as said its not a good idea to build this yourself. There is more happening behind the scene that Camel take care of with its endpoint-dsl, and whatnot.
dkryukov:1631171007:2021-09-09T15:03:27.016+0000:1631171007:2021-09-09T15:03:27.016+0000:I can successfully create endpoints for Kafka, JMS and even server endpoint for AS2 myself and don't understand why it's not a good idea. That's code for server AS2 endpoint (works fine) [https://github.com/dk2k/camel-as2-usage/blob/main/src/main/java/ru/outofrange/as2/route/AS2ServerRouteBuilder.java]
The benefit of this approach is type safety of the setters and that I can see a typo in the name of method in compile time, not runtime.
The only way to create a route with a properly configured client AS2 endpoint is to pass properties like exchange.getIn().setHeader(""CamelAS2.requestUri"", ""/as2/HttpReceiver""); - the entire class is here: [https://github.com/dk2k/camel-as2-usage/blob/main/src/main/java/ru/outofrange/as2/route/MendelsonAs2ClientRouteBuilder.java]
But there is a big room for a typo in the name of header and you will know about it only in runtime.
dkryukov:1631171365:2021-09-09T15:09:25.988+0000:1631171365:2021-09-09T15:09:25.988+0000:context.addComponent(""as2"", as2component); sounds like an option. Why it's not needed for Kafka and JMS endpoints configured the same way?

What if I need to use several AS2 routes whith different settings for AS2 client? I guess I can register only one ""as2"" component
dkryukov:1631172436:2021-09-09T15:27:16.330+0000:1631172436:2021-09-09T15:27:16.330+0000:How a chain of certificates can be configured via endpoint-dsl?
dkryukov:1631175547:2021-09-09T16:19:07.100+0000:1631175547:2021-09-09T16:19:07.100+0000:I don't think it's a good manner to close an issue with unanswered questions
acosentino:1631175850:2021-09-09T16:24:10.488+0000:1631175850:2021-09-09T16:24:10.488+0000:If you have question about this, or you think there is space to improvement, open another issue. The information has been provided. There is the zulip chat for discussing about how you can do something, but if something has been resolved and the answer has been given, you can, for sure, re-open the issue, but now you're talking about something different. The chain of certificates is a different question. Your question about endpoint-dsl too. Mixing everything in the comments will create only confusion. That's why I resolved the issue again.
acosentino:1631175901:2021-09-09T16:25:01.896+0000:1631175928:2021-09-09T16:25:28.709+0000:Now, it's re-open. It's not a good manner, being a bit too aggressive in questioning and arguing too, like you were doing in the above comments.
dkryukov:1631176844:2021-09-09T16:40:44.765+0000:1631176844:2021-09-09T16:40:44.765+0000:I have posted once a question on encryption in as2 in zulip and was encouraged to improve the code and post a pull request. !image-2021-09-09-19-40-17-973.png!
dkryukov:1631176939:2021-09-09T16:42:19.860+0000:1631176939:2021-09-09T16:42:19.860+0000:Andrea, I think you take fair questions too personal
acosentino:1631177122:2021-09-09T16:45:22.744+0000:1631177122:2021-09-09T16:45:22.744+0000:No, I really don't. By the way, you're welcome to dive into the component, because it really need some love, since the main contributor doesn't work on it from a while. 

I don't take question too personal, because I don't have anything personal with as2, I'm just trying to maintain the JIRA issues clear without a mixing of information, questions and so on. 
acosentino:1631177317:2021-09-09T16:48:37.605+0000:1631177317:2021-09-09T16:48:37.605+0000:What I'm taking too personal is when people talk about components and camel in general and each time I have the feeling that those people think ""I could do better than this"", ""This could be done better"" etc. but in the end, nobody contributes improvements, fixes or anything else, just complains. That's what I take too personally.
acosentino:1631177437:2021-09-09T16:50:37.743+0000:1631177437:2021-09-09T16:50:37.743+0000:This is not related to you. I was just thinking aloud
dkryukov:1631177918:2021-09-09T16:58:38.798+0000:1631177918:2021-09-09T16:58:38.798+0000:Andrea, my recent patches into Camel ;)
https://github.com/apache/camel/pull/5978
https://github.com/apache/camel/pull/5787
https://github.com/apache/camel/pull/5856
https://github.com/apache/camel/pull/5842
https://github.com/apache/camel/pull/5757
https://github.com/apache/camel/pull/5755
https://github.com/apache/camel/pull/5682
[https://github.com/apache/camel/pull/5650
]
If I could fix encryption, I would do it. At least I need more data. I can see many usages of As2 My point is that I don't understand why for the users it's fine to have messages encrypted only with the first certificate from the chain. So I need to be sure that I don't break anything.
But we got sidetracked :)
acosentino:1631178073:2021-09-09T17:01:13.892+0000:1631178073:2021-09-09T17:01:13.892+0000:As I said, I was thinking aloud, it wasn't related to you in any way. 
davsclaus:1631225622:2021-09-10T06:13:42.195+0000:1631225622:2021-09-10T06:13:42.195+0000:there is component-dsl for type-safety component configuration, and endpoint-dsl for endpoints.
dkryukov:1631504638:2021-09-13T11:43:58.947+0000:1631504638:2021-09-13T11:43:58.947+0000:My point is: the only working way to set definite list of parameters e.g. certificate chains and even as2To and as2From is via exchange:
|exchange.getIn().setHeader(""CamelAS2.as2To"", ""mendelsontestAS2"");|

|exchange.getIn().setHeader(""CamelAS2.as2From"", ""mycompanyAS2"");|

|exchange.getIn().setHeader(""CamelAS2.as2Version"", ""1.1"");|

|exchange.getIn().setHeader(""CamelAS2.ediMessageContentType"", contentType);|

|exchange.getIn().setHeader(""CamelAS2.server"", ""DKAS2Client"");|

|exchange.getIn().setHeader(""CamelAS2.subject"", ""testDK"");|

exchange.getIn().setHeader(""CamelAS2.from"", ""DKEdi"");

I'm not opposing the point that there are setters in configuration, but these settings are ignored.
davsclaus:1632448123:2021-09-24T09:48:43.999+0000:1632448123:2021-09-24T09:48:43.999+0000:Okay this was a problem in the api based component in camel-support. The configuration object was not taken into account, so only message headers and uri options could be used. Now you can use all 3 of them, and they mix together.
dkryukov:1632723748:2021-09-27T14:22:28.744+0000:1632723748:2021-09-27T14:22:28.744+0000:Claus. many thanks!"
0,CAMEL-16931,Improvement,Major,"3.11.2, 3.12.0",3.12.0,"
None
",Resolved,Fixed,3.12.0,Unassigned,Christoph Deppisch,0,1,2021-09-08 16:57:16+00:00,2021-09-09 06:29:22+00:00,"Log masking formatter should preserve the quotes used in the source data when masking keyValue pairs. Source key value data can use no quotes, single quotes and normal quotes.


Masked data should use the very same quotes as the source.",
0,CAMEL-16930,Improvement,Minor,3.11.1,3.12.0,"
None
",Resolved,Fixed,3.12.0,Andrea Cosentino,Simon Rasmussen,1,2,2021-09-08 14:59:42+00:00,2021-09-09 05:23:34+00:00,"Currently, aws2-sns component does not translate exchange headers of type Number into a MessageAttributeValue.


I stumbled upon this when getting a WARN message when attempting to send header of type `int`.


Please see attached patch",acosentino:1631136214:2021-09-09T05:23:34.909+0000:1631136214:2021-09-09T05:23:34.909+0000:Thanks
0,CAMEL-16899,Improvement,Minor,3.11.0,3.12.0,"
None
",Resolved,Fixed,3.12.0,Jesse Gorzinski,King Harrison,0,3,2021-08-30 13:18:16+00:00,2021-09-02 04:47:45+00:00,When calling an RPG program there is no way to handle or description of how to handle values returned by the RPG program,"davsclaus:1630305456:2021-08-30T14:37:36.057+0000:1630305456:2021-08-30T14:37:36.057+0000:Can you provide more details what you ask for, and maybe with an example to help put this into perspective
kingharrison:1630308899:2021-08-30T15:34:59.175+0000:1630308899:2021-08-30T15:34:59.175+0000:Sure [~davsclaus]

My end goal is that I am using Apache Camel in our system to send a Purchase Order to a number of systems that have different protocols they use to accept POs. If the PO call was successful, I want to use the values to call RPG programs on our side to 'finalize' that everything is accepted. I would look to call two RPG programs in a row, and the result from one RPG program would influence which second RPG program is called. 

 

I am 'very' new to Java and Apache Camel, so I can't really show exactly how the Java 'should' look, but here is a hacky example in PHP pseudo language. 

 
$result = jt400://user:password@system/QSYS.LIB/LIBRARY.LIB/program.PGM[?options];
 
$secondresult = jt400://user:password@system/QSYS.LIB/LIBRARY.LIB/program.PGM[?parm1['$result']['value']];
  
 
ThePrez:1630411984:2021-08-31T20:13:04.649+0000:1630411984:2021-08-31T20:13:04.649+0000:I think this will be addressed with the doc improvements included in https://github.com/apache/camel/pull/6019"
0,CAMEL-16898,Improvement,Major,None,3.12.0,"
None
",Resolved,Fixed,3.12.0,Claus Ibsen,Claus Ibsen,0,1,2021-08-30 11:49:18+00:00,2021-08-30 11:54:35+00:00,"Reported on zulip chat
https://camel.zulipchat.com/#narrow/stream/257298-camel/topic/AdviceWith.20weaveByToUri.20and.20pattern.20match/near/250277860",
0,CAMEL-16897,Improvement,Major,None,None,"
None
",Resolved,Fixed,3.12.0,Claus Ibsen,Claus Ibsen,0,1,2021-08-30 08:22:14+00:00,2021-08-30 09:33:08+00:00,And spreadsheetsId is required option so lets use that in the apiName that was not in use.,
0,CAMEL-16896,Bug,Major,"3.7.5, 3.11.0",,"

pull-request-available

",Resolved,Not A Bug,None,Karen Lease,Karen Lease,0,2,2021-08-26 20:57:59+00:00,2021-08-29 14:28:10+00:00,"onders reported an issue when setting a header in a Processor with a constant value, like this:




from(""direct:uploadFiles"")
        .process(new Processor() {
            @Override
            public void process(Exchange exchange) throws Exception {exchange.getIn().setHeader(Exchange.HTTP_RESPONSE_CODE,
constant(500));
            }
        });




This was invoked from a rest() route and was expected to return HTTP 500 but did not.
The reason is that the DefaultHttpBinding calls getHeader(Exchange.HTTP_RESPONSE_CODE, Integer.class) but the value in the Exchange header is a ValueBuilder and not an Integer.","klease78:1629983448:2021-08-26T21:10:48.080+0000:1629983448:2021-08-26T21:10:48.080+0000:I proposed a change to DefaultMessage to handle this case, if that makes sense to the camel team.
davsclaus:1630217972:2021-08-29T14:19:32.012+0000:1630217972:2021-08-29T14:19:32.012+0000:This is by design.
davsclaus:1630218467:2021-08-29T14:27:47.532+0000:1630218467:2021-08-29T14:27:47.532+0000:Posted a longer reply on the user mailing list."
0,CAMEL-16895,Bug,Minor,3.11.0,3.12.0,"
None
",Resolved,Fixed,3.12.0,Claus Ibsen,Julius Krah,0,3,2021-08-26 16:49:13+00:00,2021-09-13 09:11:14+00:00,"When a fairly large input string is submitted for logging and masking is enabled, this results in a StackoverflowError


 


Using camel with Spring Boot


pom.xml



 <dependencyManagement>
         <dependencies>
             <dependency>
                 <groupId>org.apache.camel.springboot</groupId>
                 <artifactId>camel-spring-boot-bom</artifactId>
                 <version>3.11.1</version>
                 <type>pom</type>
                 <scope>import</scope>
             </dependency>
         </dependencies>
 </dependencyManagement>

  <!-- ... -->
 <dependency>
             <groupId>org.springframework.boot</groupId>
             <artifactId>spring-boot-starter-validation</artifactId>
 </dependency>
 <dependency>
             <groupId>org.apache.camel.springboot</groupId>
             <artifactId>camel-spring-boot-starter</artifactId>
  </dependency>




Route.java



 @Component
 public class Route extends RouteBuilder {  

     @Override
     public void configure() throws Exception {
         from(""rabbitmq:{{core.consumer.rabbitmq.exchange}}"" +
             ""?exchangeType={{core.consumer.rabbitmq.exchange-type}}"" +
             ""&queue={{core.consumer.rabbitmq.queue}}"" +
             ""&routingKey={{core.consumer.rabbitmq.routing-key}}"")
             .routeId(""queue route"")
             .log(""Received payload from rabbitMQ: ${body}"")
             .unmarshal(new JacksonDataFormat(Dto.class))
             .process(aProcessor)
             .log(""Data received ${body}"")
             .to(""bean:requestProcessor?method=handleAckRequest"").id(""handle-ack-request"")
  
             .to(""direct:anotherRoute"")
         .end();
     }
 }




In the application.properties
camel.springboot.log-mask=true
  
 Now if I should post the following JSON payload through RabbitMQ
  



 {
     ""qwjabrlanfssaPaymentID"": 93974430,
     ""apiPortNumber"": 0,
     ""pollerFrequency"": 0,
     ""serviceCode"": ""QWERETEMKLJLANDD"",
     ""extraData"": {
         ""97280991"": {
             ""pushToOriginator"": true,
             ""uidID"": 41189716,
             ""metaData"": [
             {                     
                      ""Value"": 1070,   
                      ""Name"": ""Amount""                
              },
              {                    
                       ""Value"": ""PHP82TK6MY"",                     
                       ""Name"": ""MpesaQwasdrtjknsNumber""                
              },
              {                    
                      ""Name"": ""Balance""                 
              },
              {                
                     ""Value"": 20210825224512, 
                     ""Name"": ""TransactionDate"" 
              },
              {                     
                     ""Value"": 599726145860,
                    ""Name"": ""PhoneNumber""
              }],
             ""pokjytsAmountCharged"": 1070,
             ""hardwareRequestId"": null,
             ""ProductCode"": ""UJHANSNLWII"",
             ""isTillNumber"": true,
             ""uniqueID"": ""83859103"",
             ""vouchercode"": "" "",
             ""paybillNumber"": ""431553""
         }
     },
     ""oiusdftrPaymentStatus"": 139,
     ""serviceUrl"": """",
     ""lkjmnbsdcvfdertCurrencyCode"": ""YUM"",
     ""wrapperUrl"": """",
     ""wsdlFile"": """",
     ""protocol"": ""default"",
     ""sslEnabled"": 0,
     ""numberOfSends"": 0,
     ""invoiceNumber"": """",
     ""erdfghytIsdgftgDate"": ""2021-08-25 22:45:20"",
     ""lkjditgfJhsgruaCustomerName"": ""Customer"",
     ""apiUserName"": """",
     ""ojudhfgKaswsxsUUID"": ""1102967588"",
     ""iuytredfHsdededAccountNumber"": ""4622785548"",
     ""tyghfderrMode"": [
         ""TUND_PUDF""
     ],
     ""zxcvfgtrNsdfdfdMSISDN"": ""254726173860"",
     ""apiFunctionName"": """",
     ""kjhxcTransactionID"": [
         ""PHP82TK6MY""
     ],
     ""apiPassword"": ""xxxxx"",
     ""kjhcvbnUUID"": ""1102967588"",
     ""dfcxvbnClientCode"": [
         ""SAFKE""
     ],
     ""sslCertificatePath"": """",
     ""isTokenService"": 0,
     ""wsazxcvgbgthyujAmount"": 1070,
     ""plsjdhfhPusherProcessorClass"": """",
     ""requestOriginIDs"": [
         ""21""
     ],
     ""firstSend"": """",
     ""maxNumberOfSends"": 0,
     ""narration"": ""The service request is processed successfully."",
     ""hubCreationDate"": ""2021-08-25 22:45:20"",
     ""allowsPolling"": 1,
     ""serviceID"": 3004,
     ""lastSend"": ""2021-08-25 19:45:20"",
     ""nextSend"": ""2021-08-25 22:45:20"",
     ""autoAcknowledgejfhtysidj"": 0
 }","davsclaus:1630218503:2021-08-29T14:28:23.142+0000:1630218503:2021-08-29T14:28:23.142+0000:Can you post more details with an example or something.
juliuskrah:1630226644:2021-08-29T16:44:04.736+0000:1630226644:2021-08-29T16:44:04.736+0000:I have updated the issue with more details
davsclaus:1630287371:2021-08-30T09:36:11.438+0000:1630287371:2021-08-30T09:36:11.438+0000:Can you post the exception
juliuskrah:1630298730:2021-08-30T12:45:30.731+0000:1630299070:2021-08-30T12:51:10.691+0000:{noformat}


org.apache.camel.CamelExecutionException: Exception occurred during execution on the exchange: Exchange[F7A4D4B989F71AF-0000000000000000]
	at org.apache.camel.CamelExecutionException.wrapCamelExecutionException(CamelExecutionException.java:45)
	at org.apache.camel.support.AbstractExchange.setException(AbstractExchange.java:589)
	at org.apache.camel.support.DefaultExchange.setException(DefaultExchange.java:27)
	at org.apache.camel.processor.LogProcessor.process(LogProcessor.java:83)
	at org.apache.camel.processor.errorhandler.RedeliveryErrorHandler$RedeliveryTask.doRun(RedeliveryErrorHandler.java:804)
	at org.apache.camel.processor.errorhandler.RedeliveryErrorHandler$RedeliveryTask.run(RedeliveryErrorHandler.java:712)
	at org.apache.camel.impl.engine.DefaultReactiveExecutor$Worker.schedule(DefaultReactiveExecutor.java:179)
	at org.apache.camel.impl.engine.DefaultReactiveExecutor.scheduleMain(DefaultReactiveExecutor.java:64)
	at org.apache.camel.processor.Pipeline.process(Pipeline.java:184)
	at org.apache.camel.impl.engine.CamelInternalProcessor.process(CamelInternalProcessor.java:398)
	at org.apache.camel.impl.engine.DefaultAsyncProcessorAwaitManager.process(DefaultAsyncProcessorAwaitManager.java:83)
	at org.apache.camel.support.AsyncProcessorSupport.process(AsyncProcessorSupport.java:41)
	at org.apache.camel.component.rabbitmq.RabbitConsumer.doHandleDelivery(RabbitConsumer.java:109)
	at org.apache.camel.component.rabbitmq.RabbitConsumer.handleDelivery(RabbitConsumer.java:84)
	at com.rabbitmq.client.impl.ConsumerDispatcher$5.run(ConsumerDispatcher.java:149)
	at com.rabbitmq.client.impl.ConsumerWorkService$WorkPoolRunnable.run(ConsumerWorkService.java:104)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)
	at java.base/java.lang.Thread.run(Thread.java:829)
Caused by: java.lang.StackOverflowError: null
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:4994)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BmpCharProperty.match(Pattern.java:3964)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BmpCharProperty.match(Pattern.java:3964)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BmpCharProperty.match(Pattern.java:3964)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BmpCharProperty.match(Pattern.java:3964)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BmpCharProperty.match(Pattern.java:3964)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BmpCharProperty.match(Pattern.java:3964)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BmpCharProperty.match(Pattern.java:3964)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BmpCharProperty.match(Pattern.java:3964)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BmpCharProperty.match(Pattern.java:3964)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BmpCharProperty.match(Pattern.java:3964)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BmpCharProperty.match(Pattern.java:3964)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BmpCharProperty.match(Pattern.java:3964)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BmpCharProperty.match(Pattern.java:3964)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BmpCharProperty.match(Pattern.java:3964)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)

2021-08-30 12:40:44.574          WARN 22839 --- [choice-consumer] o.a.c.c.rabbitmq.RabbitMQConsumer                : transactionId: mobileNumber:          traceId: spanId: traceFlags: ::: Error processing exchange. Exchange[F7A4D4B989F71AF-0000000000000000]. Caused by: [org.apache.camel.CamelExecutionException - Exception occurred during execution on the exchange: Exchange[F7A4D4B989F71AF-0000000000000000]]

org.apache.camel.CamelExecutionException: Exception occurred during execution on the exchange: Exchange[F7A4D4B989F71AF-0000000000000000]
	at org.apache.camel.CamelExecutionException.wrapCamelExecutionException(CamelExecutionException.java:45)
	at org.apache.camel.support.AbstractExchange.setException(AbstractExchange.java:589)
	at org.apache.camel.support.DefaultExchange.setException(DefaultExchange.java:27)
	at org.apache.camel.processor.LogProcessor.process(LogProcessor.java:83)
	at org.apache.camel.processor.errorhandler.RedeliveryErrorHandler$RedeliveryTask.doRun(RedeliveryErrorHandler.java:804)
	at org.apache.camel.processor.errorhandler.RedeliveryErrorHandler$RedeliveryTask.run(RedeliveryErrorHandler.java:712)
	at org.apache.camel.impl.engine.DefaultReactiveExecutor$Worker.schedule(DefaultReactiveExecutor.java:179)
	at org.apache.camel.impl.engine.DefaultReactiveExecutor.scheduleMain(DefaultReactiveExecutor.java:64)
	at org.apache.camel.processor.Pipeline.process(Pipeline.java:184)
	at org.apache.camel.impl.engine.CamelInternalProcessor.process(CamelInternalProcessor.java:398)
	at org.apache.camel.impl.engine.DefaultAsyncProcessorAwaitManager.process(DefaultAsyncProcessorAwaitManager.java:83)
	at org.apache.camel.support.AsyncProcessorSupport.process(AsyncProcessorSupport.java:41)
	at org.apache.camel.component.rabbitmq.RabbitConsumer.doHandleDelivery(RabbitConsumer.java:109)
	at org.apache.camel.component.rabbitmq.RabbitConsumer.handleDelivery(RabbitConsumer.java:84)
	at com.rabbitmq.client.impl.ConsumerDispatcher$5.run(ConsumerDispatcher.java:149)
	at com.rabbitmq.client.impl.ConsumerWorkService$WorkPoolRunnable.run(ConsumerWorkService.java:104)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)
	at java.base/java.lang.Thread.run(Thread.java:829)
Caused by: java.lang.StackOverflowError: null
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:4994)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BmpCharProperty.match(Pattern.java:3964)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BmpCharProperty.match(Pattern.java:3964)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BmpCharProperty.match(Pattern.java:3964)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BmpCharProperty.match(Pattern.java:3964)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BmpCharProperty.match(Pattern.java:3964)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BmpCharProperty.match(Pattern.java:3964)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BmpCharProperty.match(Pattern.java:3964)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BmpCharProperty.match(Pattern.java:3964)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BmpCharProperty.match(Pattern.java:3964)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BmpCharProperty.match(Pattern.java:3964)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BmpCharProperty.match(Pattern.java:3964)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BmpCharProperty.match(Pattern.java:3964)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BmpCharProperty.match(Pattern.java:3964)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BmpCharProperty.match(Pattern.java:3964)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)
	at java.base/java.util.regex.Pattern$LazyLoop.match(Pattern.java:5009)
	at java.base/java.util.regex.Pattern$GroupTail.match(Pattern.java:4863)
	at java.base/java.util.regex.Pattern$BranchConn.match(Pattern.java:4713)
	at java.base/java.util.regex.Pattern$CharProperty.match(Pattern.java:3940)
	at java.base/java.util.regex.Pattern$Branch.match(Pattern.java:4749)
	at java.base/java.util.regex.Pattern$GroupHead.match(Pattern.java:4804)


{noformat}

davsclaus:1630451504:2021-09-01T07:11:44.802+0000:1630451504:2021-09-01T07:11:44.802+0000:Is that the original json that fails for you? Or did you change something as I can parse/mask it on my system.
davsclaus:1630452029:2021-09-01T07:20:29.957+0000:1630452029:2021-09-01T07:20:29.957+0000:We can optimize the log-mask to not do all 3 kind of masking if we know the structure is json or xml, that reduces the regexp parsing overhead *DONE*
juliuskrah:1630452092:2021-09-01T07:21:32.705+0000:1630452092:2021-09-01T07:21:32.705+0000:I obfuscated it a little to remove sensitive information, but it's generally the same structure. It fails on my system and in our k8s environment, below is the memory configuration

{noformat}
resources:
  limits:
    cpu: 500m
    memory: 800Mi
  requests:
    cpu: 150m
    memory: 250Mi
{noformat}

juliuskrah:1630452342:2021-09-01T07:25:42.008+0000:1630452342:2021-09-01T07:25:42.008+0000:Great, I actually don't need the JSON to be parsed and masked, this is already done by the upstream system. It is being masked as a side effect of a global masking setting
davsclaus:1630452953:2021-09-01T07:35:53.135+0000:1630452953:2021-09-01T07:35:53.135+0000:Ah so you are low on memory, yeah I just ran a test with GBs of heap
davsclaus:1630561344:2021-09-02T13:42:24.257+0000:1630561344:2021-09-02T13:42:24.257+0000:Using a simpler regexp now, and also optimized to detect if payload is json based and only parse for that
rambichler:1631495474:2021-09-13T09:11:14.365+0000:1631495474:2021-09-13T09:11:14.365+0000:Hi [~davsclaus] / Hi community. Is there any chance to backport this patch into a 3.11.x *LTS* Release? We use .log(""${body}"") within several routes but did not plan to use non LTS versions in our project."
0,CAMEL-16894,Improvement,Major,3.11.0,,"
None
",Resolved,Won't Do,None,Unassigned,winger,0,2,2021-08-26 12:07:33+00:00,2021-08-29 14:18:56+00:00,"As example, it will be possible to use a Kamelet to create a[ Debezium Source Connectors |https://camel.apache.org/components/latest/debezium-summary.html]


 Definition


Definite DBZ MySQL Connector named debezium-mysql-source.kamelet.yaml 





apiVersion: camel.apache.org/v1alpha1
kind: Kamelet
metadata:
  name: debezium-mysql-source
  annotations:
    camel.apache.org/kamelet.support.level: ""Preview""
    // other ...
  labels:
    camel.apache.org/kamelet.type: ""source""
spec:
  definition:
    title: ""Debezium MySQL""
    required:
      - databaseServerId
      - databaseServerName
// others...
    properties:
      databaseServerId:
        //...
      databaseServerName:
       //...
      // others ...
  dependencies:
   // ...
  flow:
    from:
      uri: debezium-mysql:{{databaseServerName}}
      parameters:
        databaseServerName: ""{{databaseServerName}}""
        databaseServerId: ""{{databaseServerId}}""
// others...
      steps:
        - to: ""kamelet:sink""




As example:




from(""debezium-mysql:dbz-test-1?databaseServerName=dbz-test-1&databaseServerId=5401&..."")
.log(""Event received from Debezium : ${body}"")




Using the Kamelet example above, the message property can then be given:
1. by setting a URI Param named databaseServerName and databaseServerId
OR 
2. by setting the property camel.kamelet.debezium-mysql-source.source.databaseServerName and camel.kamelet.debezium-mysql-source.source.databaseServerId


It will be very useful when build this with camel-kamelets projects.
For example create a YAML file like the following one:




apiVersion: camel.apache.org/v1alpha1
kind: KameletBinding
metadata:
  name: debezium-mysql-source-binding
spec:
  source:
    ref: 
      kind: Kamelet
      apiVersion: camel.apache.org/v1alpha1
      name: debezium-mysql-source
    properties:
      databaseServerId: 5401
      databaseServerName: ""dbz-test-1"" 
      // difference !! we can't defined includeQuery and includeSchemaChanges  in  source YAML above(debezium-mysql-source.kamelet.yaml)
      includeQuery: ""true""
      includeSchemaChanges:""false""
      ....




The includeQuery and includeSchemaChanges  may be affected as same as uri params like databaseServerName in runtime env",davsclaus:1630217936:2021-08-29T14:18:56.248+0000:1630217936:2021-08-29T14:18:56.248+0000:See the comments on the PR
0,CAMEL-16893,Bug,Major,None,"3.11.2, 3.12.0","
None
",Resolved,Fixed,"3.11.2, 3.12.0",James Netherton,James Netherton,0,1,2021-08-26 10:56:28+00:00,2021-09-01 09:30:22+00:00,"GrpcProducer.doStop() invokes shutdown() on the forwarder:


https://github.com/apache/camel/blob/main/components/camel-grpc/src/main/java/org/apache/camel/component/grpc/GrpcProducer.java#L141


If the GrpcStreamingExchangeForwarder has not receieved any any exchanges, then the streamObserver field will be null, and any refrence to it triggered in doCreateStream will result in a NullPointerException:


https://github.com/apache/camel/blob/main/components/camel-grpc/src/main/java/org/apache/camel/component/grpc/client/GrpcStreamingExchangeForwarder.java#L92-L113


If the streamObserver is null, then I don't see any need to run the logic in shutdown().",
0,CAMEL-16892,Bug,Major,None,"3.11.3, 3.12.0","
None
",Resolved,Fixed,"3.11.3, 3.12.0",Andrea Cosentino,Andrea Cosentino,0,1,2021-08-26 05:46:36+00:00,2021-09-13 09:32:04+00:00,https://github.com/apache/camel/pull/3737#issuecomment-905515585,
0,CAMEL-16891,Improvement,Minor,None,3.12.0,"
None
",Resolved,Fixed,3.12.0,Claus Ibsen,Zheng Feng,0,1,2021-08-25 11:43:32+00:00,2021-08-26 05:21:50+00:00,It comes across from camel-quarkus issue #2965,
0,CAMEL-16890,Dependency upgrade,Major,None,None,"
None
",Resolved,Fixed,3.12.0,Claus Ibsen,Claus Ibsen,0,1,2021-08-25 11:21:54+00:00,2021-08-26 05:24:55+00:00,No Desc,
0,CAMEL-16889,Improvement,Major,3.11.0,3.12.0,"
None
",Resolved,Fixed,3.12.0,Claus Ibsen,Claus Ibsen,0,2,2021-08-25 11:14:26+00:00,2021-08-25 15:00:02+00:00,"When using pooled CF such as org.messaginghub.pooled.jms.JmsPoolConnectionFactory to pool an existing Artemis CF, then camel-jms does not detect this.


This would require to check if the CF is pooled and has a getConnectionFactory to get the target CF and then check if its Artemis.


This work can be done on startup instead of in the binding that would be overhead per message.",
0,CAMEL-16888,Improvement,Major,None,3.x,"
None
",Resolved,Fixed,3.x,Jean-Baptiste Onofré,Jean-Baptiste Onofré,3,6,2021-08-25 09:32:49+00:00,2023-08-09 09:18:38+00:00,"xml-specs-api should be updated with:



use dependency=true on stax2-api and update to stax2-api 4.2 (aligned with other camel features)
use woodstox-core instead of woodstox-core-asl and update to woodstox 6.2.4
update jaxb-runtime bundle to 2.3.2_1 to match CXF one","acosentino:1629855341:2021-08-25T09:35:41.909+0000:1629855341:2021-08-25T09:35:41.909+0000:It's an improvement. Only 3.12 I think. Lts should be stable
jbonofre:1629855476:2021-08-25T09:37:56.001+0000:1629855476:2021-08-25T09:37:56.001+0000:IMHO, it should be on 3.11 as well, as it's causing bunch of issue mixing CXF and camel features.
acosentino:1629855530:2021-08-25T09:38:50.874+0000:1629855530:2021-08-25T09:38:50.874+0000:Then it's not an improvement.
jbonofre:1629855600:2021-08-25T09:40:00.555+0000:1629855600:2021-08-25T09:40:00.555+0000:We can consider as a bug indeed.
davsclaus:1632649250:2021-09-26T17:40:50.583+0000:1632649250:2021-09-26T17:40:50.583+0000:We want to release 3.12 soon, so we should work on this asap or move it to 3.13.
lichtin:1651578686:2022-05-03T19:51:26.717+0000:1651578686:2022-05-03T19:51:26.717+0000:Point 3 would be good to fix as it causes
{noformat}
Caused by: java.lang.ClassNotFoundException: com.sun.istack.FinalArrayList not found by org.apache.servicemix.bundles.jaxb-runtime [223]
    at org.apache.felix.framework.BundleWiringImpl.findClassOrResourceByDelegation(BundleWiringImpl.java:1639) ~[?:?]
    at org.apache.felix.framework.BundleWiringImpl.access$200(BundleWiringImpl.java:80) ~[?:?]
    at org.apache.felix.framework.BundleWiringImpl$BundleClassLoader.loadClass(BundleWiringImpl.java:2053) ~[?:?]
    at java.lang.ClassLoader.loadClass(ClassLoader.java:351) ~[?:1.8.0_321] {noformat}
davsclaus:1691543918:2023-08-09T09:18:38.157+0000:1691543918:2023-08-09T09:18:38.157+0000:We have updated karaf stuff"
0,CAMEL-16887,Improvement,Minor,None,3.x,"
None
",Resolved,Abandoned,3.x,Jean-Baptiste Onofré,Jean-Baptiste Onofré,0,3,2021-08-25 09:21:54+00:00,2023-05-07 08:51:25+00:00,"camel-groovy feature only installs groovy:




<bundle dependency=""true"">mvn:org.codehaus.groovy/groovy/3.0.3</bundle>



In order to work smoothly, camel-groovy feature should install ""all"" groovy bundles, aka:




groovy-ant
groovy-cli-commons
groovy-cli-picocli 
groovy-console
groovy-datetime
groovy-docgenerator
groovy-groovydoc
groovy-groovysh
groovy-jmx
groovy-json
groovy-macro
groovy-nio
groovy-servlet
groovy-sql
groovy-swing
groovy-templates
groovy-test
groovy-test-junit5
groovy-testng
groovy-xml","davsclaus:1629854992:2021-08-25T09:29:52.626+0000:1629854992:2021-08-25T09:29:52.626+0000:Can you not create another feature that install the kitchen sink for groovy. 

The camel-groovy feature has always been like this, and its for using groovy as Camel expressions to do some minor content based routing etc.
Its not a FULL programming language for groovy.

For example you can add a groovy feature to Apache Karaf itself.

Also be careful with the 3.11 LTS release it should be stable.

jbonofre:1629855423:2021-08-25T09:37:03.564+0000:1629855423:2021-08-25T09:37:03.564+0000:Yes, Karaf specs repo can provide groovy feature and reference it in camel-groovy."
0,CAMEL-16886,Test,Major,None,"3.11.2, 3.12.0","
None
",Resolved,Fixed,"3.11.2, 3.12.0",Freeman Yue Fang,Freeman Yue Fang,0,1,2021-08-24 16:52:14+00:00,2021-08-24 16:56:42+00:00,"We randomly can get error like




org.apache.camel.component.jira.consumer.NewCommentsConsumerTest.singleIssueCommentsTest  Time elapsed: 1.939 s  <<< FAILURE!
java.lang.AssertionError: mock://result Received message count. Expected: <3> but was: <4>
	at org.apache.camel.component.mock.MockEndpoint.fail(MockEndpoint.java:1790)
	at org.apache.camel.component.mock.MockEndpoint.assertEquals(MockEndpoint.java:1767)




this is very rare to reproduce,  but if we change the comments number from 3 to 3000 in this test, we can see this error constantly.


The problem comes from that the issue with comments can be read multiple times and send to the mock endpoint, we should ensure the issue with comments  only be read once, just like the way in NewCommentsConsumerTest#multipleIssuesTest",
0,CAMEL-16885,Task,Major,None,3.12.0,"
None
",Resolved,Fixed,3.12.0,Andrea Cosentino,Andrea Cosentino,0,1,2021-08-24 16:29:11+00:00,2021-08-25 05:53:03+00:00,No Desc,
0,CAMEL-16884,Task,Major,None,3.12.0,"
None
",Resolved,Won't Fix,3.12.0,Andrea Cosentino,Andrea Cosentino,0,1,2021-08-24 16:28:41+00:00,2021-08-25 05:26:03+00:00,No Desc,"acosentino:1629840357:2021-08-25T05:25:57.235+0000:1629840357:2021-08-25T05:25:57.235+0000:1. not a bundle
2. Mess with OSGi headers
3. Mess with package naming.

"
0,CAMEL-16883,Improvement,Major,3.11.0,3.12.0,"
None
",Resolved,Fixed,3.12.0,Unassigned,Tamas Utasi,0,2,2021-08-24 10:50:39+00:00,2021-09-15 10:54:29+00:00,"Acceptance criteria:



pubsub integration can send and receive messages on GKE when using workload identity to authenticate to Google services



Background


Quoting from docs:


Workload Identity is the recommended way to access Google Cloud services from applications running within GKE due to its improved security properties and manageability.


Testing


Testing is difficult, as the changes should only work in ""real"" environment (GKE in this instance).","utamas:1629870718:2021-08-25T13:51:58.400+0000:1629870718:2021-08-25T13:51:58.400+0000:https://github.com/apache/camel/pull/5987
davsclaus:1629924525:2021-08-26T04:48:45.462+0000:1629924525:2021-08-26T04:48:45.462+0000:Is this something that the other google cloud components may also need?
utamas:1629936931:2021-08-26T08:15:31.895+0000:1629936931:2021-08-26T08:15:31.895+0000:I only looked at bigquery and storage and they look mostly fine (maybe they lack the capability to be used against emulators, but haven't tested).

As for the other components, I haven't looked.
utamas:1629938483:2021-08-26T08:41:23.996+0000:1629938483:2021-08-26T08:41:23.996+0000:Should I open a PR in [https://github.com/apache/camel-spring-boot] as well? `org.apache.camel.component.google.pubsub.springboot.GooglePubsubComponentConfiguration` has changed (the authenticate field was added)?
davsclaus:1629939229:2021-08-26T08:53:49.686+0000:1629939229:2021-08-26T08:53:49.686+0000:The SB files are auto generated from the source.
utamas:1629939316:2021-08-26T08:55:16.175+0000:1629939316:2021-08-26T08:55:16.175+0000:I noticed that, just wasn't sure about the procedure. Thank you!"
0,CAMEL-16882,Improvement,Major,None,3.12.0,"
None
",Resolved,Fixed,3.12.0,Unassigned,winger,0,2,2021-08-24 04:18:13+00:00,2021-08-26 04:47:33+00:00,"When set  DBZ configuration 'includes.schema.change'=true, downstream can get ddl sql from Exchange's header","davsclaus:1629788353:2021-08-24T14:59:13.068+0000:1629788353:2021-08-24T14:59:13.068+0000:Can you maybe also update the documentation, see in the src/main/docs folder of the component. 
winger2049@gmail.com:1629913457:2021-08-26T01:44:17.104+0000:1629913457:2021-08-26T01:44:17.104+0000:ok,done."
0,CAMEL-16881,Task,Major,None,3.12.0,"
None
",Resolved,Fixed,3.12.0,Claus Ibsen,Claus Ibsen,0,1,2021-08-23 13:00:09+00:00,2021-08-23 13:31:55+00:00,"Was not in use, and there is work to improve the website build that can benefit from not keeping the component docs up to date in another way.",
0,CAMEL-16880,Dependency upgrade,Minor,None,None,"
None
",Resolved,Fixed,3.12.0,Zheng Feng,Zheng Feng,0,2,2021-08-23 11:57:39+00:00,2021-08-26 05:28:24+00:00,it needs to include the fix of CVE-2020-13949,davsclaus:1629926904:2021-08-26T05:28:24.968+0000:1629926904:2021-08-26T05:28:24.968+0000:Was this backported to 3.11.x LTS ?
0,CAMEL-16879,New Feature,Major,None,,"
None
",Resolved,Won't Fix,None,Unassigned,Almog Tavor,0,2,2021-08-22 08:21:59+00:00,2023-07-17 11:30:46+00:00,"It would be great if support for the park streaming libraries were added. The Spark Structured Streaming library is very popular and in general, the Spark Streaming libraries are in common use (see the Stackoverflow questions count). The first support in my opinion would be added to the newer Spark Structured Streaming library - a library with a similar API to the Spark SQL Dataframes API. Then to the DStreams API (similar to the RDDs API). That's because the main use of the library is with the Structured Streaming library.


I put it in a major priority because lots of Apache Spark users will tend to give up the use of Apache Camel if they are using Spark Structured Streaming, which is currently unsupported.","almogtavor:1631485516:2021-09-13T06:25:16.296+0000:1631485853:2021-09-13T06:30:53.819+0000:As for the Structured Streaming support, as said in

[https://spark.apache.org/docs/latest/structured-streaming-programming-guide.html#creating-streaming-dataframes-and-streaming-datasets]

I think there should be an implementation for the Kafka source and the Files source.

As for the DStream support:

There should be connectors for each Spark Streaming’s supported connection in the Camel-Spark component. According to the Spark Streaming documentation:

Spark Streaming provides two categories of built-in streaming sources.
 * _Basic sources_: Sources directly available in the StreamingContext API. Example: file systems, socket connections, and Akka actors.
 * _Advanced sources_: Sources like Kafka, Flume, Kinesis, Twitter, etc. are available through extra utility classes. These require linking against extra dependencies as discussed in the [linking|https://spark.apache.org/docs/1.2.2/streaming-programming-guide.html#linking] section.

I think that there should be an option of choosing the source, and there will be an implementation for each of the following:
||Source||Artifact||
|Kafka|spark-streaming-kafka_2.10|
|Flume|spark-streaming-flume_2.10|
|Kinesis|spark-streaming-kinesis-asl_2.10 [Amazon Software License]|
|Twitter|spark-streaming-twitter_2.10|
|ZeroMQ|spark-streaming-zeromq_2.10|
|MQTT|spark-streaming-mqtt_2.10|

Plus an implementation for the basic sources, which should look pretty much the same for the Camel-Spark user.

 

 

Its important to emphasize that the Structured Streaming support is much more important since this is the most common way of using the library.
davsclaus:1662166991:2022-09-03T09:03:11.232+0000:1662166991:2022-09-03T09:03:11.232+0000:Almog would you be able to work on such a functionality? Maybe as a new camel-spark-streaming component
davsclaus:1689564646:2023-07-17T11:30:46.580+0000:1689564646:2023-07-17T11:30:46.580+0000:camel-spark is removed in v4"
0,CAMEL-16878,Bug,Major,None,"3.11.2, 3.12.0","
None
",Resolved,Fixed,"3.11.2, 3.12.0",Claus Ibsen,Rik van Ballegooijen,0,2,2021-08-19 15:50:47+00:00,2021-08-21 10:42:43+00:00,"ClassCastException: class org.apache.camel.component.directvm.DirectVmEndpoint cannot be cast to class org.apache.camel.component.mail.MailEndpoint


 


This is caused by:


 




MailConfiguration mailConfiguration = ((MailEndpoint) exchange.getFromEndpoint()).getConfiguration();



Which assumes the exchanges endpoint is always a MailEndpoint.


 


This piece of code from DefaultUnitOfWork will trigger the init of headers:




if (useBreadcrumb) {
    // create or use existing breadcrumb
    String breadcrumbId = exchange.getIn().getHeader(Exchange.BREADCRUMB_ID, String.class);
    if (breadcrumbId == null) {
        // no existing breadcrumb, so create a new one based on the exchange id
        breadcrumbId = exchange.getExchangeId();
        exchange.getIn().setHeader(Exchange.BREADCRUMB_ID, breadcrumbId);
    }
}




If message is of type MailMessage, it will be delegated there:




MailBinding binding = ExchangeHelper.getBinding(getExchange(), MailBinding.class);
if (binding != null) {
    map.putAll(binding.extractHeadersFromMail(mailMessage, getExchange()));
}




This works for the initial route with a from imaps, but in a subroute the error occurs.


 


Possible solution could be to pass a reference to either the mail endpoint or mail configuration to the binding on create/set.","davsclaus:1629414692:2021-08-20T07:11:32.150+0000:1629414692:2021-08-20T07:11:32.150+0000:What version of Camel are you using?
rikvb:1629426479:2021-08-20T10:27:59.664+0000:1629426479:2021-08-20T10:27:59.664+0000:I am using Wildfly Camel, which uses 3.4.0. The issue is related to leaving the current camel context. I am unable to reproduce this when I move over the route throwing the error to the same deployment/camel context.
davsclaus:1629513763:2021-08-21T10:42:43.852+0000:1629513763:2021-08-21T10:42:43.852+0000:Thanks for reporting and explaining how you run this with Camel."
0,CAMEL-16877,Bug,Major,3.11.1,"3.7.6, 3.11.3, 3.12.0","
None
",Resolved,Fixed,"3.7.6, 3.11.3, 3.12.0",Jeremy Ross,Jeremy Ross,0,2,2021-08-19 15:12:07+00:00,2021-09-18 16:39:49+00:00,"A transacted route with a salesforce operation will time out if it's called from a non-transacted route with a salesforce operation.


Reproducer here: https://github.com/jeremyross/camel-transacted-salesforce-reproducer","jeremyross:1629371685:2021-08-19T19:14:45.613+0000:1629371768:2021-08-19T19:16:08.120+0000:This feels similar to this https://issues.apache.org/jira/browse/CAMEL-14138.
Workaround is going back to camel 3.7.x, in which the salesforce component still has the synchronous option and always using synchronous=true.

I suspect that in route1 the operation is async, then because route2 is transacted, it's forced to be sync, then the deadlock happens. In CAMEL-14138 I'd discovered that a sync call after an async call resulted in deadlock.
jeremyross:1629375149:2021-08-19T20:12:29.485+0000:1629375149:2021-08-19T20:12:29.485+0000:Another workaround. This one works on more recent Camel releases: Put all salesforce operations in `direct:xyz?synchronous=true` routes.
davsclaus:1630711541:2021-09-04T07:25:41.051+0000:1630711541:2021-09-04T07:25:41.051+0000:Note that transacted only works with JMS and JDBC with a JTA transaction manager so it has limited usage. "
0,CAMEL-16876,New Feature,Major,None,None,"
None
",Resolved,Fixed,3.12.0,Unassigned,Hokutor,0,1,2021-08-19 15:00:01+00:00,2021-09-21 07:57:05+00:00,New Camel component to integrate with Huawei Cloud Distributed Message Service (DMS) - DMS,
0,CAMEL-16875,New Feature,Minor,None,,"
None
",Open,Unresolved,None,Unassigned,Hokutor,0,1,2021-08-19 13:14:39+00:00,2021-08-19 13:14:39+00:00,"Currently, we have implementation listed [here](https://camel.apache.org/components/latest/master-component.html#_implementations) to support clustering. 


Since etcd is gaining popularity among distributed systems, it would be worth to have a ClusterService implementation to use the same",
0,CAMEL-16874,Bug,Minor,"3.7.5, 3.11.0",None,"
None
",Resolved,Fixed,"3.7.6, 3.11.2, 3.12.0",Karen Lease,Karen Lease,0,1,2021-08-19 10:09:13+00:00,2022-04-01 06:13:17+00:00,"In the dev mailing list, onders reported an issue using pollEnrich in combination with a REST request to upload files. 




from(""direct:uploadFiles"")
        .pollEnrich(""file:{{shared-folder}}?include=.*.gz&delete=true&sendEmptyMessageWhenIdle=true"")
        .choice()
          .when(body().isNull()).log(""No files found.. skipping to send to S3"")
          .otherwise().to(""direct:toAwsS3"")
        .endChoice();




If the shared-folder contained no file, the empty event was sent, but when a file was then put in the folder, the empty event was still sent on the next rest request.",klease78:1629340354:2021-08-19T10:32:34.791+0000:1629340354:2021-08-19T10:32:34.791+0000:Created PR [https://github.com/apache/camel/pull/5962] with a correction and unit test.
0,CAMEL-16873,Improvement,Major,3.11.0,"3.11.2, 3.12.0, 3.16.0","
None
",Resolved,Fixed,"3.11.2, 3.12.0, 3.16.0",Claus Ibsen,Matthias Leinweber,0,2,2021-08-19 09:19:52+00:00,2022-03-20 20:34:53+00:00,"When you are using route templates you can dumpRoutesAsXML but the parameters are not replaced even if you set the replacement boolean to true.


It would be very useful to see resulting template with parameters replaced.","leinweberm:1629426196:2021-08-20T10:23:16.642+0000:1629426196:2021-08-20T10:23:16.642+0000:This was fast, thank you!
leinweberm:1647501557:2022-03-17T15:19:17.396+0000:1647501557:2022-03-17T15:19:17.396+0000:The fix unfortunately does not work for xml defined templates:


{code:java}
    <routeTemplate id=""exampleTemplate"">
      <templateParameter name=""from""/>
      <templateParameter name=""to""/>
      <templateParameter name=""description"" defaultValue=""No description""/>
      <route template=""true""> <!-- !!!!! This becomes RoutesDefinition not RouteDefintion-->
        <description>{{description}}</description>
        <from uri=""{{from}}""/>
        <to uri=""{{to}}""/>
      </route>
    </routeTemplate>{code}

best Regards,
A fix is highly appreciated. :)



 
davsclaus:1647589333:2022-03-18T15:42:13.644+0000:1647589333:2022-03-18T15:42:13.644+0000:Can you put together an unit test / example etc to demonstrate this, this will give you help faster.
leinweberm:1647609610:2022-03-18T21:20:10.180+0000:1647609610:2022-03-18T21:20:10.180+0000: 

maybe add camel/components/camel-spring-xml/SpringRouteTemplateTest.java following test. And see that templates variables are not replaced, 
{code:java}
    @Test
    public void testDumpModelAsXml() throws Exception {
        Map<String, Object> parameters = new HashMap<>();
        parameters.put(""foo"", ""one"");
        parameters.put(""bar"", ""cheese"");
        context.addRouteFromTemplate(""first"", ""myTemplate"", parameters);
        ExtendedCamelContext ecc = context.adapt(ExtendedCamelContext.class);
        String xml = ecc.getModelToXMLDumper().dumpModelAsXml(context, context.getRouteDefinition(""first""));
        assertNotNull(xml);
        System.out.println(xml);
    } {code}


Due to [https://github.com/apache/camel/blob/abbbb2716d7e287e09a777a001d1026e99a038d8/core/camel-xml-jaxb/src/main/java/org/apache/camel/xml/jaxb/JaxbModelToXMLDumper.java#L161] is a RoutesDefintion object and the first route of this is the RouteDefintinon object

 
davsclaus:1647735499:2022-03-20T08:18:19.769+0000:1647735499:2022-03-20T08:18:19.769+0000:You need to use resolve placeholders, eg

        String xml = ecc.getModelToXMLDumper().dumpModelAsXml(context, def, true, true);

leinweberm:1647749029:2022-03-20T12:03:49.011+0000:1647749029:2022-03-20T12:03:49.011+0000:You are absolute right. I maybe simplified the test cast to much.
In reality I am using jolokokia dumpRoutesAsXml(boolean,boolean)/True/True on karaf. 
I also tested this with paxExam:
{code:java}
public class CamelRouteTemplateTest extends AbstractFeatureTest {    @Test
    public void testCamelRouteTemplate() throws Exception {
        // install the camel blueprint xml file we use in this test
        URL url = ObjectHelper.loadResourceAsURL(""org/apache/camel/itest/CamelRouteTemplateTest.xml"", CamelCoreTest.class.getClassLoader());
        installBlueprintAsBundle(""CamelRouteTemplate"", url, true);        // lookup Camel from OSGi
        CamelContext context = getOsgiService(bundleContext, CamelContext.class);
        Map<String, Object> parameters = new HashMap<>();
        parameters.put(""foo"", ""one"");
        parameters.put(""bar"", ""cheese"");
        context.addRouteFromTemplate(""first"", ""myTemplate"", parameters);
        System.out.println(context);
        RouteDefinition first = context.getExtension(Model.class).getRouteDefinition(""first"");
        System.out.println(""RouteDefinition "" + first);
        ExtendedCamelContext ecc = context.adapt(ExtendedCamelContext.class);
        String xml = ecc.getModelToXMLDumper().dumpModelAsXml(context, first, true, true);
        System.out.println(xml);
    }    @Configuration
    public Option[] configure() {
        return CamelKarafTestSupport.configure(""camel-test-karaf"");
    }
 {code}

This work works too. And yes after some debugging the problem is here in the mbean ManagedCamelContext, 


{code:java}
   @Override
    public String dumpRoutesAsXml(boolean resolvePlaceholders, boolean resolveDelegateEndpoints) throws Exception {
        List<RouteDefinition> routes = context.getExtension(Model.class).getRouteDefinitions();
        if (routes.isEmpty()) {
            return null;
        }        // use a routes definition to dump the routes
        RoutesDefinition def = new RoutesDefinition();
        def.setRoutes(routes);        
        ExtendedCamelContext ecc = context.adapt(ExtendedCamelContext.class);
        return ecc.getModelToXMLDumper().dumpModelAsXml(context, def, resolvePlaceholders, resolveDelegateEndpoints);
    } {code}
 

 
leinweberm:1647750029:2022-03-20T12:20:29.020+0000:1647750029:2022-03-20T12:20:29.020+0000:Problem is withing mbean  ManagedCamelContext when multiple routes are querried.
davsclaus:1647753958:2022-03-20T13:25:58.697+0000:1647753958:2022-03-20T13:25:58.697+0000:Then create a new JIRA and send a PR - as its in JMX and not normal Camel
leinweberm:1647773463:2022-03-20T18:51:03.502+0000:1647773463:2022-03-20T18:51:03.502+0000:I could but i think this is only fixable in core. Because core supports calling with RoutesDefinition and not only with RouteDefinition. I think the mbean can not iterate over routes and call dumpModelAsXml multiple times. If i am wrong give me a direction.

br
davsclaus:1647778156:2022-03-20T20:09:16.771+0000:1647778156:2022-03-20T20:09:16.771+0000:Okay so made the placeholder replcament work for a list of routes which only happens when you use the mbean
leinweberm:1647779693:2022-03-20T20:34:53.698+0000:1647779693:2022-03-20T20:34:53.698+0000:Yeah this is not that easy. The xml transformer iterates over lines and we have to check if we are currently in a line with a templated route. Maybe its easier to iterate over routes in the mbean and merge the results. But would you merge this pr?"
0,CAMEL-16872,Dependency upgrade,Major,None,None,"
None
",Resolved,Fixed,"3.11.2, 3.12.0",Claus Ibsen,James Netherton,0,2,2021-08-18 16:06:17+00:00,2021-09-04 07:23:33+00:00,"The 5.0.8 version currently used by Camel uses some Binance APIs that are supposed to no longer be available.


https://www.binance.com/en/support/announcement/f45dde7da58b473aa885349946bed269


We should upgrade to the latest xchange version as this has been fixed. 


See also:


https://github.com/apache/camel-quarkus/issues/3016",davsclaus:1630711408:2021-09-04T07:23:28.377+0000:1630711408:2021-09-04T07:23:28.377+0000:Upgraded to 5.0.11
0,CAMEL-16871,Improvement,Minor,None,4.x,"
None
",Open,Unresolved,4.x,Unassigned,Brendan,0,2,2021-08-18 14:45:59+00:00,2023-08-09 09:18:46+00:00,"Camel aws2-s3 mutlipart upload only supports Files.


 


There are at least two approaches to solving this:


The hard, general case and a simple specific case.


 


1) The harder but general case: use something like Spring's aws SimpleStorageInputStream:


https://github.com/spring-cloud/spring-cloud-aws/blob/main/spring-cloud-aws-core/src/main/java/org/springframework/cloud/aws/core/io/s3/SimpleStorageResource.java


 and translate any exchange body to an Inputstream for mulitpart uploads.


 


2) The simpler but specific case: for remote files in particular, camel often makes use of a localwork directory to download files. In fact,




e.getIn().getBody(File.class) 




will resolve the file in the local work directory when polling from an FTP site with a local work directory specified.


 


The aws2-s3 producer (AWS2S3Producer.class) on lines 134 to 145 would need to be modified in both cases.","acosentino:1631483742:2021-09-13T05:55:42.524+0000:1631483742:2021-09-13T05:55:42.524+0000:I think we could also use the same approach as the single op is doing https://github.com/apache/camel/blob/main/components/camel-aws/camel-aws2-s3/src/main/java/org/apache/camel/component/aws2/s3/AWS2S3Producer.java#L270

as an else case.
bmarcj:1631529553:2021-09-13T18:39:13.748+0000:1631529553:2021-09-13T18:39:13.748+0000:I suppose it depends on what line 271 does. But that might actually be sufficient."
0,CAMEL-16870,New Feature,Minor,None,,"
None
",Open,Unresolved,None,Jean-Baptiste Onofré,Jean-Baptiste Onofré,0,1,2021-08-18 14:36:38+00:00,2021-08-19 05:06:59+00:00,No Desc,
0,CAMEL-16869,Task,Major,None,3.12.0,"
None
",Resolved,Fixed,3.12.0,Unassigned,Claus Ibsen,0,1,2021-08-18 13:57:26+00:00,2021-08-19 05:03:41+00:00,"Its not a good to use this, and its cumbersome to register.
Instead you should use the dozer component for pojo mapping",
0,CAMEL-16868,Test,Minor,None,None,"
None
",Resolved,Information Provided,None,Unassigned,Peter Palaga,0,2,2021-08-17 14:57:25+00:00,2022-09-03 08:14:27+00:00,I am going through the DSL methods listed in EIP catalog and I am adding Camel Quarkus tests where necessary to make sure that the methods work also in native mode. I often search for inspiration in Camel tests. However for basicAuth() I neither was able to figure out how to use it nor there is a test in Camel code base. Would it please be possible to add one?,"davsclaus:1629320727:2021-08-19T05:05:27.930+0000:1629320727:2021-08-19T05:05:27.930+0000:the rest-dsl is ""just"" a facade, so if you specify that basic auth as securtity in the rest-dsl, then Camel only uses this when generating the open api / swagger spec file.

Its the underlying http platform that must be configure to basic auth, eg if you run on jee server, spring boot, quarkus or something else."
0,CAMEL-16867,Task,Minor,None,3.12.0,"
None
",Resolved,Fixed,3.12.0,Andrea Cosentino,Claus Ibsen,0,3,2021-08-17 11:08:39+00:00,2021-09-09 05:30:22+00:00,The maven wrapper is 3.6.3. We should upgrade to 3.8.2,"smox:1631088215:2021-09-08T16:03:35.547+0000:1631088215:2021-09-08T16:03:35.547+0000:Attached a patch for upgrading to maven 3.8.2.
acosentino:1631136622:2021-09-09T05:30:22.220+0000:1631136622:2021-09-09T05:30:22.220+0000:Thanks"
0,CAMEL-16866,New Feature,Major,None,4.x,"
None
",Open,Unresolved,4.x,Vignesh Nayak Manel,Claus Ibsen,0,2,2021-08-17 07:47:59+00:00,2023-08-31 18:39:26+00:00,"Currently we only have tracing support, but opentelemtry can also be used for gather metrics.


Maybe look at how camel-micrometer is doing this
https://github.com/apache/camel/tree/main/components/camel-micrometer","vmanel:1693473032:2023-08-31T17:10:32.588+0000:1693473032:2023-08-31T17:10:32.588+0000:I can try working on this
davsclaus:1693478005:2023-08-31T18:33:25.046+0000:1693478005:2023-08-31T18:33:25.046+0000:Thanks [~vmanel] I granted your user karma to self-assign JIRA tickets 
vmanel:1693478366:2023-08-31T18:39:26.447+0000:1693478366:2023-08-31T18:39:26.447+0000:thanks [~davsclaus] "
0,CAMEL-16865,Bug,Major,3.11.1,"3.7.6, 3.11.2, 3.12.0","
None
",Resolved,Fixed,"3.7.6, 3.11.2, 3.12.0",Claus Ibsen,Ruben Gerits,0,2,2021-08-16 06:55:35+00:00,2021-08-16 09:08:27+00:00,"When trying to find all items of a specific namespace within a parent tag it will stop detecting the children once it comes across a parent tag that does not have any child elements within this namespace. 


It seems that the code to go up a level again is only triggered once a matching child element has been found. If no elements are found this logic is not triggered, even though the xml tag ends at that level.


For example having XML:




<?xml version='1.0' encoding='UTF-8'?>
<greatgrandparent xmlns='urn:g' xmlns:c='urn:c' xmlns:x='urn:x'>
    <grandparent>
        <x:uncle>bob</x:uncle>
        <x:aunt>emma</x:aunt>
    </grandparent>
    <grandparent>
        <c:parent some_attr='1'>
            <c:child some_attr='a' anotherAttr='a'></c:child>
            <c:child some_attr='b' anotherAttr='b' />
        </c:parent>
        <c:parent some_attr='2'>
            <c:child some_attr='c' anotherAttr='c'></c:child>
            <c:child some_attr='d' anotherAttr='d' />
        </c:parent>
    </grandparent>
    <grandparent>
        <x:uncle>ben</x:uncle>
        <x:aunt>jenna</x:aunt>
        <c:parent some_attr='3'>
            <c:child some_attr='e' anotherAttr='e'></c:child>
            <c:child some_attr='f' anotherAttr='f' />
        </c:parent>
    </grandparent>
</greatgrandparent>
 



And we run the xtokenize expression as following (within test class XMLTokenExpressionIteratorTest):




nsmap.put(""X"", ""urn:x"");
invokeAndVerify(""//G:grandparent/X:*"",
        'i', new ByteArrayInputStream(TEST_BODY_MIXED_CHILDREN), RESULTS_AUNT_AND_UNCLE);




As a result we now get:




<x:uncle xmlns=\""urn:g\"" xmlns:x=\""urn:x\"" xmlns:c=\""urn:c\"">bob</x:uncle>
<x:aunt xmlns=\""urn:g\"" xmlns:x=\""urn:x\"" xmlns:c=\""urn:c\"">emma</x:aunt>




This means it stops processing at the moment it got to the grandparent tag that only has <c:child> elements.


The expected result would be:




<x:uncle xmlns=\""urn:g\"" xmlns:x=\""urn:x\"" xmlns:c=\""urn:c\"">bob</x:uncle>
<x:aunt xmlns=\""urn:g\"" xmlns:x=\""urn:x\"" xmlns:c=\""urn:c\"">emma</x:aunt>
<x:uncle xmlns=\""urn:g\"" xmlns:x=\""urn:x\"" xmlns:c=\""urn:c\"">ben</x:uncle>
<x:aunt xmlns=\""urn:g\"" xmlns:x=\""urn:x\"" xmlns:c=\""urn:c\"">jenna</x:aunt>","gerits:1629068192:2021-08-16T06:56:32.536+0000:1629068192:2021-08-16T06:56:32.536+0000:I've found the solution for this problem within the code, I will create a pull requests to submit the changes for review.
gerits:1629069654:2021-08-16T07:20:54.000+0000:1629069654:2021-08-16T07:20:54.000+0000:Created Pull Request with the required changes: https://github.com/apache/camel/pull/5955
davsclaus:1629076107:2021-08-16T09:08:27.303+0000:1629076107:2021-08-16T09:08:27.303+0000:Thanks for detailed reporting and providing a fix with an unit test."
0,CAMEL-16864,Improvement,Major,3.11.0,3.12.0,"
None
",Resolved,Fixed,3.12.0,Claus Ibsen,Claus Ibsen,0,1,2021-08-13 14:38:14+00:00,2021-08-13 14:49:10+00:00,No Desc,
0,CAMEL-16863,Bug,Minor,3.11.1,3.12.0,"
None
",Resolved,Fixed,3.12.0,Claus Ibsen,qingbo li,0,2,2021-08-13 07:46:11+00:00,2021-09-18 02:41:45+00:00,"Hi ,


 we are using Camel(3.11.1) Spring Ws for the ws server and use wiretap eip to log and found the following problem:


the wiretap exchange lost the original message body.i found the reason is: doCopyResults method in ExchangeHelper will not copy body while the result exchange's pattern is InOptionalOut.but I don't know how to change it and when the InOptionalOut Exchange offer to exchange pool (I set exchange factory = pooled)","davsclaus:1628834197:2021-08-13T13:56:37.789+0000:1628834197:2021-08-13T13:56:37.789+0000:try set ?exchangePattern=InOut in the spring-ws endpoint
davsclaus:1628834255:2021-08-13T13:57:35.008+0000:1628834255:2021-08-13T13:57:35.008+0000:Can you post the route you use, or put a reproducer example on github or attach as .zip in this JIRA
spinachomes:1628886365:2021-08-14T04:26:05.220+0000:1628886365:2021-08-14T04:26:05.220+0000:I uploaded the example attach,after you run this eaxmple,the wsdl url:[http://localhost:8080/services/HolidayService/holiday.wsdl,] you can use soapui to send a request ,then you can see wireTap log and original log.
davsclaus:1630319531:2021-08-30T18:32:11.409+0000:1630319531:2021-08-30T18:32:11.409+0000:Thanks for the sample project - I have reproduced it, however had to run with java 8 to make soap saaj work as saaj is not included anymore in the jdk.


davsclaus:1630327496:2021-08-30T20:44:56.342+0000:1630327496:2021-08-30T20:44:56.342+0000:Thanks this is resolved by the other tickets. Thanks for reporting and the reproducer.
spinachomes:1631904105:2021-09-18T02:41:45.141+0000:1631904105:2021-09-18T02:41:45.141+0000:Hi [~davsclaus]，this issue is still not resolved in camel 3.11.2. you can try the example again after upgrade to 3.11.2"
0,CAMEL-16862,Bug,Major,"3.11.1, 3.11.0",,"
None
",Closed,Not A Bug,None,Unassigned,Pascal Schumacher,0,2,2021-08-11 16:52:03+00:00,2023-10-24 14:07:12+00:00,"After updating from Camel 3.10.0 to Camel 3.11.0 or Camel 3.11.1 the dataSource option of a SQL Endpoint no longer overrides the DataSource set by a Component ComponentCustomizer (at least when using Spring Boot, no idea if it works with just Camel).


https://github.com/PascalSchumacher/CamelSpringBootEndpointDataSource contains a small example which demonstrates the issue. ExampleTest passes with Camel 3.10.0, but fails with Camel 3.11.0 and Camel 3.11.1.


I believe this was caused by CAMEL-16732 probably by the changes to SqlComponent#createEndpoint in https://github.com/apache/camel/commit/8d4714d4b9cca87c947b8dd3813ab5c556583db5#diff-192e08c8d708cf496f905153f919bdfc444992b4fe424ae5f9841bfabd838bf7L65","davsclaus:1628834794:2021-08-13T14:06:34.514+0000:1628834794:2021-08-13T14:06:34.514+0000:Can you look at your sample project as it cannot run.

It should run the tests when you type mvn clean install



davsclaus:1628835481:2021-08-13T14:18:01.509+0000:1628835503:2021-08-13T14:18:23.113+0000:Okay you should use

dataSource(""#secondDataSource"")

To refer to a data source by its id, that would be the same for uri parameter - always use # as prefix as bean lookup
davsclaus:1628836639:2021-08-13T14:37:19.424+0000:1628836639:2021-08-13T14:37:19.424+0000:But lets see if we can improve the validation and fail Camel if the data source is mis configured
pascalschumacher:1628848980:2021-08-13T18:03:00.180+0000:1628848980:2021-08-13T18:03:00.180+0000:Thank you very much for the quick response! :)

As it was working without the # since Camel 3.0.0 I wasn't aware that it should not have been working. Sorry!
davsclaus:1628855468:2021-08-13T19:51:08.423+0000:1628855468:2021-08-13T19:51:08.423+0000:It was some old code that was special in camel-sql about the non #

At the end of the day then we now have a better error message, if invalid configured, so that is good.
And now all the components are similar with the built-in *autowired* functionality."
0,CAMEL-16861,Task,Major,None,Future,"
None
",Open,Unresolved,Future,Claus Ibsen,Claus Ibsen,0,1,2021-08-11 06:02:22+00:00,2023-08-09 09:18:56+00:00,"The documentation needs some polishing and cleanup, and to remove obsolete pages etc.","davsclaus:1629095330:2021-08-16T14:28:50.909+0000:1635146219:2021-10-25T15:16:59.260+0000:TODO: cleanup general docs *DONE*
TODO: cleanup eip docs *DONE*
TODO: cleanup languages *DONE*
TODO: cleanup core languages *DONE*
TODO: cleanup FAQ
TODO: remove more FAQs that are out-dated or out of fashion, and move content to relevant general doc page instead

TODO: async *DONE*
TODO: asynchronous-routing-engine *DONE*
TODO: spring-testing *DONE*
TODO: testing *DONE*
TODO: threading-model *DONE*
TODO: using property placeholders *DONE*


davsclaus:1629097736:2021-08-16T15:08:56.962+0000:1631229033:2021-09-10T07:10:33.039+0000:TODO: move osgi docs to camel-karaf *DONE*
davsclaus:1629259084:2021-08-18T11:58:04.203+0000:1629272085:2021-08-18T15:34:45.697+0000:TODO: move dozer type converter to dozer-component *DONE*
davsclaus:1629346062:2021-08-19T12:07:42.680+0000:1629346062:2021-08-19T12:07:42.680+0000:TODO: reactive-routing-engine
davsclaus:1629516010:2021-08-21T11:20:10.236+0000:1629516010:2021-08-21T11:20:10.236+0000:TODO: Restructure document nav into a TOC with relevant topics

davsclaus:1629674543:2021-08-23T07:22:23.791+0000:1629940240:2021-08-26T09:10:40.639+0000:TODO: advanced-configuring-of-spring rename to a better name (and make general as camel-main does this convention over configuration thingy) *DONE*
TODO: NotifyBuilder *DONE*
TODO: AdviceWith *DONE*
davsclaus:1629860468:2021-08-25T11:01:08.994+0000:1634639272:2021-10-19T18:27:52.688+0000:TODO: each of the camel-test JARs and their docs (the camel-test-spring is very outdated) *DONE*

TODO: test camel on spring boot *DONE*
davsclaus:1631754247:2021-09-16T09:04:07.275+0000:1634187312:2021-10-14T12:55:12.037+0000:TODO: eip cleanup A-R *DONE*
TODO: eip cleanup U-W *DONE*
davsclaus:1634639259:2021-10-19T18:27:39.044+0000:1635146208:2021-10-25T15:16:48.400+0000:TODO: eip split *DONE*
TODO: eip threads *DONE*
TODO: eip to *DONE*
TODO: eip toD *DONE*
TODO: eip transactional client *DONE*
davsclaus:1634639298:2021-10-19T18:28:18.070+0000:1634639298:2021-10-19T18:28:18.070+0000:TODO: There may be two different pages that covers camel on spring-boot
davsclaus:1635898231:2021-11-03T08:10:31.506+0000:1635898231:2021-11-03T08:10:31.506+0000:TODO: create page for camel concepts and move stuff from camelcontext.adoc there
davsclaus:1635898254:2021-11-03T08:10:54.872+0000:1635987216:2021-11-04T08:53:36.372+0000:TODO: user guide cleanup 2nd pass
TODO: 2nd pass a..d *DONE*
TODO: currently at error-handler
davsclaus:1635900086:2021-11-03T08:41:26.786+0000:1635900086:2021-11-03T08:41:26.786+0000:TODO: Rename Endpoint-dsl to endpoint-dsl"
0,CAMEL-16860,Improvement,Minor,None,Future,"
None
",Open,Unresolved,Future,Unassigned,Zineb Bendhiba,0,2,2021-08-10 14:20:08+00:00,2023-08-09 09:19:01+00:00,"The Salesforce component uses the commons-lang3 utilities for working with Fields reflection.


Find a better way to create the Jackson Mapper for the consumer with PUSH_TOPIC, dealing with the NULL fields without using the org.apache.commons.lang3.reflect.FieldUtils in the FieldsToNullPropertyFilter.


 


This is the problematic line of code : https://github.com/apache/camel/blob/7406711360935a11ade7e0c90989832079e3b2d1/components/camel-salesforce/camel-salesforce-component/src/main/java/org/apache/camel/component/salesforce/api/FieldsToNullPropertyFilter.java#L34",jeremyross:1633163919:2021-10-02T16:38:39.929+0000:1633163919:2021-10-02T16:38:39.929+0000:[~zbendhiba] is this for Quarkus? There are probably other [places|https://github.com/apache/camel/blob/da610a701d538106141eaa495fb50fefca9cea26/components/camel-salesforce/camel-salesforce-component/src/main/java/org/apache/camel/component/salesforce/internal/processor/AbstractRestProcessor.java#L680-L684] that would need to be addressed too.
0,CAMEL-16859,Bug,Major,3.11.0,,"
None
",Resolved,Information Provided,None,Unassigned,Matthieu Ghilain,0,3,2021-08-10 12:19:48+00:00,2021-10-02 08:19:49+00:00,"I am using Camel 3.11.0 with Spring boot and opentelemetry-java-instrumentation java agent version 1.3.1 to implement distributed tracing across my microservices.


The trace id is not propagated between the input and output message. A new trace id is created for outgoing messages and therefore correlation is lost.


If you need additional information to investigate don't hesitate to ask.


(see discussion here -> https://camel.zulipchat.com/#narrow/stream/257298-camel/topic/OpenTelemetry.20-.20Trace.20Messages)


 


Sample project -> https://github.com/ghilainm/camel-spring-boot-showcase","jamesnetherton:1630630968:2021-09-03T09:02:48.678+0000:1630630968:2021-09-03T09:02:48.678+0000:This isn't related to camel-opentelemetry component. The mentioned example project doesn't use it. Rather it's related to the OpenTelemetry Java Agent.

I had a brief look at it. I think the issue is thread related. When all of the kafka producer / consumer parts are initiated from separate threads (as they are in Camel), then you end up with the split traces for the topic produce / consume parts. It's pretty simple to replicate the problem in a simple standalone Kafka Java app without Camel.

FWIW, I tried the same style of app with Camel Quarkus and the trace & spans are recorded as expected under a single trace. Quarkus doesn't need the Java agent, so that makes me think maybe that's where the root cause of the problem is.
ghilainm@gmail.com:1630900205:2021-09-06T11:50:05.291+0000:1630900325:2021-09-06T11:52:05.214+0000:Thx for watching [~jamesnetherton]!

What do you mean by Quarkus doesn't need the Java agent?

So you think the bug should be open on the Opentelemetry Agent project? Because you do agree that it's not working as expected?

(in the mean time I have created an issue on their side https://github.com/open-telemetry/opentelemetry-java-instrumentation/issues/4052)
davsclaus:1633133989:2021-10-02T08:19:49.292+0000:1633133989:2021-10-02T08:19:49.292+0000:Okay so this is open-telemetry that are tracking this on their side"
0,CAMEL-16858,Improvement,Major,None,3.12.0,"
None
",Resolved,Fixed,3.12.0,James Netherton,James Netherton,0,1,2021-08-09 11:41:41+00:00,2021-08-09 14:05:10+00:00,"If you do something like:


consumerTemplate.receiveBody(""sjms:foo.queue?messageSelector=foo='bar'"", 5000L, String.class) 


The selector is never used because the logic in SjmsTemplate.receive uses the single argument Session.createConsumer(destination) implementation.


It should be possible to pass along the selector, and if not empty, do Session.createConsumer(destination, selector).


The existing unit test for this is flawed, so I guess this has gone unnoticed for some time.",
0,CAMEL-16857,Bug,Major,3.11.1,"3.11.2, 3.12.0","
None
",Resolved,Fixed,"3.11.2, 3.12.0",Unassigned,Vladimir Dobos,0,2,2021-08-09 09:15:44+00:00,2021-09-03 10:08:02+00:00,"When breakOnfirstError is enabled in camel-kafka, there is visible thread leak (one hung heartbeat thread per kafka client restart/route retry) in underlying kafka client, accompanied by small memory leak, for extreme example - see attached VisualVM screenshots).
 Example application used for screenshot can be found in https://github.com/vdobos-tr/camel-kafka-on-error-leak.
 We are relatively new to kafka so im unable to determine, if its issue with underlying kafka client, or problem with the way camel handles reconnect after error.","davsclaus:1630634878:2021-09-03T10:07:58.474+0000:1630634878:2021-09-03T10:07:58.474+0000:We have another fix related to, and I found a missing bit when using breakOnFirst so adding that. Can you try 3.11.2 when its released."
0,CAMEL-16856,Dependency upgrade,Major,None,"3.11.2, 3.12.0","
None
",Resolved,Fixed,"3.11.2, 3.12.0",Andrea Cosentino,Jean-Baptiste Onofré,0,2,2021-08-09 08:42:02+00:00,2021-09-09 09:30:01+00:00,No Desc,"davsclaus:1629171462:2021-08-17T11:37:42.617+0000:1629171462:2021-08-17T11:37:42.617+0000:The karaf feauture file is broken

[caused by: Unable to resolve org.apache.camel.camel-azure-storage-blob/3.12.0.SNAPSHOT: missing requirement [org.apache.camel.camel-azure-storage-blob/3.12.0.SNAPSHOT] osgi.wiring.package; filter:=""(osgi.wiring.package=com.azure.storage.blob.changefeed)""]]]"
0,CAMEL-16855,Task,Minor,None,3.15.0,"
None
",Resolved,Fixed,3.15.0,Jean-Baptiste Onofré,Jean-Baptiste Onofré,0,3,2021-08-09 07:37:59+00:00,2022-01-13 15:36:20+00:00,No Desc,"davsclaus:1635479130:2021-10-29T11:45:30.358+0000:1635479130:2021-10-29T11:45:30.358+0000:Reverting this as this causes that problem as in CAMEL-17137
raminxp@hotmail.com:1642056169:2022-01-13T14:42:49.355+0000:1642056169:2022-01-13T14:42:49.355+0000:[~jbonofre] I think this is a bug in karaf-maven-plugin. When given a repository version range of [3,4), it is trying to pull 4.0.0-SNAPSHOT which doesn't even exist.. Your commit initially fixed the issue for us, since the version was pinned. But this commit is reverted now and we are getting the same failure using latest 3.11.x"
0,CAMEL-16854,Task,Major,3.11.0,3.12.0,"
None
",Resolved,Fixed,3.12.0,David Jencks,David Jencks,0,2,2021-08-08 04:39:46+00:00,2021-09-21 06:52:01+00:00,"Investigate how to generate the options tables for components from json during the website build using an Asciidoctor extension.


Also, upgrade to Antora 3 (alpha) and use symlinks rather than copying adoc files for components.",zregvart:1632178307:2021-09-21T06:51:47.347+0000:1632178307:2021-09-21T06:51:47.347+0000:This is done on the {{main}} branch.
0,CAMEL-16853,Bug,Major,None,"3.7.6, 3.11.2, 3.12.0","
None
",Resolved,Fixed,"3.7.6, 3.11.2, 3.12.0",Unassigned,Rik van Ballegooijen,0,2,2021-08-06 16:31:33+00:00,2021-08-10 19:51:06+00:00,"In XsltEndpoint.java,  createXsltBuilder() the resultHandlerFactory is set if configured.


However, further down in the method it is overwritten because of




configureOutput(xslt, output.name());



Since output is an enum which cannot be set to """" or null via Spring/XML, there is no way around this except for extending the Endpoint class and overriding the behavior.


Suggested solution is setting the result handler factory after configureOutput, or skipping configureOutput in case of a custom result handler factory.","davsclaus:1628455104:2021-08-09T04:38:24.324+0000:1628455104:2021-08-09T04:38:24.324+0000:You are welcome to provide a PR with a fix
rikvb:1628498951:2021-08-09T16:49:11.670+0000:1628498951:2021-08-09T16:49:11.670+0000:PR provided
davsclaus:1628596266:2021-08-10T19:51:06.508+0000:1628596266:2021-08-10T19:51:06.508+0000:Thanks for reporting and the PR"
0,CAMEL-16852,Improvement,Minor,3.11.0,None,"
None
",Resolved,Fixed,3.12.0,Unassigned,Hokutor,0,1,2021-08-05 19:46:37+00:00,2021-08-21 11:00:48+00:00,"Currently, all component modules of HuaweiCloud have duplicated model class ServiceKeys. Since its common across all hauwei components, this needs to be in a common package and re-used.


Refer discussion here -> https://camel.zulipchat.com/#narrow/stream/257298-camel/topic/Common.20package.20for.20HuaweiCloud.20components",hokutor:1628229602:2021-08-06T14:00:02.879+0000:1628229602:2021-08-06T14:00:02.879+0000:PR raised at https://github.com/apache/camel/pull/5940
0,CAMEL-16851,Improvement,Major,3.11.0,3.12.0,"
None
",Resolved,Fixed,3.12.0,Jeremy Ross,Jeremy Ross,0,1,2021-08-05 17:09:45+00:00,2021-08-05 21:33:11+00:00,"The salesforce component currently uses the login URL as the JWT audience, which doesn't work in all cases. We need the ability to override the audience value. This is needed when uses things like salesforce's Gov Cloud or custom domains.",
0,CAMEL-16850,Bug,Major,3.11.0,"3.11.2, 3.12.0","
None
",Resolved,Fixed,"3.11.2, 3.12.0",Claus Ibsen,Zoran Regvart,0,2,2021-08-05 09:27:53+00:00,2021-08-06 06:53:17+00:00,"The MainBootstrapCloseable clears and sets to null initial properties, override properties wildcard properties and main configuration properties on bootstrap of Camel context. Adding a route that depends on those properties after bootstrap is therefore no longer possible.


The value MainBootstrapCloseable has in static route configurations is at odds in dynamic route configurations.


Example (obviously not production code):




final Main main = new Main();main.addInitialProperty(""prop"", ""value"");
try (MainConfigurationProperties conf = main.configure()) {
	conf.addRoutesBuilder(new RouteBuilder() {
		@Override
		public void configure() throws Exception {
			from(""timer:one"").log(""{{prop}}"").process(e -> e.getContext().addRoutes(new RouteBuilder() {
				@Override
				public void configure() throws Exception {
					from(""timer:two"").log(""{{prop}}"");
				}
			}));
		}
	});
	main.run();
} 



Should the MainBootstrapCloseable be removed, or should the properties component be configured to incorporate these properties?","davsclaus:1628202820:2021-08-06T06:33:40.559+0000:1628202820:2021-08-06T06:33:40.559+0000:camel-main is intended for microservices styles where you dont dynamic add new routes and so on. But what we can tie this to is whether lightweight is true or false, so if false, then dont clear, if true then clear. 
davsclaus:1628203615:2021-08-06T06:46:55.340+0000:1628203615:2021-08-06T06:46:55.340+0000:So with the lightweight mode then this is actually better, as adding dyanamic routes is not allowed there so you get a better error"
0,CAMEL-16819,New Feature,Minor,3.11.0,3.12.0,"
None
",Resolved,Fixed,3.12.0,Unassigned,Jose Montoya,0,2,2021-07-26 21:14:26+00:00,2021-10-13 14:25:30+00:00,"Simply would like to add support for a configurable ExceptionPolicyStrategy. We're specifically looking to reverse the matching order, as to start from the top instead of the bottom. We feel this is more in line with Java's try-catch bevahiour so it's more intuitive to our new developers, and also for some of our devs coming from Mule developement.


 


Here's an exploratory implementation: https://github.com/MS3Inc/camel/commit/8433213caa8664fb5c61c8d1a3ab7bc8e1bdddd8


This one makes the default strategy non final which I think may have been the original intent since it has a few protected methods.","davsclaus:1627609294:2021-07-30T09:41:34.248+0000:1627609294:2021-07-30T09:41:34.248+0000:Can you submit a PR against main branch. Also if possible an unit test would be good with a custom strategy.
davsclaus:1627609396:2021-07-30T09:43:16.854+0000:1627609396:2021-07-30T09:43:16.854+0000:Also it may be easier if we just lookup in registry if there is a custom implementation of ExceptionPolicyStrategy and use that instead of the default. As we dont want to add a ton of APIs for making this configurable in the DSL.
davsclaus:1627794854:2021-08-01T13:14:14.355+0000:1627794854:2021-08-01T13:14:14.355+0000:Thanks for the PR. I polished the code a little bit"
0,CAMEL-16818,Bug,Minor,3.11.0,"3.11.1, 3.12.0","
None
",Resolved,Fixed,"3.11.1, 3.12.0",Claus Ibsen,Andrea Tarocchi,0,1,2021-07-26 14:55:02+00:00,2021-07-28 05:18:31+00:00,"Using route dump option of camel context does not print the correct route in case of using kamelet eip.


Find the reproducer here: https://github.com/valdar/camel/tree/issue/16818


run:




./mvnw clean verify -pl :camel-kamelet -Dtest=KameletRouteDumpTest




the test will pass but in the test log that you can find in components/camel-kamelet/target/camel-kamelet-test.log this is what is printed as route:




<routes xmlns=""http://camel.apache.org/schema/spring"">

    <route customId=""true"" id=""test"">
        <from uri=""direct:templateEmbedded""/>
        <kamelet id=""kamelet1"" name=""setBody?bodyValue=test""/>
    </route>

    <route customId=""true"" id=""setBody-1"" template=""true"">
        <from uri=""kamelet://source?routeId=setBody-1""/>
        <setBody id=""setBody1"">
            <constant>{{bodyValue}}</constant>
        </setBody>
        <to id=""to2"" uri=""kamelet://sink?routeId=setBody-1""/>
    </route>

</routes>




but there should be a to(...) statement after <kamelet id=""kamelet1"" name=""setBody?bodyValue=test""/> in the route with id=test.",
0,CAMEL-16817,Task,Major,None,"3.11.1, 3.12.0","
None
",Resolved,Fixed,"3.11.1, 3.12.0",Unassigned,Claus Ibsen,0,1,2021-07-26 09:23:07+00:00,2021-07-28 05:26:22+00:00,"[ERROR] Failed to execute goal on project apache-camel: Could not resolve dependencies for project org.apache.camel.karaf:apache-camel:pom:3.12.0-SNAPSHOT: Failed to collect dependencies at org.ops4j.pax.logging:pax-logging-service:jar:1.11.2 -> org.knopflerfish.kf6:log-API:jar:5.0.0: Failed to read artifact descriptor for org.knopflerfish.kf6:log-API:jar:5.0.0: Could not transfer artifact org.knopflerfish.kf6:log-API:pom:5.0.0 from/to maven-default-http-blocker (http://0.0.0.0/): Blocked mirror for repositories: [knopflerfish (http://resources.knopflerfish.org/repo/maven2/release, default, releases+snapshots)] -> [Help 1]","davsclaus:1627262619:2021-07-26T09:23:39.551+0000:1627262619:2021-07-26T09:23:39.551+0000:It looks like maven does not allow http repo access, so it should be https for that knoplerfish repo.

"
0,CAMEL-16816,Improvement,Minor,3.7.3,3.12.0,"

help-wanted

",Resolved,Fixed,3.12.0,Claus Ibsen,Sebastian Brandt,0,2,2021-07-22 17:08:46+00:00,2021-07-30 10:21:34+00:00,"For long running processes routing a lot of messages, integer overflows can occur, like:


2021-07-22 15:13:34.123 INFO 33 — [hroughputLogger] d.g.p.m.g.ReceiveThroughput : Received: -4294840335 new messages, with total -2147428547 so far. Last group took: 10000 millis which is: -429,484,033.5 messages per second. average: -4,225.12",davsclaus:1627278994:2021-07-26T13:56:34.815+0000:1627278994:2021-07-26T13:56:34.815+0000:You are welcome to work on a PR
0,CAMEL-16815,Bug,Minor,None,"3.11.1, 3.12.0","
None
",Resolved,Fixed,"3.11.1, 3.12.0",Claus Ibsen,Thomas Stuber,0,1,2021-07-22 10:10:41+00:00,2021-07-30 10:05:46+00:00,"I am writing an event to Kafka. The key and value are both written in Avro format (same entity used). Code is like:




// invokation: curl -H ""Content-Type: application/json"" -X POST -d '{""id"": ""1"", ""message"": ""some message text""}' localhost:8080/event
from(platformHttp(""/event"").httpMethodRestrict(HttpMethod.POST))
                .log(""Start"")
                .unmarshal().json(JsonLibrary.Jackson, AvroEntry.class)

                // set avro header
                .process(exchange -> {
                    exchange.getIn().setHeader(KafkaConstants.KEY, new AvroEntry(1L, ""header""));
                })

                .to(kafka(""{{kafka.to.topic}}"")
                    .brokers(""{{kafka.bootstrap.servers}}"")
                    .securityProtocol(""{{kafka.security.protocol}}"")
                    .sslContextParameters(getSslContext())
                    .sslKeystoreType(""{{kafka.ssl.keystore.type}}"")
                    .sslTruststoreType(""{{kafka.ssl.truststore.type}}"")
                    .schemaRegistryURL(""{{schema.registry.url}}"")
                    .valueSerializer(""{{kafka.value.serializer}}"")
                    .keySerializer(""{{kafka.key.serializer}}""))

                // Set response for invoker
                .setBody(constant(""{\""message\"": \""done\""}""))
                .log(""End"");




When OpenTracing is included, the following warning is shown:




2021-07-19 14:53:39,648 WARN  [org.apa.cam.tra.Tracer] (vert.x-worker-thread-1) Tracing: Failed to capture tracing data: java.lang.ClassCastException: class com.example.model.AvroEntry cannot be cast to class java.lang.String (com.example.model.AvroEntry is in unnamed module of loader io.quarkus.bootstrap.classloading.QuarkusClassLoader @46dd830d; java.lang.String is in module java.base of loader 'bootstrap')
        at org.apache.camel.tracing.decorators.KafkaSpanDecorator.pre(KafkaSpanDecorator.java:75)
        at org.apache.camel.tracing.Tracer$TracingEventNotifier.notify(Tracer.java:246)
        at org.apache.camel.support.EventHelper.doNotifyEvent(EventHelper.java:1240)
        at org.apache.camel.support.EventHelper.notifyExchangeSending(EventHelper.java:704)
        at org.apache.camel.processor.SendProcessor.process(SendProcessor.java:140)
        at org.apache.camel.processor.errorhandler.RedeliveryErrorHandler$SimpleTask.run(RedeliveryErrorHandler.java:395)
        at org.apache.camel.impl.engine.DefaultReactiveExecutor$Worker.schedule(DefaultReactiveExecutor.java:148)
        at org.apache.camel.impl.engine.DefaultReactiveExecutor.scheduleMain(DefaultReactiveExecutor.java:60)
        at org.apache.camel.processor.Pipeline.process(Pipeline.java:147)
        at org.apache.camel.impl.engine.CamelInternalProcessor.process(CamelInternalProcessor.java:312)
        at org.apache.camel.component.platform.http.vertx.VertxPlatformHttpConsumer.lambda$handleRequest$2(VertxPlatformHttpConsumer.java:184)
        at io.vertx.core.impl.ContextImpl.lambda$executeBlocking$2(ContextImpl.java:313)
        at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)
        at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)
        at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)
        at java.base/java.lang.Thread.run(Thread.java:829)




This comprehensive warning is written for every message.


 


However, the message is still written to Kafka. Seems like the tracer can not handle a non-string Key (https://github.com/apache/camel/blob/80b92e3624ae5db59a1a24a441f1b10b39eaa1a5/components/camel-tracing/src/main/java/org/apache/camel/tracing/decorators/KafkaSpanDecorator.java#L75). 


Furthermore, when using Avro format as message key, the uber-trace-id in the message headers is missing. See the comparision (kafkacat extract):




// When using no key
Topic: avro-topic
   Key (-1 bytes):
   Value (24 bytes): ""some message text
   Headers: Accept=*/*,Content-Length=43,Content-Type=application/json,Host=localhost:8080,uber-trace-id=a5c968dea6f3d52c:bfdfb86ec15171db:a5c968dea6f3d52c:0,User-Agent=curl/7.71.1
   Timestamp: 1626696278639
   Partition: 0
   Offset: 0

// When using Avro key (no trace info)
Topic: avro-topic
   Key (13 bytes): header
   Value (24 bytes): ""some message text
   Headers: Accept=*/*,Content-Length=43,Content-Type=application/json,Host=localhost:8080,User-Agent=curl/7.71.1
   Timestamp: 1626696849111
   Partition: 0
   Offset: 1




See also this discussion on zulip.",
0,CAMEL-16814,Test,Minor,None,"3.11.1, 3.12.0","
None
",Resolved,Fixed,"3.11.1, 3.12.0",Freeman Yue Fang,Freeman Yue Fang,0,1,2021-07-21 21:20:44+00:00,2021-07-21 21:28:42+00:00,This mainly port the testcase from CAMEL-16772(camel-sjms) to ensure we don't have the similar issue in camel-jms,
0,CAMEL-16813,Improvement,Minor,3.10.0,None,"
None
",Resolved,Fixed,3.12.0,Pasquale Congiusti,Pasquale Congiusti,0,3,2021-07-21 15:07:30+00:00,2021-07-30 06:39:46+00:00,"We've been reported a possible bug when using the RAW function including a ) character. This is interpreted as closing the RAW function, though it may be part of the argument.


As an example:




    from(""sftp:testserver/../testdir/?password=RAW(se+re?t)&23)"")




Will fail as the function will take only se+re?t as an argument. I wonder if there is any escape character and if not, I think it makes sense to include all the text until the last ) character.","squakez:1626851284:2021-07-21T15:08:04.693+0000:1626851284:2021-07-21T15:08:04.693+0000:If there is no escape character I can work on the fix.
tadayosi:1627249051:2021-07-26T05:37:31.451+0000:1627249140:2021-07-26T05:39:00.372+0000:[~squakez] As I sent to the user ML, I don't think this is a bug. If you use RAW(...) and "")&"" in the middle like:
{code:java}
    ?password=RAW(41)&fail)
{code}
there should be no way to syntactically parse the query uniquely. Parsing it as a single ""password"" key with value ""41)&fail"" is a valid way, but also parsing it as two params of password = ""41"" and no value key ""fail)"" can be valid. Let's see another example. How do we parse this query?
{code:java}
    ?param1=RAW(abc)&param2=RAW(def)
{code}
Is it param1 = ""abc)&param2=RAW(def)"" or param1 = ""abc"" and param2 = ""def""?

With CAMEL-12982 what we provide for such a case as using a password containing "")&"" is to use RAW\{...} instead of RAW(...).
{code:java}
    ?password=RAW{41)&fail}
{code}
For more detail on RAW() vs RAW{} I wrote an explanation here:
 https://issues.apache.org/jira/browse/CAMEL-12982?focusedCommentId=16744700&page=com.atlassian.jira.plugin.system.issuetabpanels%3Acomment-tabpanel#comment-16744700
squakez:1627256483:2021-07-26T07:41:23.031+0000:1627256483:2021-07-26T07:41:23.031+0000:Thanks for the explanation [~tadayosi]. I agree with your conclusions and I think it's a good thing to know which is the way to handle this corner case. I will add some documentation note in order to highlight that.
davsclaus:1627260685:2021-07-26T08:51:25.498+0000:1627260685:2021-07-26T08:51:25.498+0000:Yes its a corner case, and good idea to add a INFO in the docs.

Instead of RAW() you can use password=#property:myPass and then have myPass a property placeholder value.
See the docs at
https://camel.apache.org/manual/latest/property-binding.html"
0,CAMEL-16812,Bug,Minor,2.25.4,,"

UnitTest
camel-core
endpoint
mock

",Resolved,Not A Bug,None,Unassigned,José Bustamante,0,2,2021-07-20 15:56:27+00:00,2021-07-31 19:22:12+00:00,"I was implementing some unit tests for our camel routes of type direct-vm (we have 2 camel contexts in our project) and I ran with this issue. I wrote a post in StackOverflow, I added information there about the possible bug that I found.


When using the adviceWith, the mockEndpoints function doesn't seem to work with direct-vm routes, an exception is being thrown. As a work around i'm using weaveByToUri and replace, but perhaps It should work with mockEndpoints too. I'm using mockEndpoints() with no parameters and __ mockEndpoints(""direct-vm:*"") but none of them works.","davsclaus:1627609483:2021-07-30T09:44:43.271+0000:1627609483:2021-07-30T09:44:43.271+0000:Camel 2.x is not active manitained, we focus on security issues and really important bugs. A testing issue is not important.
davsclaus:1627609820:2021-07-30T09:50:20.014+0000:1627609820:2021-07-30T09:50:20.014+0000:seda and direct are not the same - a seda is using a queue in between the producer and consumer. direct does not and it must be linked to a consumer. So you need to add a from ( direct-vm :...) route for that
wayqui:1627730532:2021-07-31T19:22:12.592+0000:1627730532:2021-07-31T19:22:12.592+0000:Thanks for your response.  So I assume that's why *mockEndpoints* doesn't work for direct-vm routes, so I assume the work around I implemented (using ** *weaveByToUri* and *replaceTo*) is the correct way to implement unit tests for direct-vm routes."
0,CAMEL-16811,Bug,Minor,3.8.0,"3.11.1, 3.12.0","
None
",Resolved,Fixed,"3.11.1, 3.12.0",Claus Ibsen,Shannon Gallagher,0,2,2021-07-19 20:08:41+00:00,2021-07-30 08:46:18+00:00,"(Note: The component in question should be camel-sjms2, but that was not an option in the component list.)


Messages cannot be consumed from an sjms2 endpoint with a delivery mode query parameter specified.


To reproduce this issue, I was using InOnlyQueueProducerTest in both the camel-sjms and camel-sjms2 components. In both tests, I changed the first producer endpoint URI to the following (where component is sjms and sjms2, respectively):




.to(""[sjms,sjms2]:queue:"" + TEST_DESTINATION_NAME + ""?deliveryMode=1"");




The sjms test continues to succeed, but the sjms2 test fails due to the consumer not receiving the message before timing out.


 


I could not determine a root cause, but as a workaround, I did discover that manually setting the JMSDeliveryMode header in the route or in the send call did work as expected.","sgalla:1626700000:2021-07-19T21:06:40.389+0000:1626737390:2021-07-20T07:29:50.233+0000:Upon further investigation, I did find that I can consume a message from an sjms2 endpoint with deliveryMode specified, if I also set timeToLive.

I'm not sure if this is by design in the camel component or JMS 2.0, but I did not see any documentation indicating that I needed to set timeToLive in conjunction with deliveryMode.

I suppose this may be a non-issue if that is by design
davsclaus:1627600574:2021-07-30T07:16:14.525+0000:1627600574:2021-07-30T07:16:14.525+0000:What message broker are you using, and what exact version is that.

ActiveMQ v5 vs Artemis has a difference, and why the unit test of camel-sjms vs camel-sjms2 works differently.
davsclaus:1627604445:2021-07-30T08:20:45.907+0000:1627604445:2021-07-30T08:20:45.907+0000:Okay found a problem that the time to live was mistakenly used as -1 value, which Artemis handles differently than ActiveMQ v5. So adding a fix there."
0,CAMEL-16810,Task,Major,None,None,"
None
",Resolved,Fixed,3.19.0,Unassigned,Andrea Cosentino,0,2,2021-07-19 11:19:26+00:00,2022-09-03 08:09:27+00:00,"Zipkin seems to be dead. No releases in the last 8 months.


We have other solutions for tracing, so maybe it is worth to remove it in the coming releases.",davsclaus:1662163677:2022-09-03T08:07:57.207+0000:1662163677:2022-09-03T08:07:57.207+0000:yeah we have somewhat outdated code in camel-zipkin and its hard to maintain. The opentelemtry is recommended to use instead
0,CAMEL-16809,Improvement,Major,None,4.x,"
None
",Open,Unresolved,4.x,Andrea Cosentino,Andrea Cosentino,0,1,2021-07-16 13:00:51+00:00,2023-08-09 09:19:35+00:00,"https://github.com/aws/aws-sdk-java-v2/issues/1703


We could try to apply ACL in the way describe in this issue with a couple of headers. We can do this on multipart and put object operations for beginnig.


This is related to CAMEL-16806",
0,CAMEL-16808,Bug,Minor,3.11.0,,"
None
",Closed,Not A Problem,None,Unassigned,Karsten Reuter,0,3,2021-07-16 09:11:05+00:00,2021-10-28 15:42:44+00:00,"I am trying to use the camel-salesforce maven plugin to generate source code but the login fails with.


Failed to execute goal org.apache.camel.maven:camel-salesforce-maven-plugin:3.11.0:generate (default-cli) on project quarkus-teams-bot: Error connecting to Salesforce: Salesforce login error {errors:[

{""errorCode"":""unsupported_grant_type"",""message"":""Login error code:[unsupported_grant_type] description:[grant type not supported]"",""fields"":null}

],statusCode:400}


I tested my credentials with Insomnia and login works when I post as multipart form. When I post the data as FORM URL encoded as it is done in the plugin I receive the same error.","cm_karsten:1626611725:2021-07-18T20:35:25.832+0000:1626611725:2021-07-18T20:35:25.832+0000:I did some more investigation and found that there is a problem with redirects. I used the url that was shown after I logged in (it is a dev sandbox)

[https://xyz.lightning.force.com/services/oauth2/token]

which resulted in a redirect to

[https://xyz.my.salesforce.com/services/oauth2/token]

that causes a problem. A redirect where the data is form-url-encoded fails in the component and in Insomnia. When the data is submitted as multipart form Insomnia succeeds but the camel component still fails (I created a patched SalesforceSession version that used MultiPartContentProvider instead of FormContentProvider).

With debugging I found that the redirect request uses GET instead of POST and fails there. Unfortunately I did not yet find where the method is changed.

It seems there is still something wrong but it works if the login URL is correct.

 
jeremyross:1633162749:2021-10-02T16:19:09.661+0000:1633162749:2021-10-02T16:19:09.661+0000:So this works when you actually use the correct login URL. Sounds like no action needed.
davsclaus:1633650975:2021-10-08T07:56:15.711+0000:1633650975:2021-10-08T07:56:15.711+0000:Yeah lets close this ticket"
0,CAMEL-16807,Bug,Major,3.8.0,"3.7.6, 3.11.1, 3.12.0","
None
",Resolved,Fixed,"3.7.6, 3.11.1, 3.12.0",Andrea Cosentino,Eric Wittmann,0,2,2021-07-15 16:03:56+00:00,2021-07-20 09:51:19+00:00,"When using camel-kafka there will typically be many routes that produce to multiple Kafka topics with different schemas associated.


When using the camel-kafka client with apicurio, explicit schema artifacts set on Kafka producers override each other with the same settings despite them having different schema artifacts set through the camel additionalProperties settings.


This results in kafka client serialization exceptions stating a matching protobuf message is not found [1].


The expected behavior is that the apicurio properties should be applied to each Kafka producer independently.


A full example is available here: https://github.com/shuawest/apicurio-sandbox.


 




String kdestA = KafkaUriBuilder.create(ProducerService.TOPIC_A)
            .appendProperty(""brokers"", ""{{aregsandbox.kafka.brokers}}"")
            .appendProperty(""clientId"", ""producerA"")
            .appendProperty(""valueSerializer"", MyProtobufKafkaSerializer.class.getName())
            .appendProperty(""maxRequestSize"", ""5242880"")
            .appendAdditional(SerdeConfig.REGISTRY_URL, ""{{registryurl}}"")
            //.appendAdditional(SerdeConfig.SCHEMA_RESOLVER, MySchemaResolver.class.getName())
            //.appendAdditional(SerdeConfig.ARTIFACT_RESOLVER_STRATEGY, MyArtifactResolverStrategy.class.getName())
            .appendAdditional(SerdeConfig.EXPLICIT_ARTIFACT_GROUP_ID, ""aregsandbox"")
            .appendAdditional(SerdeConfig.EXPLICIT_ARTIFACT_ID, ""samplea"")
            .appendAdditional(SerdeConfig.FIND_LATEST_ARTIFACT, ""true"")
            //.appendAdditional(SerdeConfig.CHECK_PERIOD_MS, ""60000"")
            .value();
    
        String kdestB = KafkaUriBuilder.create(ProducerService.TOPIC_B)
            .appendProperty(""brokers"", ""{{aregsandbox.kafka.brokers}}"")
            .appendProperty(""clientId"", ""producerB"")
            .appendProperty(""valueSerializer"", MyProtobufKafkaSerializer.class.getName())
            .appendProperty(""maxRequestSize"", ""5242880"")
            .appendAdditional(SerdeConfig.REGISTRY_URL, ""{{registryurl}}"")
            //.appendAdditional(SerdeConfig.SCHEMA_RESOLVER, MySchemaResolver.class.getName())
            //.appendAdditional(SerdeConfig.ARTIFACT_RESOLVER_STRATEGY, MyArtifactResolverStrategy.class.getName())
            .appendAdditional(SerdeConfig.EXPLICIT_ARTIFACT_GROUP_ID, ""aregsandbox"")
            .appendAdditional(SerdeConfig.EXPLICIT_ARTIFACT_ID, ""sampleb"")
            .appendAdditional(SerdeConfig.FIND_LATEST_ARTIFACT, ""true"")
            //.appendAdditional(SerdeConfig.CHECK_PERIOD_MS, ""60000"")
            .value();
    
        log.info(""Kafka connection A: {}\n\n\n"", kdestA);
        log.info(""Kafka connection B: {}\n\n\n"", kdestB);

        from(""timer:producerTimerA?repeatCount=1000&delay=1s&period=1s"")
            .bean(this, ""genA"")
            //.log(""producer timer fired ${headers.genCount}:\n${body}"");
            .to(kdestA);

        from(""timer:producerTimerB?repeatCount=1000&delay=1s&period=1s"")
            .bean(this, ""genB"")
            //.log(""producer timer fired ${headers.genCount}:\n${body}"");
            .to(kdestB);




The root cause seems to be that the Kafka configuration is cloned for each new connector, but the clone does not make a copy of the additionalProperties field.  The result is that all Kafka configuration instances share the same Map of additionalProperties.


Tested in 3.8.0 but it looks like this problem exists in the latest current version as well.",
0,CAMEL-16806,Bug,Major,"3.7.5, 3.11.0","3.11.1, 3.12.0","
None
",Resolved,Fixed,"3.11.1, 3.12.0",Andrea Cosentino,Morgan L,0,1,2021-07-15 14:55:08+00:00,2021-09-30 10:34:30+00:00,"The documentation page for the AWS2 S3 component (here) refers to the `com.amazonaws.services.s3` package in several places. However, that package is not in the AWS2 API.


As a result, it is not clear what type of object is expected for headers such as `CamelAwsS3Acl` and URI arguments such as `amazonS3Client`. 


Discussion on Zulip: https://camel.zulipchat.com/#narrow/stream/257298-camel",
0,CAMEL-16805,Improvement,Minor,3.11.0,3.x,"
None
",Resolved,Won't Fix,3.x,Jiri Ondrusek,Jiri Ondrusek,0,2,2021-07-15 13:17:27+00:00,2023-07-17 11:35:17+00:00,"DefaultExchangeHolder should be revisited. It would be nice to use json/avro/protobuf instead of serialization.


It requires special behavior in camel-quarkus. See https://github.com/apache/camel-quarkus/pull/2904","davsclaus:1634166727:2021-10-14T07:12:07.607+0000:1634166727:2021-10-14T07:12:07.607+0000:Yeah having a SPI to plugin different serializers would be good. 

Because a Camel Exchange can contain anything then serialize this with avro/protobuf without any schema etc then that may be a challenge. So it may be that for those you need to specify some schema that the exchange (message body) should match.

"
0,CAMEL-16804,Bug,Minor,3.11.0,"3.11.1, 3.12.0","
None
",Resolved,Fixed,"3.11.1, 3.12.0",Zoran Regvart,Zoran Regvart,0,1,2021-07-15 09:05:36+00:00,2021-07-15 11:54:27+00:00,"When using try-with-resources with MainConfigurationProperties, MainConfigurationProperties::close might be invoked twice leading to NullPointerException on shutdown:




...
Caused by: java.lang.NullPointerException
	at all//org.apache.camel.main.MainConfigurationProperties.close(MainConfigurationProperties.java:88)
	at all//io.github.zregvart.dbzcamel.dbtodb.App.main(App.java:26)
	... 4 more




I.e. the Camel's shutdown will invoke MainConfigurationProperties::close, but also the try-with-resources bit if used like:




try (MainConfigurationProperties configure = main.configure()) {
    configure.addRoutesBuilder(Route.class);
    main.run(args);
} catch (final Exception e) {
    throw new RuntimeException(e);
}",
0,CAMEL-16803,Task,Minor,3.11.0,"3.11.1, 3.12.0","
None
",Resolved,Fixed,"3.11.1, 3.12.0",Freeman Yue Fang,Freeman Yue Fang,0,1,2021-07-13 17:04:43+00:00,2021-07-13 17:14:25+00:00,No Desc,
0,CAMEL-16802,Bug,Major,3.11.0,"3.7.6, 3.11.1, 3.12.0","
None
",Resolved,Fixed,"3.7.6, 3.11.1, 3.12.0",Claus Ibsen,Sergio Penkale,0,2,2021-07-12 15:40:22+00:00,2021-07-24 11:23:11+00:00,"Does the Split/Aggregate EIP guarantee that messages will be aggregated in the original order?




public class CamelTest extends CamelTestSupport {

    @Override
    protected RoutesBuilder createRouteBuilder() {
        return new RouteBuilder() {
            public void configure() {
                from(""direct:start"")
                  .split(body().tokenize("",""), new StringAggregationStrategy())
                    .parallelProcessing()
                    .to(""mock:foo"")
                  .end()
                  .to(""mock:result"");
            }
        };

    }

    @Test
    public void testSplitter() throws Exception {
        getMockEndpoint(""mock:result"").expectedBodiesReceived(""123"");
        template.sendBody(""direct:start"", ""1,2,3"");
        assertMockEndpointsSatisfied();
    }
}




With the above I get:




[ERROR] Failures: 
[ERROR]   CamelTest.testSplitter mock://result Body of message: 0. Expected: <123> but was: <231>




The actual order varies randomly from run to run.


 


In my real route I'm only able to reproduce this during the very first request after Camel has started.","davsclaus:1627083477:2021-07-24T07:37:57.539+0000:1627083477:2021-07-24T07:37:57.539+0000:Ah yeah so its because the splitter breaks down the 3 tasks into a reactive task that gets executed in parallel (you turned on parallel) but they can be executed in ""random"" order, and then each task then submit again a task for the when its done to aggregate the result, but those tasks are therefore submitted in random order, and hence why you get 231 etc.

So we have to move the submit ordering to an earlier phase or something
davsclaus:1627083691:2021-07-24T07:41:31.444+0000:1627086640:2021-07-24T08:30:40.282+0000:TODO: Added unit test in class Split123ParallelTest *DONE*"
0,CAMEL-16801,Bug,Major,3.11.0,,"
None
",Closed,Not A Problem,None,Otavio Rodolfo Piske,Otavio Rodolfo Piske,0,1,2021-07-12 08:50:57+00:00,2021-07-12 12:11:51+00:00,"This is related to a discussion initially raised on ticket CAMEL-16797. It seems that the ability to run tests in a remote docker instance is not working. I am creating a separate ticket because that one was rejected.


 


This is a very handy feature provided by test containers and leveraged by our test infra, and we should make sure it works if supported.","orpiske:1626063111:2021-07-12T12:11:51.093+0000:1626063111:2021-07-12T12:11:51.093+0000:After careful investigation, this was caused by having the `UnixSocketClientProviderStrategy` on the `~/.testcontainers.properties` file."
0,CAMEL-16800,Wish,Major,"3.9.0, 3.10.0, 3.11.0",,"
None
",Resolved,Won't Fix,None,Unassigned,Tom Cassimon,0,2,2021-07-12 06:37:17+00:00,2021-07-30 10:25:35+00:00,We use this property to check after a part of the route is done if the filter specified in that part of the route has a match or not. It would be handy to re-introduce this as now we need to implement custom logic to achieve this.,davsclaus:1627611935:2021-07-30T10:25:35.020+0000:1627611935:2021-07-30T10:25:35.020+0000:Its a core optimization that adds some unnessary overhead 
0,CAMEL-16799,Dependency upgrade,Major,None,None,"
None
",Resolved,Fixed,3.12.0,James Netherton,Claus Ibsen,0,1,2021-07-09 11:37:13+00:00,2021-07-28 07:51:34+00:00,"There are some newer releases that works with latest vert.x and quarkus, we should upgrade the versions we use in camel.","davsclaus:1627420763:2021-07-28T05:19:23.532+0000:1627420763:2021-07-28T05:19:23.532+0000:James do you mind looking at this, we need to catch up with quarkus"
0,CAMEL-16798,Task,Major,3.12.0,3.12.0,"
None
",Resolved,Fixed,3.12.0,Unassigned,Michael Genereux,0,1,2021-07-09 00:05:38+00:00,2021-07-09 04:21:09+00:00,"On case-sensitive SQL implementations that also manipulate the case of unquoted SQL names, the `JdbcCachedIdempotentMessageIdRepository` uses column names to retrieve SQL results and fails.  While this is a failure on the part of the SQL implementation, there's no reason that using column index methods can't be used and fix the problem.",
0,CAMEL-16797,Task,Critical,3.9.0,,"
None
",Resolved,Invalid,None,Otavio Rodolfo Piske,Nayana Thorat,0,2,2021-07-08 18:08:42+00:00,2021-07-12 08:51:20+00:00,"I have build apache camel v3.9.0 from source and also executing tests as mentioned in 
https://camel.apache.org/manual/latest/building.html


while executing mvn install I observed that testcases for some components like camel-couchdb or camel-arangodb are activated only if docker is installed whereas tests for components like camel-couchbase are executed even if docker is not installed. Curious to know why the difference.


Another question is how to run the tests using a remote docker server? ( camel code on one host from where we execute mvn install and docker running on another host)


I tried overriding DOCKER_HOST variable as mentioned here  but it didn't help. 
DOCKER_HOST=tcp://myhost:2375 mvn clean install


Am I missing anything here?",davsclaus:1625775778:2021-07-09T04:22:58.417+0000:1625775778:2021-07-09T04:22:58.417+0000:Use the mailing list or chat room for asking such kind of questions
0,CAMEL-16796,Bug,Major,3.11.0,"3.11.1, 3.12.0","
None
",Resolved,Fixed,"3.11.1, 3.12.0",Freeman Yue Fang,Tom Cassimon,0,1,2021-07-08 14:29:01+00:00,2023-01-23 10:03:49+00:00,"Following our discussion on zulip:


https://camel.zulipchat.com/#narrow/stream/257298-camel/topic/inflight.20repository


i've created this ticket to investigate the issue.


 


The two stacktraces of the call to the remove method of DefaultInflightRepository:




at org.apache.camel.impl.engine.DefaultInflightRepository.remove(DefaultInflightRepository.java:62)
    at org.apache.camel.impl.engine.DefaultUnitOfWork.done(DefaultUnitOfWork.java:241)
    at org.apache.camel.support.UnitOfWorkHelper.doneUow(UnitOfWorkHelper.java:59)
    at org.apache.camel.support.DefaultConsumer.doneUoW(DefaultConsumer.java:124)
    at org.apache.camel.component.cxf.CxfConsumer$CxfConsumerInvoker.asyncInvoke(CxfConsumer.java:201)
    at org.apache.camel.component.cxf.CxfConsumer$CxfConsumerInvoker.invoke(CxfConsumer.java:161)
    at org.apache.cxf.interceptor.ServiceInvokerInterceptor$1.run(ServiceInvokerInterceptor.java:59)
    at org.apache.cxf.interceptor.ServiceInvokerInterceptor.handleMessage(ServiceInvokerInterceptor.java:96)
    at org.apache.cxf.phase.PhaseInterceptorChain.doIntercept(PhaseInterceptorChain.java:308)
    at org.apache.cxf.phase.PhaseInterceptorChain.resume(PhaseInterceptorChain.java:278)
    at org.apache.cxf.transport.ChainInitiationObserver.onMessage(ChainInitiationObserver.java:78)
    at org.apache.cxf.transport.http.AbstractHTTPDestination.invoke(AbstractHTTPDestination.java:265)
    at org.apache.cxf.transport.http_jetty.JettyHTTPDestination.doService(JettyHTTPDestination.java:247)
    at org.apache.cxf.transport.http_jetty.JettyHTTPHandler.handle(JettyHTTPHandler.java:79)
    at org.eclipse.jetty.server.handler.HandlerWrapper.handle(HandlerWrapper.java:127)
    at org.eclipse.jetty.server.handler.ScopedHandler.nextHandle(ScopedHandler.java:235)
    at org.eclipse.jetty.server.handler.ContextHandler.doHandle(ContextHandler.java:1435)
    at org.eclipse.jetty.server.handler.ScopedHandler.nextScope(ScopedHandler.java:190)
    at org.eclipse.jetty.server.handler.ContextHandler.doScope(ContextHandler.java:1350)
    at org.eclipse.jetty.server.handler.ScopedHandler.handle(ScopedHandler.java:141)
    at org.eclipse.jetty.server.handler.ContextHandlerCollection.handle(ContextHandlerCollection.java:191)
    at org.eclipse.jetty.server.handler.HandlerWrapper.handle(HandlerWrapper.java:127)
    at org.eclipse.jetty.server.Server.handleAsync(Server.java:559)
    at org.eclipse.jetty.server.HttpChannel.lambda$handle$2(HttpChannel.java:396)
    at org.eclipse.jetty.server.HttpChannel$$Lambda$629.1395631876.dispatch(Unknown Source:-1)
    at org.eclipse.jetty.server.HttpChannel.dispatch(HttpChannel.java:633)
    at org.eclipse.jetty.server.HttpChannel.handle(HttpChannel.java:396)
    at org.eclipse.jetty.server.HttpConnection.onFillable(HttpConnection.java:277)
    at org.eclipse.jetty.io.AbstractConnection$ReadCallback.succeeded(AbstractConnection.java:311)
    at org.eclipse.jetty.io.FillInterest.fillable(FillInterest.java:105)
    at org.eclipse.jetty.io.ChannelEndPoint$1.run(ChannelEndPoint.java:104)
    at org.eclipse.jetty.util.thread.QueuedThreadPool.runJob(QueuedThreadPool.java:882)
    at org.eclipse.jetty.util.thread.QueuedThreadPool$Runner.run(QueuedThreadPool.java:1036)
    at java.lang.Thread.run(Thread.java:748)






 
at org.apache.camel.impl.engine.DefaultInflightRepository.remove(DefaultInflightRepository.java:62) at org.apache.camel.impl.engine.DefaultUnitOfWork.done(DefaultUnitOfWork.java:241) at org.apache.camel.support.UnitOfWorkHelper.doneUow(UnitOfWorkHelper.java:59) at org.apache.camel.component.cxf.util.CxfUtils.closeCamelUnitOfWork(CxfUtils.java:46) at org.apache.camel.component.cxf.CxfConsumer.lambda$createServer$0(CxfConsumer.java:87) at org.apache.camel.component.cxf.CxfConsumer$$Lambda$583.392278313.onMessage(Unknown Source:-1) at org.apache.cxf.phase.PhaseInterceptorChain.wrapExceptionAsFault(PhaseInterceptorChain.java:374) at org.apache.cxf.phase.PhaseInterceptorChain.doIntercept(PhaseInterceptorChain.java:332) at org.apache.cxf.phase.PhaseInterceptorChain.resume(PhaseInterceptorChain.java:278) at org.apache.cxf.transport.ChainInitiationObserver.onMessage(ChainInitiationObserver.java:78) at org.apache.cxf.transport.http.AbstractHTTPDestination.invoke(AbstractHTTPDestination.java:265) at org.apache.cxf.transport.http_jetty.JettyHTTPDestination.doService(JettyHTTPDestination.java:247) at org.apache.cxf.transport.http_jetty.JettyHTTPHandler.handle(JettyHTTPHandler.java:79) at org.eclipse.jetty.server.handler.HandlerWrapper.handle(HandlerWrapper.java:127) at org.eclipse.jetty.server.handler.ScopedHandler.nextHandle(ScopedHandler.java:235) at org.eclipse.jetty.server.handler.ContextHandler.doHandle(ContextHandler.java:1435) at org.eclipse.jetty.server.handler.ScopedHandler.nextScope(ScopedHandler.java:190) at org.eclipse.jetty.server.handler.ContextHandler.doScope(ContextHandler.java:1350) at org.eclipse.jetty.server.handler.ScopedHandler.handle(ScopedHandler.java:141) at org.eclipse.jetty.server.handler.ContextHandlerCollection.handle(ContextHandlerCollection.java:191) at org.eclipse.jetty.server.handler.HandlerWrapper.handle(HandlerWrapper.java:127) at org.eclipse.jetty.server.Server.handleAsync(Server.java:559) at org.eclipse.jetty.server.HttpChannel.lambda$handle$2(HttpChannel.java:396) at org.eclipse.jetty.server.HttpChannel$$Lambda$629.1395631876.dispatch(Unknown Source:-1) at org.eclipse.jetty.server.HttpChannel.dispatch(HttpChannel.java:633) at org.eclipse.jetty.server.HttpChannel.handle(HttpChannel.java:396) at org.eclipse.jetty.server.HttpConnection.onFillable(HttpConnection.java:277) at org.eclipse.jetty.io.AbstractConnection$ReadCallback.succeeded(AbstractConnection.java:311) at org.eclipse.jetty.io.FillInterest.fillable(FillInterest.java:105) at org.eclipse.jetty.io.ChannelEndPoint$1.run(ChannelEndPoint.java:104) at org.eclipse.jetty.util.thread.QueuedThreadPool.runJob(QueuedThreadPool.java:882) at org.eclipse.jetty.util.thread.QueuedThreadPool$Runner.run(QueuedThreadPool.java:1036) at java.lang.Thread.run(Thread.java:748)","TCke83:1625790703:2021-07-09T08:31:43.390+0000:1625790703:2021-07-09T08:31:43.390+0000:If I add following code to the CxfConsumerPayloadFaultTest at the end of the test method it returns -1

 
{code:java}
assertEquals(0, context.getInflightRepository().size()){code}"
0,CAMEL-16795,Bug,Minor,3.11.0,"3.11.1, 3.12.0","
None
",Resolved,Fixed,"3.11.1, 3.12.0",Unassigned,Philippe Schaller,0,2,2021-07-08 13:12:10+00:00,2021-07-09 07:25:06+00:00,"I am not sure what [1] tried to solve, but it surely introduced a regression with the read-lock behavior. The removal of brackets in line 90/91 in the file FileChangedExclusiveReadLockStrategy.java completely changed the semantics of that if-clause.


[1] https://github.com/apache/camel/commit/c5bbbd5b58569fbbd00d2936223f4d52ed23f78d#diff-e90f2831ab339881c4b627055a7bb905fa9762171f00a362898ee252b0e25122","davsclaus:1625723921:2021-07-08T13:58:41.511+0000:1625723921:2021-07-08T13:58:41.511+0000:You are welcome to send a PR against main branch
philschaller:1625726868:2021-07-08T14:47:48.897+0000:1625726868:2021-07-08T14:47:48.897+0000:PR attached. Just a partial revert of the aforementioned commit.

A PR for better read-lock testing (integration tests) in Camel-Quarkus is also ready:
https://github.com/apache/camel-quarkus/pull/2889

Looks like we have a different opinion on the priority, but I guess you win :-)
davsclaus:1625727262:2021-07-08T14:54:22.042+0000:1625727262:2021-07-08T14:54:22.042+0000:You can plugin your own read-lock and have it working
philschaller:1625727705:2021-07-08T15:01:45.272+0000:1625727705:2021-07-08T15:01:45.272+0000:Thanks for the hint. I will give that one a try."
0,CAMEL-16794,Bug,Major,"3.8.0, 3.11.0","3.11.1, 3.12.0","
None
",Resolved,Fixed,"3.11.1, 3.12.0",Unassigned,Sergio Penkale,0,1,2021-07-08 10:36:02+00:00,2021-07-08 14:23:19+00:00,"I get random errors when using the Loop EIP with more than one concurrent request. It started happening from release 3.8.0.
 This reproduces it:




from(""servlet:test"")
    .log(""test.exchangeId=${exchangeId}"")
    .loop(1)
        .log(""loop.exchangeId=${exchangeId}"")
.end();




When testing with the following the client times out:




ab -n1000 -c 2 http://localhost:8080/camel/test



 


Note in the logs below how thread 4 starts working on exchange 0FBD82C2E690DA5-0000000000000018 but then switches to exchange 0FBD82C2E690DA5-0000000000000017


This is because the state is created and then scheduled in a non atomic way, so by the time it gets scheduled another thread has changed it:




state = new LoopState(exchange, callback);

if (exchange.isTransacted()) {
   reactiveExecutor.scheduleSync(state);
} else {
   reactiveExecutor.scheduleMain(state);
}






2021-07-08 10:04:28.717 TRACE 18495 --- [nio-8080-exec-4] o.a.c.i.engine.CamelInternalProcessor    : Processing exchange for exchangeId: 0FBD82C2E690DA5-0000000000000018 -> Exchange[0FBD82C2E690DA5-0000000000000018]
2021-07-08 10:04:28.717 TRACE 18495 --- [nio-8080-exec-5] o.a.c.i.engine.CamelInternalProcessor    : Processing exchange for exchangeId: 0FBD82C2E690DA5-0000000000000017 -> Exchange[0FBD82C2E690DA5-0000000000000017]
2021-07-08 10:04:28.717 TRACE 18495 --- [nio-8080-exec-4] o.a.c.i.engine.DefaultReactiveExecutor   : Schedule [first=true, main=true, sync=false]: SimpleTask
2021-07-08 10:04:28.717 TRACE 18495 --- [nio-8080-exec-5] o.a.c.i.engine.DefaultReactiveExecutor   : Schedule [first=true, main=true, sync=false]: SimpleTask
2021-07-08 10:04:28.717 TRACE 18495 --- [nio-8080-exec-4] o.a.c.i.engine.DefaultReactiveExecutor   : Queuing reactive work: SimpleTask
2021-07-08 10:04:28.717 TRACE 18495 --- [nio-8080-exec-5] o.a.c.i.engine.DefaultReactiveExecutor   : Queuing reactive work: SimpleTask
2021-07-08 10:04:28.717 TRACE 18495 --- [nio-8080-exec-4] o.a.c.i.engine.CamelInternalProcessor    : Exchange processed and is continued routed asynchronously for exchangeId: 0FBD82C2E690DA5-0000000000000018 -> Exchange[0FBD82C2E690DA5-0000000000000018]
2021-07-08 10:04:28.717 TRACE 18495 --- [nio-8080-exec-5] o.a.c.i.engine.CamelInternalProcessor    : Exchange processed and is continued routed asynchronously for exchangeId: 0FBD82C2E690DA5-0000000000000017 -> Exchange[0FBD82C2E690DA5-0000000000000017]
2021-07-08 10:04:28.717 TRACE 18495 --- [nio-8080-exec-4] o.a.c.i.engine.DefaultReactiveExecutor   : Worker #4 running: org.apache.camel.processor.Pipeline$PipelineTask@3a83e1b8
2021-07-08 10:04:28.717 TRACE 18495 --- [nio-8080-exec-5] o.a.c.i.engine.DefaultReactiveExecutor   : Worker #5 running: org.apache.camel.processor.Pipeline$PipelineTask@74d4d21
2021-07-08 10:04:28.717 TRACE 18495 --- [nio-8080-exec-5] o.a.c.i.c.CoreTypeConverterRegistry      : Finding type converter to convert java.lang.String -> java.lang.Integer with value: 1
2021-07-08 10:04:28.717 TRACE 18495 --- [nio-8080-exec-4] o.a.c.i.c.CoreTypeConverterRegistry      : Finding type converter to convert java.lang.String -> java.lang.Integer with value: 1
2021-07-08 10:04:28.717 TRACE 18495 --- [nio-8080-exec-5] o.a.c.i.c.CoreTypeConverterRegistry      : Using bulk converter: CamelBaseBulkConverterLoader to convert [class java.lang.String=>class java.lang.Integer]
2021-07-08 10:04:28.717 TRACE 18495 --- [nio-8080-exec-4] o.a.c.i.c.CoreTypeConverterRegistry      : Using bulk converter: CamelBaseBulkConverterLoader to convert [class java.lang.String=>class java.lang.Integer]
2021-07-08 10:04:28.718 TRACE 18495 --- [nio-8080-exec-4] o.a.c.i.engine.DefaultReactiveExecutor   : Schedule [first=true, main=true, sync=false]: LoopState
2021-07-08 10:04:28.718 TRACE 18495 --- [nio-8080-exec-5] o.a.c.i.engine.DefaultReactiveExecutor   : Schedule [first=true, main=true, sync=false]: LoopState
2021-07-08 10:04:28.718 TRACE 18495 --- [nio-8080-exec-4] o.a.c.i.engine.DefaultReactiveExecutor   : Queuing reactive work: LoopState
2021-07-08 10:04:28.718 TRACE 18495 --- [nio-8080-exec-5] o.a.c.i.engine.DefaultReactiveExecutor   : Queuing reactive work: LoopState
2021-07-08 10:04:28.718 TRACE 18495 --- [nio-8080-exec-4] o.a.c.i.engine.DefaultReactiveExecutor   : Worker #4 running: org.apache.camel.processor.Pipeline$PipelineTask@3a83e1b8
2021-07-08 10:04:28.718 TRACE 18495 --- [nio-8080-exec-5] o.a.c.i.engine.DefaultReactiveExecutor   : Worker #5 running: org.apache.camel.processor.Pipeline$PipelineTask@74d4d21
2021-07-08 10:04:28.718 DEBUG 18495 --- [nio-8080-exec-4] o.apache.camel.processor.LoopProcessor   : LoopProcessor: iteration #0
2021-07-08 10:04:28.718 DEBUG 18495 --- [nio-8080-exec-5] o.apache.camel.processor.LoopProcessor   : LoopProcessor: iteration #0
2021-07-08 10:04:28.718 TRACE 18495 --- [nio-8080-exec-4] o.a.c.i.engine.CamelInternalProcessor    : Processing exchange for exchangeId: 0FBD82C2E690DA5-0000000000000017 -> Exchange[0FBD82C2E690DA5-0000000000000017]
2021-07-08 10:04:28.718 TRACE 18495 --- [nio-8080-exec-4] o.a.c.i.engine.DefaultReactiveExecutor   : Schedule [first=true, main=true, sync=false]: SimpleTask
2021-07-08 10:04:28.718 TRACE 18495 --- [nio-8080-exec-4] o.a.c.i.engine.DefaultReactiveExecutor   : Queuing reactive work: SimpleTask
2021-07-08 10:04:28.718 TRACE 18495 --- [nio-8080-exec-5] o.a.c.i.engine.CamelInternalProcessor    : Processing exchange for exchangeId: 0FBD82C2E690DA5-0000000000000017 -> Exchange[0FBD82C2E690DA5-0000000000000017]",spenkale:1625711893:2021-07-08T10:38:13.734+0000:1625711893:2021-07-08T10:38:13.734+0000:please review the proposed fix: https://github.com/apache/camel/pull/5813
0,CAMEL-16793,Bug,Major,"2.25.3, 3.11.0","3.11.2, 3.12.0","
None
",Resolved,Fixed,"3.11.2, 3.12.0",James Netherton,Grigorii Ivanov,0,4,2021-07-08 08:03:05+00:00,2021-09-07 14:03:32+00:00,"From documentation - https://camel.apache.org/manual/latest/rest-dsl.html#_configuring_rest_dsl





apiHost
-
Specific hostname for the API documentation (eg swagger)
This can be used to override the generated host with this configured hostname





In fact the option's value gets lost with both camel-swagger and camel-oneapi components, see also camel mailing list","avi5kdonrh:1625720222:2021-07-08T12:57:02.131+0000:1625720222:2021-07-08T12:57:02.131+0000:From the Openapi perspective, this doesn't look like a bug. It is setting the URL that way because you are not sending any X-Forward headers. Either disable using the X-Forward headers like so:

 
{code:java}
restConfiguration().component(""undertow"").contextPath(""/rest"")
        .useXForwardHeaders(false)
        .port(8090)
        .apiContextPath(""/api"")
{code}
Or, use the X-Forward headers when you call the API context:

 

 
{code:java}
curl -H ""X-Forwarded-Proto: http"" -H  ""X-Forwarded-Host: example.com"" http://localhost:8080/rest/api

{code}
It will give you a result like this:
{code:java}
  ""servers"" : [ {

    ""url"" : ""http://example.com/rest""

  } ],

{code}
 
greenev:1625790233:2021-07-09T08:23:53.187+0000:1625790233:2021-07-09T08:23:53.187+0000:[~avi5kdonrh], thanks a lot! It seems now that the only thing we should do here is to add this hint to the docs, or?
avi5kdonrh:1626046764:2021-07-12T07:39:24.030+0000:1626046764:2021-07-12T07:39:24.030+0000:Hi [~davsclaus], can we add these instructions to the openapi component docs? https://camel.apache.org/components/3.4.x/others/openapi-java.html
davsclaus:1627081686:2021-07-24T07:08:06.604+0000:1627081686:2021-07-24T07:08:06.604+0000:Yes you are welcome to add instructions to the docs, I suggest to do this on the main branch, then we can backport to older branches.
jamesnetherton:1630900002:2021-09-06T11:46:42.620+0000:1630900002:2021-09-06T11:46:42.620+0000:I just stumbled across the same problem. X-Forwarded-* headers are typically only relevant to requests coming from behind a proxy or load balancer. They are not guaranteed to be present.

I'll see if I can figure out why the host API property is lost.
jamesnetherton:1630972328:2021-09-07T07:52:08.683+0000:1630972328:2021-09-07T07:52:08.683+0000:Ok, so reading the background of CAMEL-13126, I understand the useXForwardHeaders thing a bit better. I'll drop a note into the documentation on how this affect things."
0,CAMEL-16792,Improvement,Major,3.11.0,"3.11.1, 3.12.0","
None
",Resolved,Fixed,"3.11.1, 3.12.0",Claus Ibsen,Jeremy Ross,0,2,2021-07-07 16:25:36+00:00,2021-07-08 14:33:49+00:00,I believe that Simple was updated so that ${exchangeProperty} looks up to `allProperties` on the exchange. I think it would be consistent and convenient if OGNL's `properties` and `property` variables also looked up to `allProperties`,"davsclaus:1625726029:2021-07-08T14:33:49.055+0000:1625726029:2021-07-08T14:33:49.055+0000:mvel, ognl and spel"
0,CAMEL-16791,Improvement,Major,3.11.0,4.x,"
None
",Open,Unresolved,4.x,Claus Ibsen,Jeremy Ross,0,3,2021-07-07 15:11:30+00:00,2023-08-09 09:19:40+00:00,"Perhaps should default to 1, or make it easily globally configured.","davsclaus:1627426433:2021-07-28T06:53:53.544+0000:1627426433:2021-07-28T06:53:53.544+0000:Jeremy can you point to your zulip chat where you talked about this, and post the link in this JIRA, we need to be able to track this.
jeremyross:1629285406:2021-08-18T19:16:46.296+0000:1629285406:2021-08-18T19:16:46.296+0000:[~davsclaus] sorry just noticed this. 

Zuplip thread: https://camel.zulipchat.com/#narrow/stream/257298-camel/topic/Aggregate.20worker.20pool.20changes.20in.203.2E11
jeremyross:1634722492:2021-10-20T17:34:52.285+0000:1634722492:2021-10-20T17:34:52.285+0000:[~davsclaus] can we get this back ported to 3.11.x?
klease78:1641377810:2022-01-05T18:16:50.117+0000:1641377810:2022-01-05T18:16:50.117+0000:I had a look at this, using the test AggregateConcurrentPerCorrelationKeyTest as a basis. In the current 3.15-SNAPSHOT, I don't find any behavior like [~jeremyross] described:
{quote}I'm seeing behavior in which the aggregate appears to be absorbing around 1,000 exchanges before letting them go. Does this pool have a queue, perhaps of size 1,000? Or is something else causing this?
{quote}
The thread pool and its queue don't actually play a role in deciding how many exchanges to aggregate; only the completed exchange for each aggregate is queued via the thread pool for further processing, and this doesn't appear to be significantly different in 3.11.0 and 3.15.

At least in the test case, the thread pool runs the completed aggregate tasks immediately if the worker thread is not busy or queues them until the worker thread is available. If I modify the test to specify a thread pool with a queue size of 1 and the CallerRunsPolicy, I notice that a significant number of the completed aggregates are in fact processed in the calling thread and not in the thread pool, since this test generates events quickly. So I think using a default queue of 1 is not a good idea.

 
jeremyross:1641381813:2022-01-05T19:23:33.336+0000:1641381813:2022-01-05T19:23:33.336+0000:The behavior I was seeing was the aggregator holding 1000 *aggregated* exchanges prior to releasing them. I suppose this could have just been an artifact of thread scheduling, but regardless, it resulted in drastically different behavior than < 3.11.
klease78:1641910265:2022-01-11T22:11:05.160+0000:1641910265:2022-01-11T22:11:05.160+0000:The only scenario I can imagine which would fill the queue with the aggregated exchanges is that when one of them is processed it takes a long time to run (or is much slower than the process generating the aggregates), so that the worker thread remains busy and any new arrivals are queued. Does that sound possible in your use case?
jeremyross:1641910434:2022-01-11T22:13:54.337+0000:1641910434:2022-01-11T22:13:54.337+0000:[~klease78] Yes. Inbound to the aggregator is reading off disk. Out of the aggregator are remote API calls. 
klease78:1641976476:2022-01-12T16:34:36.673+0000:1641976476:2022-01-12T16:34:36.673+0000:[~jeremyross] I guess that could cause such behavior. Then what I'd expect is if the inbound is running in a single thread, that thread would also be used to execute the outbound API call so it would basically slow down the processing to match what the remote can handle. So for example, you might see one aggregate being completed by the Aggregator thread but following ones being completed by the thread sending events to the aggregator (pool-3-thread3 in the test case log below.)
{code:java}
[Camel (camel-1) thread #1 - Aggregator] TRACE AggregateProcessor             - Aggregated exchange onComplete: Exchange[DEB82B7F5DE944A-00000000000000D7]
[pool-3-thread-3                       ] TRACE AggregateProcessor             - Aggregated exchange onComplete: Exchange[DEB82B7F5DE944A-00000000000000D9]{code}
Unless your inbound side is already multi-threaded, maybe it would be interesting to use an aggregator thread pool with more threads.
jeremyross:1641977518:2022-01-12T16:51:58.387+0000:1641977518:2022-01-12T16:51:58.387+0000:[~klease78] Inbound is single threaded, and I've got the aggregator using a pool with a single thread. Really the issue was the aggregator now has a default queue size of 1000, which filled up instantaneously. The problem that creates for me is it makes tracing and debugging more difficult."
0,CAMEL-16790,Improvement,Major,None,3.12.0,"
None
",Resolved,Fixed,3.12.0,Unassigned,Kai Levy,0,2,2021-07-06 22:24:30+00:00,2021-07-29 13:02:48+00:00,"I have filed a bug in the pulsar project about uneven distribution of messages using the Java client:  https://github.com/apache/pulsar/issues/11008 - there are some reproduction instructions in this ticket. This means that for large backlogs, only the instances that were connected when the messages were produced will be able to process the messages.


The issue occurs when you use a consumer with `messageListener` and set `receiverQueueSize > 0`. It appears that the camel-pulsar component uses that message listener: https://github.com/apache/camel/blob/main/components/camel-pulsar/src/main/java/org/apache/camel/component/pulsar/utils/consumers/CommonCreationStrategyImpl.java#L54


 


We observed the issue in our camel application using camel 3.5.0, but I believe it occurs on more versions. If the issue is not fixed in the java client, a convenient workaround could be to use a threadpool calling `consumer.receive()` in a loop instead of `messageListener`.","davsclaus:1625605536:2021-07-07T05:05:36.127+0000:1625605536:2021-07-07T05:05:36.127+0000:This appear to be mostly a pulsar issue so lets see what they say
klevy-toast:1625663095:2021-07-07T21:04:55.986+0000:1625663095:2021-07-07T21:04:55.986+0000:[~davsclaus] agree that it is a pulsar issue but I haven't had much success getting the maintainers to look at it, and if it is patched it will be in a future version. Might be worth designing a workaround in the meantime anyway.
davsclaus:1625715999:2021-07-08T11:46:39.202+0000:1625715999:2021-07-08T11:46:39.202+0000:Would you have time to implement a workaround? You can then also test it on your system.

klevy-toast:1625726000:2021-07-08T14:33:20.349+0000:1625726000:2021-07-08T14:33:20.349+0000:Yes, I will look at implementing a fix in the next couple weeks
klevy-toast:1627278477:2021-07-26T13:47:57.978+0000:1627278477:2021-07-26T13:47:57.978+0000:[~davsclaus] I've worked on a fix that is mostly complete (just need to test out process shutdown): [https://github.com/klevy-toast/camel/pull/1/files - |https://github.com/klevy-toast/camel/pull/1/files]although just the other day I got through to the pulsar folks and they are working on a fix to be released in 2.9.0. Where do you stand on patching the bug in camel directly, given that?
davsclaus:1627278939:2021-07-26T13:55:39.889+0000:1627278939:2021-07-26T13:55:39.889+0000:Okay since its coming so soon in 2.9.0, then I would prefer to wait for them.

However your local fix could be temporary fix (as preview) and be marked as deprecated and release in Camel 3.12, and then when pulsar 2.9.0 is out, then we upgrade and remove your temporary fix.

And your fix should only be ""enabled"" if explicit configured by the end user (not enabled by default).
klevy-toast:1627279134:2021-07-26T13:58:54.483+0000:1627279134:2021-07-26T13:58:54.483+0000:OK, sounds good. Do I need to change anything to mark the fix as preview?
davsclaus:1627281360:2021-07-26T14:36:00.319+0000:1627281360:2021-07-26T14:36:00.319+0000:Not really, you can say preview in the documentation. 
klevy-toast:1627386265:2021-07-27T19:44:25.402+0000:1627386265:2021-07-27T19:44:25.402+0000:PR is up: [https://github.com/apache/camel/pull/5872]

 

Let me know if you have any suggestions"
0,CAMEL-16789,Task,Minor,None,None,"
None
",Open,Unresolved,Future,Unassigned,Alex Dettinger,0,2,2021-07-06 13:52:11+00:00,2023-08-09 09:19:52+00:00,"It looks like faulttolerance timeoutScheduledExecutorServiceRef and bulkHead* have no effect.


FaultToleranceConfiguration.getTimeoutScheduledExecutorServiceRef() is never called from camel code, so the configured value is never reified into an actual processor as far as I get it.


Concerning bulkHead*, the FaultToleranceReifier does not propagate the bulkHeadEnabled boolean by calling something like target.setBulkheadEnabled(true);


As such, the FaultToleranceProcessor never actually executes the doStart() and process() code related to bulkhead.","davsclaus:1625786382:2021-07-09T07:19:42.936+0000:1625786382:2021-07-09T07:19:42.936+0000:Yeah this requires some work as the bulk head executing is a bit tricky to implement for the current camel implementation. I took a look and it seems we need to refactor this to setup the circuit breaker and its bulk head, timeout etc in doStart.

"
0,CAMEL-16788,Bug,Major,None,3.12.0,"
None
",Resolved,Fixed,3.12.0,Claus Ibsen,Nicola Ferraro,0,2,2021-07-06 10:25:49+00:00,2022-01-19 19:41:28+00:00,"When a Kamelet declares a parameter like ""namespace"" or ""port"", then the value assigned to that parameter via properties is ignored if there's a ""NAMESPACE"" or ""PORT"" environment variable set on the host.


That strategy may work well for global parameters, but scoped parameters should prioritize the local configuration if present.","davsclaus:1625716217:2021-07-08T11:50:17.692+0000:1625716217:2021-07-08T11:50:17.692+0000:Its probably a good idea as you did as the workaround to specify a set of forbidden parameter names. Instead of trying to hack this in camels property placeholder algorithm, as then we end up with more and more _special_ situations.
davsclaus:1628053597:2021-08-04T13:06:37.251+0000:1628053597:2021-08-04T13:06:37.251+0000:Yeah lets make local properties used first always, then that would work with host, port, path, namespace etc.
davsclaus:1628056561:2021-08-04T13:56:01.984+0000:1628056561:2021-08-04T13:56:01.984+0000:Now kamelets will always use the given value (local parameter)"
0,CAMEL-16787,Task,Major,None,,"
None
",Resolved,Later,None,Unassigned,Claus Ibsen,0,1,2021-07-06 08:45:44+00:00,2022-09-03 08:02:34+00:00,"You can see this when building endpoint-dsl


[INFO] ----------------< org.apache.camel:camel-endpointdsl >----------------
[INFO] Building Camel :: Endpoint DSL 3.12.0-SNAPSHOT                   [26/27]
[INFO] -------------------------------[ jar ]--------------------------------
[WARNING] Failure to transfer com.google.code.findbugs:jsr305/maven-metadata.xml from http://allenai.bintray.com/maven was cached in the local repository, resolution will not be reattempted until the update interval of bintray-allenai-maven has elapsed or updates are forced. Original error: Could not transfer metadata com.google.code.findbugs:jsr305/maven-metadata.xml from/to bintray-allenai-maven (http://allenai.bintray.com/maven): Authorization failed for http://allenai.bintray.com/maven/com/google/code/findbugs/jsr305/maven-metadata.xml 403 Forbidden",davsclaus:1625532371:2021-07-06T08:46:11.177+0000:1625532371:2021-07-06T08:46:11.177+0000:It would be good to know which one to see if we can fix it or something
0,CAMEL-16786,Task,Minor,None,None,"
None
",Resolved,Fixed,3.12.0,Claus Ibsen,Claus Ibsen,0,1,2021-07-06 05:30:30+00:00,2021-08-04 12:50:36+00:00,"csimple should have label: language, java
csimple-joor should have label: language, java
camel-jta should have label: database
camel-lra should have label: database, microservice
camel-tracing should have label: monitoring, microservice",
0,CAMEL-16785,Dependency upgrade,Major,None,None,"
None
",Resolved,Fixed,3.7.5,Claus Ibsen,Claus Ibsen,0,1,2021-07-05 07:36:09+00:00,2021-07-05 08:28:49+00:00,Upgrade to newer dependency and spring boot for the next 3.7.x release,"davsclaus:1625443193:2021-07-05T07:59:53.258+0000:1625444748:2021-07-05T08:25:48.170+0000:activemq 5.16.0 -> 5.16.2
chunk 3.5.0 -> 3.6.1
cxf 3.4.2 -> 3.4.4
jetty 9.4.36 -> 9.4.42
johnzon 1.2.8 -> 1.2.13
json-smart 2.4.2 -> 2.4.7
kafka 2.6.0 -> 2.6.2
metrics 4.1.12 -> 4.1.24
micrometer 1.6.1 -> 1.6.8
netty 4.1.60 -> 4.1.65
spring boot 2.4.5 -> 2.4.8
rxjava 2.2.20 -> 2.2.21
spring-batch 4.3.1 -> 4.3.3
spring-integration 5.4.3 -> 5.4.8
spring-ldap 2.3.3 -> 2.3.4
spring-security 5.4.2 -> 5.4.7
spring 5.3.6 -> 5.3.8
undertow 2.2.0 -> 2.2.8
"
0,CAMEL-16784,Test,Major,None,3.12.0,"
None
",Resolved,Fixed,3.12.0,Ramu,Claus Ibsen,0,1,2021-07-04 08:54:32+00:00,2021-07-27 07:03:08+00:00,"org.apache.camel.component.file.remote.integration.FileToFtpsExplicitSSLWithClientAuthIT.testFromFileToFtp
org.apache.camel.component.file.remote.integration.FileToFtpsExplicitSSLWithoutClientAuthAndGlobalSSLContextParametersIT.testFromFileToFtp
org.apache.camel.component.file.remote.integration.FileToFtpsExplicitSSLWithoutClientAuthAndSSLContextParametersIT.testFromFileToFtp
org.apache.camel.component.file.remote.integration.FileToFtpsExplicitSSLWithoutClientAuthIT.testFromFileToFtp
org.apache.camel.component.file.remote.integration.FileToFtpsImplicitSSLWithClientAuthAndSSLContextParametersIT.testFromFileToFtp
org.apache.camel.component.file.remote.integration.FileToFtpsImplicitSSLWithClientAuthIT.testFromFileToFtp
org.apache.camel.component.file.remote.integration.FileToFtpsImplicitSSLWithoutClientAuthAndSSLContextParametersIT.testFromFileToFtp
org.apache.camel.component.file.remote.integration.FileToFtpsImplicitSSLWithoutClientAuthIT.testFromFileToFtp
org.apache.camel.component.file.remote.integration.FileToFtpsWithCustomKeyAndTrustStorePropertiesIT.testFromFileToFtp
org.apache.camel.component.file.remote.integration.FileToFtpsWithCustomTrustStorePropertiesIT.testFromFileToFtp
org.apache.camel.component.file.remote.integration.FileToFtpsWithFtpClientConfigRefIT.testFromFileToFtp",
0,CAMEL-16783,Improvement,Minor,None,None,"
None
",Resolved,Invalid,None,Unassigned,Paul Galbraith,0,2,2021-07-02 21:15:30+00:00,2021-07-03 08:16:56+00:00,,davsclaus:1625271416:2021-07-03T08:16:56.734+0000:1625271416:2021-07-03T08:16:56.734+0000:We only do for components that are more popular - otherwise the list is too big with 300+
0,CAMEL-16782,Bug,Major,3.11.0,"3.11.1, 3.12.0","
None
",Resolved,Fixed,"3.11.1, 3.12.0",Claus Ibsen,Tapio Piironen,0,2,2021-07-02 05:45:43+00:00,2021-07-05 07:22:32+00:00,"When splitting and then sending a huge list of strings(38 000) that create xml-documents for each line. Getting randomly this exception (so not for each line, about 5 times failed):


org.apache.camel.FailedToCreateProducerException: Failed to create Producer for endpoint: sftp://serverHere?disconnect=true. Reason: java.util.ConcurrentModificationException
 at org.apache.camel.support.cache.DefaultProducerCache.acquireProducer(DefaultProducerCache.java:155) ~[?:?]
 at org.apache.camel.support.cache.DefaultProducerCache.doInAsyncProducer(DefaultProducerCache.java:283) ~[?:?]
 at org.apache.camel.processor.SendProcessor.process(SendProcessor.java:190) ~[?:?]
 at org.apache.camel.processor.errorhandler.RedeliveryErrorHandler$SimpleTask.run(RedeliveryErrorHandler.java:463) ~[?:?]
 at org.apache.camel.impl.engine.DefaultReactiveExecutor$Worker.schedule(DefaultReactiveExecutor.java:179) ~[?:?]
 at org.apache.camel.impl.engine.DefaultReactiveExecutor.schedule(DefaultReactiveExecutor.java:59) ~[?:?]
 at org.apache.camel.processor.MulticastProcessor.lambda$schedule$1(MulticastProcessor.java:348) ~[?:?]
 at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515) [?:?]
 at java.util.concurrent.FutureTask.run(FutureTask.java:264) [?:?]
 at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128) [?:?]
 at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628) [?:?]
 at java.lang.Thread.run(Thread.java:829) [?:?]
Caused by: java.util.ConcurrentModificationException
 at java.util.ArrayList$Itr.checkForComodification(ArrayList.java:1043) ~[?:?]
 at java.util.ArrayList$Itr.next(ArrayList.java:997) ~[?:?]
 at org.apache.camel.support.cache.ServicePool$MultiplePool.cleanupEvicts(ServicePool.java:318) ~[?:?]
 at org.apache.camel.support.cache.ServicePool$MultiplePool.acquire(ServicePool.java:333) ~[?:?]
 at org.apache.camel.support.cache.ServicePool$MultiplePool.acquire(ServicePool.java:296) ~[?:?]
 at org.apache.camel.support.cache.ServicePool.acquire(ServicePool.java:109) ~[?:?]
 at org.apache.camel.support.cache.DefaultProducerCache.acquireProducer(DefaultProducerCache.java:126) ~[?:?]
 ... 11 more


 


two routes:


<from uri=""sftp: ...""/>


<split parallelProcessing=""true"">
 <tokenize token=""\r\n|\n"" xml=""false"" trim=""true""/>
 <convertBodyTo type=""java.lang.String"" charset=""UTF-8""/>
 <to uri=""bean:createXML?method=collect""/>
 <to uri=""direct:sendToSftpRoute""/>
</split>


 


<from uri=""direct:sendToSftpRoute""/>


<to uri=""sftp: ...?disconnect=true""/>


 


This issue came after upgrading from 3.4.2 -> 3.11.0","davsclaus:1625209137:2021-07-02T14:58:57.517+0000:1625209137:2021-07-02T14:58:57.517+0000:This is with camel-ftp that uses the multi service pool, 99% of the other components will use the singleton pool
davsclaus:1625209695:2021-07-02T15:08:15.518+0000:1625209695:2021-07-02T15:08:15.518+0000:Thanks for reporting. I have pushed a fix on the 3.11.x branch and also main.
You are welcome to test this - where you would need to build from source or try out 3.12.0-SNAPSHOT from apache snapshot maven server (takes a while for it to rebuild with latest fix as just commit now)
davsclaus:1625209724:2021-07-02T15:08:44.181+0000:1625209724:2021-07-02T15:08:44.181+0000:Potential fix
https://github.com/apache/camel/commit/95d62423c0c224985965575d142a902fa37247d2
tapiiron:1625439711:2021-07-05T07:01:51.081+0000:1625439711:2021-07-05T07:01:51.081+0000:Built 3.11.x and patched my camel-support jar with ServicePool fix. Confirming that this fixed the issue.
davsclaus:1625440952:2021-07-05T07:22:32.416+0000:1625440952:2021-07-05T07:22:32.416+0000:Thanks for checking the fix."
0,CAMEL-16781,Improvement,Major,None,None,"
None
",Resolved,Fixed,3.12.0,Unassigned,Paul Galbraith,0,2,2021-07-02 03:59:22+00:00,2021-07-05 04:44:57+00:00,"By default camel-json-validator assumes that provided schemas are version Draft 4 but the underlying validator library supports the newer draft version 2019-09, so it probably makes sense to make that the default.","davsclaus:1625210124:2021-07-02T15:15:24.250+0000:1625210124:2021-07-02T15:15:24.250+0000:Are you able to work on this?
paul_galbraith:1625226688:2021-07-02T19:51:28.460+0000:1625226688:2021-07-02T19:51:28.460+0000:I have it mixed in with fixes for CAMEL-16780 and CAMEL-16779 ... still want to test some more.

[https://github.com/pgalbraith/camel/tree/pr/camel-json-validator]

 
davsclaus:1625431492:2021-07-05T04:44:52.787+0000:1625431492:2021-07-05T04:44:52.787+0000:Would you send a new PR to update the documentation. I think its worthwhile to mention about the spec version default and that that version is resolved when reading the spec file."
0,CAMEL-16780,Improvement,Minor,None,None,"
None
",Resolved,Fixed,3.12.0,Unassigned,Paul Galbraith,0,2,2021-07-02 03:50:53+00:00,2021-07-05 04:43:38+00:00,camel-json-validator current does not work if the schema provided has a local ref to another subschema in the same directory,"davsclaus:1625210166:2021-07-02T15:16:06.079+0000:1625210166:2021-07-02T15:16:06.079+0000:Okay yeah this is maybe a bit more tricky if the sub schema is in the classpath or file system then you need some pluggable way to load this resource.
paul_galbraith:1625292549:2021-07-03T14:09:09.425+0000:1625292549:2021-07-03T14:09:09.425+0000:No actually the validator library will do this already, but you just need to call the right method.
davsclaus:1625431418:2021-07-05T04:43:38.024+0000:1625431418:2021-07-05T04:43:38.024+0000:Thanks for the work and the PR"
0,CAMEL-16779,Improvement,Minor,None,None,"
None
",Resolved,Fixed,None,Unassigned,Paul Galbraith,0,2,2021-07-02 03:48:48+00:00,2021-07-05 04:43:48+00:00,"camel-json-validator defaults to assuming that the schema being used for validation is draft 4, it would be nice if instead it actually checked the $schema property specified in the schema document to determine what version it is","davsclaus:1625210105:2021-07-02T15:15:05.338+0000:1625210105:2021-07-02T15:15:05.338+0000:Are you able to work on this?
paul_galbraith:1625231623:2021-07-02T21:13:43.046+0000:1625231623:2021-07-02T21:13:43.046+0000:Yes I have a PR, just testing a little more
davsclaus:1625431428:2021-07-05T04:43:48.483+0000:1625431428:2021-07-05T04:43:48.483+0000:Thanks for the work and the PR"
0,CAMEL-16778,Dependency upgrade,Major,None,None,"
None
",Resolved,Fixed,"3.11.1, 3.12.0",Unassigned,Claus Ibsen,0,1,2021-07-01 19:57:31+00:00,2021-07-02 15:18:43+00:00,No Desc,
0,CAMEL-16777,Improvement,Minor,3.11.0,3.12.0,"
None
",Resolved,Fixed,3.12.0,Unassigned,Jeremy Ross,0,1,2021-07-01 15:52:49+00:00,2021-07-02 14:50:58+00:00,"The Java DSL needs a constant() overload that allows the user to disable white space trimming. I.e.:
constant(Object body, boolean trim)


XML config supports a trim option, but the Java DSL does not.",
0,CAMEL-16776,Bug,Minor,3.11.0,"3.11.1, 3.12.0","
None
",Resolved,Fixed,"3.11.1, 3.12.0",Claus Ibsen,Claus Ibsen,0,2,2021-07-01 12:59:04+00:00,2021-07-04 14:27:46+00:00,Report on user forum,"davsclaus:1625116134:2021-07-01T13:08:54.993+0000:1625116134:2021-07-01T13:08:54.993+0000:This is only for unit testing with camel-test which does bean post processing eager on the test class itself
graben:1625178117:2021-07-02T06:21:57.265+0000:1625178117:2021-07-02T06:21:57.265+0000:Well, I see this behavior also in non-test scenarios, e.g. Spring-Boot Pojos with injected ProducerTemplate.
davsclaus:1625180340:2021-07-02T06:59:00.775+0000:1625180340:2021-07-02T06:59:00.775+0000:Can you create a sample project with SB that demonstrates this
davsclaus:1625209757:2021-07-02T15:09:17.012+0000:1625209757:2021-07-02T15:09:17.012+0000:Your test case now works. But I would like to see the spring boot problem
graben:1625218893:2021-07-02T17:41:33.190+0000:1625218893:2021-07-02T17:41:33.190+0000:Hi [~davsclaus] 

I attached [^BasicSpringbootProject.zip] to show SB problem with 3.11

Regards
Benjamin
davsclaus:1625359141:2021-07-04T08:39:01.038+0000:1625359141:2021-07-04T08:39:01.038+0000:Thanks for the SB project - this works now - I also fixed so you can turn off autowiring per component that otherwise would have been configured by spring too late when using those bean injections. 
davsclaus:1625359569:2021-07-04T08:46:09.586+0000:1625359569:2021-07-04T08:46:09.586+0000:This also affected non test projects and therefore backporting to 3.1.x so it has same behaviour as in earlier releases.
graben:1625380066:2021-07-04T14:27:46.420+0000:1625380066:2021-07-04T14:27:46.420+0000:Thanks [~davsclaus] :)"
0,CAMEL-16775,Bug,Major,3.6.0,3.12.0,"
None
",Resolved,Fixed,3.12.0,Claus Ibsen,Onlinee,0,3,2021-07-01 12:55:49+00:00,2021-07-02 12:42:36+00:00,"Hello,


since Camel Version 3.6 simple language operator ""starts with"" / ""startsWith"" is buggy.


This works with camel 3.5



.when(simple(""${body} starts with '010'""))
.when(simple(""${body} startsWith '010'""))
.when(bodyAs(String.class).startsWith(""010"")) 



This works with camel 3.6 only



.when(bodyAs(String.class).startsWith(""010"")) 



See also TestCase StartsWithTest.java.


Regards.","acosentino:1625115454:2021-07-01T12:57:34.820+0000:1625115454:2021-07-01T12:57:34.820+0000:Please try with 3.11.0 release, 3.6.0 and 3.5.0 were development releases and they are not meant to be used in prod.
davsclaus:1625115714:2021-07-01T13:01:54.765+0000:1625115714:2021-07-01T13:01:54.765+0000:This is because '010' is a parsed as a number, so you must use bodyAs(String) to tell Camel you want to compare this text based.

davsclaus:1625115799:2021-07-01T13:03:19.595+0000:1625115799:2021-07-01T13:03:19.595+0000:And we have also as Andrea fixed bugs since, so it may also work in 3.10 or 3.11.
Onlinee:1625116437:2021-07-01T13:13:57.291+0000:1625116437:2021-07-01T13:13:57.291+0000:My fault. I recognized this upgrading from camel 3.5 to 3.11. 

It is not working in 3.11 too.
davsclaus:1625184288:2021-07-02T08:04:48.815+0000:1625184288:2021-07-02T08:04:48.815+0000:Yeah we should actually improve the parser so it does not optimize the quoted text block as a numeric value
As if you want to use numeric you would not quote the text.
Onlinee:1625200956:2021-07-02T12:42:36.047+0000:1625200956:2021-07-02T12:42:36.047+0000:That is what i expect when i read ""startsWith/starts with : _For testing if the left hand side string starts with the right hand string""_ in the simple language documentation_._"
0,CAMEL-16774,Dependency upgrade,Major,None,None,"
None
",Resolved,Fixed,3.12.0,Ramu,Claus Ibsen,0,2,2021-07-01 12:29:11+00:00,2021-07-06 11:45:12+00:00,No Desc,
0,CAMEL-16773,New Feature,Major,None,3.12.0,"
None
",Resolved,Fixed,3.12.0,Claus Ibsen,Claus Ibsen,0,1,2021-07-01 12:18:02+00:00,2021-07-01 12:26:33+00:00,So you can configure misfireInstructions and other advanced options.,"davsclaus:1625113588:2021-07-01T12:26:28.871+0000:1625113588:2021-07-01T12:26:28.871+0000:You can now do

                from(""file:target/inbox?scheduler=quartz&scheduler.trigger.misfireInstruction=2&scheduler.cron=0/2+*+*+*+*+?"")
"
0,CAMEL-16772,Bug,Major,"3.10.0, 3.11.0","3.11.1, 3.12.0","
None
",Resolved,Fixed,"3.11.1, 3.12.0",Zheng Feng,Nick Paul,0,1,2021-06-30 15:52:30+00:00,2021-07-01 14:52:38+00:00,"When a route has an onCompletion() handler associated with it the sjms component will not deliver messages if transaction=true is set. The route configured in this way results in loss of data with no exception or errors logged. 


See example code https://github.com/NickPaul41/camel-sjms2-issue-example",
0,CAMEL-16771,Dependency upgrade,Major,None,"3.11.1, 3.12.0","
None
",Resolved,Fixed,"3.11.1, 3.12.0",Ramu,Claus Ibsen,0,1,2021-06-30 05:11:13+00:00,2021-07-04 08:48:31+00:00,No Desc,davsclaus:1625359711:2021-07-04T08:48:31.964+0000:1625359711:2021-07-04T08:48:31.964+0000:I was working on some SB stuff and had to upgrade to use same version as a reproducer.
0,CAMEL-16770,New Feature,Major,3.11.0,3.12.0,"
None
",Resolved,Fixed,3.12.0,Unassigned,Michael Genereux,0,2,2021-06-30 00:40:03+00:00,2021-07-06 11:35:12+00:00,"The JDBC Idempotent Repository does a full transactional query on every check by the Idempotent Consumer.  On SQL Server implementations that have a high overhead per query, each query can take two seconds. For a 1000 checks, this can take a half hour.  My proposal is to cache the repository list in a single query and then reference that list in memory.",davsclaus:1625473806:2021-07-05T16:30:06.340+0000:1625473806:2021-07-05T16:30:06.340+0000:Thanks for the work and the PR
0,CAMEL-16739,Improvement,Minor,None,3.12.0,"
None
",Resolved,Implemented,3.12.0,Unassigned,Paul Galbraith,0,1,2021-06-21 02:23:30+00:00,2021-07-09 12:50:25+00:00,"If the endpoint URI specifies a wildcard for accepting connections, then after a client establishes a connection the relative path of that connection should be provided by the consumer in a message header.


E.g. if my endpoint is websocket://0.0.0.0:80/application/* and a client connects using URL ws://host.com/application/customer/profile, then the relative path customer/profile should be provided in a message header for potential custom routing.",
0,CAMEL-16738,New Feature,Minor,None,3.12.0,"
None
",Resolved,Fixed,3.12.0,Unassigned,Paul Galbraith,0,2,2021-06-21 01:23:41+00:00,2021-07-09 07:28:13+00:00,"I would like to see camel-websocket support subprotocols as per RFC 6455, during connection upgrade negotiation.  Ideally we could specify the subprotocol(s) that our application supports via a subprotocol option in the component/endpoint URI.  If camel-websocket accepts a subprotocol proposed by a connecting client, then the client should be informed of the agreed subprotocol via HTTP header (as per RFC 6455), and the agreed subprotocol should also be provided as a message header via the camel-subprotocol consumer.",davsclaus:1625786893:2021-07-09T07:28:13.743+0000:1625786893:2021-07-09T07:28:13.743+0000:Thanks for the PR
0,CAMEL-16737,Improvement,Major,None,Future,"
None
",Open,Unresolved,Future,Unassigned,Claus Ibsen,0,2,2021-06-20 06:25:38+00:00,2023-07-17 11:35:38+00:00,"Lets look at if we can make transacted work better with the reactive routing engine.


See CAMEL-16734 and the ticket it mentions for background.


Maybe we could let the routing engine be aware if a task is under transaction and execute it synchronously via its current thread, and ensure any other tasks that this thread or exchange is providing to the reactive engine is processed under the transaction via that same thread.


At this movement its the EIP implementation that need to splitup their tasks into transacted vs non-transacted which would ideally be avoided.","graben:1625382440:2021-07-04T15:07:20.371+0000:1625383868:2021-07-04T15:31:08.453+0000:Hi [~davsclaus],

I think the worker feature introduced in Camel 3.11.0 makes this issue to a bug since non-synchronous routing leads to endpoint being fired too early. If you like, I can show an example, but the test cases from CAMEL-16734 should also fail, too if you order the exchanges in mock:result. But to be honest, I did not test it myself :)

Benjamin

BTW: Dirty workaround is to set SynchronousExecutorService (Works not in every case!)"
0,CAMEL-16736,Improvement,Minor,3.10.0,3.11.0,"
None
",Resolved,Fixed,3.11.0,Unassigned,Michael Genereux,0,2,2021-06-18 23:59:46+00:00,2021-06-22 10:16:10+00:00,"During the parsing of the CSV and setHeader is set to new String[0], the headers are collected and beautifully validated.  These headers are then used in Map output but discarded on List output.  It would be nice to preserve that knowledge downstream in the Message header.",davsclaus:1624328170:2021-06-22T10:16:10.381+0000:1624328170:2021-06-22T10:16:10.381+0000:Thanks for the PR
0,CAMEL-16735,Task,Major,3.11.0,3.11.0,"
None
",Resolved,Cannot Reproduce,3.11.0,Claus Ibsen,Claus Ibsen,0,1,2021-06-18 19:03:07+00:00,2021-06-19 07:05:10+00:00,"[INFO]
[INFO] — camel-maven-plugin:3.11.0-SNAPSHOT:run (default-cli) @ camel-example-kamelet-main —
[INFO] You can skip tests from the command line using: mvn camel:run -Dmaven.test.skip=true
[INFO] camel-kamelet-main detected on classpath
[INFO] Using org.apache.camel.main.KameletMain to initiate a CamelContext
[INFO] camel-kamelet-main detected on classpath
[INFO] Starting Camel ...
[ERROR] *************************************
[ERROR] Error occurred while running main from: org.apache.camel.main.KameletMain
[ERROR]
java.lang.IllegalArgumentException: wrong number of arguments
    at jdk.internal.reflect.NativeMethodAccessorImpl.invoke0 (Native Method)
    at jdk.internal.reflect.NativeMethodAccessorImpl.invoke (NativeMethodAccessorImpl.java:62)
    at jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke (DelegatingMethodAccessorImpl.java:43)
    at java.lang.reflect.Method.invoke (Method.java:566)
    at org.apache.camel.maven.RunMojo$1.run (RunMojo.java:429)
    at java.lang.Thread.run (Thread.java:834)
[ERROR] *************************************
[INFO] ------------------------------------------------------------------------
[INFO] BUILD FAILURE
[INFO] ------------------------------------------------------------------------
[INFO] Total time:  0.763 s
[INFO] Finished at: 2021-06-18T21:02:21+02:00
[INFO] ------------------------------------------------------------------------
[ERROR] Failed to execute goal org.apache.camel:camel-maven-plugin:3.11.0-SNAPSHOT:run (default-cli) on project camel-example-kamelet-main: null: MojoExecutionException: wrong number of arguments -> [Help 1]",davsclaus:1624057510:2021-06-19T07:05:10.648+0000:1624057510:2021-06-19T07:05:10.648+0000:Rebuild today cannot reproduce
0,CAMEL-16734,Bug,Major,"3.7.4, 3.7.2, 3.7.3, 3.8.0, 3.10.0",3.11.0,"
None
",Resolved,Fixed,3.11.0,Claus Ibsen,Krzysztof Mackowiak,0,2,2021-06-18 15:06:00+00:00,2021-06-21 14:40:20+00:00,"When migrating to Camel 3.7.2 I've noticed that there is a problem with the recipient list in transacted routes.
Recipient list does not wait for processing an exchange by recipients and ignores aggregation strategy when :



route is transacted,
doTry()...doCatch() is used,
processing by the recipient takes longer.



The bug was discovered in version 3.7.2 but it's also present in the newest versions 3.10.0 and 3.7.4 (LTS).


Here is a test, which reproduces the problem:




public class TransactedRecipientListTest extends TransactionClientDataSourceSupport {

    @Test
    public void testRecipientList() throws Exception {
        System.out.println(""Running on version : "" + context.getVersion());

        String response = template.requestBody(""direct:start"", ""Hello World"", String.class);

        assertEquals(""Hi !!!"", response);
    }

    @Override
    protected RouteBuilder createRouteBuilder() throws Exception {
        return new RouteBuilder() {
            @Override
            public void configure() throws Exception {
                // NOTE commenting transacted(), doTry() or delay() make this test green in Camel 3.7.4 and above
                // however commenting delay() doest not make this test green in Camel 3.7.2
                from(""direct:start"")
                        .transacted()
                        .doTry()
                            .recipientList(constant(""direct:a""))
                        .endDoTry();
                // NOTE doCatch() skipped here to keep test as simple as possible

                from(""direct:a"")
                        .delay(1000)
                        .transform(constant(""Hi !!!""));
            }
        };
    }
}




This test is passing with Camel 3.7.1 and below, but it's failing with Camel 3.7.2 and above.
However it's also passing with Camel 3.9.0 !


It's also passing on 'main' and '3.7.x' branches after reverting commit b1b5b7d0 : ""CAMEL-16550: camel-core - Split and Aggregate with Transacted may cause thread to stuck"".


I've checked a history of MulticastProcessor class and it looks that:



CAMEL-16103 introduced the problem.
CAMEL-16295 fixed the problem.
CAMEL-16550 introduced this problem again.","davsclaus:1624141347:2021-06-20T06:22:27.654+0000:1624141347:2021-06-20T06:22:27.654+0000:Thanks for reporting. 

So yeah there is a problem with transacted and the reactive routing engine that goes against each other. 
So its all the EIPs that use the routing engine to breakup into a series of tasks, such as try .. catch, pipeline, etc.


davsclaus:1624226821:2021-06-21T06:07:01.807+0000:1624226821:2021-06-21T06:07:01.807+0000:Thanks for reporting and the detailed analysis and testing which other JIRAs caused this etc.

I was able to come up with a better fix in the aggregator EIP itself and can therefore remove that special _hack_ in the multicast processor.

The 3.11 upgrade doc mention the change in the aggregator eip.
kmackowiak:1624256475:2021-06-21T14:21:15.318+0000:1624256475:2021-06-21T14:21:15.318+0000:Would it be possible to backport this fix to LTS version (3.7.x) ?
davsclaus:1624257620:2021-06-21T14:40:20.374+0000:1624257620:2021-06-21T14:40:20.374+0000:No intention to backport to 3.7.x as the change is not a simple change and its in a core area. And Camel 3.11 LTS is coming out soon."
0,CAMEL-16733,Improvement,Major,3.10.0,3.11.0,"
None
",Resolved,Fixed,3.11.0,Claus Ibsen,Samrat Dhillon,0,2,2021-06-18 12:34:18+00:00,2021-06-21 08:30:19+00:00,"The below code results in creation of a new bean of type MyBean rather than looking up an existing instance from the registry. Also there is an imposition that MyBean has a no-args ctor for camel to construct a new bean. This behaviour is very confusing when an existing bean can be found from the registry such as spring which can use ctor injection without having the need for a default ctor 


 


public void configure() throws Exception 

{
 from(""direct:a"").transform().method(MyBean.class).to(""mock:a"");

from(""direct:b"").transform().method(MyBean.class).to(""mock:b"");
 }

 };","davsclaus:1624232915:2021-06-21T07:48:35.212+0000:1624232915:2021-06-21T07:48:35.212+0000:The documentation/javadoc says a new instance is created.

To refer to an existing bean use the ref (however ref is for a bean id, not by type).
davsclaus:1624235419:2021-06-21T08:30:19.263+0000:1624235419:2021-06-21T08:30:19.263+0000:Thanks for the PR."
0,CAMEL-16732,Improvement,Major,None,3.11.0,"
None
",Resolved,Fixed,3.11.0,Claus Ibsen,Claus Ibsen,0,1,2021-06-18 10:27:53+00:00,2021-06-18 10:42:37+00:00,"We have some home grown code that does something like autowried, but we can do this out of the box with the new autowired support in core",davsclaus:1623984157:2021-06-18T10:42:37.943+0000:1623984157:2021-06-18T10:42:37.943+0000:This is for both camel-sql and camel-elsql
0,CAMEL-16731,Task,Minor,3.10.0,3.11.0,"
None
",Resolved,Information Provided,3.11.0,Unassigned,Aurélien Pupier,0,2,2021-06-18 06:53:40+00:00,2021-10-22 07:25:31+00:00,"Using reference directly in the URI is reporting the validation error



Invalid reference value: dataSource must start with #




Although it is mentioned as supported here https://camel.apache.org/components/latest/sql-component.html#_datasource","davsclaus:1623983071:2021-06-18T10:24:31.742+0000:1623983071:2021-06-18T10:24:31.742+0000:Yeah that little bit in the doc was wrong, you should use #xxx or #bean:xxx"
0,CAMEL-16730,Improvement,Major,None,3.11.0,"
None
",Resolved,Fixed,3.11.0,Claus Ibsen,Claus Ibsen,0,1,2021-06-17 08:01:06+00:00,2021-06-17 09:46:49+00:00,"Today its generated as direct:operation-id


We should be able to configure this, so you can use kamelet instead or something else.",
0,CAMEL-16729,Bug,Major,None,,"
None
",Resolved,Not A Bug,None,Unassigned,Claudio Miranda,0,1,2021-06-17 00:05:28+00:00,2021-06-17 04:43:12+00:00,"I am using the mongodb url




mongodb://?collection=sales&database=sales&hosts=172.17.0.7%3A27017&operation=findAll&password=xxxxxx&username=myuser




When using the hosts parameter to authenticate to a mongodb server, it fails with




Caused by: com.mongodb.MongoCommandException: Command failed with error 18 (AuthenticationFailed): 'Authentication failed.' on server 172.17.0.7:27017. The full response is {""ok"": 0.0, ""errmsg"": ""Authentication failed."", ""code"": 18, ""codeName"": ""AuthenticationFailed""}




mongo server shows




""Authentication failed"",""attr"":{""mechanism"":""SCRAM-SHA-1"",""speculative"":false,""principalName"":""myuser"",""authenticationDatabase"":""admin"",""remote"":""172.17.0.6:60642"",""extraInfo"":{},""error"":""UserNotFound: Could not find user \""myuser\"" for db \""admin\""""




MongoDB connection string uses admin database when no authentication database is specified
https://github.com/mongodb/mongo-java-driver/blob/r4.1.0/driver-core/src/main/com/mongodb/ConnectionString.java#L63
https://github.com/mongodb/mongo-java-driver/blob/r4.1.0/driver-core/src/main/com/mongodb/ConnectionString.java#L729


I think the database should be used in camel-mongodb authentication mechanism, at least I changed the code and it worked.




mongoClient = MongoClients.create(String.format(""mongodb://%s%s"", credentials, hosts));




https://github.com/apache/camel/blob/main/components/camel-mongodb/src/main/java/org/apache/camel/component/mongodb/MongoDbEndpoint.java#L344","claudio4j:1623859562:2021-06-17T00:06:02.418+0000:1623859562:2021-06-17T00:06:02.418+0000:Related to this change https://issues.apache.org/jira/browse/CAMEL-16729
claudio4j:1623876170:2021-06-17T04:42:50.468+0000:1623876170:2021-06-17T04:42:50.468+0000:I may be wrong, in my test the created user was not added to the standard ""system.users"" collection in ""admin"" db, but once I did, the authentication worked."
0,CAMEL-16728,Bug,Major,2.23.2,,"
None
",Resolved,Invalid,None,Unassigned,Nayana Thorat,0,2,2021-06-16 13:50:41+00:00,2021-06-16 17:24:23+00:00,"Environment: Linux x86_64 RHEL 8.3 
Java : IBM SDK 8




# java -version
java version ""1.8.0_281""
Java(TM) SE Runtime Environment (build 8.0.6.25 - pxa6480sr6fp25-20210115_01(SR6 FP25))
IBM J9 VM (build 2.9, JRE 1.8.0 Linux amd64-64-Bit Compressed References 20201218_462060 (JIT enabled, AOT enabled)
OpenJ9   - 4c03b71
OMR      - 86a8e1a
IBM      - 8c30c56)
JCL - 20210108_01 based on Oracle jdk8u281-b09




Facing below test failures on mvn install on camel-core module:




ERROR] Failures:
[ERROR] org.apache.camel.component.xslt.XsltMessageTerminateTest.testXsltTerminate(org.apache.camel.component.xslt.XsltMessageTerminateTest)
[ERROR] Run 1: XsltMessageTerminateTest.testXsltTerminate:41->Assert.assertNotNull:722->Assert.assertNotNull:712->Assert.assertTrue:41->Assert.fail:86
[ERROR] Run 2: XsltMessageTerminateTest.testXsltTerminate:41->Assert.assertNotNull:722->Assert.assertNotNull:712->Assert.assertTrue:41->Assert.fail:86
[ERROR] Run 3: XsltMessageTerminateTest.testXsltTerminate:41->Assert.assertNotNull:722->Assert.assertNotNull:712->Assert.assertTrue:41->Assert.fail:86
[INFO]
[ERROR] org.apache.camel.converter.jaxp.XmlConverterTest.testToStringWithDocument(org.apache.camel.converter.jaxp.XmlConverterTest)
[ERROR] Run 1: XmlConverterTest.testToStringWithDocument:101->Assert.assertEquals:144->Assert.assertEquals:115 expected:<....0"" encoding=""UTF-8""[ standalone=""no""]?><foo>bar</foo>> but was:<....0"" encoding=""UTF-8""[]?><foo>bar</foo>>
[ERROR] Run 2: XmlConverterTest.testToStringWithDocument:101->Assert.assertEquals:144->Assert.assertEquals:115 expected:<....0"" encoding=""UTF-8""[ standalone=""no""]?><foo>bar</foo>> but was:<....0"" encoding=""UTF-8""[]?><foo>bar</foo>>
[ERROR] Run 3: XmlConverterTest.testToStringWithDocument:101->Assert.assertEquals:144->Assert.assertEquals:115 expected:<....0"" encoding=""UTF-8""[ standalone=""no""]?><foo>bar</foo>> but was:<....0"" encoding=""UTF-8""[]?><foo>bar</foo>>
[INFO]
[ERROR] org.apache.camel.converter.jaxp.XmlConverterTest.testToStringWithDocumentSourceOutputProperties(org.apache.camel.converter.jaxp.XmlConverterTest)
[ERROR] Run 1: XmlConverterTest.testToStringWithDocumentSourceOutputProperties:117->Assert.assertEquals:144->Assert.assertEquals:115 expected:<...ncoding=""ISO-8859-1""[ standalone=""no""]?><foo>bar</foo>> but was:<...ncoding=""ISO-8859-1""[]?><foo>bar</foo>>
[ERROR] Run 2: XmlConverterTest.testToStringWithDocumentSourceOutputProperties:117->Assert.assertEquals:144->Assert.assertEquals:115 expected:<...ncoding=""ISO-8859-1""[ standalone=""no""]?><foo>bar</foo>> but was:<...ncoding=""ISO-8859-1""[]?><foo>bar</foo>>
[ERROR] Run 3: XmlConverterTest.testToStringWithDocumentSourceOutputProperties:117->Assert.assertEquals:144->Assert.assertEquals:115 expected:<...ncoding=""ISO-8859-1""[ standalone=""no""]?><foo>bar</foo>> but was:<...ncoding=""ISO-8859-1""[]?><foo>bar</foo>>
[INFO]
[ERROR] org.apache.camel.util.jsse.SSLContextParametersTest.testCipherSuitesFilter(org.apache.camel.util.jsse.SSLContextParametersTest)
[ERROR] Run 1: SSLContextParametersTest.testCipherSuitesFilter:582->assertStartsWith:838->Assert.assertTrue:41->Assert.fail:88 SSL_RSA_WITH_AES_128_CBC_SHA does not start with the prefix TLS
[ERROR] Run 2: SSLContextParametersTest.testCipherSuitesFilter:582->assertStartsWith:838->Assert.assertTrue:41->Assert.fail:88 SSL_RSA_WITH_AES_128_CBC_SHA does not start with the prefix TLS
[ERROR] Run 3: SSLContextParametersTest.testCipherSuitesFilter:582->assertStartsWith:838->Assert.assertTrue:41->Assert.fail:88 SSL_RSA_WITH_AES_128_CBC_SHA does not start with the prefix TLS
[INFO]
[ERROR] Errors:
[ERROR] org.apache.camel.util.jsse.SSLContextParametersTest.testSecureSocketProtocol(org.apache.camel.util.jsse.SSLContextParametersTest)
[ERROR] Run 1: SSLContextParametersTest.testSecureSocketProtocol:779 » NoSuchAlgorithm SSLv3 ...
[ERROR] Run 2: SSLContextParametersTest.testSecureSocketProtocol:779 » NoSuchAlgorithm SSLv3 ...
[ERROR] Run 3: SSLContextParametersTest.testSecureSocketProtocol:779 » NoSuchAlgorithm SSLv3 ...
[INFO]
[INFO]
[ERROR] Tests run: 6211, Failures: 4, Errors: 1, Skipped: 19



Steps to reproduce:




wget https://github.com/apache/camel/archive/camel-2.23.2.tar.gz
tar -xvzf camel-2.23.2.tar.gz
cd camel-camel-2.23.2/
mvn clean install","acosentino:1623822908:2021-06-16T13:55:08.528+0000:1623822908:2021-06-16T13:55:08.528+0000:It hasn't been in the list of the supported jdk. Also 2.23.x is not active anymore. 
Nayana:1623835463:2021-06-16T17:24:23.638+0000:1623835463:2021-06-16T17:24:23.638+0000:[~acosentino] Oh ok...i tried IBM SDK as I see it referred here :
https://github.com/apache/camel/blob/main/core/camel-core/src/test/java/org/apache/camel/support/jsse/SSLContextParametersTest.java#L305
Thank you for clarification."
0,CAMEL-16727,Improvement,Major,None,3.11.0,"
None
",Resolved,Fixed,3.11.0,Andrea Cosentino,Andrea Cosentino,0,1,2021-06-15 13:40:26+00:00,2021-06-15 15:05:14+00:00,There could be cases in which a user is only interested to metadata and wants to consume them. We could add an ignoreBody as false by default.,
0,CAMEL-16726,New Feature,Major,None,3.11.0,"
None
",Resolved,Fixed,3.11.0,Claus Ibsen,Luca Burgazzoli,0,2,2021-06-15 11:16:10+00:00,2021-06-17 12:07:43+00:00,"as today the camel-openapi-plugin can genrate routes in XML and Java, we should add support for YAML","davsclaus:1623730518:2021-06-15T12:15:18.661+0000:1623730518:2021-06-15T12:15:18.661+0000:I have something in the works, just need to maven facade now
davsclaus:1623733419:2021-06-15T13:03:39.694+0000:1623733419:2021-06-15T13:03:39.694+0000:We do not support restConfiguration in the YAML DSL, so we either need to add that, or remove it from the output.
davsclaus:1623733432:2021-06-15T13:03:52.269+0000:1623733432:2021-06-15T13:03:52.269+0000:{code}
restConfiguration:
  component: ""servlet""
  contextPath: ""/foo""
rest:
  path: ""/api/v3""
  put:
  - consumes: ""application/json,application/xml""
    id: ""updatePet""
    uri: ""/pet""
    param:
      description: ""Pet object that needs to be added to the store""
      name: ""body""
      required: ""true""
      type: ""body""
    to:
      uri: ""direct:updatePet""
...
{code}
davsclaus:1623735697:2021-06-15T13:41:37.019+0000:1623735697:2021-06-15T13:41:37.019+0000:PR https://github.com/apache/camel/pull/5670"
0,CAMEL-16725,Bug,Major,3.10.0,3.12.0,"
None
",Resolved,Fixed,3.12.0,Claus Ibsen,Martin Muzikar,0,3,2021-06-15 11:14:51+00:00,2021-06-25 08:17:23+00:00,"If an issue with lastestId was deleted then the Jira client fails the jql generated by the endpoint. https://github.com/apache/camel/blob/main/components/camel-jira/src/main/java/org/apache/camel/component/jira/consumer/NewIssuesConsumer.java#L75


With stacktrace




Caused by: RestClientException{statusCode=Optional.of(400), errorCollections=[ErrorCollection{status=400, errors={}, errorMessages=[A value with ID '13383056' does not exist for the field 'id'.]}]}
	at com.atlassian.jira.rest.client.internal.async.AbstractAsynchronousRestClient$2.apply(AbstractAsynchronousRestClient.java:176)
	at com.atlassian.jira.rest.client.internal.async.AbstractAsynchronousRestClient$2.apply(AbstractAsynchronousRestClient.java:170)
	at com.atlassian.httpclient.api.ResponsePromiseMapFunction.apply(ResponsePromiseMapFunction.java:49)
	at com.atlassian.httpclient.api.ResponsePromiseMapFunction.apply(ResponsePromiseMapFunction.java:10)
	at io.atlassian.util.concurrent.Promises$OfStage.lambda$fold$4(Promises.java:332)
	at io.atlassian.util.concurrent.Promises.lambda$biFunction$7(Promises.java:422)
	at java.base/java.util.concurrent.CompletableFuture.uniHandle(CompletableFuture.java:930)
	at java.base/java.util.concurrent.CompletableFuture$UniHandle.tryFire(CompletableFuture.java:907)
	at java.base/java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:506)
	at java.base/java.util.concurrent.CompletableFuture.complete(CompletableFuture.java:2073)
	at com.atlassian.httpclient.apache.httpcomponents.SettableFuturePromiseHttpPromiseAsyncClient$1.lambda$doCompleted$0(SettableFuturePromiseHttpPromiseAsyncClient.java:37)
	at com.atlassian.httpclient.apache.httpcomponents.SettableFuturePromiseHttpPromiseAsyncClient.runInContext(SettableFuturePromiseHttpPromiseAsyncClient.java:61)
	at com.atlassian.httpclient.apache.httpcomponents.SettableFuturePromiseHttpPromiseAsyncClient$ThreadLocalDelegateRunnable.run(SettableFuturePromiseHttpPromiseAsyncClient.java:129)
	... 3 more




This gets the newIssues endpoint always failing not being able to recover.","davsclaus:1623727527:2021-06-15T11:25:27.281+0000:1623727527:2021-06-15T11:25:27.281+0000:You are welcome to work on a fix
davsclaus:1624580243:2021-06-25T08:17:23.104+0000:1624580243:2021-06-25T08:17:23.104+0000:Okay we attempt to detect the http error 400 and the message about ID does not exist, and then in such situation, we recover by re-fetching a new last known ID from JIRA and continue from that on the next poll."
0,CAMEL-16724,Improvement,Minor,None,3.11.0,"
None
",Resolved,Fixed,3.11.0,Claus Ibsen,Claus Ibsen,0,1,2021-06-15 10:58:20+00:00,2021-06-17 13:35:23+00:00,"You can turn on DEBUG logging level for the mock component, but sometimes when you work with a few messages you just want to say mock:cheese?loggingLevel=INFO to have it log when it receives messages etc.


Or 
mock:cheese?log=true",
0,CAMEL-16723,Task,Minor,3.11.0,3.11.0,"
None
",Resolved,Fixed,3.11.0,Unassigned,Andrea Cosentino,0,3,2021-06-15 09:42:52+00:00,2021-06-18 05:24:40+00:00,"[WARNING] 	Missing document detected: 3
[WARNING] 		camel-huaweicloud-functiongraph
[WARNING] 		camel-huaweicloud-smn
[WARNING] 		src
[INFO] 
[INFO] ================================================================================
[INFO] 
[INFO] Camel missing documents report","davsclaus:1623727580:2021-06-15T11:26:20.576+0000:1623727580:2021-06-15T11:26:20.576+0000:Some endpoint options on those components need javadoc
hokutor:1623826898:2021-06-16T15:01:38.482+0000:1623827688:2021-06-16T15:14:48.891+0000:I would like to add Huawei Cloud to the title of each Huawei component here:

!Screenshot.png|width=466,height=165!

I tried to do this in one of my recent PR's, but it seems to have been reverted by one of the auto-generation plugins.

Here are my changes in this PR [https://github.com/apache/camel/pull/5667/files|https://github.com/apache/camel/pull/5667/files):]
 !screenshot-1.png|width=499,height=171! 
 !screenshot-2.png|width=500,height=208! 
 !screenshot-3.png|width=500,height=199!

These changes were all reverted in this regen commit [https://github.com/apache/camel/commit/daf5c6058b952850a8fc419fbf2fa5ac84050983|https://github.com/apache/camel/commit/daf5c6058b952850a8fc419fbf2fa5ac84050983):]
 !screenshot-4.png|width=512,height=177! 
 !screenshot-5.png|width=517,height=232! 
 !screenshot-6.png|width=517,height=217!

How can I make these desired changes without them being reverted?
davsclaus:1623877139:2021-06-17T04:58:59.932+0000:1623877139:2021-06-17T04:58:59.932+0000:See the title attribute in the annotation at
https://github.com/apache/camel/blob/main/components/camel-huawei/camel-huaweicloud-functiongraph/src/main/java/org/apache/camel/FunctionGraphEndpoint.java#L35

And the javadoc is used as the one line summary, you may want to improve this
https://github.com/apache/camel/blob/main/components/camel-huawei/camel-huaweicloud-smn/src/main/java/org/apache/camel/component/huaweicloud/smn/SimpleNotificationEndpoint.java#L34"
0,CAMEL-16722,Bug,Minor,None,3.11.0,"
None
",Resolved,Fixed,3.11.0,Claus Ibsen,Claus Ibsen,0,1,2021-06-14 14:24:37+00:00,2021-06-14 14:30:01+00:00,"When using in predicate in camel-mock, then each item becomes a predicate, so if you have in(1, 2, 3, 4, 5) then there is 5 + 1 predicates. It should be a single compound predicate.",
0,CAMEL-16721,Bug,Major,3.10.0,3.10.0,"
None
",Resolved,Invalid,3.10.0,Unassigned,Godfrey,0,2,2021-06-14 12:58:59+00:00,2021-06-14 13:17:18+00:00,"Issue when using camel-google-pubsub-kafka-connector as sink for Strimzi kafka.


I've created a KafkaConnect single-node cluster using camel kafka connect for Pubsub.


That works fine.


Please find the k8s files and the error msg.


Any idea of resolving the google-pubsub-kafka-connector for k8s?","acosentino:1623646987:2021-06-14T13:03:07.624+0000:1623646987:2021-06-14T13:03:07.624+0000:Please open the issue in camel-kafka-connector github issues section.
qafro:1623647838:2021-06-14T13:17:18.498+0000:1623647838:2021-06-14T13:17:18.498+0000:ok"
0,CAMEL-16720,Task,Minor,None,3.11.0,"
None
",Resolved,Fixed,3.11.0,Andrea Cosentino,Claus Ibsen,0,1,2021-06-12 10:09:53+00:00,2021-06-17 13:39:24+00:00,"We only have AWS 2 clients so lets remove this from the component descriptions
https://camel.apache.org/components/latest/aws-summary.html",
0,CAMEL-16719,Improvement,Major,None,3.11.0,"
None
",Resolved,Fixed,3.11.0,Unassigned,Claus Ibsen,0,1,2021-06-12 08:56:51+00:00,2021-06-15 05:37:50+00:00,"https://camel.zulipchat.com/#narrow/stream/257298-camel/topic/Kafka.3A.20Group.20Instance.20id


Add this as endpoint option for the consumer


    public static final String GROUP_INSTANCE_ID_CONFIG = ""group.instance.id"";
    private static final String GROUP_INSTANCE_ID_DOC = ""A unique identifier of the consumer instance provided by the end user. Only non-empty strings are permitted. If set, the consumer is treated as a static member, which means that only one instance with this ID is allowed in the consumer group at any time. This can be used in combination with a larger session timeout to avoid group rebalances caused by transient unavailability (e.g. process restarts). If not set, the consumer will join the group as a dynamic member, which is the traditional behavior."";",
0,CAMEL-16718,Bug,Major,"3.7.4, 3.10.0","3.7.5, 3.11.0","
None
",Resolved,Fixed,"3.7.5, 3.11.0",Claus Ibsen,Morgan L,0,2,2021-06-12 08:56:43+00:00,2023-03-22 08:12:10+00:00,"My team has found what we believe is a conflict between the Netty TCP producer and the Resilience4J circuit breaker, under specific circumstances.


When the Netty TCP client encounters an error while writing to the server (for us, usually a broken pipe exception), if it is inside a circuit breaker, the route will hang indefinitely.


Discussion on Zulip: Conflict with Netty TCP + Resilience4J circuit breaker


A zipped version of the complete test project is attached.  It should allow you to reproduce the issue.


By running BrokeTCPServer.main(), and then invoking NettyTest.testNettyCircuitBreaker(), you should see that of the two messages we push into the queue, only one is processed. Only one connection is initiated to the BrokeTCPServer.","Morgan L:1623648412:2021-06-14T13:26:52.572+0000:1623648451:2021-06-14T13:27:31.203+0000:This issue does not occur when using the Mina TCP producer, nor when using the camel-hystrix circuit breaker implementation.
davsclaus:1623726104:2021-06-15T11:01:44.498+0000:1623726104:2021-06-15T11:01:44.498+0000:Where do you see a thread is hanging? I cannot easily reproduce this. I have the mock endpoint receive 2 messages, the big and then the small message.

However during shutdown netty does report an exception of shutting down its channel pool.

{code}
ERROR	2021-06-15 12:59:51,139	14951	io.netty.util.concurrent.DefaultPromise.rejectedExecution	[main]	Failed to submit a listener notification task. Event loop shut down?
java.util.concurrent.RejectedExecutionException: event executor terminated
	at io.netty.util.concurrent.SingleThreadEventExecutor.reject(SingleThreadEventExecutor.java:926)
	at io.netty.util.concurrent.SingleThreadEventExecutor.offerTask(SingleThreadEventExecutor.java:353)
	at io.netty.util.concurrent.SingleThreadEventExecutor.addTask(SingleThreadEventExecutor.java:346)
	at io.netty.util.concurrent.SingleThreadEventExecutor.execute(SingleThreadEventExecutor.java:828)
	at io.netty.util.concurrent.SingleThreadEventExecutor.execute(SingleThreadEventExecutor.java:818)
	at io.netty.util.concurrent.DefaultPromise.safeExecute(DefaultPromise.java:842)
	at io.netty.util.concurrent.DefaultPromise.notifyListeners(DefaultPromise.java:499)
	at io.netty.util.concurrent.DefaultPromise.addListener(DefaultPromise.java:184)
	at io.netty.channel.DefaultChannelPromise.addListener(DefaultChannelPromise.java:95)
	at io.netty.channel.DefaultChannelPromise.addListener(DefaultChannelPromise.java:30)
	at org.apache.camel.component.netty.NettyProducer$NettyProducerPoolableObjectFactory.destroyObject(NettyProducer.java:599)
	at org.apache.camel.component.netty.NettyProducer$NettyProducerPoolableObjectFactory.destroyObject(NettyProducer.java:577)
	at org.apache.commons.pool.impl.GenericObjectPool.destroy(GenericObjectPool.java:1339)
	at org.apache.commons.pool.impl.GenericObjectPool.clear(GenericObjectPool.java:1324)
	at org.apache.commons.pool.impl.GenericObjectPool.close(GenericObjectPool.java:1495)
	at org.apache.camel.component.netty.NettyProducer.doStop(NettyProducer.java:194)
{code}
Morgan L:1623734903:2021-06-15T13:28:23.363+0000:1623734903:2021-06-15T13:28:23.363+0000:One additional note: this issue does also occur with the camel-microprofile-fault-tolerance circuit breaker, at least on 3.10.0. 

Claus,

I was not able to pinpoint where a thread was hanging. Attached are logs from my run of the tests, out of the box and unchanged. Snippets edited for readability:
[^sample-camel - nettytest.log.txt]

 
{noformat}
INFO 2021-06-15 09:09:57,617 0 org.apache.camel.test.junit4.CamelTestSupport [main] ********************************************************************************
INFO 2021-06-15 09:09:57,618 1 org.apache.camel.test.junit4.CamelTestSupport [main] Testing: testNettyCircuitBreaker(com.peraton.camel.NettyTest)
INFO 2021-06-15 09:09:57,618 1 org.apache.camel.test.junit4.CamelTestSupport [main] ********************************************************************************
INFO 2021-06-15 09:09:57,665 48 org.apache.camel.support.LRUCacheFactory [main] Detected and using LRUCacheFactory: camel-caffeine-lrucache
INFO 2021-06-15 09:09:57,932 315 org.apache.camel.component.seda.SedaEndpoint [main] Endpoint seda://egress is using shared queue: seda://egress with size: 1000
INFO 2021-06-15 09:09:58,026 409 org.apache.camel.impl.engine.AbstractCamelContext [main] Apache Camel 3.7.3 (camel-1) is starting
INFO 2021-06-15 09:09:58,049 432 org.apache.camel.component.netty.NettyComponent [main] Creating shared NettyConsumerExecutorGroup with 17 threads
INFO 2021-06-15 09:09:58,604 987 org.apache.camel.impl.engine.InternalRouteStartupManager [main] Route: route1 started and consuming from: seda://egress
INFO 2021-06-15 09:09:58,605 988 org.apache.camel.impl.engine.AbstractCamelContext [main] Total 1 routes, of which 1 are started
INFO 2021-06-15 09:09:58,605 988 org.apache.camel.impl.engine.AbstractCamelContext [main] Apache Camel 3.7.3 (camel-1) started in 579ms
INFO 2021-06-15 09:09:58,624 1007 org.apache.camel.component.mock.MockEndpoint [main] Asserting: mock://result is satisfied
INFO 2021-06-15 09:09:59,621 2004 route1 [Camel (camel-1) thread #1 - seda://egress] Sending message: 8ACB67D83234BDE-0000000000000003.
WARN 2021-06-15 09:10:08,627 11010 org.apache.camel.component.mock.MockEndpoint [main] The latch did not reach 0 within the specified time
INFO 2021-06-15 09:10:08,627 11010 org.apache.camel.test.junit4.CamelTestSupport [main] ********************************************************************************
INFO 2021-06-15 09:10:08,627 11010 org.apache.camel.test.junit4.CamelTestSupport [main] Testing done: testNettyCircuitBreaker(com.peraton.camel.NettyTest)
INFO 2021-06-15 09:10:08,627 11010 org.apache.camel.test.junit4.CamelTestSupport [main] Took: 10s21ms (10021 millis)
INFO 2021-06-15 09:10:08,627 11010 org.apache.camel.test.junit4.CamelTestSupport [main] ********************************************************************************
INFO 2021-06-15 09:10:08,634 11017 org.apache.camel.impl.engine.AbstractCamelContext [main] Apache Camel 3.7.3 (camel-1) is shutting down
INFO 2021-06-15 09:10:08,634 11017 org.apache.camel.impl.engine.DefaultShutdownStrategy [main] Starting to graceful shutdown 1 routes (timeout 10 seconds)
INFO 2021-06-15 09:10:08,637 11020 org.apache.camel.impl.engine.DefaultShutdownStrategy [Camel (camel-1) thread #3 - ShutdownTask] Waiting as there are still 2 inflight and pending exchanges to complete, timeout in 10 seconds. Inflights per route: [route1 = 2]
...
INFO 2021-06-15 09:10:17,643 20026 org.apache.camel.impl.engine.DefaultShutdownStrategy [Camel (camel-1) thread #3 - ShutdownTask] Waiting as there are still 2 inflight and pending exchanges to complete, timeout in 1 seconds. Inflights per route: [route1 = 2]
WARN 2021-06-15 09:10:18,638 21021 org.apache.camel.impl.engine.DefaultShutdownStrategy [main] Timeout occurred during graceful shutdown. Forcing the routes to be shutdown now. Notice: some resources may still be running as graceful shutdown did not complete successfully.
WARN 2021-06-15 09:10:18,638 21021 org.apache.camel.impl.engine.DefaultShutdownStrategy [Camel (camel-1) thread #3 - ShutdownTask] Interrupted while waiting during graceful shutdown, will force shutdown now.
WARN 2021-06-15 09:10:18,658 21041 org.apache.camel.component.seda.SedaConsumer [Camel (camel-1) thread #1 - seda://egress] Error processing exchange. Exchange[]. Caused by: [java.util.concurrent.RejectedExecutionException - Run not allowed as ShutdownStrategy is forcing shutting down, will reject
	executing exchange: Exchange[8ACB67D83234BDE-0000000000000002]]
	java.util.concurrent.RejectedExecutionException: Run not allowed as ShutdownStrategy is forcing shutting down, will reject executing exchange: Exchange[8ACB67D83234BDE-0000000000000002]
	at org.apache.camel.impl.engine.CamelInternalProcessor.process(CamelInternalProcessor.java:249)
	...
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628) 
	at java.base/java.lang.Thread.run(Thread.java:834)
INFO 2021-06-15 09:10:18,660 21043 org.apache.camel.impl.engine.DefaultShutdownStrategy [Camel (camel-1) thread #3 - ShutdownTask] Route: route1 shutdown complete, was consuming from: seda://egress
INFO 2021-06-15 09:10:18,660 21043 org.apache.camel.impl.engine.DefaultShutdownStrategy [main] Graceful shutdown of 1 routes completed in 10s26ms
INFO 2021-06-15 09:10:18,679 21062 org.apache.camel.impl.engine.AbstractCamelContext [main] Apache Camel 3.7.3 (camel-1) uptime 20s653ms
INFO 2021-06-15 09:10:18,679 21062 org.apache.camel.impl.engine.AbstractCamelContext [main] Apache Camel 3.7.3 (camel-1) is shutdown in 10s45ms
java.lang.AssertionError: mock://result Received message count. Expected: <1> but was: <0>
Expected :<1>
Actual   :<0>
<Click to see difference> 

	at org.apache.camel.component.mock.MockEndpoint.fail(MockEndpoint.java:1762)
	...
	at com.intellij.rt.junit.JUnitStarter.main(JUnitStarter.java:58)Process finished with exit code -1{noformat}
 

[^sample-camel - broketcpserver.log.txt]
{noformat}
INFO 2021-06-15 09:09:51,777 0 com.peraton.camel.BrokeTCPServer [main] Starting broken server on port 6666
INFO 2021-06-15 09:10:00,405 8628 com.peraton.camel.BrokeTCPServer [Thread-0] Connection #1 accepted. Closing...{noformat}

Analyzing the trace-level logs on the actual application showed that some asynchronous callbacks were not being released, which is needed to continue routing. I will post more information on this as soon as I can.
Morgan L:1623744992:2021-06-15T16:16:32.245+0000:1623745441:2021-06-15T16:24:01.553+0000:So, trace logs give some clues when we grep for ""Asynchronous callback"". Here is the result when there is no write failure (for example, the first message is small enough that the write completes before the client 'realizes' the channel is closed):

 
{noformat}
TRACE   2021-06-15 12:03:14,514    942    org.apache.camel.impl.engine.DefaultAsyncProcessorAwaitManager [main] Asynchronous callback received for exchangeId: 88A601D1784658B-0000000000000000
... [main] Asynchronous callback received for exchangeId: 88A601D1784658B-0000000000000001
... [Camel Thread #2 - NettyClientTCPWorker]   Asynchronous callback received for exchangeId: 88A601D1784658B-0000000000000003
... [Camel (camel-1) thread #1 - seda://egress]    Asynchronous callback received, will continue routing exchangeId: 88A601D1784658B-0000000000000003 -> Exchange[88A601D1784658B-0000000000000003]
... [Camel Thread #2 - NettyClientTCPWorker]   Asynchronous callback received for exchangeId: 88A601D1784658B-0000000000000003
... [Camel Thread #4 - NettyClientTCPWorker]   Asynchronous callback received for exchangeId: 88A601D1784658B-0000000000000005
... [Camel (camel-1) thread #1 - seda://egress]    Asynchronous callback received, will continue routing exchangeId: 88A601D1784658B-0000000000000005 -> Exchange[88A601D1784658B-0000000000000005]
... [Camel Thread #4 - NettyClientTCPWorker]   Asynchronous callback received for exchangeId: 88A601D1784658B-0000000000000005
{noformat}
This log features two sets of such callbacks, because both messages got routed.

However, here is the result when this bug occurs (i.e. when there is a write failure):

 
{noformat}
TRACE   2021-06-15 11:57:50,602    903    org.apache.camel.impl.engine.DefaultAsyncProcessorAwaitManager [main] Asynchronous callback received for exchangeId: 23D0A193D5CDDE3-0000000000000000
... [main] Asynchronous callback received for exchangeId: 23D0A193D5CDDE3-0000000000000001
... [Camel (camel-1) thread #1 - seda://egress]    Asynchronous callback received for exchangeId: 23D0A193D5CDDE3-0000000000000002
{noformat}
As you can see, the asynchronous callback which causes routing to continue is never invoked.
Morgan L:1623745380:2021-06-15T16:23:00.171+0000:1623759228:2021-06-15T20:13:48.479+0000:To give you more information about the write error which can lead to this, debugging indicates that an error in {{io.netty.channel.AbstractChannel.writeAndFlush}} (or a subclass implementation) which leads to an invocation of {{io.netty.channel.AbstractChannel.handleWriteError}} leads to this bug occuring.

I was able to identify a possible partial cause of the issue, located in {{org.apache.camel.component.netty.NettyProducer.processWithConnectedChannel}}.  An anonymous subclass of ChannelFutureListener is created with a callback that invokes {{producerCallback.done}} if and only if the associated ChannelFuture completed successfully. If it failed, {{producerCallback.done}} is not invoked. In a debugger, manually invoking {{producerCallback.done}} inside that callback will prevent the route from hanging.

A comment in that method states that {{exceptionCaught}} should be invoked to handle failure instead, but {{exceptionCaught}} is never invoked in this case.

 

This is about as far as I got.

As for difficulty reproducing this, can you check in your debugger whether {{AbstractChannel.handleWriteError}} is being invoked?
 edit: also, are you using an IDE or any tool to run these? I am using IntelliJ. If you tell me what tool you're using, I will see if I can reproduce it on that.
davsclaus:1623799498:2021-06-16T07:24:58.968+0000:1623799498:2021-06-16T07:24:58.968+0000:Thanks for the detailed analysis.

Yeah I can see that we have a catch-22 where netty does not invoke the exceptionCaught in the client channel handler when the write operation failed in this way. However in other situations then its invoked.

I have a potential fix in the works, however it revealed a problem in an unit test in camel-netty-http that falsely is working but ignoring an internal netty reference count error.
davsclaus:1623801566:2021-06-16T07:59:26.896+0000:1623801566:2021-06-16T07:59:26.896+0000:Morgan,

Can you try testing with this commit merged in your 3.7.x branch (or rebuild main and use 3.11.0-SNAPSHOT)
https://github.com/apache/camel/commit/4845cf938e423355ea96ed7a3e1942fcceac2de3
Morgan L:1623819508:2021-06-16T12:58:28.272+0000:1623819508:2021-06-16T12:58:28.272+0000:Claus,

I rebuilt the Netty component from that commit, and it behaved correctly. The commit does fix this error.

If there's anything more I can do to help, let me know. Otherwise, I look forward to this fix being released.

Thanks!"
0,CAMEL-16717,New Feature,Major,None,None,"
None
",Resolved,Fixed,3.11.0,Unassigned,Hokutor,0,1,2021-06-11 18:23:36+00:00,2021-06-18 21:12:06+00:00,New camel component to integrate with Huawei Cloud Identity and Access Management (IAM) - [IAM](https://www.huaweicloud.com/intl/en-us/product/iam.html),"hokutor:1623932509:2021-06-17T20:21:49.200+0000:1623932509:2021-06-17T20:21:49.200+0000:First 2 PR's contain 4 Huawei Cloud IAM operations:
 * listUsers
 * getUser
 * listGroups
 * getGroupUsers
hokutor:1623936417:2021-06-17T21:26:57.384+0000:1623936417:2021-06-17T21:26:57.384+0000:PR raised at [https://github.com/apache/camel/pull/5703] for new Huawei Cloud IAM operations:
 * updateUser
 * updateGroup"
0,CAMEL-16716,Bug,Major,3.10.0,3.11.0,"
None
",Resolved,Fixed,3.11.0,Claus Ibsen,Andrea Tarocchi,0,2,2021-06-11 14:07:06+00:00,2021-06-12 08:33:38+00:00,"Although streamFilter is declared as a UriParam: https://github.com/apache/camel/blob/main/components/camel-mongodb/src/main/java/org/apache/camel/component/mongodb/MongoDbEndpoint.java#L108 (it should be annotated as consumer only though)


it is not honored. Such filter is only loaded from property: https://github.com/apache/camel/blob/main/components/camel-mongodb/src/main/java/org/apache/camel/component/mongodb/MongoDbChangeStreamsConsumer.java#L60-L64


as reported in ckc issue: https://github.com/apache/camel-kafka-connector/issues/1112","davsclaus:1623457524:2021-06-12T08:25:24.949+0000:1623457524:2021-06-12T08:25:24.949+0000:Yeah this option is very unusal as the contributor of this feature added it as a route property which NO other component uses, so lets correct this"
0,CAMEL-16715,Bug,Minor,3.10.0,3.11.0,"
None
",Resolved,Fixed,3.11.0,Unassigned,Pavol Zabka,0,1,2021-06-11 13:41:49+00:00,2021-06-14 04:30:32+00:00,"ZipkinServerResponseAdapter#onResponse possible NullPointerException


ISSUE:


 




if (exchange.getException() != null) { 
  String message = exchange.getException().getMessage();
  span.tag(""camel.server.exchange.failure"", message); 
}




span is instance of SpanCustomizer.
SpanCustomizer has method:


 




// Params: key – Name used to lookup spans, such as ""your_app.version"". 
//         value – String value, cannot be null.
SpanCustomizer tag(String key, String value);




 


SpanCustomizer#tag second parameter cannot be null. 


exchange.getException() is instance of Throwable
Throwable#getMethod documentation:




//Returns the detail message string of this throwable. 
//Returns: the detail message string of this Throwable instance (which may be null).
public String getMessage() { return detailMessage; }




Throwable.getMessage() may be null


FIX:
Second null check of getMessage method should fix this bug




if (exchange.getException() != null && exchange.getException().getMessage() != null) { 
  String message = exchange.getException().getMessage();
  span.tag(""camel.server.exchange.failure"", message); 
}",p8z:1623391922:2021-06-11T14:12:02.279+0000:1623391922:2021-06-11T14:12:02.279+0000:PR: https://github.com/apache/camel/pull/5657
0,CAMEL-16714,Task,Major,None,,"
None
",Closed,Invalid,None,Unassigned,Otavio Rodolfo Piske,0,2,2021-06-11 13:19:25+00:00,2021-06-14 08:59:55+00:00,"I am working on a Kamelet defined according to the attachment. However, when I define the binding, the integration fails because it cannot find the bean. The integration fails with:


 




2021-06-11 11:33:57,960 ERROR [io.qua.run.Application] (main) Failed to start application (with profile prod): java.lang.IllegalArgumentException: Property with key [connectionFactoryBean] not found in properties from text: jms:queue:person?connectionFactory=#bean:{{connectionFactoryBean}} 



In addition to how it is defined in the kamelet, I have also tried using:


 



kamelet-reify with allowAutoWiredConnectionFactory true or false


uri: ""kamelet-reify:jms:{{destinationType}}:{{destinationName}}""
 parameters:
 connectionFactory: ""#bean:{{connectionFactoryBean}}""
 allowAutoWiredConnectionFactory: true
 steps:
 - to:
 uri: ""log:info"" 

jms directly


uri: ""jms:{{destinationType}}:{{destinationName}}""
 parameters:
 connectionFactory: ""#bean:{{connectionFactoryBean}}""
 steps:
 - to:
 uri: ""log:info""

 




the old way of setting up the bean


uri: ""jms:{{destinationType}}:{{destinationName}}""
 parameters:
 connectionFactory: ""#{{connectionFactoryBean}}""
 steps:
 - to:
 uri: ""log:info""

 



Neither seems to work.


 


jms-source-binding.yaml


jms-source.kamelet.yaml","orpiske:1623388805:2021-06-11T13:20:05.270+0000:1623388805:2021-06-11T13:20:05.270+0000:I cannot provide debug logs at the moment due to: https://github.com/apache/camel-k/issues/2396
davsclaus:1623449481:2021-06-12T06:11:21.356+0000:1623449481:2021-06-12T06:11:21.356+0000:On main branch I cannot reproduce this - uses this route to call the sink, and had started a local ActiveMQ broker

- route:
    from: ""kamelet:jms-source?destinationName=cheese&brokerURL=tcp://localhost:61616""
    steps:
      - to:
          uri: ""log:info""


And used its web console to send a message to the cheese queue

17:58:47.747 [org.apache.camel.main.KameletMain.main()] INFO  o.a.c.i.engine.AbstractCamelContext - Routes startup summary (total:2 started:2)
17:58:47.747 [org.apache.camel.main.KameletMain.main()] INFO  o.a.c.i.engine.AbstractCamelContext -     Started route1 (kamelet://jms-source)
17:58:47.747 [org.apache.camel.main.KameletMain.main()] INFO  o.a.c.i.engine.AbstractCamelContext -     Started jms-source-1 (kamelet-reify:jms:queue:cheese)
17:58:47.747 [org.apache.camel.main.KameletMain.main()] INFO  o.a.c.i.engine.AbstractCamelContext - Apache Camel 3.11.0-SNAPSHOT (MyEarthQuake) started in 1s129ms (build:17ms init:887ms start:225ms)
17:58:47.747 [org.apache.camel.main.KameletMain.main()] INFO  o.a.c.i.engine.AbstractCamelContext - Lightweight mode enabled. Performing optimizations and memory reduction.
17:59:57.831 [Camel (MyEarthQuake) thread #0 - JmsConsumer[cheese]] INFO  info - Exchange[ExchangePattern: InOnly, BodyType: String, Body: Hello World]
orpiske:1623449666:2021-06-12T06:14:26.520+0000:1623449666:2021-06-12T06:14:26.520+0000:[~davsclaus] thanks for checking it. 

 

I had a chat with [~nferraro] and [~acosentino] yesterday and there is a very big chance I am using an outdated set of versions. I couldn't finish in time yesterday, and I will check again on Monday, but I think this issue might turn out as invalid.
orpiske:1623632334:2021-06-14T08:58:54.739+0000:1623632334:2021-06-14T08:58:54.739+0000:I'm closing this one as invalid. It worked OK after I correctly aligned the versions, so it was a mistake on my end. Thanks and sorry for the false negative!
orpiske:1623632395:2021-06-14T08:59:55.069+0000:1623632395:2021-06-14T08:59:55.069+0000:The issue was caused because I had an outdated set of versions for Camel K Runtime + Camel Quarkus. It was not a bug. Therefore, closing it as invalid."
0,CAMEL-16713,Improvement,Major,3.10.0,3.11.0,"
None
",Resolved,Fixed,3.11.0,Claus Ibsen,Claus Ibsen,0,1,2021-06-11 08:35:25+00:00,2021-06-11 08:49:10+00:00,No Desc,
0,CAMEL-16712,Bug,Major,3.10.0,None,"
None
",Resolved,Information Provided,None,Unassigned,Andrea Cosentino,0,2,2021-06-11 07:49:49+00:00,2021-06-11 08:38:33+00:00,"Suppose you have a Kamelet like this one:




apiVersion: camel.apache.org/v1alpha1
kind: Kamelet
metadata:   name: sql-sink
  annotations:     camel.apache.org/kamelet.support.level: ""Preview""
    camel.apache.org/catalog.version: ""main-SNAPSHOT""
    camel.apache.org/kamelet.icon: ""data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4KPCEtLSBHZW5lcmF0b3I6IEFkb2JlIElsbHVzdHJhdG9yIDIyLjEuMCwgU1ZHIEV4cG9ydCBQbHVnLUluIC4gU1ZHIFZlcnNpb246IDYuMDAgQnVpbGQgMCkgIC0tPgo8c3ZnIHZlcnNpb249IjEuMSIgaWQ9IkxheWVyXzEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHg9IjBweCIgeT0iMHB4IgoJIHZpZXdCb3g9IjAgMCAzMiAzMiIgc3R5bGU9ImVuYWJsZS1iYWNrZ3JvdW5kOm5ldyAwIDAgMzIgMzI7IiB4bWw6c3BhY2U9InByZXNlcnZlIj4KPHRpdGxlPmNhc3NhbmRyYTwvdGl0bGU+CjxwYXRoIGQ9Ik0yMy4zLDguN2MwLDAtMC4zLDAuMy0wLjUsMC41Yy0wLjUsMC41LTEuMiwxLjMtMS43LDEuNWgwYy0wLjEsMC0wLjEsMC0wLjItMC4xbDAuOS0xLjlsMCwwYzAsMC4xLTEsMS45LTIuMiwxLjZsMCwwCgljMCwwLDAsMC0wLjEsMGMwLjYtMC44LDAuOC0xLjUsMC44LTEuNXMtMSwxLjYtMi4zLDEuMmMwLDAtMC4xLDAtMC4xLTAuMWMwLDAsMC0wLjEsMC0wLjFjMC0wLjEsMC4xLTAuMSwwLjEtMC4yCgljMC4xLTAuMiwwLjMtMC41LDAuMy0wLjVTMTguMyw5LjUsMTgsOS43bDAsMGMtMC4yLDAuMS0wLjUsMC4zLTAuNywwLjNjLTAuMSwwLTAuMSwwLTAuMiwwYy0wLjMtMC4xLTAuMy0wLjMtMC4yLTAuNgoJYzAuMS0wLjMsMC4yLTAuNSwwLjItMC41cy0wLjMsMC40LTAuNSwwLjhjLTAuMiwwLjMtMC40LDAuNS0wLjYsMC42bC0wLjIsMGMtMC4xLTAuMiwwLjEtMSwwLjEtMWMtMC4xLDAuMi0wLjMsMC40LTAuNCwwLjYKCWMtMC4xLDAuMi0wLjMsMC4zLTAuNSwwLjRoMGMtMC4xLDAtMC4yLDAtMC4zLDBjMCwwLTAuMS0wLjEtMC4xLTAuMmMtMC4xLTAuNCwwLjItMSwwLjItMWMwLDAtMC4xLDAuMy0wLjMsMC43djAKCWMwLDAuMS0wLjEsMC4yLTAuMSwwLjJjLTAuMSwwLjItMC4yLDAuMy0wLjMsMC4zYy0wLjItMC4xLTAuMy0wLjMtMC4zLTAuNWMtMC4xLTAuMi0wLjEtMC40LTAuMS0wLjRzMCwwLjMtMC4yLDAuNwoJYzAsMC4xLTAuMSwwLjItMC4yLDAuM2MwLDAtMC4xLDAuMS0wLjEsMC4xYy0xLjIsMC4yLTIuNCwwLjYtMy41LDFjLTAuMywwLjEtMC42LDAuMi0wLjksMC4zYy0xLDAuNC0yLDEtMy4xLDEuNwoJYy0xLjIsMC44LTIuMywxLjYtMy40LDIuNmMtMC42LDAuNS0xLjIsMS4xLTEuOCwxLjdjNC43LTIuNiw2LjYtNi4zLDE1LjUtNi43YzYuNy0wLjMsOS45LDIuOCwxMC45LDIuOWMyLjYsMC4xLDQuMy0xLjksNC45LTIuNgoJYzAuMS0wLjIsMC4yLTAuMywwLjItMC4zYzAsMC0wLjQsMC41LTEsMWwwLDBjLTAuNiwwLjUtMS40LDAuOS0yLjEsMC44aDBjLTAuMSwwLTAuMiwwLTAuMywwYzEtMC42LDEuNi0xLjYsMi0yLjEKCWMwLjEtMC4yLDAuMy0wLjUsMC4zLTAuNXMtMi4zLDIuNC00LjEsMi4yYy0wLjEsMC0wLjEsMC0wLjIsMGMwLjgtMC42LDEuMy0xLjQsMS43LTIuMXYwaDBjMC40LTAuNywwLjYtMS4zLDAuNi0xLjMKCWMwLDAtMC40LDAuNy0xLDEuNGwwLDBjLTAuNiwwLjctMS4zLDEuNS0yLDEuN2MtMC4xLDAtMC4yLDAuMS0wLjMsMC4xYzEuNC0xLjMsMi4xLTMuMSwyLjEtMy4xcy0xLjUsMi4xLTIuNywyLjUKCWMtMC4xLDAtMC4yLDAuMS0wLjIsMC4xYzAuOC0wLjcsMS4yLTEuMiwxLjQtMS43YzAuMy0wLjUsMC40LTAuOSwwLjQtMC45bDAsMGMtMC4xLDAuMi0wLjIsMC4zLTAuNCwwLjRsMCwwYy0wLjMsMC40LTAuOSwxLTEuNCwxLjQKCWwwLDBjLTAuMSwwLjEtMC4zLDAuMi0wLjQsMC4zYzAsMC0wLjEsMC4xLTAuMSwwLjFjLTAuMSwwLjEtMC4yLDAuMS0wLjQsMC4yYzAsMC0wLjEsMC0wLjEsMGMtMC4xLTAuMS0wLjItMC4xLTAuMy0wLjIKCWMtMC4xLDAuMS0wLjEsMC4yLTAuMiwwLjJoMGMwLDAtMC4xLDAtMC4xLDBjMS4xLTEuMiwxLjktMi44LDEuOS0yLjhsMCwwYzAsMC0xLjYsMi4xLTIuMywyLjNjLTAuMSwwLTAuMi0wLjEtMC4zLTAuMQoJYzAtMC4xLDAtMC4xLDAuMS0wLjJjMC4yLTAuNCwwLjYtMSwwLjYtMXMtMC4xLDAuMS0wLjIsMC4xYy0wLjEsMC4xLTAuMywwLjItMC40LDAuM2MtMC4xLDAuMS0wLjIsMC4xLTAuMiwwLjEKCWMtMC4xLDAuMS0wLjIsMC4xLTAuMywwLjFjLTAuMSwwLjEtMC4yLDAuMS0wLjMsMC4xYy0wLjEsMC0wLjEsMC0wLjEsMEMyMi4zLDEwLjUsMjMuMyw4LjcsMjMuMyw4LjdMMjMuMyw4Ljd6IE0xNywxMS42CgljLTAuNCwwLTAuOCwwLTEuMiwwYy0wLjQsMC0wLjcsMC0xLjEsMC4xYy0wLjQsMC4yLTAuNywwLjQtMSwwLjZjMCwwLjEsMCwwLjEsMCwwLjJjMCwwLjEsMCwwLjItMC4xLDAuMmwxLjIsMC45bDAsMGwtMC41LTEuNwoJbDAuOCwxLjVjMCwwLDAuMSwwLDAuMSwwbDAtMS42bDAuNSwxLjZsMC42LTEuNWwwLDEuN2MwLDAsMCwwLDAsMGwwLjktMS4zbC0wLjUsMS42bDAsMGwxLjQtMC45bC0xLDEuNHYwbDEuMy0wLjVjMCwwLDAsMCwwLjEtMC4xCgljLTAuMy0wLjQsMC0wLjksMC41LTAuOGMwLjItMC4zLDAuMy0wLjcsMC40LTFDMTguNiwxMS43LDE3LjgsMTEuNiwxNywxMS42TDE3LDExLjZ6IE0xMy42LDExLjhMMTMuNiwxMS44Yy0wLjQsMC0wLjgsMC4xLTEuMiwwLjIKCXMtMC44LDAuMS0xLjEsMC4yaDBjMC4yLDAuNSwwLjQsMSwwLjcsMS40YzAuMS0wLjMsMC4zLTAuNiwwLjUtMC45Yy0wLjItMC41LDAuMy0wLjksMC44LTAuN0MxMy40LDExLjksMTMuNSwxMS44LDEzLjYsMTEuOAoJTDEzLjYsMTEuOHogTTE5LjYsMTEuOWMwLDAuNC0wLjEsMC43LTAuMiwxLjFjMC40LDAuMywwLjEsMS0wLjQsMC45Yy0wLjIsMC4zLTAuNSwwLjYtMC43LDAuOGwwLjksMGwtMS4zLDAuM2MwLDAtMC4xLDAuMS0wLjEsMC4xCgljMC44LDAuMSwxLjUsMC40LDIuMSwwLjljMC40LTAuOCwwLjctMS42LDAuNy0yLjZDMjAuNCwxMi44LDIwLDEyLjMsMTkuNiwxMS45TDE5LjYsMTEuOXogTTExLjEsMTIuMmMtMC40LDAuMS0wLjgsMC4yLTEuMSwwLjMKCWMtMC4yLDAuMy0wLjMsMC43LTAuMywxYzAsMi4yLDEuMyw0LDMuMSw0LjlsMCwwYy0wLjMtMC4zLTAuNi0wLjctMC44LTEuMWMtMC45LDAuMS0xLjItMS4xLTAuNC0xLjRjLTAuMS0wLjYsMC0xLjMsMC4yLTEuOQoJQzExLjUsMTMuNSwxMS4yLDEyLjksMTEuMSwxMi4yTDExLjEsMTIuMnogTTIxLjMsMTIuMmMwLjIsMC41LDAuMywxLjEsMC4zLDEuN2MwLDMuMy0yLjksNS45LTYuNiw1LjljLTMuNiwwLTYuNi0yLjYtNi42LTUuOQoJYzAtMC4zLDAtMC42LDAuMS0wLjljLTEsMC40LTEuOSwwLjktMi44LDEuNWMtMC4zLDAuNS0wLjQsMS4xLTAuNCwxLjZjMC4xLDEuMywxLjMsMi40LDMsMy4ybC0wLjMtMC4xYy0zLjEtMC45LTUuNSwwLjctOC4xLTAuNwoJYzAuNiwwLjUsMS4zLDEsMy4zLDFjMC43LDAsMi45LTAuMSwzLjMsMC4yYzAuNCwwLjMtMS40LDItMS40LDJzMy0yLjUsMy4zLTEuN2MwLjIsMC41LTAuOSwyLTAuOSwyczEtMS40LDEuOC0xLjcKCWMwLjUtMC4yLDEtMC4yLDEuNCwwLjRjMC4yLDAuMy0xLjIsMi4xLTEuMiwyLjFzMi0xLjksMi4zLTEuOGMwLjQsMC4xLDAsMS44LDAsMS44czAuNy0xLjcsMS4xLTEuOWMwLjUtMC4yLTEuMiw0LTEuMiw0CglzMi4xLTMuOSwyLjUtNGMwLjctMC4yLDEuMSwyLjcsMS4xLDIuN3MtMC4zLTIuNSwwLTIuN2MyLjMtMSwxLDQuMywxLDQuM3MxLjUtMy42LDAuNi00LjRjMi40LDEuNiwyLjEsNC40LDIuMSw0LjRzMC42LTEuNC0xLjEtNC43CgljMSwwLDIuNCwyLjUsMi40LDIuNXMtMS42LTIuOC0wLjUtMi44YzIuMS0wLjEsMi4zLDMuNywyLjMsMy43czAuNi0wLjUtMS4xLTQuMmMxLjEtMC43LDMuNywzLjQsMy43LDMuNHMtMi40LTQtMi00LjMKCWMwLjQtMC4zLDEuOCwxLjMsMS44LDEuM3MtMS4xLTEuNS0wLjgtMS42YzAuMy0wLjIsMy4yLDIuOSwzLjIsMi45cy0yLjUtMy0yLjEtMy40YzAuNC0wLjQsMi4zLDEsMi4zLDFzLTIuOC0xLjktMi4zLTIuMgoJYzAuOC0wLjQsMywxLDMsMXMtMS4zLTEuMS0xLjEtMS40YzAuMi0wLjMsMi44LDEuNywyLjgsMS43cy0yLjMtMS44LTIuNC0yLjNjLTAuMS0wLjUsMS44LDAuMiwxLjgsMC4ycy0yLjEtMS0yLjItMS4zCgljMC0wLjMsMS40LDAuMywxLjQsMC4zcy0yLTEuNi0yLjUtMC4zYy0wLjEsMC4yLTAuMiwwLjQtMC40LDAuNmMwLjEtMC40LDAuMi0wLjcsMC4xLTEuMWMwLTAuMSwwLTAuMi0wLjEtMC40CglDMjQuNiwxMy41LDIzLjIsMTIuOCwyMS4zLDEyLjJMMjEuMywxMi4yeiBNMTMuNSwxMi44Yy0wLjEsMC4yLTAuNCwwLjMtMC43LDAuMmMtMC4xLDAuMS0wLjEsMC4yLTAuMiwwLjNsMS43LDAuNmMwLDAsMCwwLDAtMC4xCglMMTMuNSwxMi44eiBNMTIuNywxMy40Yy0wLjEsMC4yLTAuMiwwLjQtMC4zLDAuN2MwLjIsMC4yLDAuMywwLjMsMC41LDAuNWwxLjIsMGwwLDBMMTIuNywxMy40eiBNMTguMiwxNC4xbC0wLjgsMC42bDAuMSwwCglDMTcuOCwxNC41LDE4LDE0LjMsMTguMiwxNC4xeiBNMTIuMiwxNC41QzEyLjIsMTQuNSwxMi4yLDE0LjUsMTIuMiwxNC41Yy0wLjEsMC41LTAuMSwwLjktMC4xLDEuM2MwLjMsMC4xLDAuNiwwLjMsMC42LDAuNmwxLjItMC44CgljLTAuMSwwLTAuMi0wLjEtMC4zLTAuMWwtMS40LTAuMWwwLjgtMC4yQzEyLjgsMTUsMTIuNSwxNC44LDEyLjIsMTQuNUwxMi4yLDE0LjV6IE0xMy4zLDE0LjhjMC4yLDAuMSwwLjQsMC4yLDAuNiwwLjNsMC4yLDAKCWMwLDAsMCwwLDAtMC4xTDEzLjMsMTQuOHogTTE3LjQsMTUuN2wxLjIsMS4yTDE3LDE2LjJsMC45LDEuNGwtMS40LTEuMWwwLDBsMC41LDEuN2wtMC44LTEuNWwtMC4xLDEuOGwtMC41LTEuOGwtMC42LDEuN2wwLjItMS44CglsMCwwTDE0LDE4LjJsMC40LTEuNWMtMC41LDAuNC0wLjgsMS0xLjEsMS42YzAuMSwwLjEsMC4zLDAuMywwLjQsMC40YzIuMiwwLjYsNC42LTAuMyw1LjgtMi4zYy0wLjUtMC4zLTEuMS0wLjYtMS43LTAuN0wxNy40LDE1Ljd6CgkgTTE0LjIsMTZsLTEuNCwwLjVjMCwwLDAsMCwwLDAuMWMwLDAuMi0wLjEsMC40LTAuMiwwLjZjMC4xLDAuMywwLjMsMC42LDAuNSwwLjhjMC4xLTAuMywwLjMtMC42LDAuNC0wLjhMMTMsMTcuNEwxNC4yLDE2egoJIE0xOSwxOS43Yy0wLjIsMC4xLTAuNSwwLjEtMC44LDAuMkMxOC41LDE5LjgsMTguOCwxOS43LDE5LDE5Ljd6IE0xNy42LDIwYy0wLjIsMC0wLjMsMC4xLTAuNSwwLjFjLTAuMywwLTAuNSwwLjEtMC44LDAuMQoJQzE2LjgsMjAuMSwxNy4yLDIwLjEsMTcuNiwyMEwxNy42LDIweiBNMTUuOCwyMC4yYy0wLjEsMC0wLjMsMC0wLjQsMEMxNS41LDIwLjIsMTUuNiwyMC4yLDE1LjgsMjAuMnoiLz4KPC9zdmc+Cg==""
    camel.apache.org/provider: ""Apache Software Foundation""
    camel.apache.org/kamelet.group: ""SQL""
  labels:     camel.apache.org/kamelet.type: ""sink""
spec:   definition:     title: ""SQL Sink""
    description: |-
      Send data to a Database.
    required:       - serverName
      - port
      - username
      - password
      - query
    type: object
    properties:       serverName:         title: Server Name
        description: Server Name for the data source
        type: string
        example: localhost
      port:         title: Port
        description: Server Port for the data source
        type: string
        example: 9042
      username:         title: Username
        description: The username to use for accessing a secured Cassandra Cluster
        type: string
      password:         title: Password
        description: The password to use for accessing a secured Cassandra Cluster
        type: string
        format: password
        x-descriptors:         - urn:alm:descriptor:com.tectonic.ui:password
      query:         title: Prepared Statement
        description: The Prepared statement to execute against the Cassandra cluster table
        type: string
  dependencies:   - ""camel:jackson""
  - ""camel:kamelet""
  - ""camel:sql""
  flow:     beans:       - name: dsBean
        type: org.postgresql.ds.PGSimpleDataSource
        property:           - key: username
            value: '{{username}}'
          - key: password
            value: '{{password}}'
          - key: serverName
            value: '{{serverName}}'
    from:       uri: ""kamelet:source""
      steps:       - unmarshal:           json: 
            library: Jackson
      - to: 
          uri: ""kamelet-reify:sql:{{query}}?dataSource=#dsBean""



 


You'll get an error like:




[1] 2021-06-11 07:44:18,800 ERROR [io.qua.run.Application] (main) Failed to start application (with profile prod): java.lang.IllegalArgumentException: Could not find a suitable setter for property: dataSource as there isn't a setter method with same type: java.lang.String nor type conversion possible: No type converter available to convert from type: java.lang.String to the required type: javax.sql.DataSource with value #dsBean



 


If you switch to




      - to: 
          uri: ""kamelet-reify:sql:{{query}}""
          parameters:             dataSource: ""#{{dsBean}}""



 


The error will be


 




[1] 2021-06-11 07:47:24,195 ERROR [io.qua.run.Application] (main) Failed to start application (with profile prod): java.lang.IllegalArgumentException: Property with key [dsBean] not found in properties from text: kamelet-reify:sql:INSERT INTO accounts (username,city) VALUES (:#username,:#city)?dataSource=#{{dsBean}}



If you switch to




      - to: 
          uri: ""kamelet-reify:sql:{{query}}""
          parameters:             dataSource: ""{{dsBean}}""



The error will be


 




[2] 2021-06-11 07:48:32,313 ERROR [io.qua.run.Application] (main) Failed to start application (with profile prod): java.lang.IllegalArgumentException: Property with key [dsBean] not found in properties from text: kamelet-reify:sql:INSERT INTO accounts (username,city) VALUES (:#username,:#city)?dataSource={{dsBean}}



This happens even without the kamelet-reify component","davsclaus:1623369107:2021-06-11T07:51:47.313+0000:1623369107:2021-06-11T07:51:47.313+0000:Try with #bean:xxx


davsclaus:1623369149:2021-06-11T07:52:29.050+0000:1623369149:2021-06-11T07:52:29.050+0000:The old syntax #beanId is deprecated, you should favour using #bean:xxx to make it stand out that its a bean reference (we also have #type #class and others)
acosentino:1623371900:2021-06-11T08:38:20.172+0000:1623371900:2021-06-11T08:38:20.172+0000:Ok this works if you use the following syntax:
https://gist.github.com/oscerd/ae119735ce6c11d849805c70d3546f3e"
0,CAMEL-16711,Improvement,Major,None,3.11.0,"
None
",Resolved,Fixed,3.11.0,Claus Ibsen,Claus Ibsen,0,1,2021-06-11 07:37:44+00:00,2021-06-14 09:44:20+00:00,"camel-cmis
camel-corda
camel-hdfs
camel-jcache
camel-zookeeper-master
camel-bean-validator
camel-bean
camel-ftp


We can create special camel-cmis-karaf JAR in camel-karaf that has the extra OSGi source code - usually something about detecting OSGi and doing some extra work","davsclaus:1623618219:2021-06-14T05:03:39.391+0000:1623635054:2021-06-14T09:44:14.918+0000:camel-cmis *DONE*
camel-corda *DONE* (no osgi)
camel-hdfs *DONE* (no karaf feature)
camel-jcache *DONE*
camel-zookeeper-master *DONE*
camel-bean-validator *DONE*
camel-ftp *DONE*
camel-bean *DONE*"
0,CAMEL-16710,Improvement,Minor,3.7.0,Future,"
None
",Open,Unresolved,Future,Unassigned,Mathias Aebersold,0,3,2021-06-11 07:20:53+00:00,2023-08-09 09:20:07+00:00,"Hi there,


we are implementing a Quickfix request-reply message exchange where the reply message can be one of 2 different message types, which is not supported by the current implementation. However, this is a common situation during FIX business processes. E.g. sending a QuoteRequest message will yield in a response of either a Quote or QuoteRequestReject message.


 


The current implementation of the correlation criteria with a MessagePredicate object requires exactly 1 MsgType in its constructor:
https://camel.apache.org/components/latest/quickfix-component.html#_implementing_inout_exchanges_for_producers




exchange.setProperty(QuickfixjProducer.CORRELATION_CRITERIA_KEY,
    new MessagePredicate(new SessionID(sessionID), MsgType.EXECUTION_REPORT)
        .withField(ExecTransType.FIELD, Integer.toString(ExecTransType.STATUS))
        .withField(OrderID.FIELD, request.getString(OrderID.FIELD)));




 


 


I see 2 potential approaches to improve the current implementation:


1) Correlation criteria without a MsgType.


This could be very quickly implemented using a new  {{MessagePredicate }}constructor:
 Existing constructor:


org.apache.camel.component.quickfixj.MessagePredicate#MessagePredicate

    public MessagePredicate(SessionID requestingSessionID, String msgType) {
        addHeaderFieldIfPresent(SenderCompID.FIELD, requestingSessionID.getSenderCompID());
        addHeaderFieldIfPresent(TargetCompID.FIELD, requestingSessionID.getTargetCompID());
        withMessageType(msgType);
    }




Proposed new constructor without the parameter String msgType:


org.apache.camel.component.quickfixj.MessagePredicate#MessagePredicate

    public MessagePredicate(SessionID requestingSessionID) {
        addHeaderFieldIfPresent(SenderCompID.FIELD, requestingSessionID.getSenderCompID());
        addHeaderFieldIfPresent(TargetCompID.FIELD, requestingSessionID.getTargetCompID());
    }




2) Multiple MessagePredicate for different MsgType


This approach would replace the existing correlation criteria consisting of a single MessagePredicate object with a list of MessagePredicate objects. An incoming message would be successfully correlated if any of the MessagePredicate objects would evaluate to true.","davsclaus:1662163065:2022-09-03T07:57:45.347+0000:1662163065:2022-09-03T07:57:45.347+0000:Are you able to work on a PR with this functionality
infosec812:1675507897:2023-02-04T18:51:37.176+0000:1675507897:2023-02-04T18:51:37.176+0000:Another possible option might be to create a superclass or parent interface which both of those types inherit from?"
0,CAMEL-16709,Improvement,Minor,3.10.0,3.11.0,"
None
",Resolved,Fixed,3.11.0,Claus Ibsen,Rastislav Papp,0,2,2021-06-11 06:48:46+00:00,2021-06-12 08:21:42+00:00,"In 3.10.0 (maybe sooner, we're trying to switch from 3.6.0) handling of URIs has changed, and this code no longer works:




org.apache.camel.support.ResourceHelper.resolveMandatoryResourceAsInputStream(context, ""file:/C:/test.txt"");




because Camel will try to send ""/C:/xxx.txt"" into Paths.get(...), instead of new FileInputStream(...) as before. Paths.get cannot handle the initial slash. 


Switching to the format without the slash - ""file:C:/..."" would work, but then following code does not:




Path path = Paths.get(URI.create(""file:C:/test.txt""));




It fails with URI is not hierarchical message (and we use something like this in multiple places, so this stops us from upgrading to newer versions of camel)","rastislav.papp:1623393644:2021-06-11T14:40:44.592+0000:1623393644:2021-06-11T14:40:44.592+0000:Sorry, I thought I've created the ticket with the wrong issue type (Improvement), I see now that you've changed it. My bad :)
davsclaus:1623456092:2021-06-12T08:01:32.327+0000:1623456092:2021-06-12T08:01:32.327+0000:Lets use java.io.File in the file resource resolver then that ought to work again with windows with those different slash combos"
0,CAMEL-16708,Improvement,Major,None,3.11.0,"
None
",Resolved,Fixed,3.11.0,Claus Ibsen,Claus Ibsen,0,1,2021-06-11 05:53:01+00:00,2021-06-11 05:53:24+00:00,No Desc,
0,CAMEL-16707,Bug,Minor,3.6.0,"3.7.5, 3.11.0","
None
",Resolved,Fixed,"3.7.5, 3.11.0",Unassigned,Rastislav Papp,0,2,2021-06-10 19:22:53+00:00,2021-07-19 10:58:53+00:00,"camel-rabbitmq component causes a connection leak when there is an error during declaration of exchanges/queues (e.g. when an exchange with the same name but different type already exists).


Problem lies in org.apache.camel.component.rabbitmq.RabbitConsumer:





    RabbitConsumer(RabbitMQConsumer consumer) {
        // super(channel);
        this.consumer = consumer;
        try {
            Connection conn = consumer.getConnection();
            this.channel = openChannel(conn);
        } catch (IOException | TimeoutException e) {
            LOG.warn(""Unable to open channel for RabbitMQConsumer. Continuing and will try again"", e);
        }
    }

    //...

    private Channel openChannel(Connection conn) throws IOException {
        Channel channel = //... channel gets created
        //...
        if (consumer.getEndpoint().isDeclare()) {
            consumer.getEndpoint().declareExchangeAndQueue(channel);
        }
        return channel;
    }




if declareExchangeAndQueue gets called, and if it throws an exception (e.g. because the exchange is already declared with different configuration) the exception is caught and consumed in the constructor, and the channel is never closed. I think the exception should be propagated in this case, because it is not recoverable (or at least there should be an option for this). It would also cause the app startup to fail, which would be a good thing in this case.","davsclaus:1623357092:2021-06-11T04:31:32.530+0000:1623357092:2021-06-11T04:31:32.530+0000:You are welcome to test with Camel 3.10.0 and also if still a bug, then try to fix and send a PR.
Also try testing with camel-spring-rabbitmq as its a better component than this.
rastislav.papp:1623364389:2021-06-11T06:33:09.326+0000:1623364389:2021-06-11T06:33:09.326+0000:I've tried to look at 3.10.0 code, it seems unchanged. 

We'll probably migrate to the camel-spring-rabbitmq component in the future. In the meantime I have the fix in our fork, will try to submit PR.
davsclaus:1623373641:2021-06-11T09:07:21.416+0000:1623373641:2021-06-11T09:07:21.416+0000:Thanks a PR is much appreciated
rastislav.papp:1623576986:2021-06-13T17:36:26.259+0000:1623576986:2021-06-13T17:36:26.259+0000:I've eventually found the connection leak at a different place. The PR is submitted :-)
davsclaus:1623631617:2021-06-14T08:46:57.600+0000:1623631617:2021-06-14T08:46:57.600+0000:You are welcome to provide a PR for 3.7.x branch if possible
rastislav.papp:1626663489:2021-07-19T10:58:09.394+0000:1626663533:2021-07-19T10:58:53.784+0000:[~davsclaus], the new camel-rabbitmq property {{recoverFromDeclareException}} has a default value of true (so as not to change the previous behavior). It is declared in the in the component as:
{code:java}
@Metadata(label = ""consumer"")
private boolean recoverFromDeclareException = true;{code}

and in the endpoint as:

{code}
@UriParam(label = ""consumer"", defaultValue = ""true"")
private boolean recoverFromDeclareException = true; 
{code}

but the documentation page https://camel.apache.org/components/3.7.x/rabbitmq-component.html  says the default value is false. How come?"
0,CAMEL-16706,Improvement,Major,None,3.13.0,"
None
",Resolved,Won't Fix,3.13.0,Unassigned,Claus Ibsen,0,1,2021-06-10 16:04:09+00:00,2021-10-12 07:17:29+00:00,"We should look at for Camel's FactoryFinder which is used to plugin various things by classpath discovery. However the class is instantiated reflective via Injector.


We could look at source code generate in src/main/generated java code that creates this class via Java code and new constructor.","davsclaus:1623367593:2021-06-11T07:26:33.782+0000:1623367593:2021-06-11T07:26:33.782+0000:Its not only factory finder, its also configurer, components, and whatnot. Basically anything that are in META-INF/services and has a metadata file that refers to a class name. That class is created with default no-arg constructor (reflection). 

We could make a maven plugin goal, that scans the classpath, and create a source code file for all those classes, and creates those via new XXX, and then put that in src/main/generated with a fixed classname, that CamelContext then can use.

However all this magic is also something that camel-quarkus may be better at by its build-time optimizations where some of such things is already done there"
0,CAMEL-16705,Bug,Minor,"3.7.0, 3.8.0, 3.9.0, 3.10.0",None,"

log
log-level
logging

",Resolved,Fixed,3.11.0,Claus Ibsen,Christian Rossius,0,2,2021-06-10 10:57:29+00:00,2021-06-11 09:17:53+00:00,"The default LogLevel is INFO. When i want to change this by spring boot actuator (JMX) to ERROR or WARN it works, but when i want to change it to DEBUG or TRACE it don't.


If I set the LogLevel at the beginning to TRACE, I can change it down to any other Level manually.


So decreasing works, but increasing the LogLevel dont.


It only applied to logging in Camel Routes. It works great on any other Logging.


In Version 3.6.0 and below it worked. All versions after that don't work anymore.


It is also descibed here [https://stackoverflow.com/questions/66357203/changing-camel-log-level-at-runtime-using-spring-boot-actuator|Stackoverflow]","davsclaus:1623294650:2021-06-10T11:10:50.052+0000:1623294650:2021-06-10T11:10:50.052+0000:Put together a reproducer such as a sample applcation and put on github or attach as .zip file here and include README how to run and change that logging at runtime, and what to expect.

davsclaus:1623294699:2021-06-10T11:11:39.824+0000:1623294699:2021-06-10T11:11:39.824+0000:Since this is spring boot it may also be a spring boot upgrade that something is changed in spring boot so its no longer possible
CRossius:1623299096:2021-06-10T12:24:56.007+0000:1623299096:2021-06-10T12:24:56.007+0000:Hi Claus,

i added an example project"
0,CAMEL-16704,Bug,Minor,"2.17.0, 2.24.3, 3.0.1, 3.1.0, 3.10.0","3.11.1, 3.12.0","
None
",Resolved,Fixed,"3.11.1, 3.12.0",Claus Ibsen,Sreejith Veluvil,0,3,2021-06-10 09:56:39+00:00,2021-06-29 05:28:22+00:00,"Hi,


Requests are getting timed out while waiting for the threads assigned to a channel because the thread is busy executing some other work.


Below is a simple camel route with a processor to imitate a long running activity by sleeping thread, camel-ahc component, and a processor to log the output. The above steps are running in a loop for two times. 


Direct(source) -> Loop (2) ->                                                                                                                                             Processor to imitate a long running  activity -> AHC component -> Processor to log body -> Mock Output


I fired two async calls with a small delay between them. For the first call, after completing the long running activity, the message reached AHC component. The response was received and it was processed successfully by the Netty thread. After this all the activities are done by Netty thread and it starts processing the long running activity (since it is running in a loop).


Meanwhile, the call with the second message completed the long running activity and message will reach the AHC component. Netty will assign the same channel which was assigned to the first message. Now it will wait for the thread to be available to process the response and this thread is busy performing the long running activity and eventually the requests times out. 


Below are some important logs I extracted from the version 2.24.3. From the logs, it is clear that the channel with id '0xbc4290ed' is assigned for both HTTP calls and request times out waiting for the thread named 'AHC-NETTY-COMMON-1-1'.                                                       


I have attached JUnits for all 3 versions with folder name '217', '224' and '301'. Each folder will have JUnit for that particular version, Detailed TRACE log named 'Detailed_Logs_XXX.log' and important logs I extracted in a file named 'Important_Logs.txt'


17:44:38| Camel (camel-1) thread #1 - ProducerTemplate | ThreadDelay.java 39 ## Camel (camel-1) thread #1 - ProducerTemplate going into sleep... Exchange Id :: ID-W-PF26MQZL-1622808877625-0-1.                           


17:44:38| Camel (camel-1) thread #1 - ProducerTemplate | ThreadDelay.java 39 ## Camel (camel-1) thread #1 - ProducerTemplate going into sleep... Exchange Id :: ID-W-PF26MQZL-1622808877625-0-1.                           


17:44:41| Camel (camel-1) thread #2 - ProducerTemplate | ThreadDelay.java 39 ## Camel (camel-1) thread #2 - ProducerTemplate going into sleep... Exchange Id :: ID-W-PF26MQZL-1622808877625-0-2.                           


17:44:42| Camel (camel-1) thread #1 - ProducerTemplate | ThreadDelay.java 41 ## Camel (camel-1) thread #1 - ProducerTemplate woke up from sleep... Exchange Id :: ID-W-PF26MQZL-1622808877625-0-1.                       


17:44:42| Camel (camel-1) thread #1 - ProducerTemplate | AhcProducer.java 53 ## Executing request https://www.boredapi.com/api/activity GET headers: breadcrumbId:ID-W-PF26MQZL-1622808877625-0-1 


17:44:44| AHC-NETTY-COMMON-1-1 | NettyConnectListener.java 73 ## Using new Channel '[id: 0xbc4290ed, L:/10.16.84.166:62334 - R:www.boredapi.com/34.201.80.84:443]' for 'GET' to '/api/activity'                           


17:44:44| AHC-NETTY-COMMON-1-1 | ThreadDelay.java 48 ## AHC-NETTY-COMMON-1-1 Exchange Id :: ID-W-PF26MQZL-1622808877625-0-1 :: Body received :: {""activity"":""Have a picnic with some friends"",""type"":""social"",""participants"":3,""price"":0.1,""link"":"""",""key"":""6813070"",""accessibility"":0.1}.                       


17:44:44| AHC-NETTY-COMMON-1-1 | ThreadDelay.java 39 ## AHC-NETTY-COMMON-1-1 going into sleep... Exchange Id :: ID-W-PF26MQZL-1622808877625-0-1.                                                                                       


17:44:44| Camel (camel-1) thread #2 - ProducerTemplate | ThreadDelay.java 41 ## Camel (camel-1) thread #2 - ProducerTemplate woke up from sleep... Exchange Id :: ID-W-PF26MQZL-1622808877625-0-2.                       


17:44:44| Camel (camel-1) thread #2 - ProducerTemplate | AhcProducer.java 53 ## Executing request https://www.boredapi.com/api/activity GET headers: breadcrumbId:ID-W-PF26MQZL-1622808877625-0-2   


17:44:44| Camel (camel-1) thread #2 - ProducerTemplate | NettyRequestSender.java 579 ## Using pooled Channel '[id: 0xbc4290ed, L:/10.16.84.166:62334 - R:www.boredapi.com/34.201.80.84:443]' for 'GET' to 'https://www.boredapi.com/api/activity'                                                                                                           


17:44:48| pool-1-thread-1 | TimeoutTimerTask.java 42 ## Request timeout to www.boredapi.com/34.201.80.84:443 after 3000 ms for NettyResponseFuture{currentRetry=0,                                                                                     


17:44:48| AHC-NETTY-COMMON-1-1 | ThreadDelay.java 41 ## AHC-NETTY-COMMON-1-1 woke up from sleep... Exchange Id :: ID-W-PF26MQZL-1622808877625-0-1.","davsclaus:1623291289:2021-06-10T10:14:49.585+0000:1623291289:2021-06-10T10:14:49.585+0000:You are using EOL Camel versions. Can you try with latest release. Also instead of using camel-ahc you can try other http components. 
sveluvil:1623294019:2021-06-10T11:00:19.644+0000:1623294019:2021-06-10T11:00:19.644+0000:Hi [~davsclaus],

Thanks for your reply. 

Unfortunately it is not possible for us to replace camel-ahc with any other http components since our product has been running for a long time now and it will be a huge change for us. The same issue is there in the version 3.0.1 as well.

It will be helpful if the issue can be fixed in camel-ahc itself. 

Thank you
davsclaus:1623294549:2021-06-10T11:09:09.289+0000:1623294549:2021-06-10T11:09:09.289+0000:3.0.1 is a very old release, try with 3.1.0.
And put together a sample application or unit test that reproduces this problem. And use latest release 3.10.0. We do not support old Camel versions.
sveluvil:1623301953:2021-06-10T13:12:33.114+0000:1623301953:2021-06-10T13:12:33.114+0000:Hi [~davsclaus],

I could reproduce the issue with versions 3.1.0 and 3.10.0. Please see attachment 'Camel_AHC_Thread_Busy_31X_310X.zip' for unit test case which will reproduce the problem.

The attachment has 2 folders. Folders are named '3.1.0' and '3.10.0' which has unit test corresponding to that version. Each folder also has a file named 'Detailed_Logs_X_X_X.log' which has the detailed TRACE log when the issue got reproduced and a file named 'Important_Logs_X_X_X.txt' which has important log statements I copied from the detailed trace log. 

Please note the problem is not always reproducible, but I was able to reproduce it when I run the test case 10-15 times. 
sveluvil:1623369534:2021-06-11T07:58:54.028+0000:1623369534:2021-06-11T07:58:54.028+0000:Hi [~davsclaus],

Can you suggest a way to release the Netty thread after processing the response ?
davsclaus:1624584377:2021-06-25T09:26:17.147+0000:1624584377:2021-06-25T09:26:17.147+0000:Thanks for the test cases. I could see that Camel would use the netty thread for continue routing, so this is changed to let camel-ahc have its own worker pool so the netty threads are free and potentially not being blocked by Camel."
0,CAMEL-16703,Bug,Minor,"3.9.0, 3.10.0",,"
None
",Resolved,Not A Bug,None,Unassigned,Ivan Bondar,0,2,2021-06-10 07:23:26+00:00,2021-06-10 07:43:40+00:00,"After upgrade from Camel 3.8.0 to 3.9.0 we noticed that CamelExceptionCaught property is missing even in simple route with following configuration:


 


 




public void configure() {

    onException(Exception.class)
            .process(new Processor() {
                public void process(Exchange exchange) throws Exception {
                    System.out.println( ""\n\n\n\n\nPROPERTIES"" );
                    for (String key: exchange.getProperties().keySet()) {
                        System.out.println(key);
                    }
                    System.out.println( ""\n\n"" );
                }
            });


    from(""file:src/data?noop=true"")
            .throwException(new Exception(""Forced""));
}




 


Here is simple project https://github.com/vashu1/camel_test_exception_properties.git that demonstrates it.


 


Run:


git clone https://github.com/vashu1/camel_test_exception_properties.git
cd camel_test_exception_properties/camel38/
mvn install ; mvn camel:run


 


cd ../camel39/
mvn install ; mvn camel:run


 


cd ../camel310/
mvn install ; mvn camel:run


 


And you will see that in camel38 message has:


PROPERTIES
CamelBatchSize
CamelFailureRouteId
CamelFatalFallbackErrorHandler
CamelBatchComplete
CamelBatchIndex
CamelFileExchangeFile
CamelExceptionCaught


 


And in 3.9 and 3.10 message only has:


 


PROPERTIES
CamelFileExchangeFile","davsclaus:1623281377:2021-06-10T07:29:37.155+0000:1623281377:2021-06-10T07:29:37.155+0000:See the upgrade guide
https://camel.apache.org/manual/latest/camel-3x-upgrade-guide-3_9.html
vashu1:1623282220:2021-06-10T07:43:40.827+0000:1623282220:2021-06-10T07:43:40.827+0000:Thanks!"
0,CAMEL-16702,Dependency upgrade,Major,None,3.11.0,"
None
",Resolved,Fixed,3.11.0,Claus Ibsen,Claus Ibsen,0,1,2021-06-10 07:11:44+00:00,2021-06-10 07:12:25+00:00,No Desc,
0,CAMEL-16701,Bug,Trivial,"3.7.3, 3.10.0",3.11.0,"
None
",Resolved,Fixed,3.11.0,Unassigned,Florian Eckhard,0,1,2021-06-09 21:53:55+00:00,2021-06-10 04:16:46+00:00,"If a KafkaConfiguration is used (see code) and no topic is defined in the configuration, the parameter from the URI is not taken over, but a null value is set. 
 This leads to a consumer not having a valid topic name, but null being provided as a value.


It looks like setProperties(endpoint, parameters); overrites the topic.


KafkaConfiguration




@Bean
public KafkaConfiguration kafkaConfig() {
     KafkaConfiguration kafkaConfiguration = new KafkaConfiguration();
     kafkaConfiguration.setBrokers(..);
     kafkaConfiguration.setClientId(..);
     //kafkaConfiguration.setTopic(kafkaTopic);
return kafkaConfiguration ;




Route




from(kafka({{topic.name}}?configuration=#kafkaConfig""))",
0,CAMEL-16700,Improvement,Minor,None,3.11.0,"
None
",Resolved,Fixed,3.11.0,Claus Ibsen,Luca Burgazzoli,0,1,2021-06-09 16:27:52+00:00,2021-06-10 11:30:51+00:00,"It should be possible to configure camel's global options using properties, like


camel.main.global-options[foo] = bar",
0,CAMEL-16699,Bug,Major,"3.7.4, 3.7.3","3.7.5, 3.9.0","
None
",Resolved,Fixed,"3.7.5, 3.9.0",Unassigned,Mathias,0,2,2021-06-09 11:59:34+00:00,2021-06-14 15:09:52+00:00,"The check for query parameters to skip when populating HTTP request headers on a bridge endpoint is broken in HttpProducer.java with release 3.7.3.


The optimisation applied for common types in headers (String, Long, Integer, Boolean) breaks out of the loop without assessing the `skipRequestHeaders` content, causing query parameters of these types to be duplicated at the receiver (present both in HTTP request params and in exchange headers).","m47iast:1623213946:2021-06-09T12:45:46.577+0000:1623213946:2021-06-09T12:45:46.577+0000:This specific issue appears to be fixed with commit [CAMEL-16199: camel-http - Optimize headers added as request headers i… · apache/camel@031ea4b (github.com)|https://github.com/apache/camel/commit/031ea4b4098834d72390d9c699fcb45e6838f57c] in version 3.9.0.
davsclaus:1623216023:2021-06-09T13:20:23.068+0000:1623216023:2021-06-09T13:20:23.068+0000:Can you provide a PR against 3.7.x branch
m47iast:1623295999:2021-06-10T11:33:19.487+0000:1623295999:2021-06-10T11:33:19.487+0000:Sure. I will do some more testing and them submit a PR for the 3.7.x branch. 
m47iast:1623375150:2021-06-11T09:32:30.502+0000:1623375150:2021-06-11T09:32:30.502+0000:PR submitted [[CAMEL-16699] Fix HttpProducer bridged endpoint skipRequestHeaders for common type headers by m47iast · Pull Request #5655 · apache/camel (github.com)|https://github.com/apache/camel/pull/5655]"
0,CAMEL-16698,Task,Major,None,3.x,"
None
",Resolved,Fixed,3.x,Otavio Rodolfo Piske,Otavio Rodolfo Piske,0,1,2021-06-08 19:59:01+00:00,2021-08-05 05:07:34+00:00,I received a report that some of our integration tests are not running. Therefore I opening this task to investigate this and take note of affected components.,
0,CAMEL-16697,Dependency upgrade,Major,None,3.11.0,"
None
",Resolved,Fixed,3.11.0,Freeman Yue Fang,Freeman Yue Fang,0,1,2021-06-08 16:21:48+00:00,2021-06-08 18:33:24+00:00,No Desc,
0,CAMEL-16696,Bug,Trivial,None,None,"
None
",Resolved,Invalid,None,Unassigned,Jawad Ahmad,0,1,2021-06-08 07:44:51+00:00,2021-06-08 07:52:49+00:00,"I have a route that receives the bulk amount of data and then processes data individually from 3rd Party API using Enrich Pattern. After Enriching I am then aggregating the responses into a batch of 100 and then sending them to our system. This causes the camel to allocate memory like crazy, stuck into the loop and eventually going out of memory. I tried with Sync routes as well but it gets failed.


Here is the route configuration :





 from(""direct:sync-likes-from-sf-reviews"")
                .id(""direct:sync-likes-from-sf-reviews"")

                .process(this::convertReviewPayload)
                .split(body())
                .to(""direct:enrich-and-fetch-likes"")

                .end();


        from(""direct:enrich-and-fetch-likes"")
                .id(""direct-enrich-and-fetch-likes"")

                .enrich(""direct:fetch-like-by-sf-review"", new ReviewLikesAggregation(), true)
                .aggregate(constant(true), new GroupedBodyAggregationStrategy())
                .completionSize(100)

                .to(""direct:upsert-collected-likes"")

                .end();


        from(""direct:upsert-collected-likes"")
                .id(""direct:upsert-collected-likes"")

                .multicast()
                    .to(""direct:upsert-consumers-batch"").to(""direct:upsert-likes-batch"")
                .end()


                .end();



        from(""direct:upsert-consumers-batch?synchronous=false"")
                .to(""direct:upsert-consumers-batch"")
                .process(this.trustpilotLikeConsumersMapper)
                .process(this::setupConsumerHeaders)
                .to(""direct:upsert-collections"")


                .end();



        from(""direct:upsert-likes-batch?synchronous=false"")
                .to(""direct:upsert-likes-batch"")
                .process(this.trustPilotLikesMapper)
                .process(this::setupLikesHeaders)
                .to(""direct:upsert-collections"")

                .end();




Logs Loop :


2021-06-08 12:41:18.568 DEBUG 11896 — [ent@65b17373-56] o.apache.camel.processor.SendProcessor   : >>>> direct://upsert-consumers-batch Exchange[]
2021-06-08 12:41:18.568 DEBUG 11896 — [ent@65b17373-56] o.apache.camel.processor.SendProcessor   : >>>> direct://upsert-consumers-batch Exchange[]
2021-06-08 12:41:18.569 DEBUG 11896 — [ent@65b17373-56] o.apache.camel.processor.SendProcessor   : >>>> direct://upsert-consumers-batch Exchange[]
2021-06-08 12:41:18.569 DEBUG 11896 — [ent@65b17373-56] o.apache.camel.processor.SendProcessor   : >>>> direct://upsert-consumers-batch Exchange[]
2021-06-08 12:41:18.569 DEBUG 11896 — [ent@65b17373-56] o.apache.camel.processor.SendProcessor   : >>>> direct://upsert-consumers-batch Exchange[]
2021-06-08 12:41:18.569 DEBUG 11896 — [ent@65b17373-56] o.apache.camel.processor.SendProcessor   : >>>> direct://upsert-consumers-batch Exchange[]
2021-06-08 12:41:18.569 DEBUG 11896 — [ent@65b17373-56] o.apache.camel.processor.SendProcessor   : >>>> direct://upsert-consumers-batch Exchange[]
2021-06-08 12:41:18.569 DEBUG 11896 — [ent@65b17373-56] o.apache.camel.processor.SendProcessor   : >>>> direct://upsert-consumers-batch Exchange[]
2021-06-08 12:41:18.569 DEBUG 11896 — [ent@65b17373-56] o.apache.camel.processor.SendProcessor   : >>>> direct://upsert-consumers-batch Exchange[]
2021-06-08 12:41:18.569 DEBUG 11896 — [ent@65b17373-56] o.apache.camel.processor.SendProcessor   : >>>> direct://upsert-consumers-batch Exchange[]",
0,CAMEL-16695,Improvement,Major,None,3.11.0,"
None
",Resolved,Fixed,3.11.0,Claus Ibsen,Claus Ibsen,0,1,2021-06-08 05:16:16+00:00,2021-06-08 05:28:31+00:00,"https://camel.zulipchat.com/#narrow/stream/257298-camel/topic/negate.20a.20placeholder.20expression


So you can do !foo to negate a boolean answer.",
0,CAMEL-16694,Dependency upgrade,Major,3.4.5,None,"
None
",Resolved,Fixed,3.4.6,Claus Ibsen,Claus Ibsen,0,1,2021-06-07 10:56:26+00:00,2021-06-07 13:59:38+00:00,"Before the last 3.4.6 EOL release of Camel 3.4 we should do some dependency upgrades of popular libraries like SB netty jetty etc, like we did for Camel 2.25.4 release.","davsclaus:1623044829:2021-06-07T13:47:09.937+0000:1623045344:2021-06-07T13:55:44.994+0000:activemq 5.15.14 -> 5.15.5
cxf 3.3.6 -> 3.3.10
freemarker 2.3.30 -> 2.3.31
johnzon 1.2.10 -> 1.2.13
micrometer 1.5.13 -> 1.5.14
netty 4.1.63 -> 4.1.64
vertx 3.9.1 -> 3.9.7
jetty 9.4.39 -> 9.4.41
spring boot 2.3.10 -> 2.3.11
karaf 4.2.9 -> 4.2.11"
0,CAMEL-16693,Improvement,Minor,None,3.11.0,"
None
",Resolved,Fixed,3.11.0,Luca Burgazzoli,Luca Burgazzoli,0,1,2021-06-07 08:35:33+00:00,2021-06-16 04:21:03+00:00,From https://github.com/apache/camel-k-runtime/issues/707,
0,CAMEL-16692,Bug,Major,3.7.3,"3.11.1, 3.12.0","
None
",Resolved,Fixed,"3.11.1, 3.12.0",Claus Ibsen,Jonas Audenaert,0,2,2021-06-07 07:38:08+00:00,2021-06-29 05:25:52+00:00,"I have following Camel route, created by a RoutingBuilder:




new org.apache.camel.builder.RouteBuilder() {
  void configure() {
    from(""direct:myProgram"")
      .routeId(""${params.profile}"")
      .to(""sftp://${params.hostname}:${params.port}/${params.directory}?username=RAW(${params.username})&amp;password=RAW(${params.password})&amp;fileName=RAW(\${header.fileName})&amp;fileExist=Fail&amp;disconnect=true&amp;stepwise=false&amp;useUserKnownHostsFile=false&amp;serverAliveInterval=${params.serverAliveInterval}"")
  }
}



This route is the only one which I place on my CamelContext and than I start the CamelContext.


I'm doing a test on my local machine to send 50 files through this route to a remote SFTP server. Most of the time, all files arrive, but sometimes 1 file seems to be missing.


My program doesn't notice the failure of sending. But during debugging I found something interesting that happened.


That one specific file which is missing throws in the camel library an SFTPException at the method existsFile (SftpOperations.java:1046).


The exception contains only reason 4: message but the exception contains another exception. The wrapped exception contain following exception message: java.io.IOException: Pipe Closed.


Camel wraps the exception in a GenericFileOperationFailedException and throws it to the method which called SftpOperations, GenericFileProducer (GenericFileProducer.java:135).
 That exception arrives in the tr/catch block of it and goes to the generic catch block.


In that catch-block the exception is handled by the handleWrite() method (RemoteFileProducer.java:83) and there it gets interesting. 
 In handleWrite() check is performed if the Camel Base Service is in stopping() or stopped() state. If that's the case, the exception is only logged but not thrown. But isStopped() returns true, so my exception is thrown, but my application doesn't receive it, so it thinks that the file is transferred succesfully to the SFTP server, but it never arrives.","davsclaus:1623034638:2021-06-07T10:57:18.131+0000:1623034638:2021-06-07T10:57:18.131+0000:So are you stopping / shutting down your Camel application?
davsclaus:1623034680:2021-06-07T10:58:00.818+0000:1623034680:2021-06-07T10:58:00.818+0000:If you can build a reproducer sample application and put on github with readme file how to run and test then that would be good."
0,CAMEL-16691,New Feature,Minor,None,None,"
None
",Open,Unresolved,Future,Unassigned,Godfrey,0,3,2021-06-06 16:11:35+00:00,2023-08-09 09:20:16+00:00,"Kafka dataproc sink is very useful to subscribe from Kafka topic into Google cloud Dataproc (Apache spark).
Dataproc is a fast, easy-to-use, fully managed cloud service for running Apache Spark and Apache Hadoop clusters in a simpler, more cost-efficient way.
Any ideas of how to create it related Kamelet?","davsclaus:1623022173:2021-06-07T07:29:33.589+0000:1623022173:2021-06-07T07:29:33.589+0000:A new camel-google-dataproc component would be a good start, then a kamelet can be built that uses this component.
davsclaus:1623022199:2021-06-07T07:29:59.072+0000:1623022199:2021-06-07T07:29:59.072+0000:There are some existing google components here
https://github.com/apache/camel/tree/main/components/camel-google
qafro:1623023405:2021-06-07T07:50:05.816+0000:1623023603:2021-06-07T07:53:23.426+0000:Where do I start to implement Google Dataproc from the git repo ?
davsclaus:1623034830:2021-06-07T11:00:30.077+0000:1623034830:2021-06-07T11:00:30.077+0000:You can either create a new component as standalone in your own maven project (or you can fork the camel git repo, and work on this source code - although its huge, so you need to build it once to get local JARs for the main branch build and installed in your local m2 repo).

There is a contribution guide at
https://camel.apache.org/community/contributing/

However at first you can also research how to integrate with google dataproc from Java. eg is there a google java library that can be used for that, and if so how would you do that.
You can then build a prototype of something (without Camel) to learn how to do that part, and then after that put it into a camel component. When you get to that part write back here
qafro:1623645997:2021-06-14T12:46:37.612+0000:1623645997:2021-06-14T12:46:37.612+0000:Am a newbie, and not a Java developer - Is any chance some developers build it?
acosentino:1623646544:2021-06-14T12:55:44.822+0000:1623646544:2021-06-14T12:55:44.822+0000:If someone would like to work on this, it will be available for devs to work on it."
0,CAMEL-16690,Improvement,Minor,None,Future,"
None
",Open,Unresolved,Future,Unassigned,Christos Gkoros,0,3,2021-06-06 13:23:44+00:00,2022-09-03 07:56:10+00:00,"The messages List operation returns a list of messages, however, although the Gmail API supports adding a query (""q"") to the request, the camel endpoint/component does not


The option is only available in Camel Google Mail Stream.


f.e.","gkorosc:1622957390:2021-06-06T13:29:50.256+0000:1622957390:2021-06-06T13:29:50.256+0000:[~davsclaus] I would like to take on this task.
acosentino:1622958747:2021-06-06T13:52:27.285+0000:1622958747:2021-06-06T13:52:27.285+0000:You're welcome to work on it.
gkorosc:1634250756:2021-10-15T06:32:36.772+0000:1634250756:2021-10-15T06:32:36.772+0000:Hello [~acosentino], after reviewing the component, it is evident that the part that controls the arguments that the endpoint can accept and passes to Gmail API is generated from  -> *camel-api-component-maven-plugin*

However, the pom.xml does not include the execution for this generation. It only has the _generate-test-component-classes_ execution for test classes.

Would you please advise on how this task should best proceed?
acosentino:1634253510:2021-10-15T07:18:30.080+0000:1634253510:2021-10-15T07:18:30.080+0000:Usually the code is autogenerated starting from the classes. It might be the gmail API use a builder approach for example. In that case the query parameter could have been omitted and not added to generated code. I think [~davsclaus] may help on this particular aspect.
davsclaus:1634467499:2021-10-17T18:44:59.539+0000:1634467499:2021-10-17T18:44:59.539+0000:Yeah this would take some effort as the gmail java api has the required parameters currently, but there are a number of optional parameters that can be set via setter afterwards.

This would require the camel-api-maven-plugin to add support for this which is somewhat complex to do."
0,CAMEL-16659,Bug,Major,3.7.0,"3.7.5, 3.11.0","
None
",Resolved,Fixed,"3.7.5, 3.11.0",Claus Ibsen,Claus Ibsen,0,1,2021-05-26 05:15:40+00:00,2021-05-26 06:53:15+00:00,"Reported on chat forum
https://camel.zulipchat.com/#narrow/stream/257298-camel/topic/SimpleIllegalSyntaxException.20after.20upgrading.20from.203.2E4.2E3",
0,CAMEL-16658,Bug,Minor,3.x,"3.7.5, 3.11.0","
None
",Resolved,Fixed,"3.7.5, 3.11.0",Claus Ibsen,Krzysztof Mackowiak,0,2,2021-05-25 14:52:32+00:00,2021-05-26 06:52:36+00:00,"In Camel 2.x camel-bean component considered only public methods when trying to choose a method to call.


In Camel 3.x this behaviour was changed and now protected and package methods are also considered (it was implemented in the CAMEL-13298 task).


Unfortunately this change causes that using Mockito mocks as beans for camel-bean components (for example to test some Camel routes) causes an AmbiguousMethodCallException to be thrown.


Here is an example of such exception:




org.apache.camel.component.bean.AmbiguousMethodCallException: Ambiguous method invocations possible:
[public java.lang.String org.apache.camel.component.bean.MockitoMockForClassTest$MyService$MockitoMock$1368359973.doSomething(java.lang.String),
final java.lang.String org.apache.camel.component.bean.MockitoMockForClassTest$MyService$MockitoMock$1368359973.doSomething$accessor$MJMz0OHK(java.lang.String)]
on the exchange: Exchange[]
  at org.apache.camel.component.bean.BeanInfo.chooseBestPossibleMethodInfo(BeanInfo.java:887)
  ...




 


This is caused by the fact that Mockito adds package level methods with the same argument list to created mock/spy.


Additional complication is added by the fact that Mockito 1.x (which uses CGLIB underneath) adds different methods than Mockito 2.x and 3.x (which uses Byte Buddy).


Here are 3 JUnit tests that reproduce this problem:




// NOTE: fails for Mockito 3.x and 2.x, but passes for Mockito 1.x
public class MockitoMockForClassTest extends ContextTestSupport {

    @Test
    public void testCallingMock() throws Exception {
        Object response = template.requestBody(""direct:start"", ""anything"");
        assertEquals(""mocked answer"", response);
    }

    @Override
    protected Registry createRegistry() throws Exception {
        MyService mockService = Mockito.mock(MyService.class);
        when(mockService.doSomething(any())).thenReturn(""mocked answer"");

        Registry answer = super.createRegistry();
        answer.bind(""myService"", mockService);
        return answer;
    }

    @Override
    protected RouteBuilder createRouteBuilder() throws Exception {
        return new RouteBuilder() {
            public void configure() throws Exception {
                from(""direct:start"").bean(""bean:myService"");
            }
        };
    }

    public class MyService {
        public String doSomething(String body) {
            return ""real answer"";
        }
    }

}






// NOTE: fails for Mockito 3.x and 2.x, but passes for Mockito 1.x
public class MockitoSpyForClassTest extends ContextTestSupport {

    @Test
    public void testCallingSpy() throws Exception {
        Object response = template.requestBody(""direct:start"", ""anything"");
        assertEquals(""mocked answer"", response);
    }

    @Override
    protected Registry createRegistry() throws Exception {
        MyService mockService = Mockito.spy(new MyService());
        when(mockService.doSomething(any())).thenReturn(""mocked answer"");

        Registry answer = super.createRegistry();
        answer.bind(""myService"", mockService);
        return answer;
    }

    @Override
    protected RouteBuilder createRouteBuilder() throws Exception {
        return new RouteBuilder() {
            public void configure() throws Exception {
                from(""direct:start"").bean(""bean:myService"");
            }
        };
    }

    public class MyService {
        public String doSomething(String body) {
            return ""real answer"";
        }
    }

}






// NOTE: fails for Mockito 1.x, but passes for Mockito 3.x and 2.x
public class MockitoMockForInterfaceTest extends ContextTestSupport {

    @Test
    public void testCallingMock() throws Exception {
        Object response = template.requestBody(""direct:start"", ""anything"");
        assertEquals(""mocked answer"", response);
    }

    @Override
    protected Registry createRegistry() throws Exception {
        MyService mockService = Mockito.mock(MyService.class);
        when(mockService.doSomething(any())).thenReturn(""mocked answer"");

        Registry answer = super.createRegistry();
        answer.bind(""myService"", mockService);
        return answer;
    }

    @Override
    protected RouteBuilder createRouteBuilder() throws Exception {
        return new RouteBuilder() {
            public void configure() throws Exception {
                from(""direct:start"").bean(""bean:myService"");
            }
        };
    }

    public interface MyService {
        String doSomething(String body);
    }

}","kmackowiak:1621926038:2021-05-25T15:00:38.787+0000:1621926102:2021-05-25T15:01:42.483+0000:I'm attaching 2 patches for master branch which contains tests and a proposed fix for this bug.

[^Tests_-_AmbiguousMethodCallException_when_using_Mockito_mock_as_bean_for_camel-bean_compon.patch]

[^Fix_-_AmbiguousMethodCallException_when_using_Mockito_mock_as_bean_for_camel-bean_componen.patch]
davsclaus:1621977170:2021-05-26T05:12:50.383+0000:1621977170:2021-05-26T05:12:50.383+0000:Thanks for reporting and providing a patch with tests"
0,CAMEL-16657,Bug,Minor,3.10.0,3.11.0,"
None
",Resolved,Fixed,3.11.0,Claus Ibsen,Claus Ibsen,0,1,2021-05-25 14:43:51+00:00,2021-05-25 19:19:15+00:00,"Some FTP servers will return a failure if you try to upload a file in APPEND mode and there is no existing file.


If there is an empty 0 file already then it can append.",davsclaus:1621941555:2021-05-25T19:19:15.126+0000:1621941555:2021-05-25T19:19:15.126+0000:We now check for file exists if using append mode
0,CAMEL-16656,New Feature,Major,None,3.14.0,"
None
",Resolved,Fixed,3.14.0,Claus Ibsen,Claus Ibsen,0,2,2021-05-25 13:42:53+00:00,2021-11-18 10:05:39+00:00,"Add some kind of feature to the RoutesLoader SPI whether it supports re-loading, such as the file based from yaml, or xml (though its harder to reload from classpath). But from file source or over http/github it can reload.


We had in the past some file watcher thingy that could re-load routes if the file was changed/save.


This allows to play with kamelets, xml | yaml routes etc from vanilla camel.


For example to change this route
https://github.com/apache/camel-examples/tree/main/examples/kamelet-main/src/main/resources/camel


While the app is running, then we can have a mode where camel detects changes and reload the routes.","davsclaus:1621921566:2021-05-25T13:46:06.203+0000:1621921566:2021-05-25T13:46:06.203+0000:It was this code in 2.x
https://github.com/apache/camel/blob/camel-2.25.x/camel-core/src/main/java/org/apache/camel/impl/FileWatcherReloadStrategy.java
davsclaus:1624237105:2021-06-21T08:58:25.453+0000:1624237105:2021-06-21T08:58:25.453+0000:We can use camel-quarkus with its dev mode that supports auto reloading/restarting"
0,CAMEL-16655,Bug,Major,None,None,"
None
",Resolved,Invalid,None,Unassigned,Nicolas Duminil,0,2,2021-05-24 16:27:08+00:00,2021-05-24 16:31:22+00:00,"I'm trying to follow the documentation at https://camel.apache.org/camel-k/latest/. Running the example, as shown, produces the following output:




[nicolas@localhost ~]$ kamel run hello.groovy --dev
integration ""hello"" created
Condition ""IntegrationPlatformAvailable"" is ""True"" for Integration hello: default/camel-k
Progress: integration ""hello"" in phase Initialization
Integration hello in phase ""Initialization""
Progress: integration ""hello"" in phase Building Kit
Condition ""IntegrationPlatformAvailable"" is ""True"" for Integration hello: default/camel-k
Integration hello in phase ""Building Kit""
Condition ""IntegrationKitAvailable"" is ""False"" for Integration hello: integration kit default/kit-c2lt1bmfinhge6sn27vg is in state ""Build Running""
Integration hello subresource kit-c2lt1bmfinhge6sn27vg (Build) changed phase to ""Failed"" (recovery 5 of 5)
Integration hello subresource kit-c2lt1bmfinhge6sn27vg (Build) changed phase to ""Error"" (recovery 5 of 5)
Integration hello subresource kit-c2lt1bmfinhge6sn27vg (Integration Kit) changed phase to ""Error""
Progress: integration ""hello"" in phase Error
Error: integration ""hello"" deployment failed
[nicolas@localhost ~]$ kamel log hello
Integration 'hello' is at: Error ...





No other information is available. Any suggestion please ? Many thanks in advance.


Nicolas","acosentino:1621845073:2021-05-24T16:31:13.576+0000:1621845082:2021-05-24T16:31:22.138+0000:Please report at camel-k issues on github, if you have questions.

 

https://github.com/apache/camel-k/issues"
0,CAMEL-16654,Task,Major,3.11.0,3.11.0,"
None
",Resolved,Fixed,3.11.0,Andrea Cosentino,Claus Ibsen,0,1,2021-05-24 14:10:00+00:00,2021-05-24 14:42:53+00:00,"Tests in error:
  CamelJpaTest.org.apache.camel.itest.springboot.CamelJpaTest » Runtime Could no...


Tests run: 284, Failures: 0, Errors: 1, Skipped: 6",
0,CAMEL-16653,Improvement,Major,None,3.x,"
None
",Resolved,Won't Fix,3.x,Unassigned,Luca Burgazzoli,0,2,2021-05-24 13:27:04+00:00,2022-04-05 07:11:28+00:00,"From https://github.com/apache/camel-k-runtime/issues/659


With the introduction of the Kamelet EIP in Camel, we could introduce a new way to define simple, linear integrations, like:




steps: 
  - kamelet: 
     name: foo
     properties: 
       a: b  
  - kamelet: 
     name: bar
     properties: 
       c: d




This could be particular useful for the materialization of a KameletBinding to a real integration so the camel-k operator does not need to care about things such as proper placement of from, to, etc.","davsclaus:1637727945:2021-11-24T12:25:45.174+0000:1637727945:2021-11-24T12:25:45.174+0000:Ah so the 1st will automatic be regarded as a ""from"", and the others are ""to""
davsclaus:1649113839:2022-04-05T07:10:39.271+0000:1649113885:2022-04-05T07:11:25.458+0000:The kamelet eip does have a ""problem"" as it should only be used for special use-cases
https://camel.apache.org/components/3.16.x/eips/kamelet-eip.html

Therefore it is not a good idea to use kamelet eips in a series of steps.

IMHO lets keep the DSL consistent for now - adding more ways to do stuff can be more confusing."
0,CAMEL-16652,Improvement,Minor,None,3.x,"
None
",Resolved,Won't Fix,3.x,Unassigned,Luca Burgazzoli,0,2,2021-05-24 13:24:59+00:00,2022-09-03 07:52:53+00:00,https://github.com/apache/camel-k-runtime/issues/485,davsclaus:1662162773:2022-09-03T07:52:53.536+0000:1662162773:2022-09-03T07:52:53.536+0000:endpoint-dsl is java only (we do not have it for xml etc)
0,CAMEL-16651,Improvement,Minor,None,4.1.0,"
None
",Resolved,Fixed,4.1.0,Unassigned,Luca Burgazzoli,0,3,2021-05-24 13:20:52+00:00,2023-11-22 20:11:16+00:00,Migrated from https://github.com/apache/camel-k-runtime/issues/386,"davsclaus:1622669007:2021-06-03T05:23:27.360+0000:1622669007:2021-06-03T05:23:27.360+0000:This will grow the yaml schema to be very very big, just sure that would be okay from tooling point of view."
0,CAMEL-16650,Improvement,Minor,None,3.11.0,"
None
",Resolved,Fixed,3.11.0,Luca Burgazzoli,Luca Burgazzoli,0,2,2021-05-24 11:44:47+00:00,2021-06-18 19:04:38+00:00,"Since camel 3.10, kamelets can be discovered from the classpath by name but it would be nice to support also loading the kamelets from alternate locations, like:




camel.component.kameelts.teamplates[foo] = classpath:my-foo.kamelet.yaml
camel.component.kameelts.teamplates[bar] = file:/etc/camel/kamelets/bar.kamelet.yaml","davsclaus:1623985004:2021-06-18T10:56:44.192+0000:1623985004:2021-06-18T10:56:44.192+0000:So you are looking for some kind of camel-kamelet component support for mapping a kamelet id to a resource location

There is a location today where you can say

camel.component.kamelet.location = classpath:my-foo.kamelet.yaml , file:/etc/camel/kamelets/bar.kamelet.yaml

And you can of course use wildcards

camel.component.kamelet.location = classpath:*.kamelet.yaml , file:/etc/camel/kamelets/*.kamelet.yaml

Then those are however only discovered on demand, eg if you ask for foo kamelet, then the classpath and file system is scanned for a foo.kamelet.yaml file.

davsclaus:1623985195:2021-06-18T10:59:55.235+0000:1623985195:2021-06-18T10:59:55.235+0000:Or are we look at something like
https://github.com/apache/camel-examples/blob/main/examples/routetemplate/src/main/resources/application.properties#L27-L33

Where you want to map those 2 route templates to which kamelet file to use as the template
{code}
camel.route-template[foo].location = classpath:my-foo.kamelet.yaml
camel.route-template[foo].name = one
camel.route-template[foo].greeting = Hello
camel.route-template[bar].location = file:/etc/camel/kamelets/bar.kamelet.yaml
camel.route-template[bar].name = two
camel.route-template[bar].greeting = Bonjour
camel.route-template[bar].my-period = 5s
{code}

Where we can then add *location* as the key to refer to the resource location of the template file.
lb:1623985202:2021-06-18T11:00:02.780+0000:1623985202:2021-06-18T11:00:02.780+0000:I do not remember what I had in mind but I think we can safely close this issue
lb:1623985249:2021-06-18T11:00:49.727+0000:1623985249:2021-06-18T11:00:49.727+0000:oh yes, adding location would be nice 
davsclaus:1623985354:2021-06-18T11:02:34.430+0000:1623985354:2021-06-18T11:02:34.430+0000:Yeah I think location is a good idea too, then it makes it explicit from where the template is for those routes to be created.
davsclaus:1623985999:2021-06-18T11:13:19.387+0000:1623985999:2021-06-18T11:13:19.387+0000:Okay I can take a look at this"
0,CAMEL-16649,Bug,Minor,3.10.0,,"
None
",Resolved,Not A Bug,None,Unassigned,Jeremy Ross,0,1,2021-05-21 17:50:43+00:00,2021-05-21 17:57:11+00:00,"We're currently mapping the salesforce Time type to OffsetTime. I believe this should be mapped to LocalTime.


In salesforce, the Time field type is wall time. There is no time zone, or date with which to determine what the offset would be. 


See CAMEL-12334 for context.


cc: zregvart","jeremyross:1621591009:2021-05-21T17:56:49.713+0000:1621591009:2021-05-21T17:56:49.713+0000:Disregard. Looks like salesforce just pins the time to `Z`, so it is indeed an offset time."
0,CAMEL-16648,Wish,Minor,2.25.3,Future,"
None
",Resolved,Won't Fix,Future,Unassigned,nizar.ben.mansour,0,2,2021-05-21 14:06:47+00:00,2021-05-21 15:08:55+00:00,"Hi,


We wanna be able to make the autostart property in camel configured using expression like for example this:


 


 




<route id=""myRoute"" autoStartup=""{{myproperty1}} && {{myproperty2}}""   shutdownRunningTask=""CompleteAllTasks"" shutdownRoute=""Defer"">
</route>




 


 


This is not yet supported by camel as autostartup does not evaluate expression.


 


Thanks","davsclaus:1621580935:2021-05-21T15:08:55.492+0000:1621580935:2021-05-21T15:08:55.492+0000:This is not something we want to do

You can use Java or other programming languages where you can configure CamelContext anyhow you like.

"
0,CAMEL-16647,Dependency upgrade,Major,None,3.11.0,"
None
",Resolved,Fixed,3.11.0,Andrea Cosentino,Claus Ibsen,0,1,2021-05-21 13:36:25+00:00,2021-05-24 06:46:25+00:00,They just released 2.5.0,davsclaus:1621575525:2021-05-21T13:38:45.609+0000:1621575525:2021-05-21T13:38:45.609+0000:https://github.com/spring-projects/spring-boot/wiki/Spring-Boot-2.5-Release-Notes
0,CAMEL-16646,Improvement,Minor,3.10.0,3.13.0,"
None
",Resolved,Fixed,3.13.0,Andrea Cosentino,Xilai Dai,0,5,2021-05-21 13:29:24+00:00,2021-10-01 08:19:31+00:00,"In Camel 3.8.0 or earlier, there are feature definition of camel-aws-xxx in the https://repo1.maven.org/maven2/org/apache/camel/karaf/apache-camel/3.8.0/apache-camel-3.8.0-features.xml




  <feature name='camel-aws' version='3.8.0' start-level='50'>
     <feature version='3.8.0'>camel-aws-cw</feature>
     <feature version='3.8.0'>camel-aws-s3</feature>
     <feature version='3.8.0'>camel-aws-ddb</feature>
     <feature version='3.8.0'>camel-aws-ec2</feature>
     <feature version='3.8.0'>camel-aws-ecs</feature>
     <feature version='3.8.0'>camel-aws-eks</feature>
     <feature version='3.8.0'>camel-aws-iam</feature>
     <feature version='3.8.0'>camel-aws-kinesis</feature>
     <feature version='3.8.0'>camel-aws-kms</feature>
     <feature version='3.8.0'>camel-aws-lambda</feature>
     <feature version='3.8.0'>camel-aws-mq</feature>
     <feature version='3.8.0'>camel-aws-msk</feature>
     <feature version='3.8.0'>camel-aws-sdb</feature>
     <feature version='3.8.0'>camel-aws-ses</feature>
     <feature version='3.8.0'>camel-aws-sns</feature>
     <feature version='3.8.0'>camel-aws-sqs</feature>
     <feature version='3.8.0'>camel-aws-swf</feature>
     <feature version='3.8.0'>camel-aws-translate</feature>
  </feature>
  <feature name='camel-aws-s3' version='3.8.0' start-level='50'>
    <feature version='3.8.0'>camel-core</feature>
    <bundle dependency='true'>mvn:org.apache.httpcomponents/httpcore-osgi/4.4.14</bundle>
    <bundle dependency='true'>mvn:org.apache.httpcomponents/httpclient-osgi/4.5.13</bundle>
    <bundle dependency='true'>mvn:joda-time/joda-time/2.10.6</bundle>
    <bundle dependency='true'>mvn:com.sun.mail/jakarta.mail/1.6.5</bundle>
    <bundle dependency='true'>mvn:commons-codec/commons-codec/1.15</bundle>
    <bundle dependency='true'>mvn:org.apache.servicemix.specs/org.apache.servicemix.specs.stax-api-1.0/2.9.0</bundle>
    <bundle dependency='true'>mvn:com.fasterxml.jackson.core/jackson-core/2.11.4</bundle>
    <bundle dependency='true'>mvn:com.fasterxml.jackson.core/jackson-databind/2.11.4</bundle>
    <bundle dependency='true'>mvn:com.fasterxml.jackson.core/jackson-annotations/2.11.4</bundle>
    <bundle dependency='true'>mvn:com.fasterxml.jackson.dataformat/jackson-dataformat-cbor/2.11.4</bundle>
    <bundle dependency='true'>mvn:org.apache.servicemix.bundles/org.apache.servicemix.bundles.aws-java-sdk/1.11.714_1</bundle>
    <bundle>mvn:org.apache.camel/camel-aws-s3/3.8.0</bundle>
  </feature>




In Camel 3.9.0, they are removed from the apache-camel-3.9.0-features.xml in the scope of the https://issues.apache.org/jira/browse/CAMEL-16115


In new released Camel 3.10.0, camel-aws-xxx features (or camel-aws2-xxx features) still missing in the apache-camel-3.10.0-features.xml, which is not possible to install these camel-aws(2) components into the OSGi(karaf) container anymore.","acosentino:1621575135:2021-05-21T13:32:15.458+0000:1621575135:2021-05-21T13:32:15.458+0000:Aws components v1 have been removed, only V2 are now supported but not on Karaf/OSGi.
jbonofre:1621575321:2021-05-21T13:35:21.233+0000:1621575321:2021-05-21T13:35:21.233+0000:Not yet, it's related to what we discussed (using private package).
jbonofre:1627678983:2021-07-31T05:03:03.480+0000:1627678983:2021-07-31T05:03:03.480+0000:We now have aws2 bundle, so, we can provide the features.
jgreffe:1632960453:2021-09-30T08:07:33.956+0000:1632960453:2021-09-30T08:07:33.956+0000:Please any update about features?
acosentino:1632965073:2021-09-30T09:24:33.715+0000:1632965073:2021-09-30T09:24:33.715+0000:You're welcome to provide the features. No news at the moment."
0,CAMEL-16645,New Feature,Major,None,None,"
None
",Resolved,Fixed,3.11.0,Claus Ibsen,Claus Ibsen,0,1,2021-05-21 07:58:53+00:00,2021-05-21 09:39:08+00:00,"A new Camel JAR you can add to classpath, that allows to load resources from github as raw content.


This is good for development and demo purposes",
0,CAMEL-16644,Improvement,Minor,None,3.11.0,"
None
",Resolved,Fixed,3.11.0,Unassigned,Claus Ibsen,0,1,2021-05-21 05:23:38+00:00,2021-06-07 14:30:16+00:00,"camel.cloud.consul.service-registry


->


camel.cloud.consul-service-registry


Then they are all on same level


See table
https://github.com/apache/camel/blob/main/docs/user-manual/modules/ROOT/pages/camel-3x-upgrade-guide-3_10.adoc#spring-boot-starters","davsclaus:1621549214:2021-05-21T06:20:14.689+0000:1621549214:2021-05-21T06:20:14.689+0000:And then add a note about this in the 3.11 upgrade guide, like we have for 3.10
https://github.com/apache/camel/blob/main/docs/user-manual/modules/ROOT/pages/camel-3x-upgrade-guide-3_11.adoc"
0,CAMEL-16643,Improvement,Major,"3.9.0, 3.10.0",3.11.0,"
None
",Resolved,Fixed,3.11.0,Alex Dettinger,Alex Dettinger,0,2,2021-05-20 17:36:54+00:00,2021-05-31 07:29:38+00:00,It should be possible to remove the dependency to camel-xslt-saxon by moving the tests out from camel-saxon.,"davsclaus:1622060403:2021-05-27T04:20:03.376+0000:1622060403:2021-05-27T04:20:03.376+0000:There are a few tests now that fails, they should maybe be moved
https://ci-builds.apache.org/job/Camel/job/Camel%20JDK11/job/main/88/#showFailuresLink
davsclaus:1622060432:2021-05-27T04:20:32.669+0000:1622060432:2021-05-27T04:20:32.669+0000:Also add a note to the 3.10 upgrade guide, you can find it in the docs folder
aldettinger:1622105480:2021-05-27T16:51:20.876+0000:1622105938:2021-05-27T16:58:58.794+0000:[~davsclaus] , the failing tests mentioned are actually flaky ones that are not linked to this commit.
 I would suspect a kind of race condition where concurrent running tests using ""System.setProperty(XPathFactory.DEFAULT_PROPERTY_NAME..."" are mixing up.
 However, I was not able to find any evidence, nor a fix.

Back to this ticket, I'm proposing an [update|https://github.com/apache/camel/pull/5605] of the 3.11 upgrade guide. I don't this there is community interest in backporting to 3.10 ?
davsclaus:1622111607:2021-05-27T18:33:27.946+0000:1622111607:2021-05-27T18:33:27.946+0000:No backport.

Okay about those unit tests, ah yeah if JVM system properties are changed then they can't run in parallel tests etc. 
I think junit5 has some kind of annotation to mark a test as non-parallel.
aldettinger:1622417378:2021-05-31T07:29:38.683+0000:1622417378:2021-05-31T07:29:38.683+0000:The removal of the useless dependency is solved [here|https://github.com/apache/camel/commit/3b3a9a00e401b97a17fcacf3d52c3af3969f2927].

The migration guide has been updated [here|https://github.com/apache/camel/commit/1fd27b28bf6890fe4f5724653d61ec1bcee6aa51].

 "
0,CAMEL-16642,Improvement,Major,3.10.0,3.19.0,"
None
",Resolved,Fixed,3.19.0,Jeremy Ross,Jeremy Ross,0,2,2021-05-20 17:06:50+00:00,2022-09-05 19:26:01+00:00,Can we sniff the result and detect SObject type? It's a bit of a pain to have to provide the sObjectClass option.,"davsclaus:1662162706:2022-09-03T07:51:46.547+0000:1662162706:2022-09-03T07:51:46.547+0000:This sounds like a good idea, is there any metadata header or something from salesforce that can hint the object type
jeremyross:1662316083:2022-09-05T02:28:03.666+0000:1662316093:2022-09-05T02:28:13.592+0000:[~davsclaus] Unfortunately there is no metadata or response headers that indicate the type of the response. So we can either parse the query, or sniff the type of response. I pushed a PR that does the latter. LMK what you think."
0,CAMEL-16641,Improvement,Major,None,3.11.0,"
None
",Resolved,Fixed,3.11.0,Andrea Cosentino,Andrea Cosentino,0,1,2021-05-20 12:54:32+00:00,2021-09-30 10:33:52+00:00,https://docs.aws.amazon.com/translate/latest/dg/what-is.html#what-is-languages,
0,CAMEL-16640,Bug,Major,3.10.0,3.11.0,"
None
",Resolved,Fixed,3.11.0,Unassigned,Ehsan Amiryousefi,0,3,2021-05-20 12:01:45+00:00,2021-05-21 13:15:18+00:00,"Latest extension in KafkaConsumer with reconnect/retry introduced race condition during shut down. Potentially this leaves threads running after shut down.


Retry flag is set to false only if consumer wakeup throws an exception during consumer poll. 


Interrupted Exception leaves the while loop only if thread is currently sleeping.


If the thread executes any thing else during shut down, the thread will continuously loop.


I will prepare a proposal patch set soon.","acosentino:1621483471:2021-05-20T12:04:31.378+0000:1621483471:2021-05-20T12:04:31.378+0000:Are you talking about camel quarkus extension or the plain component or something else? It is not clear, not too much details.
EhsanAmiryousefi:1621487891:2021-05-20T13:18:11.953+0000:1621487891:2021-05-20T13:18:11.953+0000:It is about the plain camel-kafka component as in 3.10. The changes which have been added for this ticket: https://issues.apache.org/jira/browse/CAMEL-14980 are causing this problem.

In KafkaConsumer class in the run() method if the thread is sleeping and an Interrupted Exception occurs, then the thread will leave the loop, which is fine. But, if before the thread enter the sleeping, something happens then the thread will remain running without caring about the stopping state(Zombie Thread). 

In the doPollRun() method, the retry flag is set to false only when the consumer wakeup method throws an exception which again causes the thread again to keep running in the loop without stopping which again leaves the thread to be zombie. 

My proposed solution would be adding the following code to the run() method before calling the doRun() method. This will prevent the loop iteration in case the component is stopped or going to be stopped. I have prepared this in a patch set and could commit it. 

 
{code:java}
if (!isRunAllowed() || isStoppingOrStopped() || isSuspendingOrSuspended()) {
 return;
}{code}
 

 

 
davsclaus:1621574118:2021-05-21T13:15:18.286+0000:1621574118:2021-05-21T13:15:18.286+0000:Thanks for reporting and the PR"
0,CAMEL-16639,Task,Major,None,,"
None
",Resolved,Delivered,None,Zoran Regvart,Zoran Regvart,0,3,2021-05-20 09:47:04+00:00,2022-09-03 07:50:58+00:00,"Antora 3 will bring several improvements, out of which two are really significant for Camel:



versionless components, this will allow us to remove the latest from URLs
git ref derived versions which will reduce the maintenance of updating versions in component descriptors



Versionless components is most disruptive, so we'd need to create redirect directives so we don't break any links.","davsclaus:1642329833:2022-01-16T18:43:53.973+0000:1642329833:2022-01-16T18:43:53.973+0000:Have we not upgraded to antora 3 now?
davsclaus:1662162658:2022-09-03T07:50:58.624+0000:1662162658:2022-09-03T07:50:58.624+0000:Use the camel-website github issue tracker for website tickets"
0,CAMEL-16638,Bug,Minor,None,,"
None
",Resolved,Cannot Reproduce,None,Jiri Ondrusek,suhas,0,3,2021-05-20 08:08:37+00:00,2021-11-14 14:15:46+00:00,"leveldb repo is storing data and aggregated messages are storing.


But when routes are starting it is deleting data in level dB and not sending aggregates messages to the downstream..","davsclaus:1621472066:2021-05-20T08:54:26.083+0000:1621472066:2021-05-20T08:54:26.083+0000:Can you add more details, what Camel version you use, and provide some more evidence what is being deleted.

In general you should get help first on the mailing list as we say here
https://camel.apache.org/community/support/
suvvisuhas:1621474613:2021-05-20T09:36:53.298+0000:1621474613:2021-05-20T09:36:53.298+0000:Thanks [~davsclaus] for the quick response.

Detailed steps I have mentioned in document. Please suggest if anything is missed and we are looking incase if camel application goes down and pending aggregates messages stored in leveldb repo should send to next route when camel application comes up again..
suvvisuhas:1621474757:2021-05-20T09:39:17.043+0000:1621474757:2021-05-20T09:39:17.043+0000:camel version is : 3.7.0
suvvisuhas:1624255778:2021-06-21T14:09:38.712+0000:1624255778:2021-06-21T14:09:38.712+0000:Can I please get an update on this issue?

[~davsclaus],[~jondruse]
jondruse:1624257711:2021-06-21T14:41:51.688+0000:1624257711:2021-06-21T14:41:51.688+0000:Hi [~suvvisuhas] , unfortunately I didn't start with this issue.

I try to looke at it during this or next week, but if anyone is willing to take this issue, no problem on my side.
jondruse:1625112668:2021-07-01T12:11:08.677+0000:1625112668:2021-07-01T12:11:08.677+0000:[~suvvisuhas] I tried to reproduce described behavior with no success.

So that, I created a simple springboot based reproducer in my repo: https://github.com/JiriOndrusek/CAMEL-16638-reproducer

Usage of the reproducer is described in readme file.

Would it be possible for you to look at it and verify that I'm simulating the same scenario? From my results nothing is deleted from the levelDb when second route is starting. I'm getting _On startup there are 1 aggregate exchanges (not completed) in repository: test_

(Brief description of my reproducer - first module fills the levelDb with some messages, which are not aggregated. Second module adds another messages and together it should be aggregated)
suvvisuhas:1625124653:2021-07-01T15:30:53.684+0000:1625124653:2021-07-01T15:30:53.684+0000:[~jondruse] Thanks for looking into it. I will run in my local and get back to you..
davsclaus:1633348472:2021-10-04T19:54:32.324+0000:1633348472:2021-10-04T19:54:32.324+0000:Suhas, any update ?
suvvisuhas:1633388483:2021-10-05T07:01:23.494+0000:1633388483:2021-10-05T07:01:23.494+0000:Hi [~davsclaus] : Thanks for followup.

I have ran the reproducer program and it is working but at app side still aggregated data is deleted on startup(destination route and aggregation route both on same camel context instance). Not sure what I am missing..

 
davsclaus:1636870231:2021-11-14T14:10:31.630+0000:1636870231:2021-11-14T14:10:31.630+0000:From the attached word document, then you have not set a repository name on the aggregation repository. You must do that.

davsclaus:1636870546:2021-11-14T14:15:46.851+0000:1636870546:2021-11-14T14:15:46.851+0000:Tried the aggregate example and switched to use leveldb repo

  <bean id=""myRepo"" class=""org.apache.camel.component.leveldb.LevelDBAggregationRepository"">
    <property name=""persistentFileName"" value=""my-repo.dat""/>
    <property name=""repositoryName"" value=""foo""/>
    <property name=""returnOldExchange"" value=""true""/>
  </bean>

This worked fine

[INFO] Starting Camel ...
[pache.camel.spring.Main.main()] LevelDBAggregationRepository   INFO  On startup there are 1 aggregate exchanges (not completed) in repository: foo
[pache.camel.spring.Main.main()] LevelDBAggregationRepository   INFO  On startup there are no completed exchanges to be recovered in repository: foo-completed
[pache.camel.spring.Main.main()] AggregateProcessor             INFO  Using RecoverableAggregationRepository by scheduling recover checker to run every 5000 millis.
[pache.camel.spring.Main.main()] AbstractCamelContext           INFO  Routes startup summary (total:1 started:1)
[pache.camel.spring.Main.main()] AbstractCamelContext           INFO      Started route1 (stream://in)
[pache.camel.spring.Main.main()] AbstractCamelContext           INFO  Apache Camel 3.14.0-SNAPSHOT (camel) started in 197ms (build:21ms init:61ms start:115ms)"
0,CAMEL-16637,Dependency upgrade,Major,None,None,"
None
",Resolved,Fixed,3.11.0,Unassigned,Marat Gubaidullin,0,1,2021-05-19 14:10:24+00:00,2021-05-20 04:29:12+00:00,No Desc,
0,CAMEL-16636,Improvement,Major,None,3.11.0,"
None
",Resolved,Fixed,3.11.0,Claus Ibsen,Claus Ibsen,0,1,2021-05-19 13:16:16+00:00,2021-06-08 08:17:36+00:00,You get some exception about stream is closed.,
0,CAMEL-16635,Improvement,Major,None,3.11.0,"
None
",Resolved,Fixed,3.11.0,Claus Ibsen,Claus Ibsen,0,1,2021-05-19 13:15:04+00:00,2021-06-04 05:47:38+00:00,"We should make the default to load all files from the camel classpath.


camel.main.routes-include-pattern = classpath:camel/*


Then it works out of the box for yaml dsl, and other dsl etc.",
0,CAMEL-16634,Bug,Minor,3.9.0,3.11.0,"

camel
kafka
snappy

",Resolved,Fixed,3.11.0,Claus Ibsen,Nicola Cisternino,0,2,2021-05-19 12:43:20+00:00,2021-06-06 08:17:07+00:00,"After camel-kafka feature installation any other feature installation raise errors.
 The problem seems to be the snappy feature (a camel-kafka requirement).
 A workaround is to install the single bundles (of snappy and camel-kafka) extracted from xml feature file (https://repo1.maven.org/maven2/org/apache/camel/karaf/apache-camel/3.9.0/apache-camel-3.9.0-features.xml)
 The sequence to reproduce the problem, starting from a fresh 4.3.1 Karaf installation, is:


Apache Karaf (4.3.1)


Hit '<tab>' for a list of available commands
 and '[cmd] --help' for help on a specific command.
 Hit 'system:shutdown' to shutdown Karaf.
 Hit '<ctrl-d>' or type 'logout' to disconnect shell from current session.


karaf@root()> feature:repo-add camel 3.9.0
 Adding feature url mvn:org.apache.camel.karaf/apache-camel/3.9.0/xml/features
 karaf@root()> feature:install http webconsole camel camel-netty
 karaf@root()> feature:install camel-kafka
karaf@root()> feature:install camel-sql
Error executing command: Unable to resolve root: missing requirement [root] osgi.identity; osgi.identity=kar; type=karaf.feature; version=""[4.3.1,4.3.1]""; filter:=""(&(osgi.identity=kar)(type=karaf.feature)(version>=4.3.1)(version<=4.3.1))"" [caused by: Unable to resolve kar/4.3.1: missing requirement [kar/4.3.1] osgi.identity; osgi.identity=org.apache.karaf.kar.core; type=osgi.bundle; version=""[4.3.1,4.3.1]""; resolution:=mandatory [caused by: Unable to resolve org.apache.karaf.kar.core/4.3.1: missing requirement [org.apache.karaf.kar.core/4.3.1] osgi.wiring.package; filter:=""(&(osgi.wiring.package=org.osgi.framework)(version>=1.0.0)(!(version>=3.0.0)))""]]
 karaf@root()>


Please see:


https://lists.apache.org/thread.html/r374d2d832fed818d44625829f086f002aaed7d70a5fea953c5551fe5%40%3Cusers.camel.apache.org%3E","davsclaus:1622792362:2021-06-04T15:39:22.405+0000:1622792362:2021-06-04T15:39:22.405+0000:Try with karaf 4.3.2
davsclaus:1622937408:2021-06-06T07:56:48.837+0000:1622937408:2021-06-06T07:56:48.837+0000:Also try to restart karaf after you have installed camel-kafka (with snappy), and then continue to install camel-sql
davsclaus:1622938627:2021-06-06T08:17:07.780+0000:1622938627:2021-06-06T08:17:07.780+0000:Okay did a change in the feature so its like on camel 2.x and it works again."
0,CAMEL-16633,New Feature,Minor,None,3.x,"
None
",Resolved,Fixed,3.x,Unassigned,Claus Ibsen,0,1,2021-05-19 12:12:02+00:00,2023-05-26 19:34:03+00:00,"Add auto configuration class that allows to configure this (turn on|off, and a few other settings). And make it enabled out of the box, so users just add the camel starter JAR. It may detect if spring boot has micrometer enable or not before turning on etc.","davsclaus:1621397559:2021-05-19T12:12:39.733+0000:1621397559:2021-05-19T12:12:39.733+0000:See chat room
https://camel.zulipchat.com/#narrow/stream/257301-camel-spring-boot/topic/Camel.20monitoring
davsclaus:1662162615:2022-09-03T07:50:15.799+0000:1662162615:2022-09-03T07:50:15.799+0000:We should have this for opentelemetry too"
0,CAMEL-16632,Bug,Minor,3.10.0,3.11.0,"

help-wanted

",Resolved,Fixed,3.11.0,Claus Ibsen,Jawad Ahmad,0,2,2021-05-19 10:32:13+00:00,2021-06-04 15:38:28+00:00,"I am able to reproduce this error while trying to upsert collection on the non external id fields. I suspect it will have similar behavior on network errors.


java.util.NoSuchElementException: No value present
	at java.base/java.util.Optional.get(Optional.java:141) ~[na:na]
	at org.apache.camel.component.salesforce.internal.processor.CompositeSObjectCollectionsProcessor.processResponse(CompositeSObjectCollectionsProcessor.java:187) ~[camel-salesforce-3.10.0-20210519.045501-220.jar:3.10.0-SNAPSHOT]
	at org.apache.camel.component.salesforce.internal.processor.CompositeSObjectCollectionsProcessor.lambda$processUpsertSObjectCollections$3(CompositeSObjectCollectionsProcessor.java:143) ~[camel-salesforce-3.10.0-20210519.045501-220.jar:3.10.0-SNAPSHOT]
	at org.apache.camel.component.salesforce.internal.client.DefaultCompositeSObjectCollectionsApiClient$2.onResponse(DefaultCompositeSObjectCollectionsApiClient.java:118) ~[camel-salesforce-3.10.0-20210519.045501-220.jar:3.10.0-SNAPSHOT]
	at org.apache.camel.component.salesforce.internal.client.AbstractClientBase$1.onComplete(AbstractClientBase.java:210) ~[camel-salesforce-3.10.0-20210519.045501-220.jar:3.10.0-SNAPSHOT]
	at org.eclipse.jetty.client.ResponseNotifier.notifyComplete(ResponseNotifier.java:218) ~[jetty-client-9.4.38.v20210224.jar:9.4.38.v20210224]
	at org.eclipse.jetty.client.ResponseNotifier.notifyComplete(ResponseNotifier.java:210) ~[jetty-client-9.4.38.v20210224.jar:9.4.38.v20210224]
	at org.eclipse.jetty.client.HttpSender.terminateRequest(HttpSender.java:411) ~[jetty-client-9.4.38.v20210224.jar:9.4.38.v20210224]
	at org.eclipse.jetty.client.HttpSender.abort(HttpSender.java:574) ~[jetty-client-9.4.38.v20210224.jar:9.4.38.v20210224]
	at org.eclipse.jetty.client.HttpSender.lambda$executeAbort$0(HttpSender.java:361) ~[jetty-client-9.4.38.v20210224.jar:9.4.38.v20210224]
	at org.eclipse.jetty.util.thread.QueuedThreadPool.runJob(QueuedThreadPool.java:882) ~[jetty-util-9.4.38.v20210224.jar:9.4.38.v20210224]
	at org.eclipse.jetty.util.thread.QueuedThreadPool$Runner.run(QueuedThreadPool.java:1036) ~[jetty-util-9.4.38.v20210224.jar:9.4.38.v20210224",davsclaus:1622792308:2021-06-04T15:38:28.824+0000:1622792308:2021-06-04T15:38:28.824+0000:Thanks for reporting
0,CAMEL-16631,New Feature,Major,None,4.0.0,"
None
",Resolved,Won't Fix,4.0.0,Unassigned,Claus Ibsen,0,1,2021-05-19 08:38:59+00:00,2023-07-17 11:37:51+00:00,"Currently the Kamelet EIP uses an URI syntax for calling a kamelet.


.kamelet(""foo?bar=Murphys&time=9:15"")
    .to(""kafka:cheese"")
.end()


But it may be nice also to allow to specify parameters with


.kamelet(""foo"")
    .parameter(""bar"", ""Murphys"")
    .parameter(""time"", ""9:15"")
     .to(""kafka:cheese"")
.end()","davsclaus:1662162550:2022-09-03T07:49:10.563+0000:1662162550:2022-09-03T07:49:10.563+0000:This would be special for Kamelet EIP to make it verbose with parameters, but then you may want to that for ""to"" as well, and that is harder to do due to how it was deisgned.

davsclaus:1662162574:2022-09-03T07:49:34.325+0000:1662162574:2022-09-03T07:49:34.325+0000:In yaml dsl you can specificy parameters"
0,CAMEL-16630,New Feature,Major,None,3.12.0,"
None
",Resolved,Information Provided,3.12.0,Claus Ibsen,Claus Ibsen,0,1,2021-05-19 08:32:07+00:00,2021-07-05 10:35:40+00:00,"With the introduction of local beans for route templates / kamelets. This brings to the table of allowing to use that more generic in Camel DSL.


When using XML DSL and other markup DSLs then you have use-cases where you need to define a bean for aggregation strategy, etc, and today you have to write that as java bean and refer to it by bean id.


With local bean you can then inline this and create the bean code in the XML or YAML dsl with script. Can be good for simple code (not very complex).


We can look at to add a special annotation in the model, that marks something as a local bean compliant, so we can generate this in the XML XSD, YAML DSL accordingly.","davsclaus:1624593602:2021-06-25T12:00:02.906+0000:1624602433:2021-06-25T14:27:13.191+0000:We can add support for #class so you can do *DONE*

{code}
                - from:
                    uri: ""direct:route""
                    steps:
                      - aggregate:
                          strategy-ref: ""#class:org.apache.camel.processor.aggregate.UseLatestAggregationStrategy""
                          completion-size: 2
                          correlation-expression:
                            simple: ""${header.StockSymbol}""
                          steps:  
                            - to: ""mock:route""
{code}
davsclaus:1624603390:2021-06-25T14:43:10.267+0000:1624603390:2021-06-25T14:43:10.267+0000:Both #class and #type is now supported anywhere in the DSL where something is looked up, like agg strategy, idempotent repository etc.
davsclaus:1624605596:2021-06-25T15:19:56.926+0000:1624605596:2021-06-25T15:19:56.926+0000:To inline a groovy script is a bit harder, as the DSL model in camel-core would need to support this to make it available universal. 

 - aggregate:
                          strategy-ref: ""groovy""
                           strategy-script: ""... some groovy code here""
davsclaus:1625011048:2021-06-30T07:57:28.716+0000:1625011048:2021-06-30T07:57:28.716+0000:You can use a local bean for the script, and then refer to it via strategy-ref.

davsclaus:1625011570:2021-06-30T08:06:10.438+0000:1625011570:2021-06-30T08:06:10.438+0000:You can now also use inlined groovy script

{code}
                        beans:
                          - name: ""myAgg""
                            type: ""groovy""
                            script: ""class MaxAgg { int agg(int s1, int s2) { return Math.max(s1, s2) }}; new MaxAgg()""
{code}

You need to create a class with the method signature as the POJO and then the logic, and return a new instance of that class.
davsclaus:1625452540:2021-07-05T10:35:40.211+0000:1625452540:2021-07-05T10:35:40.211+0000:Okay lets leave it as-is for now. 

Route templates / kamelets can now use local beans for any aggregation strategy (or other beans) and then refer to them in the route via the {{beanId}} syntax.

To add support for local beans generally in normal camel routes is a bigger task."
0,CAMEL-16629,Bug,Major,None,"3.7.5, 3.11.0","
None
",Resolved,Fixed,"3.7.5, 3.11.0",Claus Ibsen,Claus Ibsen,0,1,2021-05-19 04:53:23+00:00,2021-05-19 05:54:41+00:00,"Reported on user forum
http://camel.465427.n5.nabble.com/interceptSendToEndpoint-interceptedUri-scope-and-when-issues-td5924757.html",
0,CAMEL-16628,New Feature,Major,None,3.16.0,"
None
",Resolved,Fixed,3.16.0,Nicolas Filotto,Claus Ibsen,0,2,2021-05-18 12:56:53+00:00,2022-04-07 10:36:47+00:00,"Like we have for endpoint options with @UriParam, we should have a new SPI annotation to markup headers that consumer/producers support.


This allows us to generate that information into the component json file for tooling support, and also to generate this in the website documentation.","essobedo:1646787192:2022-03-09T08:53:12.590+0000:1646787192:2022-03-09T08:53:12.590+0000:May I try this one?
davsclaus:1646789804:2022-03-09T09:36:44.353+0000:1646789804:2022-03-09T09:36:44.353+0000:Yeah absolutely this would be great to have
essobedo:1646985034:2022-03-11T15:50:34.814+0000:1647306198:2022-03-15T09:03:18.213+0000:First PR [https://github.com/apache/camel/pull/7190]
essobedo:1647306376:2022-03-15T09:06:16.301+0000:1647306376:2022-03-15T09:06:16.301+0000:The IT has been disabled by [https://github.com/apache/camel/commit/fadf550cad1d48c1375f91b2e4949df65fdf1e1c] to fix the chicken and egg problem. Once the build will pass and will publish the artifacts, it can be re-enabled.
essobedo:1647334438:2022-03-15T16:53:58.257+0000:1647334438:2022-03-15T16:53:58.257+0000:[~davsclaus] I started to propagate what has been done within the context of this ticket to the existing components and I faced a complex use case with the component `camel-atomix` that contains several endpoints (map, messaging, multimap, queue, set, value).

Those endpoints share headers but in a complex way, as you can see below:

+all+
 * RESOURCE_ACTION_HAS_RESULT
 * RESOURCE_NAME
 * RESOURCE_VALUE

+map and value+
 * RESOURCE_OLD_VALUE

+map and multimap+
 * RESOURCE_KEY

+map, queue, set and value+
 * EVENT_TYPE

+map, multimap, set and value+
 * RESOURCE_TTL

+map, multimap, queue, set and value+
 * RESOURCE_READ_CONSISTENCY

+map only+
 * RESOURCE_DEFAULT_VALUE

+messaging only+
 * MESSAGE_ID
 * MEMBER_NAME
 * CHANNEL_NAME
 * BROADCAST_TYPE

With the existing code, the only way to do that is to replace the existing class that contains all the headers called `AtomixClientConstants` by a Constants class for each endpoint and duplicate common constants/headers with their metadata.

Unless we consider that duplicating the common constants/headers with their metadata is acceptable, I believe that the existing code needs to be improved to properly address this kind of use case, don't you agree?

What I first proposed could manage this kind of use case as we provided the list of header names for each end point but maybe you have a better way to manage it? 
davsclaus:1647336091:2022-03-15T17:21:31.168+0000:1647336091:2022-03-15T17:21:31.168+0000:Take a look at how uri endpoints are doing it where we use Java OO inheritance. So the commons headers can be in a base class.

But if that can't work then I dont mind duplicating as we should have this as now - easy to setup - and if there is 1 camel component that is complex, then so be it, and you just duplicate the headers.

atomix is also a ""bad component"" and would be deprecated in the future. Atomix is a dying project - there was only 2 basic commits last year
https://github.com/atomix/atomix/commits/master
davsclaus:1647336415:2022-03-15T17:26:55.688+0000:1647336415:2022-03-15T17:26:55.688+0000:The code is something like here where we check the super classes also
https://github.com/apache/camel/blob/5072d09284657bdeb3607ee497ad9f7e9d472104/tooling/maven/camel-package-maven-plugin/src/main/java/org/apache/camel/maven/packaging/EndpointSchemaGeneratorMojo.java#L905



essobedo:1647336932:2022-03-15T17:35:32.010+0000:1647336932:2022-03-15T17:35:32.010+0000:Ok so for the atomix component, I will duplicate the fields as this use case cannot be fully managed using inheritance at best it could be managed using composition.

Let's see if I meet other use cases where inheritance could fix the problem and if so, I will implement it in the Mojo class.
essobedo:1647514995:2022-03-17T19:03:15.009+0000:1647573105:2022-03-18T11:11:45.465+0000:[~davsclaus] I've met the same problem as camel-atomix with camel-cxf, where we have one Constants class shared with several endpoints.

In this particular case, I could split the class in two to do the job but it is too intrusive just to add some doc to headers. Moreover, migrating all the components that have headers is already a very long task so if we could avoid having to split classes and duplicating declaration, it could be helpful.

As compromise, in case we have several endpoints sharing the same constants class, to avoid splitting it, I propose to add a new annotation or a new element to the annotation Metadata to be able to filter the headers.

Something like:

 
{code:java}
@Metadata(description = ""some description"", javaType = ""String"", applicableFor = {""foo"", ""bar""})
public static final String SOME_HEADER = ""someHeaderName"";
{code}
In the example above, the header ""SOME_HEADER"" is only for endpoints whose scheme is ""foo"" or ""bar"".

Is-it an acceptable solution for you? If so, I will do it tomorrow

 
davsclaus:1647554404:2022-03-18T06:00:04.684+0000:1647554404:2022-03-18T06:00:04.684+0000:Yeah that is okay"
0,CAMEL-16627,New Feature,Major,None,3.11.0,"
None
",Resolved,Fixed,3.11.0,Claus Ibsen,Claus Ibsen,0,1,2021-05-18 12:55:22+00:00,2021-06-09 11:38:40+00:00,"Some component consumers have message headers with a timestamp when a message arrived to the source (JMSTimestamp, file modified date, S3 modified date, kafka timestamp and others).


We do not have a common header / api to retrieve that information across the components.


It would be good to have that with


1)
common header name and Exchange constant for the key


2)
API on message to get timestamp


    long getSourceTimestamp()


The timestamp or 0 if not possible to get this information, or -1 if the component does not have such information.","davsclaus:1623117959:2021-06-08T10:05:59.913+0000:1623209867:2021-06-09T11:37:47.150+0000:DONE
- file
- ftp
- jms
- sjms
- kafka
- vertx-kafka
- timer
- scheduler
- rabbitmq
- spring-rabbitmq
- telegram
- file-watch
- nsq
- quartz
- pulsar
- mail
- pubnub
- azure
- debezium
- aws
davsclaus:1623118189:2021-06-08T10:09:49.255+0000:1623129560:2021-06-08T13:19:20.878+0000:TODO: simple language *DONE*
davsclaus:1623130117:2021-06-08T13:28:37.874+0000:1623130117:2021-06-08T13:28:37.874+0000:Components can now store a message header with key Exchange.MESSAGE_TIMESTAMP (long value) the timestamp, for the unified header. There is also API on Message to get this header with a nice API and also in the simple language is a new messageTimestamp function.
davsclaus:1623209920:2021-06-09T11:38:40.868+0000:1623209920:2021-06-09T11:38:40.868+0000:We can add this to other components when we find some have that information. I did a first pass of all the components that are messaging or cloud type, and some others known."
0,CAMEL-16626,Dependency upgrade,Major,2.25.3,None,"
None
",Resolved,Fixed,2.25.4,Claus Ibsen,Claus Ibsen,0,1,2021-05-18 08:23:29+00:00,2021-05-18 08:27:24+00:00,Lets upgrade some of the most common 3rd party dependencies and align a bit also better to spring boot 2.1.8 that this Camel 2.25.x uses.,"davsclaus:1621297633:2021-05-18T08:27:13.382+0000:1621297633:2021-05-18T08:27:13.382+0000:cxf 3.3.6 -> 3.3.10
freemarker 2.3.28 -> 2.3.31
httpcore 4.4.10 -> 4.4.13
httpclient 4.5.6 -> 4.5.13
jetty 9.4.18 -> 9.4.33
jolokia 1.6.0 -> 1.6.2
johnzon 1.1.10 -> 1.1.13
micrometer 1.1.1 -> 1.1.19
netty 4.1.56 -> 4.1.64
rxjava2 2.2.3 -> 2.2.20
spring-integration 5.1.0 -> 5.1.13
spring-ws 3.0.4 -> 3.0.10
undertow 1.4.26 -> 1.4.28
vertx 3.6.2 -> 3.6.3
"
0,CAMEL-16625,Improvement,Major,None,3.11.0,"
None
",Resolved,Fixed,3.11.0,Claus Ibsen,Claus Ibsen,0,1,2021-05-18 04:53:20+00:00,2021-06-08 07:57:05+00:00,"We should make this component use the new Resource API (see camel-api) and add a type converter that can do string -> resource. Then we can do classpath, file, mem, base64, http, and others that come in the future.",davsclaus:1623108554:2021-06-08T07:29:14.750+0000:1623108554:2021-06-08T07:29:14.750+0000:ResourceEndoint is already using this as ResourceHelper uses the new ResourceLoader SPI
0,CAMEL-16624,Improvement,Minor,3.9.0,4.x,"
None
",Open,Unresolved,4.x,Unassigned,Hemang Ajmera,0,2,2021-05-17 13:44:20+00:00,2023-08-09 09:20:25+00:00,"We should replace Map with Multi Value, so that they can be initialized in URI sting.


 


Please refer to https://camel.zulipchat.com/#narrow/stream/257298-camel/topic/set.20Map.20option/near/239077029 for details


 


The Map options in Salesforce Component are



apexQueryParams
initialReplayIdMap



 


If there is quick way to find all the options in other component which is Map, then this Jira can be extended to convert them all.","davsclaus:1662162355:2022-09-03T07:45:55.292+0000:1662162355:2022-09-03T07:45:55.292+0000:Ah you mean

apexQuery.key1=blah&apexQuery.key2=yada&apexQuery.key3=123

Which then can be extracted into a map by the component (like some other component do)
davsclaus:1662162402:2022-09-03T07:46:42.655+0000:1662162402:2022-09-03T07:46:42.655+0000:The initialReplayIdMap what details would you need to configure, I am just curiois what a real world example would be
hemangajmera:1662606249:2022-09-08T11:04:09.345+0000:1662606249:2022-09-08T11:04:09.345+0000:I do not remember for sure since lately I am not working on camel. It could be either, I just happened to notice initialReplayIdMap also, so added to jira.

But if I remember correctly, initialReplayIdMap  can be used to set different values of replay Id for different topics."
0,CAMEL-16623,Improvement,Minor,None,3.11.0,"
None
",Resolved,Fixed,3.11.0,Andrea Cosentino,Claus Ibsen,0,1,2021-05-17 12:11:38+00:00,2021-06-06 08:06:39+00:00,"Logs this many times


2021-05-17 14:10:35,454 [rderMain.main()] INFO  AbstractJacksonDataFormat      - The option autoDiscoverObjectMapper is set to false, Camel won't search in the registry
2021-05-17 14:10:35,518 [rderMain.main()] INFO  AbstractJacksonDataFormat      - The option autoDiscoverObjectMapper is set to false, Camel won't search in the registry
2021-05-17 14:10:35,546 [rderMain.main()] INFO  AbstractJacksonDataFormat      - The option autoDiscoverObjectMapper is set to false, Camel won't search in the registry
2021-05-17 14:10:35,546 [rderMain.main()] INFO  AbstractJacksonDataFormat      - The option autoDiscoverObjectMapper is set to false, Camel won't search in the registry
2021-05-17 14:10:35,572 [rderMain.main()] INFO  AbstractJacksonDataFormat      - The option autoDiscoverObjectMapper is set to false, Camel won't search in the registry
2021-05-17 14:10:35,572 [rderMain.main()] INFO  AbstractJacksonDataFormat      - The option autoDiscoverObjectMapper is set to false, Camel won't search in the registry
2021-05-17 14:10:35,574 [rderMain.main()] INFO  AbstractJacksonDataFormat      - The option autoDiscoverObjectMapper is set to false, Camel won't search in the registry
2021-05-17 14:10:35,574 [rderMain.main()] INFO  AbstractJacksonDataFormat      - The option autoDiscoverObjectMapper is set to false, Camel won't search in the registry
2021-05-17 14:10:35,576 [rderMain.main()] INFO  AbstractJacksonDataFormat      - The option autoDiscoverObjectMapper is set to false, Camel won't search in the registry
2021-05-17 14:10:35,576 [rderMain.main()] INFO  AbstractJacksonDataFormat      - The option autoDiscoverObjectMapper is set to false, Camel won't search in the registry


We should log this once","davsclaus:1621224725:2021-05-17T12:12:05.256+0000:1621224725:2021-05-17T12:12:05.256+0000:This is from CiA2 example chapter10-undertow-swagger
davsclaus:1622937995:2021-06-06T08:06:35.203+0000:1622937995:2021-06-06T08:06:35.203+0000:We have tuned this to DEBUG logging - so its not noisy anymore"
0,CAMEL-16622,Bug,Minor,2.25.1,"2.25.4, 3.4.6, 3.7.5, 3.11.0","
None
",Resolved,Fixed,"2.25.4, 3.4.6, 3.7.5, 3.11.0",Claus Ibsen,Mathieu Boretti,0,2,2021-05-17 08:30:17+00:00,2021-05-17 18:39:50+00:00,"Same issue as reported in CAMEL-14372. but for the https


 


When the protocol is https, the url is corrupted and the host is lost.","boretti:1621211918:2021-05-17T08:38:38.416+0000:1621211918:2021-05-17T08:38:38.416+0000:I think the fix for CAMEL-14372 was only applied for http and not https.

 

I haven't test it, but it may be in [https://github.com/apache/camel/blob/master/core/camel-util/src/main/java/org/apache/camel/util/FileUtil.java#L292] that we need to also support https ?
davsclaus:1621211932:2021-05-17T08:38:52.508+0000:1621211932:2021-05-17T08:38:52.508+0000:Try with 2.25.3
boretti:1621212255:2021-05-17T08:44:15.713+0000:1621212255:2021-05-17T08:44:15.713+0000:Same issue with 2.25.3.
davsclaus:1621212439:2021-05-17T08:47:19.468+0000:1621212439:2021-05-17T08:47:19.468+0000:Thanks for testing. You can provide a PR and fix it at
https://github.com/apache/camel/blob/camel-2.x/camel-core/src/main/java/org/apache/camel/util/FileUtil.java#L291
davsclaus:1621213323:2021-05-17T09:02:03.213+0000:1621213323:2021-05-17T09:02:03.213+0000:I fixed this for 3.11
https://github.com/apache/camel/commit/172c061b8304b7a599297af2f8ce51c24ab3de9d

You are welcome to work on a backport for this to 2.x as the structure of the project is different on 2.x so you cannot cleanly backport
boretti:1621213971:2021-05-17T09:12:51.407+0000:1621213971:2021-05-17T09:12:51.407+0000:Thanks. I also prepare a commit for the 2.x. => https://github.com/apache/camel/pull/5578
davsclaus:1621214656:2021-05-17T09:24:16.371+0000:1621214656:2021-05-17T09:24:16.371+0000:Thanks for the PR"
0,CAMEL-16621,Dependency upgrade,Major,None,3.4.6,"
None
",Resolved,Fixed,3.4.6,Claus Ibsen,Claus Ibsen,0,1,2021-05-17 05:56:57+00:00,2021-05-17 07:36:10+00:00,No Desc,
0,CAMEL-16620,Dependency upgrade,Major,None,3.4.6,"
None
",Resolved,Fixed,3.4.6,Claus Ibsen,Claus Ibsen,0,1,2021-05-17 05:56:26+00:00,2021-05-17 07:36:14+00:00,Upgrade to SB 2.3.10,
0,CAMEL-16619,Improvement,Major,3.7.4,"3.7.5, 3.11.0","
None
",Resolved,Fixed,"3.7.5, 3.11.0",Unassigned,Anton Ovcharenko,0,2,2021-05-16 12:07:15+00:00,2021-05-19 04:27:23+00:00,"It was noticed that org.apache.camel.component.rabbitmq.RabbitMQProducer uses org.apache.commons.pool.impl.GenericObjectPool for managing channels pool.


This implementation leads to permanent recreation of channels if we try to manage high rate of messages .
 When the producer was configured with channelPoolMaxSize value more than 8 (this is equals to org.apache.commons.pool.impl.GenericObjectPool#DEFAULT_MAX_IDLE) this pool destroys channel on returning it to the pool (GenericObjectPool).


 


The solution is to specify maxIdle during pool creation (org.apache.camel.component.rabbitmq.RabbitMQProducer#openConnectionAndChannelPool).",davsclaus:1621198924:2021-05-17T05:02:04.638+0000:1621198924:2021-05-17T05:02:04.638+0000:You are welcome to provide a PR with a proposed fix
0,CAMEL-16618,Improvement,Major,3.10.0,3.11.0,"
None
",Resolved,Fixed,3.11.0,Claus Ibsen,Claus Ibsen,0,1,2021-05-15 13:49:27+00:00,2021-05-17 04:50:44+00:00,"Running the tests of the camel spring boot examples output a bunch of WARNs on startup such as


2021-05-15 15:47:51.115  WARN 52777 — [           main] o.a.c.i.e.DefaultCamelBeanPostProcessor  : No CamelContext defined yet so cannot inject into bean: org.apache.camel.spring.converter.ResourceConverterLoader
2021-05-15 15:47:51.117  WARN 52777 — [           main] o.a.c.i.e.DefaultCamelBeanPostProcessor  : No CamelContext defined yet so cannot inject into bean: org.apache.camel.component.file.GenericFileConverterLoader
2021-05-15 15:47:51.126  WARN 52777 — [           main] o.a.c.i.e.DefaultCamelBeanPostProcessor  : No CamelContext defined yet so cannot inject into bean: org.apache.camel.converter.jaxp.CamelXmlJaxpBulkConverterLoader
2021-05-15 15:47:51.128  WARN 52777 — [           main] o.a.c.i.e.DefaultCamelBeanPostProcessor  : No CamelContext defined yet so cannot inject into bean: org.apache.camel.converter.stream.StreamCacheBulkConverterLoader
2021-05-15 15:47:51.131  WARN 52777 — [           main] o.a.c.i.e.DefaultCamelBeanPostProcessor  : No CamelContext defined yet so cannot inject into bean: org.apache.camel.converter.CamelBaseBulkConverterLoader",
0,CAMEL-16617,Bug,Minor,3.10.0,3.10.0,"
None
",Resolved,Fixed,3.10.0,Unassigned,Claus Ibsen,0,1,2021-05-15 10:23:33+00:00,2021-05-15 10:41:58+00:00,"2021-05-15 12:06:11,371 ) thread #20 - Split WARN    MulticastProcessor - Error releasing exchange due to null. This exception is ignored.
java.lang.IllegalStateException: null
	at org.apache.camel.util.Scanner.checkClosed(Scanner.java:293) ~[camel-util-3.10.0-SNAPSHOT.jar:3.10.0-SNAPSHOT]
	at org.apache.camel.util.Scanner.hasNext(Scanner.java:123) ~[camel-util-3.10.0-SNAPSHOT.jar:3.10.0-SNAPSHOT]
	at org.apache.camel.processor.Splitter$SplitterIterable$1.hasNext(Splitter.java:234) ~[camel-core-processor-3.10.0-SNAPSHOT.jar:3.10.0-SNAPSHOT]
	at org.apache.camel.processor.MulticastProcessor.doDone(MulticastProcessor.java:838) ~[camel-core-processor-3.10.0-SNAPSHOT.jar:3.10.0-SNAPSHOT]
	at org.apache.camel.processor.MulticastProcessor$MulticastTask.doDone(MulticastProcessor.java:496) ~[camel-core-processor-3.10.0-SNAPSHOT.jar:3.10.0-SNAPSHOT]
	at org.apache.camel.processor.MulticastProcessor$MulticastTask.aggregate(MulticastProcessor.java:453) ~[camel-core-processor-3.10.0-SNAPSHOT.jar:3.10.0-SNAPSHOT]
	at org.apache.camel.processor.MulticastProcessor$MulticastReactiveTask.lambda$run$0(MulticastProcessor.java:587) ~[camel-core-processor-3.10.0-SNAPSHOT.jar:3.10.0-SNAPSHOT]
	at org.apache.camel.AsyncCallback.run(AsyncCallback.java:44) ~[camel-api-3.10.0-SNAPSHOT.jar:3.10.0-SNAPSHOT]
	at org.apache.camel.impl.engine.DefaultReactiveExecutor$Worker.schedule(DefaultReactiveExecutor.java:179) ~[camel-base-engine-3.10.0-SNAPSHOT.jar:3.10.0-SNAPSHOT]
	at org.apache.camel.impl.engine.DefaultReactiveExecutor.schedule(DefaultReactiveExecutor.java:59) ~[camel-base-engine-3.10.0-SNAPSHOT.jar:3.10.0-SNAPSHOT]
	at org.apache.camel.processor.MulticastProcessor.lambda$schedule$1(MulticastProcessor.java:348) ~[camel-core-processor-3.10.0-SNAPSHOT.jar:3.10.0-SNAPSHOT]
	at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515) [?:?]
	at java.util.concurrent.FutureTask.run(FutureTask.java:264) [?:?]
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128) [?:?]
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628) [?:?]
	at java.lang.Thread.run(Thread.java:834) [?:?]",
0,CAMEL-16616,Improvement,Minor,3.x,3.x,"
None
",Resolved,Abandoned,3.x,Unassigned,Ashutosh Vaish,0,2,2021-05-15 09:50:38+00:00,2023-05-26 19:34:32+00:00,"As the span name uses the endpoint URI, in camel the endpoint URI also includes the header options after '?' character. This makes the whole span name large and eats up the Zipkin UI dashboard","davsclaus:1662162248:2022-09-03T07:44:08.748+0000:1662162248:2022-09-03T07:44:08.748+0000:You can argue also that the base path  is too generic, in case the ? has options that make the span very different and you want to track this independently. I guess there is no good balance.

There are also endpoints where a queue name etc that is important information is part of the query and not the base path, then you can't see that in the UI.

I wonder if zipkin has 2 entries so we have 
- full endpoint uri
- base endpoint

And then you will be able to see the full uri if needed"
0,CAMEL-16615,New Feature,Major,None,None,"
None
",Resolved,Fixed,3.10.0,Nicola Ferraro,Nicola Ferraro,0,2,2021-05-14 13:24:58+00:00,2021-05-14 19:15:33+00:00,No Desc,"davsclaus:1620976556:2021-05-14T15:15:56.692+0000:1620976556:2021-05-14T15:15:56.692+0000:We need starters for spring boot, and potentially a karaf feature too
davsclaus:1620990929:2021-05-14T19:15:29.938+0000:1620990929:2021-05-14T19:15:29.938+0000:spring boot starters *DONE*
karaf feature *DONE*"
0,CAMEL-16614,Improvement,Major,None,3.10.0,"
None
",Resolved,Fixed,3.10.0,Claus Ibsen,Claus Ibsen,0,1,2021-05-14 10:31:32+00:00,2021-05-14 19:16:23+00:00,This allows to get hold of CamelContext during converters that may not have an Exchange instance to do that.,"davsclaus:1620960782:2021-05-14T10:53:02.693+0000:1620960782:2021-05-14T10:53:02.693+0000:Non static converter methods can benefit from this by making their class CamelContextAware and camel will inject the context before use.
davsclaus:1620963186:2021-05-14T11:33:06.812+0000:1620963186:2021-05-14T11:33:06.812+0000:Now you can just add CamelContext instead of Exchange as parameter"
0,CAMEL-16613,Test,Major,None,3.10.0,"
None
",Resolved,Fixed,3.10.0,Unassigned,Claus Ibsen,0,1,2021-05-14 09:28:37+00:00,2021-05-14 19:32:24+00:00,The speedup of testing these module by running in parallel works fine locally. However the CI server struggle and we always have failing tests in these two modules.,
0,CAMEL-16612,New Feature,Major,None,3.13.0,"
None
",Resolved,Fixed,3.13.0,Otavio Rodolfo Piske,Claus Ibsen,0,3,2021-05-14 08:32:08+00:00,2021-10-12 17:56:59+00:00,"Look at making running kamelets with jbang easier.


We can have jbang apps, which could maybe help
https://www.jbang.dev/appstore/","orpiske:1625786725:2021-07-09T07:25:25.549+0000:1625786725:2021-07-09T07:25:25.549+0000:TODO:
 * Add documentation page for Camel JBang
 * Add support for other languages such as XML (I'm probably depend on CAMEL-16757 for that)
 * Add search capabilities for Camel Kafka Connectors,
 * Add search capabilities for Camel Quarkus Extensions
 * Add search capabilities for other components and sub-projects if applicable
orpiske:1634032619:2021-10-12T17:56:59.166+0000:1634032619:2021-10-12T17:56:59.166+0000:JBang support was added to 3.12.0 with the final bits and fixes going on 3.13.0. Therefore, closing."
0,CAMEL-16611,New Feature,Minor,3.7.3,3.11.0,"
None
",Resolved,Fixed,3.11.0,Unassigned,Gerasimos Kalouris,0,2,2021-05-14 07:55:21+00:00,2021-05-19 13:16:43+00:00,"These two parameters configure the internal task executor, that handles PDUs. Since the core and max threads of this thread pool is set to the same number (org.jsmpp.session.SMPPSession.BoundSessionStateListener) more threads than needed are created !


The default value of pduProcessorDegree = 3, which means that each SMPP session would spawn 3 threads. For a big number of sessions (SMPP Producer/Consumer) with a really small window, this is really unnecessary (1 thread with a fair sized queue could handle low traffic scenarios when the processing time of the route is fast!)


Could these two JSMPP parameters be exported and configurable as an advanced configuration?","davsclaus:1620951010:2021-05-14T08:10:10.272+0000:1620951010:2021-05-14T08:10:10.272+0000:You are welcome to work on this and provide a PR agains main branch
memas.kal:1621244901:2021-05-17T17:48:21.914+0000:1621244901:2021-05-17T17:48:21.914+0000:ok [~davsclaus]  I would submit a PR
davsclaus:1621284164:2021-05-18T04:42:44.601+0000:1621284164:2021-05-18T04:42:44.601+0000:https://github.com/apache/camel/commit/baf18c9d09adee46c26e5a2b5e9119857ea04489
memas.kal:1621400696:2021-05-19T13:04:56.052+0000:1621400696:2021-05-19T13:04:56.052+0000:Would this feature be added to the next release as well? I see it was tagged with 3.11.0 which would be released in July?
davsclaus:1621401403:2021-05-19T13:16:43.484+0000:1621401403:2021-05-19T13:16:43.484+0000:Yes it will be in 3.11, as the JIRA says"
0,CAMEL-16610,Improvement,Major,None,3.10.0,"
None
",Resolved,Fixed,3.10.0,Claus Ibsen,Claus Ibsen,0,1,2021-05-14 06:22:35+00:00,2021-05-14 06:49:16+00:00,No Desc,
0,CAMEL-16579,Improvement,Minor,None,None,"
None
",Resolved,Won't Fix,None,Unassigned,James Netherton,0,2,2021-05-05 07:36:34+00:00,2022-09-02 17:53:50+00:00,"MllpComponent has some static variables for options logPhi, logPhiMaxBytes & defaultCharset. I think the original intent is that they are set up via system properties. But statics do not play well in some environments (E.g WildFly) where the component class is shared among all applications deployed into the container.",davsclaus:1662112430:2022-09-02T17:53:50.427+0000:1662112430:2022-09-02T17:53:50.427+0000:we move to spring boot / quarkus style where you are not  in app servers
0,CAMEL-16578,Improvement,Minor,None,3.19.0,"
None
",Resolved,Not A Problem,3.19.0,Unassigned,James Netherton,0,2,2021-05-05 07:33:41+00:00,2022-09-06 11:16:47+00:00,"MLLP has a component configuration option 'logPhi'. From what I can tell, it does nothing. The value is never read wherever the PHI is used in log messages / exceptions etc. The functionality should either be implemented or removed.","davsclaus:1662112383:2022-09-02T17:53:03.878+0000:1662112383:2022-09-02T17:53:03.878+0000:Lets remove this
davsclaus:1662112384:2022-09-02T17:53:04.012+0000:1662112384:2022-09-02T17:53:04.012+0000:Lets remove this
davsclaus:1662434207:2022-09-06T11:16:47.086+0000:1662434207:2022-09-06T11:16:47.086+0000:Okay so logPhi is configurable on the component, and set on Hl7Util that is used for generating some hl7 messages / invalid messages, where the logphi is used to log more verbose or not.

So it seems correct as-is"
0,CAMEL-16577,New Feature,Major,None,3.10.0,"
None
",Resolved,Fixed,3.10.0,Unassigned,Dillon Gilmore,0,1,2021-05-04 23:05:21+00:00,2021-05-15 06:48:38+00:00,"Problem


Events that come in an Integration may define the time of which that event occurred. An Integration developer cannot use a message's timestamp as the index time.


Solution


Add support to set the index time.",
0,CAMEL-16576,Task,Minor,3.9.0,3.10.0,"

website

",Resolved,Fixed,3.10.0,Unassigned,Karen Lease,0,3,2021-05-04 17:08:00+00:00,2021-05-14 04:16:49+00:00,"In the User Manual, most of the files in the ""Community"" section (Mailing Lists, Support, Team, User Stories, as well as Books in the ""Resources & Guides"" section, exist as .adoc files in the camel project but also as .md files in camel-website/content/community. Some links in the website reference adoc files and others reference md files.


Both sets of files have changes so the content is not always consistent.Only one set of files should be maintained and the other ones should be removed.


After discussion with zregvart it has been decided to remove the .adoc files and keep the .md files.


The Community section in the user manual navigation panel and index page will be removed.


The /CONTRIBUTING.md in the GitHub Camel repository contains almost the same content as the contributing.adoc file in the User Manual. The main contributing content will be put in the camel-website/content/community section. The CONTRIBUTING.md file at the repository root will be contain only the guidelines for actually making a contribution and it will link to the Community contributing.md file.","githubbot:1620543037:2021-05-09T14:50:37.709+0000:1620543037:2021-05-09T14:50:37.709+0000:klease opened a new pull request #573:
URL: https://github.com/apache/camel-website/pull/573


   The Community section of the Camel user manual contained .adoc pages which duplicated content in the Community section of the website. They've been removed and extra changes made there have been merged to the pages in the Community section.
   There are also changes in the camel repository itself which need to be merged at the same time as these.


-- 
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.

For queries about this service, please contact Infrastructure at:
users@infra.apache.org

githubbot:1620620623:2021-05-10T12:23:43.290+0000:1620620623:2021-05-10T12:23:43.290+0000:zregvart merged pull request #573:
URL: https://github.com/apache/camel-website/pull/573


   


-- 
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.

For queries about this service, please contact Infrastructure at:
users@infra.apache.org

githubbot:1620621650:2021-05-10T12:40:50.938+0000:1620621650:2021-05-10T12:40:50.938+0000:github-actions[bot] commented on pull request #573:
URL: https://github.com/apache/camel-website/pull/573#issuecomment-836648452


   🚀 Preview is available at https://pr-573--camel.netlify.app


-- 
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.

For queries about this service, please contact Infrastructure at:
users@infra.apache.org

davsclaus:1620701436:2021-05-11T10:50:36.843+0000:1620701436:2021-05-11T10:50:36.843+0000:Thanks for all the work on helping the project and improving our website.

You are very welcome to continue helping."
0,CAMEL-16575,Improvement,Major,None,3.10.0,"
None
",Resolved,Fixed,3.10.0,Claus Ibsen,Claus Ibsen,0,1,2021-05-04 12:49:03+00:00,2021-05-05 18:04:48+00:00,"It may be desirable to bind a bean that is lazy evaluated via a Supplier, so you can bind a bean that is lambda based.


context.bind(""foo"", () -> 

{ ... something that returns a bean ... }

);","davsclaus:1620107129:2021-05-04T13:45:29.878+0000:1620107139:2021-05-04T13:45:39.731+0000:You need to provide the class type, but then the bean is lazy

{code}
        registry.bind(""myBar"", FooBar.class, () -> {
            FooBar bar = new FooBar();
            bar.setGreeting(""I am lazy "" + counter.incrementAndGet());
            return bar;
        });
{code}"
0,CAMEL-16574,Bug,Major,"3.7.0, 3.7.4, 3.7.3, 3.9.0","3.7.5, 3.10.0","
None
",Resolved,Fixed,"3.7.5, 3.10.0",Unassigned,Jawad Ahmad,0,2,2021-05-04 11:35:14+00:00,2021-05-11 10:53:40+00:00,"doHttpRequest(request, new ClientResponseCallback() {
            @Override
            public void onResponse(InputStream response, Map<String, String> headers, SalesforceException ex) 

{
                callback.onResponse(Optional.of(response), headers, ex);
            }

        });


  callback.onResponse(Optional.of(response), headers, ex); Throws NPE when response stream is null. This happens when there is Socket Timeout error.","davsclaus:1620102913:2021-05-04T12:35:13.973+0000:1620102913:2021-05-04T12:35:13.973+0000:Can you work on a PR to fix this (main branch) ?
jawwad124:1620104470:2021-05-04T13:01:10.776+0000:1620104470:2021-05-04T13:01:10.776+0000:Yeah, i will pick it up.
jawwad124:1620132621:2021-05-04T20:50:21.141+0000:1620132621:2021-05-04T20:50:21.141+0000:PR Created : https://github.com/apache/camel/pull/5502"
0,CAMEL-16573,Task,Minor,None,None,"

help-wanted

",Resolved,Fixed,3.x,Unassigned,Claus Ibsen,0,3,2021-05-04 09:07:02+00:00,2022-01-11 19:10:49+00:00,"There are a number of components etc that has CS violations around parenthesis.


Anyone is welcome to help with this to contribute PRs


Change this to 8.42 at
https://github.com/apache/camel/blob/main/parent/pom.xml#L387


And then in components run
mvn compile -P sourcecheck | grep ERROR","dejan2609:1620535557:2021-05-09T12:45:57.256+0000:1620535557:2021-05-09T12:45:57.256+0000:(i) [~davsclaus] this could be related issue: https://github.com/checkstyle/checkstyle/issues/9957 _*UnnecessaryParentheses false positives in 8.42*_
essobedo:1641891295:2022-01-11T16:54:55.820+0000:1641891295:2022-01-11T16:54:55.820+0000:It seems to be fixed by https://github.com/apache/camel/pull/5734
davsclaus:1641899449:2022-01-11T19:10:49.403+0000:1641899449:2022-01-11T19:10:49.403+0000:Thanks"
0,CAMEL-16572,Improvement,Major,None,3.10.0,"
None
",Resolved,Fixed,3.10.0,Claus Ibsen,Claus Ibsen,0,1,2021-05-04 06:44:29+00:00,2021-05-04 07:54:35+00:00,"Lets make a new camel-spring-jdbc that extends camel-jdbc and has that spring jdbc use to support spring TX.


Non Spring users should not have dependency on spring via plain camel-jdbc.","davsclaus:1620086075:2021-05-04T07:54:35.058+0000:1620086075:2021-05-04T07:54:35.058+0000:[~ppalaga] heads-up that camel-jdbc is now spring-less, so camel-quarkus-jdbc could be improved to drop spring dependency."
0,CAMEL-16571,Improvement,Minor,None,3.10.0,"
None
",Resolved,Fixed,3.10.0,Claus Ibsen,Claus Ibsen,0,2,2021-05-03 14:19:19+00:00,2021-05-03 15:47:39+00:00,"This does not make sense, as its really only for methods, eg to Camel call a methods when a message is consumed.


The @Produce is for field/constructor injection and not method.
And same for @EndpointInject","davsclaus:1620023138:2021-05-03T14:25:38.070+0000:1620023351:2021-05-03T14:29:11.838+0000:Oh yeah there is the old camel proxy which allows to define interfaces as contract such as
{code}
public interface Echo {

    @Produce(""direct:hello"")
    String hello(String name);

}
{code}

Then invoking hello(""goofy"") would then automatic send the message to direct:hello endpoint. 

So the annotations have a bit more widespread usage patterns
ppalaga:1620027139:2021-05-03T15:32:19.245+0000:1620027139:2021-05-03T15:32:19.245+0000:There is some setter method injection implemented in  org.apache.camel.impl.engine.DefaultCamelBeanPostProcessor.setterInjection(Method, Object, String) for {{@Produce}} and {{@EndpointInject}}
davsclaus:1620028059:2021-05-03T15:47:39.197+0000:1620028059:2021-05-03T15:47:39.197+0000:Yes so if you do not do field injection you can do it on the setter method instead (probably not so often used).

{code}
        private ProducerTemplate producer;

        @EndpointInject(""mock:result"")
        public void setProducer(ProducerTemplate producer) {
            this.producer = producer;
        }

        public ProducerTemplate getProducer() {
            return producer;
        }
{code}

I added the changes in the upgrade guide, see section API changes at
https://github.com/apache/camel/blob/40d701b10817fb3e5bbd7d4c8f00ebfd13648b08/docs/user-manual/modules/ROOT/pages/camel-3x-upgrade-guide-3_10.adoc#api-changes"
0,CAMEL-16570,New Feature,Minor,None,3.10.0,"
None
",Resolved,Fixed,3.10.0,Luca Burgazzoli,Luca Burgazzoli,0,1,2021-05-03 11:04:26+00:00,2021-05-11 14:36:07+00:00,As today the kamelet component assumes that efor each kamelet there is a route template already defined in the camel context. We should support reading the kamelet definition from the file system / classpath when not found int the Camel Context,
0,CAMEL-16569,Bug,Major,None,3.10.0,"
None
",Resolved,Fixed,3.10.0,Andrea Tarocchi,Andrea Tarocchi,0,1,2021-05-02 14:15:31+00:00,2021-05-02 16:35:25+00:00,"If for any reason a route created from a camel-kamelet template has a conflicting id (i.e. an id equal to any other route in the same camel context) a weird error occur:




org.apache.camel.FailedToStartRouteException: Failed to start route test because of null




instead of the real cause, these makes diagnosing the problem quite hard.",
0,CAMEL-16568,Improvement,Major,None,3.10.0,"
None
",Resolved,Fixed,3.10.0,Claus Ibsen,Claus Ibsen,0,1,2021-05-02 11:03:40+00:00,2021-05-02 11:44:48+00:00,"ActiveMQ has
https://activemq.apache.org/destination-options


We can set them via multi-valued, eg destination.consumer.prefetchSize=100",
0,CAMEL-16567,Bug,Minor,3.9.0,3.10.0,"
None
",Resolved,Fixed,3.10.0,Unassigned,Dietrich Schulten,0,1,2021-05-01 11:12:17+00:00,2022-04-26 06:00:03+00:00,"It is not possible to mock consul producers, at least I have tried with the catalog and agent producers. Test:




public class MockAgentTest extends CamelTestSupport {

    @Test
    public void testMockAgent() throws Exception {
        MockEndpoint mockConsulAgent = getMockEndpoint(""mock:consul:agent"");

        AdviceWith.adviceWith(context, ""servicesRoute"", a -> {
            a.mockEndpointsAndSkip(""consul:agent*"");
        });
        mockConsulAgent.returnReplyBody(constant(ImmutableMap.of(""foo-1"", ImmutableService.builder()
            .id(""foo-1"")
            .service(""foo"")
            .address(""localhost"")
            .port(80)
            .build())));

        @SuppressWarnings(""unchecked"")
        Map<String, Service> result = fluentTemplate.to(""direct:start"").request(Map.class);
    }

    @Override
    protected RoutesBuilder createRouteBuilder() throws Exception {
        return new RouteBuilder() {
            @Override
            public void configure() throws Exception {
                from(""direct:start"").to(""consul:agent?action="" + ConsulAgentActions.SERVICES);
            }
        };
    }
}




Error:




org.apache.camel.FailedToStartRouteException: Failed to start route servicesRoute because of null
 at org.apache.camel.impl.engine.RouteService.warmUp(RouteService.java:123) 
...
Caused by: java.lang.NullPointerException at org.apache.camel.support.HeaderSelectorProducer.doBuild(HeaderSelectorProducer.java:150) at org.apache.camel.support.service.BaseService.build(BaseService.java:63) at org.apache.camel.support.service.ServiceHelper.buildService(ServiceHelper.java:55) at org.apache.camel.support.service.ServiceHelper.buildService(ServiceHelper.java:72) at org.apache.camel.processor.InterceptSendToEndpointProcessor.doBuild(InterceptSendToEndpointProcessor.java:151) at org.apache.camel.support.service.BaseService.build(BaseService.java:63) at org.apache.camel.support.service.BaseService.init(BaseService.java:79) at org.apache.camel.support.service.BaseService.start(BaseService.java:111) at org.apache.camel.support.service.ServiceHelper.startService(ServiceHelper.java:113) at org.apache.camel.impl.engine.AbstractCamelContext.internalAddService(AbstractCamelContext.java:1465) at org.apache.camel.impl.engine.AbstractCamelContext.addService(AbstractCamelContext.java:1383) at org.apache.camel.processor.SendProcessor.doStart(SendProcessor.java:247) at org.apache.camel.support.service.BaseService.start(BaseService.java:119) at org.apache.camel.support.service.ServiceHelper.startService(ServiceHelper.java:113) at org.apache.camel.support.service.ServiceHelper.startService(ServiceHelper.java:130) at org.apache.camel.processor.errorhandler.RedeliveryErrorHandler.doStart(RedeliveryErrorHandler.java:1638) at org.apache.camel.support.ChildServiceSupport.start(ChildServiceSupport.java:60) ... 92 more



The reason is that camelContext is null in HeaderSelectorProducer, but I am still unsure why that is:




@Override
protected void doBuild() throws Exception {
    super.doBuild();

    String key = this.getClass().getName();
    String fqn = RESOURCE_PATH + key;
    // -------- camelContext is null here:
    strategy = camelContext.adapt(ExtendedCamelContext.class).getBootstrapFactoryFinder(RESOURCE_PATH)
            .newInstance(key, InvokeOnHeaderStrategy.class)
            .orElseThrow(() -> new IllegalArgumentException(""Cannot find "" + fqn + "" in classpath."")); 
    ...



Same with catalog:




 public class MockCatalogTest extends CamelTestSupport {

    @Test
    public void testMockCatalog() throws Exception {
        MockEndpoint mockConsulAgent = getMockEndpoint(""mock:consul:catalog"");

        AdviceWith.adviceWith(context, ""servicesRoute"", a -> {
            a.mockEndpointsAndSkip(""consul:catalog*"");
        });
        mockConsulAgent.returnReplyBody(constant(singletonList(ImmutableNode.builder().node(""node-1"").build())));

        @SuppressWarnings(""unchecked"")
        Map<String, Service> result = fluentTemplate.to(""direct:start"").request(Map.class);
    }

    @Override
    protected RoutesBuilder createRouteBuilder() throws Exception {
        return new RouteBuilder() {
            @Override
            public void configure() throws Exception {
                from(""direct:start"").to(""consul:catalog?action="" + ConsulCatalogActions.LIST_NODES);
            }
        };
    }
}




Why this fails is not clear to me. Two instances of ConsulAgentProducer are being created. At runtime the method setCamelContext of the failing instance never gets called, although it is a CamelContextAware. I suspect that it is the mock or the real object behind the mock which is not a CamelContextAware so that it receives no camelContext. My assumption is that a mock is a kind of wrapper around the real thing, but I wasn't able to understand the relationship between the two enough to fix this. The instances look very similar, the failing instance appears not to be a Java proxy.


Anyone who understands the mocking mechanics better than me: what might go wrong here? Any hints how it should work? Is the mock a proxy or what exactly is the relationship between mock and mocked?


UPDATE


The failing instance is the delegate ConsulAgentProducer inside an InterceptSendToEndpointProcessor. The latter is not a CamelContextAware, hence it receives no camelContext. I see two different approaches:



The delegate inside the InterceptSendToEndpointProcessor could be made to receive a camelContext, e.g. by making the InterceptSendToEndpointProcess a CamelContextAware and setting the camelContext on the delegate
The method invocation HeaderSelectorProducer.doBuild() could be skipped somehow



Advice would be very much appreciated.


UPDATE 2


Turns out, it is not the delegate (ConsulEndpoint) member nor the endpoint (DefaultInterceptorSendToEndpoint) member inside InterceptSendToEndpointProcessor which has no CamelContext, but the producer (ConsulAgentProducer) member, which holds a second instance of the producer. Again, two approaches:



Let InterceptSendToEndpointProcessor set the camelContext on the producer when it receives the camelContext.
Find out why the second producer inside InterceptSendToEndpointProcessor does not receive a camelContext when it gets constructed



UPDATE 3


DefaultInterceptSendToEndpoint is responsible to create the producer in createAsyncProducer. One could call camelContext.addService(producer) there, in order to initialize the delegate producer like any other component. It does fix the problem, but I am unsure if the delegate producer should be added as a service or if it is the whole point not to add it.


DefaultInterceptSendToEndpoint.java




@Override
public AsyncProducer createAsyncProducer() throws Exception {
    AsyncProducer producer = delegate.createAsyncProducer();
    camelContext.addService(producer); // <-- insert this to initialize the producer with camelContext
    return camelContext.adapt(ExtendedCamelContext.class).getInternalProcessorFactory()
            .createInterceptSendToEndpointProcessor(this, delegate, producer, skip);
} 



The alternative would still be to make InterceptSendToEndpointProcessor a CamelContextAware and if its producer is a CamelContextAware in turn, set the camelContext on the producer, hold it in the InterceptSendToEndpointProcessor and get it from there in getCamelContext. Somehow this feels less intrusive than adding the producer as a service.


What would you recommend?","dschulten:1619850637:2021-05-01T14:30:37.558+0000:1619850637:2021-05-01T14:30:37.558+0000:https://github.com/apache/camel/pull/5484 makes the InterceptSendToEndpointProcessor CamelContextAware.
dschulten:1650923954:2022-04-26T05:59:14.378+0000:1650924003:2022-04-26T06:00:03.403+0000:To mock a consul response, look for the proper {{ImmutableXXX.builder()}} for the model interfaces of the respective consul api at [https://github.com/rickfast/consul-client/tree/master/src/main/java/com/orbitz/consul/model]. E.g. kv uses a {{Value}} model interface, hence you need the {{{}ImmutableValue.builder(){}}}. Those builders are generated, you don't find them in the source code, only in the jars.

Mocking a kv response:
{code:java}
consulMock.returnReplyBody(
  constant(
    ImmutableValue.builder()
      .value(""bm90aGluZyB0byBzZWUgaGVyZQ=="")
      .createIndex(1)
      .modifyIndex(1)
      .lockIndex(1)
      .key(""key"")
      .flags(1)
      .build()));
{code}"
0,CAMEL-16566,Bug,Major,3.7.3,"3.7.5, 3.10.0","
None
",Resolved,Fixed,"3.7.5, 3.10.0",Claus Ibsen,Jens Kleine-Herzbruch,0,2,2021-04-30 12:15:17+00:00,2021-05-01 08:30:54+00:00,"If you have routes that have nested enrichers that use shareUnitOfWork=true, you'll get a ConcurrentModificationException when the subroutes are joined back.


 




from(""direct:routeA"").
    enrichWith(""direct:routeB"", true, true).body((a, b) -> a);

from(""direct:routeB"").
    enrichWith(""direct:routeC"", true, true).body((a, b) -> a);

from(""direct:routeC"").setBody(constant(""xxx"")); 



 




org.apache.camel.CamelExchangeException: Error occurred during aggregation. Exchange[0A01B3DD98090F3-0000000000000001]. Caused by: [java.util.ConcurrentModificationException - null]
 at org.apache.camel.processor.Enricher$1.done(Enricher.java:247) ~[camel-core-processor-3.7.3.jar:3.7.3]
 at org.apache.camel.AsyncCallback.run(AsyncCallback.java:44) ~[camel-api-3.7.3.jar:3.7.3]
 ...
Caused by: java.util.ConcurrentModificationException
 at java.util.ArrayList$Itr.checkForComodification(ArrayList.java:1042) ~[?:?]
 at java.util.ArrayList$Itr.remove(ArrayList.java:1010) ~[?:?]
 at org.apache.camel.impl.engine.DefaultUnitOfWork.handoverSynchronization(DefaultUnitOfWork.java:202) ~[camel-base-engine-3.7.3.jar:3.7.3]
 at org.apache.camel.impl.engine.DefaultUnitOfWork.handoverSynchronization(DefaultUnitOfWork.java:179) ~[camel-base-engine-3.7.3.jar:3.7.3]
 at org.apache.camel.support.DefaultExchange.handoverCompletions(DefaultExchange.java:612) ~[camel-support-3.7.3.jar:3.7.3]
 at org.apache.camel.processor.Enricher$1.done(Enricher.java:242) ~[camel-core-processor-3.7.3.jar:3.7.3]
 ...",davsclaus:1619827381:2021-05-01T08:03:01.256+0000:1619827381:2021-05-01T08:03:01.256+0000:Thanks for reporting
0,CAMEL-16565,New Feature,Minor,None,,"
None
",Resolved,Information Provided,None,Unassigned,Ajinkya,0,2,2021-04-30 07:49:00+00:00,2021-05-01 07:33:30+00:00,"As per the thread below, it is observed that quickfix is unable to read cfg file from file system unlike other camel components.


https://stackoverflow.com/questions/37278103/config-file-from-file-system-for-apache-camel-quickfix-application


It would be a nice feature to allow quickfix to read cfg file from file system","davsclaus:1619741808:2021-04-30T08:16:48.930+0000:1619741808:2021-04-30T08:16:48.930+0000:Can you try with file: as prefix, eg

XX.config.file=file:/home/user/fixApp/XXconfig.cfg

If you are using a new Camel version like 3.9.0, we have improved it a lot since that old stackoverflow question
ajinkyatankhiwale:1619754969:2021-04-30T11:56:09.674+0000:1619754969:2021-04-30T11:56:09.674+0000:Tried with above mentioned way to load configuration file on windows machine. Camel could not load file to create routes.

!image-2021-04-30-17-25-49-557.png!
davsclaus:1619825604:2021-05-01T07:33:24.132+0000:1619825604:2021-05-01T07:33:24.132+0000:Works fine for me on 3.9. Maybe you use an too old Camel version. Also try to avoid having spaces in the folder name."
0,CAMEL-16564,New Feature,Minor,3.9.0,3.x,"
None
",Resolved,Won't Fix,3.x,Jean-Baptiste Onofré,Piotr Klimczak,0,3,2021-04-29 19:47:43+00:00,2022-09-02 17:52:39+00:00,"Camel Blueprint namespace handler is missing Spring Namespace declaration:




<blueprint xmlns=""http://www.osgi.org/xmlns/blueprint/v1.0.0"">

    <service interface=""org.apache.aries.blueprint.NamespaceHandler"">
        <service-properties>
            <entry key=""osgi.service.blueprint.namespace"">
                <array value-type=""java.lang.String"">
                    <value>http://camel.apache.org/schema/spring</value> <!-- THIS IS MISSING -->
                    <value>http://camel.apache.org/schema/blueprint</value>
                    <value>http://camel.apache.org/schema/placeholder</value>
                </array>
            </entry>
        </service-properties>
        <bean class=""org.apache.camel.blueprint.handler.CamelNamespaceHandler""/>
    </service>

</blueprint> 



There is support implemented in Camel Blueprint project (partially), there is even some test spring context, but no real test coverage for this.
 Is it because Apache Camel community is abandoning such approach?
 We have quite few integrations which we have to be able to run in both: Tomcat and Karaf.
 I can provide some patches and improvements, provided that the community is interested in supporting such path, rather then me spending time and nobody even accepting PRs.","acosentino:1619699283:2021-04-29T20:28:03.756+0000:1619699283:2021-04-29T20:28:03.756+0000:In this project, I've seen one or two PRs rejected with good reason, so i don't know why you think a PR will be rejected, at least I don't know why you're reporting this issue in this way. It seems you're angry and frustrated about this particular problem.

 

 
nannou9:1619739329:2021-04-30T07:35:29.640+0000:1619739329:2021-04-30T07:35:29.640+0000:[~acosentino], apologies if it comes this way. I was nowhere close to frustrated or anything like that.

Instead I am being pragmatic, as someone else raised bug against Camel Spring and was told that it doesn't work because it is not supported anymore.
Therefore 1st thing I wanted to establish is if community is willing to go in this direction at all.
Surely there must be a plan within community in terms of future direction of camel.
If that direction is killing spring support for camel under Karaf, then it is fine, I just want to know it rather sooner than later- before I start investing my time into it.

I hope it sounds sensible.
So I will take your answer as yes- that community is willing to accept improvements in this area and support it in future.
davsclaus:1619740038:2021-04-30T07:47:18.956+0000:1619740038:2021-04-30T07:47:18.956+0000:This is NOT missing.

If you look at camel-blueprint in an old 2.x version like this
https://github.com/apache/camel/blob/camel-2.17.x/components/camel-blueprint/src/main/resources/OSGI-INF/blueprint/camel-blueprint.xml

There is NO support for parsing spring XML files (eg <beans>) in camel-blueprint. It has newer been. It was camel-spring-dm (via camel-spring) that does that.
Spring DM is a dead project, and hence Spring XML on OSGi is dead. For XML files with <beans> like dependency injections there is only OSGi blueprint that is active project for OSGi / Karaf.

In camel-blueprint there is a /spring namespace in the source code because the JAXB model classes in camel-core are historically defined with that namespace. So in camel-blueprint the namespace handler must transpose /blueprint to /spring to make it possible to marshal from XML into JAXB objects.

Camel does allow to load Camel only XML files (eg what you can define only inside <routes> XML snippets). Those are Spring / Blueprint agnostic and can be loaded from any runtime, also standalone etc. 

So you are wrong when you say that /spring is missing in that XML file in the top.
acosentino:1619740115:2021-04-30T07:48:35.788+0000:1619740115:2021-04-30T07:48:35.788+0000:All the work related to OSGi and karaf in general is best effort for camel 3. We are open to PRs, but the point is that we want to maintain the needed bits separated from plain camel. if your updates are only in the camel-karaf repository we'll evaluate the PR, if it requires updates in core or plain camel, in that case we'll need to evaluate and probably we'll reject the PR
nannou9:1619741698:2021-04-30T08:14:58.042+0000:1619742340:2021-04-30T08:25:40.205+0000:[~davsclaus] thanks for your explanation.
 I think there is some misunderstanding however.

I am not asking for camel-blueprint to support Spring XMLs. This is what Aries Blueprint Spring does.
 I am only asking for handling [http://camel.apache.org/schema/spring] namespace by Camel Karaf (blueprint component).

You are surely aware there is Aries Blueprint Spring project which embeds Spring within Blueprint- so Blueprint can read Spring XML and they can work together in single application context.
 This works actually quite well with some limitations and is very helpful where there is requirement for XML DSL to work in Karaf and Tomcat container.

However in such scenario and without above fix, a bundle with Spring XML (which has Camel Spring XML) hangs in grace period due to not finding namespace handler for [http://camel.apache.org/schema/spring.]

So from that perspective it is missing, as adding this line registers namespace handler in OSGi correctly and Spring Camel route starts correctly, except it starts as Blueprint context and not Spring context- which is not a problem.
 The only remaining problem I have is making Camel to correctly recognise properties, which might be either Camel Karaf or Aries Blueprint Spring fix.

But anyway, I am slightly confused what next in light of above answers.
I will create PR and we'll see I suppose.
davsclaus:1619988411:2021-05-03T04:46:51.369+0000:1619988411:2021-05-03T04:46:51.369+0000:That is new information and not really what you reported.

For spring xml handling via blueprint-spring, then its best to do that in a new camel-blueprint-spring module (can extend camel-blueprint)..
nannou9:1620824331:2021-05-12T20:58:51.997+0000:1620907843:2021-05-13T20:10:43.219+0000:Will wait for ARIES-2045 and ARIES-2046  prs to be accepted before creating one for this jira.
 I have working prototype however.

This will allow to use BridgePropertyPlaceholderConfigurer just like with regular Spring camel context"
0,CAMEL-16563,Bug,Minor,2.25.1,,"
None
",Resolved,Information Provided,None,Unassigned,rabee,0,2,2021-04-29 18:21:35+00:00,2021-04-30 19:28:30+00:00,"Dear All,


I'm using camel quartz to connect to ftp (cron based job), so the job is created on (quartz job_details, quartz_trigger, and cron_quartz_trigger) tables, do everything is working normally, but if one of the services shutdown then all this information got removed, and the job will not pull files from FTP


 


here is my connection url


sftp://user@xxx:2222/path?useUserKnownHostsFile=true&scheduler=quartz2&scheduler.triggerId=some-trigger-id&scheduler.cron=0/15?*


 


The scenario of removing the trigger only happens for cron jobs and is not happening for a simple job, is there any way to stop removing this trigger upon the shutdown of the service


(since my services are clustered and contain multiple replicas from )","davsclaus:1619693195:2021-04-29T18:46:35.901+0000:1619693195:2021-04-29T18:46:35.901+0000:Try with latest 2.25.x release and also latest Camel 3.

davsclaus:1619740840:2021-04-30T08:00:40.806+0000:1619740840:2021-04-30T08:00:40.806+0000:Since you use clustered quartz you need to set deleteJob=false and maybe a few others, see the docs at
https://camel.apache.org/components/2.x/quartz2-component.html
rabee:1619743841:2021-04-30T08:50:41.236+0000:1619743841:2021-04-30T08:50:41.236+0000:Thank you for your kind reply,

since I use sftp endpoint when I add deleteJob=false, the application fails to start since this property is not in sftp endpoint, I added it like this but still doesn't work

 
{code:java}
@Bean
QuartzComponent quartzComponent(CamelContext camelContext, SchedulerFactoryBean schedulerFactoryBean) {
 QuartzComponent quartzComponent = camelContext.getComponent(""quartz2"", QuartzComponent.class);
 quartzComponent.setScheduler(schedulerFactoryBean.getScheduler());
 Properties properties = new Properties();
 properties.getProperty(""deleteJob"",""false"")
 quartzComponent.setProperties(properties);
 return quartzComponent;
}
{code}
I also followed your suggestion to use the latest camel and camel-quartz, but still the same behavior.

am I setting the property in the incorrect place? I mean 
{code:java}
 Properties properties = new Properties();
 properties.getProperty(""deleteJob"",""false"")
 quartzComponent.setProperties(properties);
{code}
davsclaus:1619762022:2021-04-30T13:53:42.117+0000:1619762022:2021-04-30T13:53:42.117+0000:scheduler.deleteJob=false
rabee:1619782110:2021-04-30T19:28:30.370+0000:1619782110:2021-04-30T19:28:30.370+0000:It seems this property is not working as expected, or at least what I expect from this property, I have added this property as suggested above to be like this
{code:java}
sftp://user@xxx:2222/path?&scheduler=quartz&scheduler.triggerId=files-route-trigger&scheduler.cron=0/15 * * ? * * *&scheduler.deleteJob=false
{code}
and then I scaled up my services to 3 replicas, all information got registered in the database, after scaling down my services to 2 or 1, the information in the database tables (job details, trigger, corn trigger) got removed and the last replica is not able to pull from the sftp

 

Note: I have tried it on versions 3.9.0 and 2.25.1 (same behavior), here is the list of dependencies  
{code:java}
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-quartz</artifactId>
    <version>2.4.4</version>
</dependency>

<dependency>
    <groupId>org.apache.camel.springboot</groupId>
    <artifactId>camel-spring-boot-starter</artifactId>
    <version>3.9.0</version>
</dependency>
<dependency>
    <groupId>org.apache.camel.springboot</groupId>
    <artifactId>camel-quartz-starter</artifactId>
    <version>3.9.0</version>
</dependency>
<dependency>
    <groupId>org.apache.camel.springboot</groupId>
    <artifactId>camel-ftp-starter</artifactId>
    <version>3.9.0</version>
</dependency>
<dependency>
    <groupId>org.apache.camel.springboot</groupId>
    <artifactId>camel-micrometer-starter</artifactId>
    <version>3.9.0</version>
</dependency>
{code}
So I think the correct behavior is to keep all information about the job in the database even after shutting down all replicas, right?

 

Thanks in advance."
0,CAMEL-16562,New Feature,Major,None,3.10.0,"
None
",Resolved,Fixed,3.10.0,Unassigned,Peter Palaga,0,2,2021-04-29 12:45:13+00:00,2021-04-30 08:20:04+00:00,This page mentions org.apache.camel.component.bean.BeanInvocation which does not seem to exist anymore in Camel source tree. The paragraph should either be removed altogether or rephrased to match the reality.,davsclaus:1619741848:2021-04-30T08:17:28.118+0000:1619741848:2021-04-30T08:17:28.118+0000:Yes that should be removed
0,CAMEL-16561,Improvement,Minor,3.9.0,3.10.0,"
None
",Resolved,Fixed,3.10.0,Unassigned,Dietrich Schulten,0,3,2021-04-29 09:13:07+00:00,2021-05-03 04:43:48+00:00,"It should be possible to use agent registration and deregistration, since it is recommended by the Consul documentation https://www.consul.io/api-docs/catalog rather than catalog registration functionality, which is considered low-level.


Support this:




 .to(""consul:agent?action=REGISTER"")



expecting a com.orbitz.consul.model.agent.Registration as body. May also support QueryOptions


The corresponding deregister method should also be supported, taking a service id.","davsclaus:1619660163:2021-04-29T09:36:03.705+0000:1619660163:2021-04-29T09:36:03.705+0000:You are welcome to work on a PR
dschulten:1619833004:2021-05-01T09:36:44.775+0000:1619833004:2021-05-01T09:36:44.775+0000:There you go: https://github.com/apache/camel/pull/5482"
0,CAMEL-16560,Improvement,Major,None,None,"
None
",Resolved,Fixed,3.10.0,James Netherton,James Netherton,0,2,2021-04-29 08:35:06+00:00,2021-04-30 07:54:55+00:00,"Small thing I noticed when configuring a REST route with clientRequestValidation = true with camel-platform-http-vertx. E.g like:




.post(""/validation"")
    .clientRequestValidation(true)            
    .param().name(""foo"").type(RestParamType.body).required(true).endParam()
    .route()
        .setBody(simple(""Hello ${header.foo}""))
    .endRest()




If I don't provide a body in the POST request, then I'd expect a 400 status code. But it actually returns 200 as the Vert.x body handler initialises an empty Buffer which when converted to String results in an empty String.


https://github.com/apache/camel/blob/80b92e3624ae5db59a1a24a441f1b10b39eaa1a5/core/camel-core-processor/src/main/java/org/apache/camel/processor/RestBindingAdvice.java#L270


Thus this condition is false and Camel thinks the request is valid:


https://github.com/apache/camel/blob/80b92e3624ae5db59a1a24a441f1b10b39eaa1a5/core/camel-core-processor/src/main/java/org/apache/camel/processor/RestBindingAdvice.java#L275


Maybe instead of checking for null it should do ObjectHelper.isEmpty? Not sure if that is a 'safe' thing to do or if there's some scenario where an empty string body has some kind of meaning?","davsclaus:1619658008:2021-04-29T09:00:08.742+0000:1619658008:2021-04-29T09:00:08.742+0000:Ah yeah good catch.

If a HTTP body is required, and its an empty string (spaces etc) then I see that as an empty body and therefore should fail the validation."
0,CAMEL-16559,Bug,Minor,3.9.0,3.10.0,"
None
",Resolved,Fixed,3.10.0,Unassigned,Dietrich Schulten,0,2,2021-04-29 06:42:58+00:00,2021-05-01 07:17:49+00:00,"Probably a copy-paste error in ConsulCatalogProducer. The handler for LIST_SERVICES calls getNodes:




@InvokeOnHeader(ConsulCatalogActions.LIST_NODES)
protected void listNodes(Message message) throws Exception {
    processConsulResponse(message, getClient().getNodes(buildQueryOptions(message, getConfiguration())));
}

@InvokeOnHeader(ConsulCatalogActions.LIST_SERVICES)
protected void listServices(Message message) throws Exception {
    processConsulResponse(message, getClient().getNodes(buildQueryOptions(message, getConfiguration())));
--------------------------------------------------^^^^
}



 Should call getServices(queryOptions) instead.


 


Workaround: use




.to(""consul:agent?action=SERVICES"") 



But that doesn't give you the node name where existing services are registered","davsclaus:1619660186:2021-04-29T09:36:26.703+0000:1619660186:2021-04-29T09:36:26.703+0000:You are welcome to work on a PR
dschulten:1619733748:2021-04-30T06:02:28.384+0000:1619733748:2021-04-30T06:02:28.384+0000:will do ;-)
dschulten:1619821368:2021-05-01T06:22:48.825+0000:1619821368:2021-05-01T06:22:48.825+0000:https://github.com/apache/camel/pull/5481"
0,CAMEL-16558,New Feature,Major,"2.25.2, 3.10.0",3.10.0,"

deprecated
endpoint
openapi
rest
swagger

",Resolved,Fixed,3.10.0,Unassigned,José Bustamante,0,3,2021-04-28 11:04:16+00:00,2021-05-09 23:05:29+00:00,"Good morning, 


I'm using camel-swagger-java for a while and i found something: I can't deprecate an endpoint with camel-swagger-java or camel-openapi-java. I assume that feature is not available yet. Is it going to be at some point?


I have raised a question in stackoverflow but no luck so far: https://stackoverflow.com/questions/67265296/mark-an-endpoint-as-deprecated-with-camel-swagger-java


Regards","davsclaus:1619660254:2021-04-29T09:37:34.445+0000:1619660254:2021-04-29T09:37:34.445+0000:No I dont think we have such functionality yet.

Contributions is welcome.
Federico Mariani:1620103490:2021-05-04T12:44:50.633+0000:1620103659:2021-05-04T12:47:39.122+0000:Hi, [https://github.com/apache/camel/pull/5501] , with this PR you can write a route like 
{code:java}
rest().get(""/foo"").description(""Foo endpoint"").deprecated().route().log(""Hello /foo"").endRest()
{code}
and the resulting yaml looks like:
{code:java}
---
openapi: ""3.0.2""
info: {}
servers:
- url: """"
paths:
  /foo:
    get:
      responses:
        ""200"": {}
      deprecated: true
      summary: ""Foo endpoint""
{code}
ref - https://swagger.io/docs/specification/paths-and-operations - Deprecated Operations section
davsclaus:1620202246:2021-05-05T16:10:46.941+0000:1620202246:2021-05-05T16:10:46.941+0000:Thanks for the PR
wayqui:1620202866:2021-05-05T16:21:06.366+0000:1620202866:2021-05-05T16:21:06.366+0000:Thank you Federico. Just a question, Does this change is for camel-openapi-java only? or it works for both openapi and swagger? It's just I saw changes in camel-core and camel-openapi but not in camel-swagger...
Federico Mariani:1620206291:2021-05-05T17:18:11.746+0000:1620206291:2021-05-05T17:18:11.746+0000:Hi José, you're totally right, I'm sorry I forgot about swagger, when I first read this issue I was wondering if swagger was still a thing and forgot about it, the fix should be straightforward and I'll open a new PR
Federico Mariani:1620208238:2021-05-05T17:50:38.105+0000:1620208238:2021-05-05T17:50:38.105+0000:PR for camel-swagger-java [https://github.com/apache/camel/pull/5516] rest example:
{code:java}
 rest(""/hello"").consumes(""application/json"").produces(""application/json"").get(""/hi/{name}"")
                        .description(""Saying hi"").deprecated()
{code}
[~wayqui] [~davsclaus] I was looking at [swagger specification|https://swagger.io/specification/] and it says that not only verbs (operation) can be deprecated; params and schema can be deprecated too. It is worth to implement params and schema deprecation, or you think that verbs is enough?
wayqui:1620220786:2021-05-05T21:19:46.094+0000:1620221667:2021-05-05T21:34:27.802+0000:Yeah, that's right, it's possible with Openapi v3 to [deprecate parameters and schemas|https://swagger.io/docs/specification/describing-parameters] but perhaps we could deal with that in another jira, since I created this one for deprecate endpoints only.

I don't know what you guys think.

By the way, thank's for your effort Federico.
davsclaus:1620248565:2021-05-06T05:02:45.860+0000:1620248565:2021-05-06T05:02:45.860+0000:Yeah you are welcome to. create another JIRA about deprecate for the other things
wayqui:1620572729:2021-05-09T23:05:29.081+0000:1620572729:2021-05-09T23:05:29.081+0000:Guys, I have a question, sorry. Since camel swagger (camel-swagger-java that uses spec Swagger 2.0) is available since camel 2.16 and the endpoint deprecations is also available for v2, shouldn't these changes be included in camel 2.x? In the same way I think that the changes implemented for openapi (camel-openapi-java, which is available for camel 3.1 onwards and is based on spec 3.0) should be included in camel 3.x. What do you think about this?"
0,CAMEL-16557,New Feature,Major,None,3.10.0,"
None
",Resolved,Fixed,3.10.0,Peter Palaga,Peter Palaga,0,1,2021-04-27 14:08:48+00:00,2021-04-30 08:20:41+00:00,"Camel K would like to receive the info which Camel components are included in a given Camel Quarkus extension, see https://github.com/apache/camel-quarkus/issues/2368


Adding a free form key value map for storing this and any other subproject specific info seems to make more sense than adding dedicated attributes that would have little to no meaning in the context of Camel Core.",
0,CAMEL-16556,Bug,Major,None,3.10.0,"
None
",Resolved,Fixed,3.10.0,Tomohisa Igarashi,Peter Palaga,0,2,2021-04-26 21:11:57+00:00,2021-04-28 00:06:14+00:00,"When there are two AtlasMapEndpoints within the same application having distinct propertiesFile values set, then both values are set on the same instance of DefaultAtlasContextFactory (obtained via DefaultAtlasContextFactory.getInstance() ) so only the last one stays in effect.


I am not sure what should be the correct behavior. Perhaps the propertiesFile property should move to the component?


WDYT igarashitm?","igarashitm:1619445117:2021-04-26T21:51:57.300+0000:1619445117:2021-04-26T21:51:57.300+0000:Ah that's right, should be moved to the component."
0,CAMEL-16555,Bug,Minor,None,3.12.0,"
None
",Resolved,Fixed,3.12.0,Claus Ibsen,Steven Tobias,0,2,2021-04-26 17:06:08+00:00,2021-06-25 07:54:31+00:00,"I'm running the Jira camel k component to get new issues from Jira cloud.


 


Just a basic




from(jira://newissues)




 


After a certain amount of time - (somewhere around 4-5 days), the Jira connector starts throwing 401s. 


 


I get errors like the below.




(Camel (camel-1) thread #0 - jira://newIssues) Consumer Consumer[jira://newIssues?accessToken=xxxxxx] failed polling endpoint: jira://newIssues?accessToken=xxxxxx. Will try again at next poll. Caused by: [com.atlassian.jira.rest.client.api.RestClientException - org.codehaus.jettison.json.JSONException: A JSONObject text must begin with '{' at character 1 of oauth_problem=nonce_used]: RestClientException{statusCode=Optional.of(401), errorCollections=[]}




I think the important part here is that the ""nonce_used"" error from oauth, but not sure what that might mean.","davsclaus:1619477955:2021-04-27T06:59:15.831+0000:1619477955:2021-04-27T06:59:15.831+0000:Does that error go away, eg on next poll do you get a success call? 

stobias123:1619507520:2021-04-27T15:12:00.076+0000:1619507520:2021-04-27T15:12:00.076+0000:No, I stop receiving new issues. I have to delete the pod to completely
restart the process


"
0,CAMEL-16554,Improvement,Major,None,3.10.0,"
None
",Resolved,Fixed,3.10.0,Grzegorz Grzybek,Grzegorz Grzybek,0,1,2021-04-26 13:24:05+00:00,2021-04-26 14:30:28+00:00,"Following CAMEL-13726, if you generate SSH key with -t ed25519 you'll get a private key with BEGIN OPENSSH PRIVATE KEY header. Such key can be read using built-in SSHD methods, provided that net.i2p.crypto/eddsa library is installed.","ggrzybek:1619415772:2021-04-26T13:42:52.230+0000:1619415772:2021-04-26T13:42:52.230+0000:PR: https://github.com/apache/camel/pull/5467
ggrzybek:1619418622:2021-04-26T14:30:22.183+0000:1619418622:2021-04-26T14:30:22.183+0000:Fixed [here|https://github.com/apache/camel/commit/9e58f40c2feb94220b887e28b5b0c1b582516ba7] in {{main}} branch."
0,CAMEL-16553,Bug,Minor,3.4.0,,"
None
",Resolved,Information Provided,None,Unassigned,MykhailoVlakh,0,2,2021-04-26 10:29:32+00:00,2021-06-24 13:15:39+00:00,"It looks like Flatpack library has defects that do not allow to parse CSV files that use text qualifiers a lot. The issues are:



it cannot process files that contain multiline strings like:


Bob,Smith,bsmiht@test.com,""This is a long fragment of text
that should be processed as a single field"", 1988, 111-222-33,""another field with new line character
 that should be considered as a field of the same data row"" 





also if string starts with text qualifier characters it also cannot handle it properly, like:


Bob, Smith, """"""Test"""" , 2, Some string, still string, also part of the string."",11111111





I have reported a defect https://github.com/Appendium/flatpack/issues/60 for Flatpack. But I am not sure if there are chances that these issues will be fixed any time soon since they released the latest available version in 2019.","davsclaus:1619413956:2021-04-26T13:12:36.716+0000:1619413956:2021-04-26T13:12:36.716+0000:Try one of the other CSV components.
davsclaus:1624511739:2021-06-24T13:15:39.578+0000:1624511739:2021-06-24T13:15:39.578+0000:This is a bug/issue in flatpack and is tracked in their issue tracker"
0,CAMEL-16552,Improvement,Minor,3.7.3,"3.7.4, 3.10.0","
None
",Resolved,Fixed,"3.7.4, 3.10.0",Claus Ibsen,Andreas Klug,0,2,2021-04-26 09:28:12+00:00,2021-04-27 10:14:59+00:00,"In BaseMainSupport.java the route id to be used for routes instantiated based on templates using properties seems to be determined by using square brackets with non-number indices (see CAMEL-15270):


...


> String id = StringHelper.between(entry.getKey(), ""["", ""]""); ...


> source.addParameter(id, key, entry.getValue()); ...


> 


I fear that may break compatibility with YAML formatted application configuration files, or at least I can't figure out how to model it in YAML.


My attempts are shown in the two YAML excepts below, which will cause


""binding to target [Bindable@7af327e3 type = java.util.List<java.util.Map<java.lang.String, java.lang.String>> failed"".


The first example results in properties generated i. e. camel.route-template.config[4][0].auto-start, as I can't get around the yaml list.


 


 1)


 camel:


     route-template:


         config:


             ""[4]"":


                 - template-id:   ""template-route""


                   ...


 2)


 camel:


     route-template:


         config:


             ""[4]"":


                 template-id:   ""template-route""


                 ...


 


Pls. provide a possibility or an example to configure routes based on templates in YAML.


 


Additional remark: I tried to set the route id in a route template definition converter, however, in DefaultModel.java, the id is overwritten after the converter is applied:


RouteDefinition def = converter.apply(target, prop);
 if (routeId != null) 

{
 def.setId(routeId);
 }


Is that intended?","davsclaus:1619414229:2021-04-26T13:17:09.706+0000:1619414229:2021-04-26T13:17:09.706+0000:How are you running Camel? Are you using spring boot or something?
andreas.klug2@de.bosch.com:1619416291:2021-04-26T13:51:31.280+0000:1619416291:2021-04-26T13:51:31.280+0000:Hello [~davsclaus], yes, I'm using Spring Boot.
davsclaus:1619487923:2021-04-27T09:45:23.368+0000:1619487923:2021-04-27T09:45:23.368+0000:Its not a yaml dsl problem, but that you are using spring boot yaml configuration which has that limitation.
davsclaus:1619489397:2021-04-27T10:09:57.443+0000:1619489397:2021-04-27T10:09:57.443+0000:Here is how it can be done in yaml
https://github.com/apache/camel-spring-boot-examples/commit/a5db888de6c1196ad31daddd532cb4cae6a97cca

Setting the route-id is possible from 3.10 onwards.
davsclaus:1619489699:2021-04-27T10:14:59.922+0000:1619489699:2021-04-27T10:14:59.922+0000:Backported to 3.7.x branch"
0,CAMEL-16551,Bug,Major,None,3.10.0,"
None
",Resolved,Fixed,3.10.0,Claus Ibsen,Andrea Tarocchi,0,2,2021-04-25 20:35:18+00:00,2021-04-26 17:21:09+00:00,"It seems that property placeholders (i.e. ""{{propertyName}}"") are not resolved if used in .marshal() and .unmarshal() DSL statements.","davsclaus:1619383937:2021-04-26T04:52:17.073+0000:1619383937:2021-04-26T04:52:17.073+0000:Can you post an example
valdar:1619417220:2021-04-26T14:07:00.258+0000:1619417220:2021-04-26T14:07:00.258+0000:This is a small reproducer:

{code:bash}
wget -O k.java https://gist.githubusercontent.com/valdar/7e6af5bde3225d55d65dc6a98a7a93f3/raw/355387a2acbc794f52b085a5068deefb636b896b/k.java
sdk inatall jban
export MARSHAL=hl7
jban k.java
{code}


davsclaus:1619428059:2021-04-26T17:07:39.298+0000:1619428059:2021-04-26T17:07:39.298+0000:Thanks, so yeah its the ref name that does not support property placeholders
valdar:1619428580:2021-04-26T17:16:20.687+0000:1619428580:2021-04-26T17:16:20.687+0000:Is that intended behavior or can be added?
davsclaus:1619428869:2021-04-26T17:21:09.440+0000:1619428869:2021-04-26T17:21:09.440+0000:Yeah its a little bug.

This is fixed in the reifier where it should do the placeholder. The commit shows how
https://github.com/apache/camel/commit/3ce6024fc86f232cf7dfaf49cc801968765f2431

If you find any other EIP that has something similar missing, then the place to look is in the reifier, where they should use those parseString, parseLong, parseXXX methods."
0,CAMEL-16550,Bug,Major,"3.7.3, 3.9.0","3.7.4, 3.10.0","
None
",Resolved,Fixed,"3.7.4, 3.10.0",Claus Ibsen,Claus Ibsen,0,1,2021-04-23 06:58:26+00:00,2021-04-25 12:56:02+00:00,"Reported on chat room


https://camel.zulipchat.com/#narrow/stream/257301-camel-spring-boot/topic/Camel.203.2E7.2E3.20transacted.20multicast.20-.3E.20stuck.20inflight.20message",
0,CAMEL-16549,New Feature,Major,None,3.11.0,"
None
",Resolved,Fixed,3.11.0,Andrea Cosentino,Andrea Cosentino,0,1,2021-04-23 06:38:16+00:00,2021-06-07 13:25:14+00:00,No Desc,acosentino:1623043508:2021-06-07T13:25:08.193+0000:1623043508:2021-06-07T13:25:08.193+0000:This has been done by [~paul@search-solutions.net]
0,CAMEL-16548,Improvement,Minor,None,3.10.0,"
None
",Resolved,Fixed,3.10.0,Unassigned,Claus Ibsen,0,1,2021-04-22 16:23:35+00:00,2021-04-26 08:48:53+00:00,"customId=false is implied for <route id> so lets avoid emitting this when dumping to XML to keep the XML short and lean.


See screenshot at
https://twitter.com/davsclaus/status/1385235682029867009/photo/2",
0,CAMEL-16547,Bug,Major,None,3.10.0,"
None
",Resolved,Fixed,3.10.0,Andrea Tarocchi,Andrea Tarocchi,0,2,2021-04-22 14:36:08+00:00,2021-05-02 16:35:40+00:00,The camel-kamelet component don't bind properties in the form described here: https://github.com/apache/camel/blob/ba4385cea52f8d2abde8a58c488dada82872959c/components/camel-kamelet/src/main/java/org/apache/camel/component/kamelet/KameletComponent.java#L153-L159,"davsclaus:1619415555:2021-04-26T13:39:15.635+0000:1619415555:2021-04-26T13:39:15.635+0000:I took a look as I was curious if the component had options for those at all, and then found out its maybe a copy/paste bug - here is a PR
https://github.com/apache/camel/pull/5466
valdar:1619417961:2021-04-26T14:19:21.709+0000:1619417961:2021-04-26T14:19:21.709+0000:Thanks a lot [~davsclaus]!

I am not sure that is the only problem, at least we would need some tests around it...
davsclaus:1619424321:2021-04-26T16:05:21.735+0000:1619424321:2021-04-26T16:05:21.735+0000:Tried the kamelet example and added this to the application.properties


camel.component.kamelet.template-properties[myTemplate].myPeriod = 1s

And that option overwrote the default in the template, so it uses 1 second instead of 3.
Before that was not the case.

Yes unit tests is needed but wanted a quick glimpse first
davsclaus:1619427830:2021-04-26T17:03:50.126+0000:1619427830:2021-04-26T17:03:50.126+0000:Andrea, you are much welcome to use the PR if you can and add unit tests etc to come up with a completion fix
valdar:1619428607:2021-04-26T17:16:47.611+0000:1619428607:2021-04-26T17:16:47.611+0000:I will do!"
0,CAMEL-16546,New Feature,Major,None,3.10.0,"
None
",Resolved,Fixed,3.10.0,Andrea Cosentino,Andrea Cosentino,0,1,2021-04-22 13:34:43+00:00,2021-04-23 05:18:37+00:00,No Desc,
0,CAMEL-16545,Improvement,Major,None,3.10.0,"
None
",Resolved,Fixed,3.10.0,Claus Ibsen,Claus Ibsen,0,1,2021-04-22 13:32:01+00:00,2021-04-22 13:55:26+00:00,"Somehow JAXB marshal to xml outputs the XML with empty lines for after each line, so the output is twice as long.",
0,CAMEL-16544,New Feature,Major,None,3.10.0,"
None
",Resolved,Fixed,3.10.0,Andrea Cosentino,Andrea Cosentino,0,1,2021-04-22 13:07:32+00:00,2021-04-22 13:34:03+00:00,"For the moment we can do that as producer operation, later as scheduled poll consumer.",
0,CAMEL-16543,Test,Minor,None,3.10.0,"
None
",Resolved,Fixed,3.10.0,Alex Dettinger,Alex Dettinger,0,1,2021-04-22 09:26:07+00:00,2021-04-22 11:03:11+00:00,No Desc,
0,CAMEL-16542,Improvement,Major,None,3.11.0,"
None
",Resolved,Fixed,3.11.0,Andrea Cosentino,Andrea Cosentino,1,2,2021-04-22 07:30:45+00:00,2021-06-10 04:15:33+00:00,No Desc,"paul@search-solutions.net:1620368914:2021-05-07T14:28:34.035+0000:1620368914:2021-05-07T14:28:34.035+0000:Thanks for this ticket [~acosentino] .

I'd like to list the following specific issues with the camel-solr component (based on an issue I encountered recently on a camel-solr 3.7.3 implementation):
 # Ability to specify the soTimeout and connectionTimeout on ""solrCloud"" uri in the same way as they are available on the ""solr"" uri (using CloudSolrClient.Builder.withConnectionTimeout, withSocketTimeout); probably HttpClient and ResponseParser are also good options to add to the builder (note: the options are 'available' (as in not raising an error) on the solrCloud endpoint, but are silently ignored and overridden by the standard Solr client parameters)
 # Ability to specify solr parameters (as with org.apache.camel.component.solr.SolrConstants.PARAM) on the ACTION.COMMIT of the OPERATION_COMMIT and OPERATION_SOFT_COMMIT: parameters waitFlush and waitSearcher on the updateRequest.setAction method are currently hard-coded; but - as with other operations - why not allow to set all parameters via updateRequest.setParam method; This is applicable to all operations not using insert method (as the insert method already allows this function for most use cases)
 # Currently, the (default) collection is bound to the solrCloud endpoint; it should however be possible to specify the collection on exchange level as exchange header parameter
 # Documentation has in general some room for improvement

Let me know when further input/help is useful.
acosentino:1620369180:2021-05-07T14:33:00.773+0000:1620369180:2021-05-07T14:33:00.773+0000:[~paul@search-solutions.net] thanks for commenting.

If you have time and will, you're welcome to open PR on the component but also for updating the documentation. 

This and the Lucene component need some love. 

You're welcome to help, I'll work on this with 3.11 as target, we can split the work if you have time. We can also create sub tasks
paul@search-solutions.net:1620894420:2021-05-13T16:27:00.091+0000:1621325404:2021-05-18T16:10:04.686+0000:Hi Andrea

Lot's of will and love to give... however time is short...
 Nevertheless, I'll see what I can do, starting with Solr (test-infra and
 component).
 Let's keep in touch: when you're ready to dig in, we'll see where we are at
 that moment...

------------------------------

Kind regards,

 

 
acosentino:1621464572:2021-05-20T06:49:32.501+0000:1621464572:2021-05-20T06:49:32.501+0000:If you have some time you may work on the test-infra side and maybe add a basic test in the component after that.
paul@search-solutions.net:1621465860:2021-05-20T07:11:00.056+0000:1621465860:2021-05-20T07:11:00.056+0000:Short status update:
test-infra should be ok (i.e. I have solr running in the docker container)
working now on solr component (quite a bit of refactoring - trying to keep
api as-is)
left the code on an issue with generated piece... will try to dive into
that next week
what is the timeline you have in mind when you mention 'with 3.11 as target'



On Thu, 20 May 2021 at 08:50, Andrea Cosentino (Jira) <jira@apache.org>


acosentino:1621567276:2021-05-21T11:21:16.845+0000:1621567276:2021-05-21T11:21:16.845+0000:The next 3.11.0 release should be middle/end of June.
paul@search-solutions.net:1622516160:2021-06-01T10:56:00.069+0000:1622516160:2021-06-01T10:56:00.069+0000:Hi Andrea,
PR #5613 generated.
Can you review and let me know your thoughts?
Still work to be done on tests for the new solr test-infra.
I will try to find some time in the coming days...



paul@search-solutions.net:1623241080:2021-06-09T20:18:00.057+0000:1623241080:2021-06-09T20:18:00.057+0000:Hi Andrea,
PR #5641 generated with some refactoring.


------------------------------


Kind regards,

Paul Blanchaert <https://www.search-solutions.net/p/paul>

www.search-solutions.net

Tel: +32 497 05.01.03

[image: View my profile on LinkedIn]
<http://be.linkedin.com/in/paulblanchaert>view
<http://be.linkedin.com/in/paulblanchaert> or connect
<https://www.linkedin.com/inviteFromProfile?from=profile&key=682342&firstName=Paul&lastName=Blanchaert>

------------------------------

Please consider the environment before printing this e-mail.

This message is explicitly subject to the conditions of the e-mail
disclaimer, available via the following link: mail-disclaimer
<https://www.search-solutions.net/mail-disclaimer>. If you are unable to
consult this e-mail disclaimer, please notify the sender at once.


On Tue, 1 Jun 2021 at 12:54, Paul Blanchaert <paul@search-solutions.net>

"
0,CAMEL-16541,Improvement,Major,None,3.10.0,"
None
",Resolved,Fixed,3.10.0,Andrea Cosentino,Andrea Cosentino,0,1,2021-04-22 07:30:10+00:00,2021-04-29 07:33:38+00:00,"Today we need to invoke a second producer operation after anything we do.


With the option we can do the commit directly",
0,CAMEL-16540,New Feature,Major,None,3.10.0,"
None
",Resolved,Fixed,3.10.0,Andrea Cosentino,Dillon Gilmore,0,2,2021-04-21 20:47:54+00:00,2021-04-26 07:06:35+00:00,"Problem


splunk-hec always sends the message body and headers under the static json keys ""body"" and ""headers"" respectively.


Solution


Include an option that defaults to the current behavior of sending the body and the headers.


These new options `bodyOnly` and `headersOnly` should send either the body or the headers. If both are true then prefer headers. This also removed the need to create a map with static keys.


Rationale



Including the headers makes searching more tedious and our queries must always be prefixed with `body.`.
Splunk charged based off of the amount of data you index. Indexing data you don't need can add up an unnecessary bill.","iridian-ks:1619009303:2021-04-21T20:48:23.341+0000:1619009303:2021-04-21T20:48:23.341+0000:I will be creating a PR shortly.
davsclaus:1619038216:2021-04-22T04:50:16.755+0000:1619038216:2021-04-22T04:50:16.755+0000:I would like to add some interface that allows to plugin a custom implementation of what data to send. Then we can have a default implementation that can do the body only, headers only, or all as today.

Since you pay per data, then users may want to plugin a custom implementation to filter out some headers (eg only header with keys starting with foo*), and only include exactly what they want. "
0,CAMEL-16539,New Feature,Minor,None,3.10.0,"
None
",Resolved,Fixed,3.10.0,Unassigned,Dillon Gilmore,0,1,2021-04-21 20:43:24+00:00,2021-04-27 10:16:26+00:00,"Problem


Right now, when using Camel to process logs into Splunk via the splunk-hec, it includes the message body and the message headers.


In most cases, we only need the body.


Solution


Include an option to include only the body or the headers.


Rationale


1. For JSON payloads, having to always include the body when you never use the headers is tedious and ugly.


2. Splunk charges based off of the amount of data you feed in. Reducing the 10+ headers and body keys can shave off some amount of gigabytes in the long-term.",
0,CAMEL-16538,Bug,Minor,3.9.0,None,"
None
",Closed,Not A Problem,3.9.0,Unassigned,nizar.ben.mansour,0,2,2021-04-21 12:56:16+00:00,2021-04-22 08:25:01+00:00,"I have made a simple blueprint application that uses Apache Camel 3.9.0 deployed on karaf 4.2.11.


 




  <dataFormats> <jacksonxml id=""jacksonxml"" /> </dataFormats>
<route id=""myRoute1""> <from uri=""activemq:queue:FROM_Q1"" /> <marshal> <custom ref=""jacksonxml""></custom> </marshal> <bean ref=""bean1"" method=""m1"" /> <log message=""RECEIVE MESSAGE FROM QUEUE  ${body}"" loggingLevel=""INFO"" />
 </route>




 


Exception happened:




021-04-21T14:50:24,235 | ERROR | Blueprint Event Dispatcher: 1 | BlueprintCamelContext            | 169 - org.apache.camel.karaf.camel-blueprint - 3.9.0 | Error occurred during starting CamelContext: groupManagerContext021-04-21T14:50:24,235 | ERROR | Blueprint Event Dispatcher: 1 | BlueprintCamelContext            | 169 - org.apache.camel.karaf.camel-blueprint - 3.9.0 | Error occurred during starting CamelContext: groupManagerContextjava.lang.IllegalArgumentException: Data format 'jacksonxml' could not be created. Ensure that the data format is valid and the associated Camel component is present on the classpath at org.apache.camel.reifier.dataformat.DataFormatReifier.createDataFormat(DataFormatReifier.java:284) ~[!/:3.9.0] at org.apache.camel.impl.DefaultModelReifierFactory.createDataFormat(DefaultModelReifierFactory.java:54) ~[!/:3.9.0] at org.apache.camel.impl.DefaultCamelContext.bindDataFormats(DefaultCamelContext.java:596) ~[!/:3.9.0] at org.apache.camel.impl.engine.AbstractCamelContext.doInit(AbstractCamelContext.java:2744) ~[!/:3.9.0] at org.apache.camel.support.service.BaseService.init(BaseService.java:83) ~[!/:3.9.0] at org.apache.camel.impl.engine.AbstractCamelContext.init(AbstractCamelContext.java:2490) ~[!/:3.9.0] at org.apache.camel.support.service.BaseService.start(BaseService.java:111) ~[!/:3.9.0] at org.apache.camel.impl.engine.AbstractCamelContext.start(AbstractCamelContext.java:2507) ~[!/:3.9.0] at org.apache.camel.impl.DefaultCamelContext.start(DefaultCamelContext.java:174) ~[!/:3.9.0] at org.apache.camel.blueprint.BlueprintCamelContext.start(BlueprintCamelContext.java:241) ~[!/:3.9.0] at org.apache.camel.blueprint.BlueprintCamelContext.maybeStart(BlueprintCamelContext.java:283) ~[!/:3.9.0] at org.apache.camel.blueprint.BlueprintCamelContext.blueprintEvent(BlueprintCamelContext.java:188) [!/:3.9.0] at org.apache.aries.blueprint.container.BlueprintEventDispatcher$3.call(BlueprintEventDispatcher.java:197) [!/:1.10.3] at org.apache.aries.blueprint.container.BlueprintEventDispatcher$3.call(BlueprintEventDispatcher.java:195) [!/:1.10.3] at java.util.concurrent.FutureTask.run(FutureTask.java:266) [?:1.8.0_191] at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511) [?:1.8.0_191] at java.util.concurrent.FutureTask.run(FutureTask.java:266) [?:1.8.0_191] at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511) [?:1.8.0_191] at java.util.concurrent.FutureTask.run(FutureTask.java:266) [?:1.8.0_191] at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(ScheduledThreadPoolExecutor.java:180) [?:1.8.0_191] at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:293) [?:1.8.0_191] at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149) [?:1.8.0_191] at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624) [?:1.8.0_191] at java.lang.Thread.run(Thread.java:748) [?:1.8.0_191]2021-04-21T14:50:24,239 | INFO  | features-2-thread-1 | FeaturesServiceImpl              | 13 - org.apache.karaf.features.core - 4.2.11 | Done.



 


I have attached a simple application that simulate the same issue on Karaf 4.2.11:


To reproduce the issue:


feature:repo-add mvn:com.test.karaftest/simplekarafapp/1.0/xml/features


feature:install -v myfeature","davsclaus:1619046203:2021-04-22T07:03:23.265+0000:1619046203:2021-04-22T07:03:23.265+0000:Can you attach the sample as zip file
davsclaus:1619046350:2021-04-22T07:05:50.236+0000:1619046350:2021-04-22T07:05:50.236+0000:And you have installed camel-jacksonxml feature 
nizar.ben.mansour@gmail.com:1619051069:2021-04-22T08:24:29.251+0000:1619051069:2021-04-22T08:24:29.251+0000:Missing the add of camel-jacksonxml feature
nizar.ben.mansour@gmail.com:1619051101:2021-04-22T08:25:01.923+0000:1619051101:2021-04-22T08:25:01.923+0000:[~davsclaus]: Thanks .Issue is resovled .Just need to add camel-jacksonxml feature"
0,CAMEL-16537,Improvement,Major,None,3.11.0,"
None
",Resolved,Fixed,3.11.0,Matej Melko,Matej Melko,0,1,2021-04-21 12:19:22+00:00,2021-06-17 12:16:04+00:00,"Connection to the mongoDB client currently requires to define connectionBean, that might be problematic in specific use-cases such as kamelet bindings.


An option for for connecting using credentials or connection string would be handy.",mmelko:1620878543:2021-05-13T12:02:23.715+0000:1620878543:2021-05-13T12:02:23.715+0000:PR: https://github.com/apache/camel/pull/5556
0,CAMEL-16536,Bug,Minor,3.9.0,None,"
None
",Resolved,Fixed,3.10.0,Zineb Bendhiba,Zineb Bendhiba,0,1,2021-04-21 09:00:47+00:00,2021-04-21 12:15:07+00:00,No Desc,
0,CAMEL-16535,New Feature,Major,None,3.10.0,"
None
",Resolved,Fixed,3.10.0,Claus Ibsen,Claus Ibsen,0,1,2021-04-21 07:05:36+00:00,2021-04-21 12:21:06+00:00,"You may want this to help diagnose route issues or the likes, where you want an XML representation of the route structures that Camel has parsed and build as its model.


Especially when you now can use many different DSLs","davsclaus:1618978866:2021-04-21T12:21:06.255+0000:1618978866:2021-04-21T12:21:06.255+0000:You can now configure

camel.main.dump-routes = true"
0,CAMEL-16534,Bug,Major,3.9.0,3.10.0,"
None
",Resolved,Fixed,3.10.0,Claus Ibsen,Claus Ibsen,0,2,2021-04-20 12:23:50+00:00,2021-04-21 07:01:50+00:00,"Based on user issue
https://github.com/apache/camel/commit/fb47a92c17d7da2b7a6a5cf162a9a550cfff3ddc",
0,CAMEL-16533,Improvement,Major,None,"2.25.4, 3.10.0","
None
",Resolved,Fixed,"2.25.4, 3.10.0",Claus Ibsen,Claus Ibsen,0,1,2021-04-20 10:58:01+00:00,2021-04-20 11:47:59+00:00,We have some docs for the EIPs with elements which we can get injected into the XSD generated.,davsclaus:1618890479:2021-04-20T11:47:59.261+0000:1618890479:2021-04-20T11:47:59.261+0000:Backporting to 2.25.x so Camel 2.x also has this as there are some elements that are deprecated that would be easier for users to spot. And also they get more docs in the XSD.
0,CAMEL-16532,Bug,Minor,"2.24.2, 3.9.0",3.11.0,"
None
",Resolved,Fixed,3.11.0,Freeman Yue Fang,Manuel Shenavai,0,5,2021-04-20 06:24:18+00:00,2021-06-08 18:33:34+00:00,"This issue is related to CAMEL-10914.


Desscription:
 Route1 - CXFConsumer with endpoint address /test is already running
 Route2 - Gets started with CXFConsumer with same endpoint /test


The expected behavior: Route2 startup fails (endpoint already registered on address). Route1 keeps running.


Expected error on Route2 (endpoint already registered on address):
https://github.com/apache/cxf/blob/master/rt/bindings/soap/src/main/java/org/apache/cxf/binding/soap/SoapBindingFactory.java#L918


Due to the change in CAMEL-10914, server.destroy() will be called after failed startup:
https://github.com/tadayosi/camel/commit/6d31d169dc17138ed02ad1164a4b2209729677fc#diff-174b6ca7cb178d3dc464aa9355d148d95fc0a3ad3f7edb60f0293fac988d3e05R100


And it will eventually unregister the route:
https://github.com/apache/cxf/blob/master/core/src/main/java/org/apache/cxf/endpoint/ServerImpl.java#L191


Observed behavior:
 After failed startup of Route2, Route1 is not registered anymore (HTTP 404 when trying to call /test). I could not reproduce this with embedded Jetty, but we experience this with tomcat on production.


Do you have any suggestion how this could be reproduced in a test using tomcat? Is there a simple way to replace jetty with tomcat?","davsclaus:1618871352:2021-04-20T06:29:12.908+0000:1618871352:2021-04-20T06:29:12.908+0000:2.24.x is EOL and not supported. You can try upgrade to latest 2.x.
And 2.x is not active maintained so we wont prioritize this unless someone have a reproducer for latest 3.x release.


mash-sap:1618871674:2021-04-20T06:34:34.943+0000:1618871674:2021-04-20T06:34:34.943+0000:Reproducing this with embedded Jetty seems not possible. I hope someone has a idea how to create a CXF test using tomcat. Once we got that, we can probably reproduce it on 3.x as well.
davsclaus:1618871815:2021-04-20T06:36:55.029+0000:1618871815:2021-04-20T06:36:55.029+0000:You can build a sample application and put it on github with a readme file with instructions how to build and deploy to an existing tomcat. 
Then users can take a look and try to help you.


njiang:1618892201:2021-04-20T12:16:41.095+0000:1618892201:2021-04-20T12:16:41.095+0000:For the tomcat user case, I'm not sure you are still using CxfServlet to start the CXF bus directly. 

There are maybe some side effect when calling the destroy method with CxfServlet. 
mash-sap:1619007009:2021-04-21T20:10:09.967+0000:1619007009:2021-04-21T20:10:09.967+0000:Please find a sample project to reproduce the problem here: [https://github.com/mash-sap/CAMEL-16532]
tadayosi:1619035967:2021-04-22T04:12:47.844+0000:1619035967:2021-04-22T04:12:47.844+0000:As I said in CAMEL-10914, having an identical CXF endpoint at multiple route {{from}} steps sounds like a application configuration bug, rather than a bug in Camel. Even if somehow the issue described here is cleared, it should fail to load eventually.
mash-sap:1619036912:2021-04-22T04:28:32.475+0000:1619038458:2021-04-22T04:54:18.748+0000:[~tadayosi] you are right. The expected behavior is, that Route2 can never be started and Route1 stays reachable.

Current behavior is, that Route1 gets unregistered due to failed startup from Route2 which then allows Route2 to be started on the second start.
mash-sap:1619049411:2021-04-22T07:56:51.435+0000:1619160935:2021-04-23T14:55:35.389+0000:I created a pull request: [https://github.com/apache/camel/pull/5453]

[https://github.com/apache/camel/pull/5454]
ffang:1619167624:2021-04-23T16:47:04.704+0000:1619167624:2021-04-23T16:47:04.704+0000:Hi [~mash-sap],

Sounds like a bug, I will take a close look.

Freeman
mash-sap:1619685626:2021-04-29T16:40:26.653+0000:1619685626:2021-04-29T16:40:26.653+0000:Thanks for looking into it, [~ffang]!
ffang:1619782466:2021-04-30T19:34:26.037+0000:1619782583:2021-04-30T19:36:23.061+0000:Per the discussion in [CXF dev|http://cxf.547215.n5.nabble.com/CXF-endpoint-unexpectedly-unregistered-td5807854.html], we fixed this at CXF side.

I'd keep this ticket open until we update to next cxf version which contains the fix in camel

Thanks all involved!

Freeman
mash-sap:1619996669:2021-05-03T07:04:29.030+0000:1619996669:2021-05-03T07:04:29.030+0000:Thank you [~ffang]!
davsclaus:1620263183:2021-05-06T09:06:23.879+0000:1620263183:2021-05-06T09:06:23.879+0000:[~ffang] do you know if a new CXF release is around the corner?
ffang:1620273736:2021-05-06T12:02:16.708+0000:1620273736:2021-05-06T12:02:16.708+0000:Hi [~davsclaus],

No, I don't think so. There couldn't be a new CXF release at least in May.(Last CXF release was in the middle of Mar, normal internal between releases is around 3 months)

Freeman
davsclaus:1622937958:2021-06-06T08:05:58.122+0000:1622937958:2021-06-06T08:05:58.122+0000:CXF 3.4.4 is on the way
ffang:1623146615:2021-06-08T18:03:35.336+0000:1623146615:2021-06-08T18:03:35.336+0000:CAMEL-16697 tracks CXF 3.4.4 upgrade"
0,CAMEL-16531,Dependency upgrade,Major,None,3.10.0,"
None
",Resolved,Fixed,3.10.0,Unassigned,Claus Ibsen,0,3,2021-04-20 06:22:09+00:00,2021-05-07 12:34:58+00:00,"Kafka 2.8 has been released and it has early access to not using zookeeper.


It may take a while for testcontainers and others to support this before we can upgrade.","Federico Mariani:1620099872:2021-05-04T11:44:32.479+0000:1620099872:2021-05-04T11:44:32.479+0000:Hi, I tried to execute camel-kafka tests on kafka 2.8 without zookeeper, but I had no luck, IT tests fails with _org.apache.kafka.common.errors.TimeoutException: Topic bar not present in metadata after 60000 ms.,_ though from kafka container logs I can see that topic are created, but I'm not a kafka expert. This is the branch [https://github.com/croway/camel/tree/kafka-no-zookeeper] and compare with main https://github.com/apache/camel/compare/main...Croway:kafka-no-zookeeper?expand=1
acosentino:1620338008:2021-05-07T05:53:28.731+0000:1620338008:2021-05-07T05:53:28.731+0000:For the moment I've updated to the plain version, still with Zookeeper.
davsclaus:1620362098:2021-05-07T12:34:58.858+0000:1620362098:2021-05-07T12:34:58.858+0000:This is fine. From Camel POV it doesnt really matter if Kafka Server runs with ZK or not."
0,CAMEL-16530,Bug,Major,3.9.0,"3.7.4, 3.10.0","
None
",Resolved,Fixed,"3.7.4, 3.10.0",Andrea Cosentino,Gustavo Maurizio,0,2,2021-04-19 20:13:13+00:00,2021-09-30 10:34:31+00:00,"when attempting to use AWS2 S3 resources via a proxy host and port, the configuration specified in the application.properties file is ignored. You can enter anything there as


camel.component.aws2-s3.proxy-host=url.of.my.proxy
camel.component.aws2-s3.proxy-port=8099


 


but it is ignored and starting the route fails with SSL error


[ERROR] Failed to execute goal org.apache.camel:camel-maven-plugin:3.9.0:run (default-cli) on project camel39-main: null: MojoExecutionException: InvocationTargetException: Failed to start route route1 because of null: Unable to execute HTTP request: Connection reset -> [Help 1]","gmaurizio:1618834838:2021-04-19T20:20:38.840+0000:1618834838:2021-04-19T20:20:38.840+0000:I performed an additional test from my home computer (that does not need proxy).

When I use the application.properties to set the following values:

camel.component.aws2-s3.use-default-credentials-provider=true

camel.component.aws2-s3.autowired-enabled=true

works fine! (again there is no proxy there)

If I add 

camel.component.aws2-s3.proxy-host=myproxy.com

camel.component.aws2-s3.proxy-port=8099

 

they are correctly read at start, but nothing changes, and of course the myproxy.com does not exist, so it should at least give a DNS or timeout error.

From my work computer (that DOES need the proxy), no matter how i load the host (host name or IP), it is ignored as well.
acosentino:1618837095:2021-04-19T20:58:15.914+0000:1618837095:2021-04-19T20:58:15.914+0000:Can you please show your complete configuration while using the proxy? Thanks.
gmaurizio:1618838709:2021-04-19T21:25:09.745+0000:1618838709:2021-04-19T21:25:09.745+0000:application.properties from resources
{code:java}

# properties used in the route
bucketName=bucketnameedited
camel.component.aws2-s3.useDefaultCredentialsProvider=true
# camel.component.aws2-s3.trustAllCertificates=true
camel.component.aws2-s3.proxy-host=myproxy.com
camel.component.aws2-s3.proxy-port=8099

{code}
route below (from java main with routeloader defined in pom.xml. Dynamically loaded
{code:java}
<routes xmlns=""http://camel.apache.org/schema/spring""> 
  <route> <from uri=""aws2-s3://{{bucketName}}""/> 
  <log message=""FILE STORED ${headers}""/> </route> 
</routes>
{code}
gmaurizio:1618838877:2021-04-19T21:27:57.330+0000:1618838877:2021-04-19T21:27:57.330+0000:MyApplication.java
{code:java}
package com.example.camel;

import org.apache.camel.main.Main;

public final class MyApplication {

    private MyApplication() {
    }

    public static void main(String[] args) throws Exception {
        Main main = new Main();
        main.run(args);
    }

}

{code}
gmaurizio:1618839016:2021-04-19T21:30:16.665+0000:1618839016:2021-04-19T21:30:16.665+0000:I will appreciate, as a possible band-aid while we figure this out, if you can post an example of a java class file that defines an S3 client (like the one used with #s3client) that works for the aws2-s3 component. That might help bypass the defaults built. It seems that for some mysterious reason the proxy part is not being attached to the autowired client.
acosentino:1618871053:2021-04-20T06:24:13.773+0000:1618871053:2021-04-20T06:24:13.773+0000:The autowired client is a client set in the registry. In that case, is up to you to set the proxy setting in the client instance you're going to use in the route.

If you want to use an autowired client and then specify the proxy host and proxy port it won't work, because camel component will pick up the client instance from the registry and ignore the configuration part.

By the way I'll check.
acosentino:1618871626:2021-04-20T06:33:46.078+0000:1618871626:2021-04-20T06:33:46.078+0000:Ok, I spotted a little bug.

I fix it today.

With a local fix I'm now getting correctly: Caused by: org.apache.http.conn.ConnectTimeoutException: Connect to myproxy.com:8099 [myproxy.com/52.219.112.235] failed: connect timed out
acosentino:1618871721:2021-04-20T06:35:21.977+0000:1618871721:2021-04-20T06:35:21.977+0000:As a workaround, follow the configuration done here:

[https://github.com/apache/camel/blob/master/components/camel-aws/camel-aws2-s3/src/main/java/org/apache/camel/component/aws2/s3/client/impl/AWS2S3ClientIAMOptimizedImpl.java#L60]

Add the proxy stuff and place the client into registry. With the autowired it should be picked up automatically
gmaurizio:1618894486:2021-04-20T12:54:46.092+0000:1618894486:2021-04-20T12:54:46.092+0000:Grazie Andrea! i added the AWS2S3ClientIAM... with the mod and it compiled and executed beautifully. 

I wonder if there are other AWS clients that might have the same challenge? When will these fixes be incorporated, can I assume the June 3.11 release?
acosentino:1618894837:2021-04-20T13:00:37.371+0000:1618894837:2021-04-20T13:00:37.371+0000:I updated all the components using useDefaultCredentialsProvider (currently s3, sns, sqs and kinesis). For 3.10 I'm working on adding the useDefaultCredentialsProvider on all the aws components. The fix should be available for 3.10. We would like to release a 3.10 release in May, before the 3.11 LTS in June. Thanks for feedback and for reporting the issue."
0,CAMEL-16499,Improvement,Major,None,3.x,"
None
",Resolved,Fixed,3.x,David Jencks,Claus Ibsen,0,4,2021-04-14 06:58:25+00:00,2021-07-29 07:25:23+00:00,"We need a section on camel-website root readme page, that talks about how you do links between pages on the website.


The xref: syntax is confusing and not intuitive how you link between: eips, components, user-manual, fag, pages between sub-projects (eg camel -> camel-k) and so forth.


For example in kamelet-eip.adoc as EIP doc, I could not link with




== More details

- xref:components::kamelet-component.adoc[Kamelet component]
- xref:manual::route-tepmplate.adoc[Route Template]
- xref:latest@camel-k:ROOT::kamelets-user.adoc[Kamelets user guide]

We also provided a small https://github.com/apache/camel-examples/tree/master/examples/kamelet[Kamelet example].




I tried 10 different things for the last two bullets, and looked other xref links, and nothing kinda worked. 


So what you end up doing is NOT to have xref links at all.","djencks:1627502436:2021-07-29T04:00:36.229+0000:1627502436:2021-07-29T04:00:36.229+0000:I wrote something up on this, [https://github.com/apache/camel-website/pull/608.] Comments?
acosentino:1627504387:2021-07-29T04:33:07.112+0000:1627504387:2021-07-29T04:33:07.112+0000:Thanks for finding the time to write it. Looks good to me.
zregvart:1627514723:2021-07-29T07:25:23.071+0000:1627514723:2021-07-29T07:25:23.071+0000:Big thanks to [~djencks] for doing this!"
0,CAMEL-16498,Bug,Major,3.9.0,3.10.0,"
None
",Resolved,Fixed,3.10.0,Andrea Cosentino,Andrea Cosentino,0,1,2021-04-14 06:41:29+00:00,2021-04-14 09:57:18+00:00,"Caused by: java.lang.NullPointerExceptionCaused by: java.lang.NullPointerException at org.apache.camel.component.azure.storage.queue.QueueConsumer.<init>(QueueConsumer.java:54) at org.apache.camel.component.azure.storage.queue.QueueEndpoint.createConsumer(QueueEndpoint.java:59) at org.apache.camel.impl.engine.DefaultRoute.gatherRootServices(DefaultRoute.java:593) at org.apache.camel.impl.engine.DefaultRoute.gatherServices(DefaultRoute.java:577) at org.apache.camel.impl.engine.DefaultRoute.initializeServices(DefaultRoute.java:162) at org.apache.camel.impl.engine.RouteService.doSetup(RouteService.java:151) at org.apache.camel.impl.engine.RouteService.setUp(RouteService.java:130) ... 81 more


 


It is enough to try the QueueConsumerIT integration test",
0,CAMEL-16497,Improvement,Minor,None,3.10.0,"
None
",Resolved,Fixed,3.10.0,Claus Ibsen,Claus Ibsen,0,1,2021-04-14 05:24:07+00:00,2021-04-14 13:18:03+00:00,"The UUID generator is very long, so you have auto generated route IDs like


07:21:55.627 [org.apache.camel.example.MyApplication.main()] INFO  o.a.c.i.engine.AbstractCamelContext - Routes startup summary (total:4 started:4)
07:21:55.628 [org.apache.camel.example.MyApplication.main()] INFO  o.a.c.i.engine.AbstractCamelContext -     Started route1 (kamelet://myTemplate)
07:21:55.628 [org.apache.camel.example.MyApplication.main()] INFO  o.a.c.i.engine.AbstractCamelContext -     Started route2 (kamelet://myTemplate)
07:21:55.628 [org.apache.camel.example.MyApplication.main()] INFO  o.a.c.i.engine.AbstractCamelContext -     Started myTemplate-47BC753EF1955F8-0000000000000000 (timer://myKamelet1)
07:21:55.628 [org.apache.camel.example.MyApplication.main()] INFO  o.a.c.i.engine.AbstractCamelContext -     Started myTemplate-47BC753EF1955F8-0000000000000001 (timer://myKamelet2)


We can probably do like we do for regular routes, and have its own running counter, so they are


myTemplate-1
myTemplate-2


And so on.",
0,CAMEL-16496,Bug,Minor,3.9.0,None,"
None
",Resolved,Cannot Reproduce,3.x,Unassigned,Zineb Bendhiba,0,3,2021-04-13 12:32:51+00:00,2021-11-14 10:49:05+00:00,the operation delete in the DigitalOceanBlockStoragesProducer can't be performed because of a bug in the used API.  The API uses data instead of pathParams.,"davsclaus:1618435816:2021-04-15T05:30:16.569+0000:1618435816:2021-04-15T05:30:16.569+0000:Zineb are you working on fixing this?
chardahe@redhat.com:1618449607:2021-04-15T09:20:07.852+0000:1618449607:2021-04-15T09:20:07.852+0000:[~zbendhiba], are you working on fix? I'll work on it if you don't.
zbendhiba:1618451034:2021-04-15T09:43:54.276+0000:1618451034:2021-04-15T09:43:54.276+0000:No I'm not. [~chardahe@redhat.com] : you can try to fix it, not sure it's Camel related. Let me know!
davsclaus:1636858133:2021-11-14T10:48:53.447+0000:1636858133:2021-11-14T10:48:53.447+0000:The delete operation uses headers to know what to delete,  either ID for volumeId, or NAME + REGION for volume name / region"
0,CAMEL-16495,Task,Major,None,3.10.0,"
None
",Resolved,Fixed,3.10.0,Andrea Cosentino,Andrea Cosentino,0,1,2021-04-13 11:25:50+00:00,2021-04-13 12:56:13+00:00,No Desc,
0,CAMEL-16494,Improvement,Minor,3.7.3,3.10.0,"
None
",Resolved,Fixed,3.10.0,Unassigned,Valeriy Ak,0,2,2021-04-13 09:14:29+00:00,2021-04-22 07:01:34+00:00,"After camel context failed to start with VetoCamelContextStartException, it never can be started again.


It happens because AbstractCamelContext.init() method checks vetoed is not null.  This method throw RuntimeException  (even if rethrowException = false, because called fail(vetoed)).


Vetoed field is cleaned in method doStartContext only.


 AbstractCamelContext code:




init(); //<--- this method throws RuntimeException when vetoed != null
try (AutoCloseable ignored = doLifecycleChange()) {
    status = STARTING;
    LOG.trace(""Starting service: {}"", this);
    doStart();  //<-- this method sets vetoed == null



 


Example for reproduce:




import org.apache.camel.CamelContext;
import org.apache.camel.VetoCamelContextStartException;
import org.apache.camel.impl.DefaultCamelContext;
import org.apache.camel.support.LifecycleStrategySupport;

public class CamelContextVetoExceptionBug {
    public static void main(String[] args) {
        CamelContext context = new DefaultCamelContext();

        boolean[] needThrow = new boolean[]{true};
        context.addLifecycleStrategy(new LifecycleStrategySupport() {
            @Override
            public void onContextStarting(CamelContext context) throws VetoCamelContextStartException {
                if (needThrow[0]) {
                    needThrow[0] = false;
                    throw new VetoCamelContextStartException(""Veto onContextStarting"", context, false);
                }
            }
        });
        context.start();
        System.out.println(""Start failed without rethrow: veto="" + context.isVetoStarted());


        try {
            context.start();
        } catch (Exception e) {
            System.out.println(""Exception: veto="" + context.isVetoStarted());
        }
    }
} 



 


Expected behavior:



next context start does not thow RuntimeException
next context start - started context","davsclaus:1618377525:2021-04-14T13:18:45.877+0000:1618377525:2021-04-14T13:18:45.877+0000:Do you want to try to work on a fix for this? If so you are welcome to provide a PR with the unit test above, and the fix included.
akvel:1618406086:2021-04-14T21:14:46.258+0000:1618406086:2021-04-14T21:14:46.258+0000:[~davsclaus] sure, i think i can do it :) 
 
akvel:1619004604:2021-04-21T19:30:04.896+0000:1619004604:2021-04-21T19:30:04.896+0000:[~davsclaus] done - PR https://github.com/apache/camel/pull/5451"
0,CAMEL-16493,New Feature,Major,None,3.10.0,"
None
",Resolved,Fixed,3.10.0,Claus Ibsen,Claus Ibsen,0,2,2021-04-13 08:27:38+00:00,2022-03-18 09:03:29+00:00,"Having an EIP for Kamelet may allow us to better flow how routing is done, when the kamelet (route template) have multiple exit points.",
0,CAMEL-16492,Dependency upgrade,Minor,None,3.10.0,"
None
",Resolved,Fixed,3.10.0,Claus Ibsen,Claus Ibsen,0,1,2021-04-13 05:26:01+00:00,2021-04-14 14:45:10+00:00,There is a new patch release on the way,
0,CAMEL-16491,Improvement,Major,3.9.0,None,"
None
",Closed,Fixed,3.10.0,Zineb Bendhiba,Zineb Bendhiba,0,1,2021-04-12 16:07:54+00:00,2021-04-21 12:14:25+00:00,"this line is problematic :  https://github.com/apache/camel/blob/e3d5e5b7ea2cc8c1044b091fb7134e9bcabdbdf8/components/camel-digitalocean/src/main/java/org/apache/camel/component/digitalocean/producer/DigitalOceanBlockStoragesProducer.java#L142


 


It should return the first element of the list. there an java.lang.IndexOutOfBoundsException:","zbendhiba:1618965946:2021-04-21T08:45:46.572+0000:1618965946:2021-04-21T08:45:46.572+0000:the volume is the first element. [Doc and example |https://developers.digitalocean.com/documentation/v2/#retrieve-an-existing-block-storage-volume-by-name]

 

 

 "
0,CAMEL-16490,Bug,Major,3.9.0,3.10.0,"
None
",Resolved,Fixed,3.10.0,Luca Burgazzoli,Nicola Ferraro,0,1,2021-04-12 16:00:49+00:00,2022-01-24 08:17:18+00:00,"It was ""tod"" prior to 3.9, while not it's only recognized as ""to-d"". We may set an alias.


 


Was working:




# camel-k: language=yaml dependency=camel-log
- from:
    uri: ""timer:yaml""
    parameters:
      period: ""1000""
    steps:
      - tod: ""log:info""",
0,CAMEL-16489,Bug,Major,3.9.0,3.10.0,"
None
",Resolved,Fixed,3.10.0,Luca Burgazzoli,Nicola Ferraro,0,1,2021-04-12 14:50:37+00:00,2021-05-17 13:07:57+00:00,"Related to https://github.com/apache/camel-k/issues/2203


 


This does not seem to work in YAML DSL:


 




 - from:
    steps:
    - to:
        parameters:
          showHeaders: ""true""
        uri: ""log:info""
    uri: ""timer:tick""




 


Error:


 




[1] Caused by: java.lang.IllegalStateException: url must be set before setting properties
[1] 	at org.apache.camel.dsl.yaml.deserializers.ModelDeserializers$ToDefinitionDeserializer.setProperty(ModelDeserializers.java:14189)
[1] 	at org.apache.camel.dsl.yaml.deserializers.ModelDeserializers$ToDefinitionDeserializer.setProperty(ModelDeserializers.java:14141)
[1] 	at org.apache.camel.dsl.yaml.common.YamlDeserializerBase.setProperties(YamlDeserializerBase.java:103)
[1] 	at org.apache.camel.dsl.yaml.common.YamlDeserializerBase.construct(YamlDeserializerBase.java:51)
[1] 	at org.apache.camel.k.loader.yaml.YamlSourceLoaderDeserializerResolver$ToDeserializer.construct(YamlSourceLoaderDeserializerResolver.java:65)
[1] 	at org.apache.camel.dsl.yaml.common.YamlDeserializationContext$2.construct(YamlDeserializationContext.java:194)
[1] 	at org.apache.camel.dsl.yaml.deserializers.ProcessorDefinitionDeserializer.construct(ProcessorDefinitionDeserializer.java:36)
[1] 	at org.apache.camel.dsl.yaml.common.YamlDeserializationContext$1.construct(YamlDeserializationContext.java:152)
[1] 	at org.apache.camel.dsl.yaml.common.YamlDeserializerSupport.asType(YamlDeserializerSupport.java:290)
[1] 	at org.apache.camel.dsl.yaml.common.YamlDeserializerSupport.asCollection(YamlDeserializerSupport.java:268)
[1] 	at org.apache.camel.dsl.yaml.common.YamlDeserializerSupport.asFlatCollection(YamlDeserializerSupport.java:249)
[1] 	at org.apache.camel.dsl.yaml.common.YamlDeserializerSupport.asFlatList(YamlDeserializerSupport.java:223)
[1] 	at org.apache.camel.dsl.yaml.deserializers.RouteFromDefinitionDeserializer.setProperties(RouteFromDefinitionDeserializer.java:76)
[1] 	at org.apache.camel.dsl.yaml.deserializers.RouteFromDefinitionDeserializer.setProperties(RouteFromDefinitionDeserializer.java:36)
[1] 	at org.apache.camel.dsl.yaml.common.YamlDeserializerBase.construct(YamlDeserializerBase.java:51)
[1] 	at org.apache.camel.k.loader.yaml.YamlSourceLoaderDeserializerResolver$RouteFromDeserializer.construct(YamlSourceLoaderDeserializerResolver.java:57)
[1] 	at org.apache.camel.dsl.yaml.common.YamlDeserializationContext$2.construct(YamlDeserializationContext.java:194)
[1] 	at org.snakeyaml.engine.v2.constructor.BaseConstructor.constructObjectNoCheck(BaseConstructor.java:140)
[1] 	at org.snakeyaml.engine.v2.constructor.BaseConstructor.constructObject(BaseConstructor.java:128)
[1] 	at org.snakeyaml.engine.v2.constructor.BaseConstructor.constructSequenceStep2(BaseConstructor.java:206)
[1] 	at org.snakeyaml.engine.v2.constructor.BaseConstructor.constructSequence(BaseConstructor.java:199)
[1] 	at org.snakeyaml.engine.v2.constructor.StandardConstructor$ConstructYamlSeq.construct(StandardConstructor.java:340)
[1] 	at org.snakeyaml.engine.v2.constructor.BaseConstructor.constructObjectNoCheck(BaseConstructor.java:140)
[1] 	at org.snakeyaml.engine.v2.constructor.BaseConstructor.constructObject(BaseConstructor.java:128)
[1] 	at org.snakeyaml.engine.v2.constructor.BaseConstructor.construct(BaseConstructor.java:87)
[1] 	... 32 more 



 


Changing the order to this, fixes:




- from:
    uri: ""timer:tick""
    steps:
    - to:
        uri: ""log:info""
        parameters:
          showHeaders: ""true""",
0,CAMEL-16488,Task,Major,None,3.19.0,"
None
",Resolved,Fixed,3.19.0,Otavio Rodolfo Piske,Otavio Rodolfo Piske,0,2,2021-04-12 12:06:31+00:00,2022-09-07 13:15:19+00:00,Check if we can reduce test duration for camel-ftp by moving some of the tests to JUnit 5 nested classes.,"davsclaus:1662112332:2022-09-02T17:52:12.737+0000:1662112332:2022-09-02T17:52:12.737+0000:Did we not speedup ftp tests already?
orpiske:1662159668:2022-09-03T07:01:08.019+0000:1662159668:2022-09-03T07:01:08.019+0000:Not yet, [~davsclaus] . The first part - converting them to the test infra - was merged, but I still want to go through the tests and see if they can be optimized. I'll take a look soon.
orpiske:1662527719:2022-09-07T13:15:19.089+0000:1662527719:2022-09-07T13:15:19.089+0000:The tests were parallelized and the execution time (on my machine) decreased by about 50%."
0,CAMEL-16487,New Feature,Major,None,3.x,"
None
",Resolved,Won't Fix,3.x,Unassigned,Claus Ibsen,0,1,2021-04-12 10:21:24+00:00,2022-09-02 17:51:37+00:00,"We can either improve the seda component to have an correlation map with timeout and the likes (eg like camel-jms have).


But this component current behavior has been as it has been since Camel 1, where the requestor will wait for the reply.


What we need is an async correlation manager (like camel-jms).


So either we



change the SEDA implementation
add a new component



In the old days with JBI there was the camel-nmr component that has this strategy, but it was replaced with JMS as the solution as you have all of this out of box with JMS, and it came out of the box with ServiceMix",
0,CAMEL-16486,Improvement,Minor,3.9.0,None,"
None
",Resolved,Fixed,3.10.0,Unassigned,Pasquale Congiusti,0,2,2021-04-12 08:36:29+00:00,2021-05-05 16:04:06+00:00,"We are not providing the possibility to parse any ErrorHandlerBuilder which is not a ref:


https://github.com/apache/camel/blob/master/dsl/camel-yaml-dsl/camel-yaml-dsl-deserializers/src/main/java/org/apache/camel/dsl/yaml/deserializers/ErrorHandlerBuilderDeserializer.java#L35


We should extend it to be able to parse all expected ErrorHandlerBuilder properties.","squakez:1618187822:2021-04-12T08:37:02.951+0000:1618187822:2021-04-12T08:37:02.951+0000:FYI [~lburgazzoli], I will work on its fix.
squakez:1618380829:2021-04-14T14:13:49.930+0000:1618380829:2021-04-14T14:13:49.930+0000:I've seen that the definition of parsers is delegated to a maven plugin which is in charge to automatically build yaml parsers from model classes annotated as @XmlRootElement. The ErrorHandlers configuration are specifically set as @XmlTransient (ie, https://github.com/apache/camel/blob/master/core/camel-core-model/src/main/java/org/apache/camel/model/errorhandler/ErrorHandlerRefConfiguration.java#L21). I understand there must be some reason that I miss, however I wonder if that reason is still in place. If it's not, we could make the change and probably solve this issue just setting them with the @XmlRootElement annotation. With this solution (if possible) we'll keep a strong alignment between the model and the deserializer.

Otherwise the solution would be to manually parse the properties with ad-hoc builders (one for each different error handler). With this approach we may experience some compatibility problem when we change the ErrorHandler model definitions in the future though.

[~lburgazzoli], wdyt?
lb:1620077658:2021-05-04T05:34:18.343+0000:1620077658:2021-05-04T05:34:18.343+0000:As today, better to explicit list the missing classes to the maven plugin so it will generate the model, however we may need some manual handling in the ErrorHandlerBuilderDeserializer"
0,CAMEL-16485,Improvement,Major,3.9.0,,"
None
",Resolved,Information Provided,None,Unassigned,Dietrich Schulten,0,2,2021-04-12 07:05:39+00:00,2022-09-02 17:51:16+00:00,"It is possible to write an xpath expectation for a mock endpoint:




 mockendpoint.message(0).body().matches().xpath(""/ns2:myElement"")



However, this does not seem to work with namespaced elements (ns2 in the example above).


The Camel XPath documentation says that the Namespaces class can be used to define namespaces for e.g. xpath filters (btw. the code snippet that was formerly presented to show the usage got lost in the current manual).


Also, the XPathBuilder already has a namespace() method to set namespaces. But it appears that the MockExpressionClause.getExpressionValue }}does not support that, it uses {{XPathLanguage.createPredicate to create the XPath expression with a plain XPathBuilder without defining namespaces.


Is it possible to add namespaces to mock expectations somehow? If not I would like to suggest such support as an improvement. If it were built like the filter DSL, it should be possible to say sth like:




Namespaces namespaces = new Namespaces(""ns2"", ""http://xpsw.domap.de/xpsw174"");
mockendpoint.message(0).body().matches().xpath(""/ns2:myElement"", namespaces)","davsclaus:1618519929:2021-04-16T04:52:09.566+0000:1618519929:2021-04-16T04:52:09.566+0000:Have you tried with

mockendpoint.message(0).body().matches(xpath(""/ns2:myElement"", namespaces))

 "
0,CAMEL-16484,Dependency upgrade,Major,None,3.20.0,"
None
",Resolved,Fixed,3.20.0,Nicolas Filotto,Andrea Cosentino,0,4,2021-04-12 05:34:59+00:00,2022-10-14 10:25:20+00:00,No Desc,"davsclaus:1662112216:2022-09-02T17:50:16.815+0000:1662112216:2022-09-02T17:50:16.815+0000:Any update on this
nfilotto:1665642693:2022-10-13T14:31:33.633+0000:1665642693:2022-10-13T14:31:33.633+0000:The related fix https://github.com/apache/camel/pull/8547
nfilotto:1665714050:2022-10-14T10:20:50.473+0000:1665714132:2022-10-14T10:22:12.676+0000:The related PR  for Karaf https://github.com/apache/camel-karaf/pull/199

Tested successfully with the next routes:

{code:java}
<blueprint xmlns=""http://www.osgi.org/xmlns/blueprint/v1.0.0""
		   xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance""
           xmlns:cm=""http://aries.apache.org/blueprint/xmlns/blueprint-cm/v1.1.0""
           xsi:schemaLocation=""
             http://aries.apache.org/blueprint/xmlns/blueprint-cm/v1.1.0 http://aries.apache.org/schemas/blueprint-cm/blueprint-cm-1.1.0.xsd
             http://www.osgi.org/xmlns/blueprint/v1.0.0 https://www.osgi.org/xmlns/blueprint/v1.0.0/blueprint.xsd"">

  <!-- blueprint property placeholders, that will use etc/dropbox.cfg as the properties file -->
  <cm:property-placeholder persistent-id=""dropbox"" update-strategy=""reload"">

  </cm:property-placeholder>
  
    <camelContext xmlns=""http://camel.apache.org/schema/blueprint"">
        <route>
            <from uri=""timer:myTimer?period=10000"" />
            <setBody><simple>Hello from timer at ${header.firedTime}</simple></setBody>
            <setHeader name=""CamelDropboxUploadMode"">
                <constant>force</constant>
            </setHeader>
            <to uri=""dropbox://put?accessToken={{accessToken}}&amp;expireIn={{expireIn}}&amp;refreshToken={{refreshToken}}&amp;apiKey={{apiKey}}&amp;apiSecret={{apiSecret}}&amp;remotePath={{workDir}}/file.txt"" />
            <log message=""After put ${body}""/>
            <to uri=""dropbox://get?accessToken={{accessToken}}&amp;expireIn={{expireIn}}&amp;refreshToken={{refreshToken}}&amp;apiKey={{apiKey}}&amp;apiSecret={{apiSecret}}&amp;remotePath={{workDir}}/file.txt"" />
            <log message=""After get ${body}""/>
            <to uri=""dropbox://move?accessToken={{accessToken}}&amp;expireIn={{expireIn}}&amp;refreshToken={{refreshToken}}&amp;apiKey={{apiKey}}&amp;apiSecret={{apiSecret}}&amp;remotePath={{workDir}}/file.txt&amp;newRemotePath={{workDir}}-new/file.txt"" />
            <log message=""After move ${body}""/>
            <to uri=""dropbox://search?accessToken={{accessToken}}&amp;expireIn={{expireIn}}&amp;refreshToken={{refreshToken}}&amp;apiKey={{apiKey}}&amp;apiSecret={{apiSecret}}&amp;remotePath=/camel-test2&amp;query=index"" />
            <log message=""After search ${body}""/>
            <to uri=""dropbox://del?accessToken={{accessToken}}&amp;expireIn={{expireIn}}&amp;refreshToken={{refreshToken}}&amp;apiKey={{apiKey}}&amp;apiSecret={{apiSecret}}&amp;remotePath={{workDir}}-new/file.txt"" />
            <log message=""After del ${body}""/>
        </route>
        <route>
            <from uri=""dropbox://get?accessToken={{accessToken}}&amp;expireIn={{expireIn}}&amp;refreshToken={{refreshToken}}&amp;apiKey={{apiKey}}&amp;apiSecret={{apiSecret}}&amp;remotePath=/camel-test2/index.md"" />
            <log message=""After get consumer ${body}""/>
        </route>        
        <route>
            <from uri=""dropbox://search?accessToken={{accessToken}}&amp;expireIn={{expireIn}}&amp;refreshToken={{refreshToken}}&amp;apiKey={{apiKey}}&amp;apiSecret={{apiSecret}}&amp;remotePath=/camel-test2&amp;query=index"" />
            <log message=""After search consumer ${body}""/>
        </route>        
    </camelContext>

</blueprint>
{code}
"
0,CAMEL-16483,New Feature,Minor,None,Future,"
None
",Open,Unresolved,Future,Unassigned,Andrea Cosentino,0,3,2021-04-12 05:34:31+00:00,2023-08-09 09:20:36+00:00,"https://docs.nats.io/jetstream/jetstream


 


https://github.com/nats-io/nats.java#jetstream","bmarcj:1658237779:2022-07-19T21:36:19.072+0000:1658237779:2022-07-19T21:36:19.072+0000:There are many differences in the API and configuration for Jetstream. Should this be a new component (`camel-nats-jetstream`)?
davsclaus:1662112197:2022-09-02T17:49:57.321+0000:1662112197:2022-09-02T17:49:57.321+0000:Yes a new component is welcome if anyone is able to work on this"
0,CAMEL-16482,Improvement,Minor,3.9.0,3.11.0,"
None
",Resolved,Fixed,3.11.0,Andrea Cosentino,Zineb Bendhiba,0,1,2021-04-10 12:09:53+00:00,2021-05-27 04:49:00+00:00,"add getAll for HazelcastListProducer and HazelcastSetProducer


+ do real integration tests",zbendhiba:1618027874:2021-04-10T12:11:14.963+0000:1618027874:2021-04-10T12:11:14.963+0000:[~mariana.roldan] is working on this one !
0,CAMEL-16481,Improvement,Major,"2.25.3, 3.8.0",3.10.0,"
None
",Resolved,Fixed,3.10.0,Ramu,Ramu,0,1,2021-04-10 07:33:08+00:00,2021-04-13 08:36:42+00:00,Implement CAMEL-16414:camel-kafka set custom timestamp for vertx-kafka,
0,CAMEL-16480,Bug,Minor,"3.7.3, 3.8.0","3.7.4, 3.10.0","
None
",Resolved,Fixed,"3.7.4, 3.10.0",Claus Ibsen,Hokutor,0,1,2021-04-09 14:26:09+00:00,2021-04-15 07:22:41+00:00,"I just upgraded from camel 3.4 to 3.8. I had a logger statement as follows in my application. I was printing exchange body as follows in a log statement


.log(""API response received is ==> ${body}"")


Prior to upgrade, the above log statement prints the exchange body perfectly by evaluating ${body} expression


However, after upgrade, it prints as following


API response received is ==> body


 


On further digging, just figured that if you happen to add a property with key ""body"", then it causes the above unexpected behavior. Attaching a screenshot which illustrates the problem with a simple camel route 


 


 This issue was also discussed on zulip - https://camel.zulipchat.com/#narrow/stream/257298-camel/topic/Upgrade.20from.203.2E4.20to.203.2E7.20.2F.2F.20Simple.20expression.20behavior",
0,CAMEL-16479,New Feature,Major,None,"4.0-RC2, 4.0.0","
None
",Resolved,Fixed,"4.0-RC2, 4.0.0",Andrea Cosentino,Andrea Cosentino,1,2,2021-04-09 13:40:02+00:00,2023-08-22 05:41:07+00:00,No Desc,acosentino:1623965561:2021-06-18T05:32:41.247+0000:1623965561:2021-06-18T05:32:41.247+0000:This will probably require a new component based on KCL
0,CAMEL-16478,New Feature,Major,None,3.10.0,"
None
",Resolved,Fixed,3.10.0,Andrea Cosentino,Andrea Cosentino,0,1,2021-04-09 13:22:11+00:00,2021-04-09 13:31:30+00:00,"In case the table doesn't exist ahead of time, while creating the table this parameter will be needed.",
0,CAMEL-16477,Improvement,Minor,None,3.10.0,"
None
",Resolved,Fixed,3.10.0,Claus Ibsen,Luca Burgazzoli,0,2,2021-04-09 13:19:43+00:00,2021-04-27 11:36:33+00:00,"The ProcessorDefinitionHelper define methods like:




Iterator<T> filterTypeInOutputs(List<ProcessorDefinition<?>> outputs, Class<T> type)
Iterator<T> filterTypeInOutputs(List<ProcessorDefinition<?>> outputs, Class<T> type, int maxDeep)




Internally those methods are based on Lists but the return is always an iterator which make processing the result a little verbose.


We could instead return an immutable Collection","lb:1617945621:2021-04-09T13:20:21.837+0000:1617945621:2021-04-09T13:20:21.837+0000:[~davsclaus] what do you think ?
davsclaus:1618005734:2021-04-10T06:02:14.305+0000:1618005734:2021-04-10T06:02:14.305+0000:Yeah of course we can do this, its also something Camel users internally so we can do the change."
0,CAMEL-16476,Bug,Major,3.9.0,3.10.0,"
None
",Resolved,Fixed,3.10.0,Claus Ibsen,Claus Ibsen,1,1,2021-04-09 10:17:01+00:00,2021-04-15 13:21:13+00:00,"Reported on user forum
http://camel.465427.n5.nabble.com/doCatch-in-XML-DSL-broken-in-3-8-0-td5917794.html",davsclaus:1618462623:2021-04-15T12:57:03.333+0000:1618462623:2021-04-15T12:57:03.333+0000:Its only doCatch and doFinally that has this problem
0,CAMEL-16475,New Feature,Major,None,3.10.0,"
None
",Resolved,Duplicate,3.10.0,Omar Al-Safi,Omar Al-Safi,0,1,2021-04-09 09:44:07+00:00,2021-04-09 09:51:18+00:00,No Desc,
0,CAMEL-16474,Improvement,Major,None,3.10.0,"
None
",Resolved,Fixed,3.10.0,Claus Ibsen,Claus Ibsen,0,1,2021-04-09 04:55:47+00:00,2021-04-09 05:05:15+00:00,"To expose its schedule based options
http://camel.465427.n5.nabble.com/Scheduled-polling-with-azure-storage-blob-consumer-td5917607.html",davsclaus:1617915915:2021-04-09T05:05:15.687+0000:1617915915:2021-04-09T05:05:15.687+0000:The same for datalake and the queue azure components.
0,CAMEL-16473,Dependency upgrade,Major,None,3.10.0,"
None
",Resolved,Fixed,3.10.0,Omar Al-Safi,Claus Ibsen,0,1,2021-04-09 04:43:53+00:00,2021-04-09 10:01:57+00:00,"There is a new 1.5 release out, we should upgrade.",
0,CAMEL-16472,Bug,Major,3.9.0,3.10.0,"
None
",Resolved,Fixed,3.10.0,Unassigned,Luca Burgazzoli,0,3,2021-04-08 17:17:54+00:00,2021-04-14 09:05:30+00:00,"Assuming we have a kamelet named aggregate that define an aggregation step, like:




- from: 
    uri: ""kamelet:source""
    steps: 
      - aggregate: 
          correlation-expression: 
            simple: ""${header.Kind}""
          strategy-ref: ""myAggregatorStrategy""
          completion-size: ""{{count}}""
          steps: 
            - to: ""log:aggregate""
            - to: ""kamelet:sink""




And a route using such kameelt:




- from: 
    uri: ""timer:tick""
    steps: 
      - set-header: 
          name: ""Kind""
          constant: ""simple""
      - set-body: 
          simple: ""${exchangeProperty.CamelTimerCounter}""
      - to: ""kamelet:aggregate?count=5""
      - to: ""log:info""




When this code is executed, the_ log:info_ endpoint will log each individual exchange produced by the timer but not the aggregated one which is instead logged by the log:aggregate endpoint (part of the aggregate kamelet). 


This happen because the route engine does not wire the kamelet:sink endpoint of the aggregate kamemelt but the route output.","davsclaus:1618298116:2021-04-13T15:15:16.194+0000:1618298116:2021-04-13T15:15:16.194+0000:Adding a new Kamelet EIP seems likely as the better solution. It allows the control and flexibility to have multiple exit points from a kamelet (kamelet:sink) that can continue route in the callee route, eg the example above works with

{code}
                routeTemplate(""my-aggregate"")
                        .templateParameter(""count"")
                        .from(""kamelet:source"")
                        .aggregate(constant(true))
                            .completionSize(""{{count}}"")
                            .aggregationStrategy(AggregationStrategies.string("",""))
                            .to(""log:aggregate"")
                            .to(""kamelet:sink"")
                        .end();

                from(""direct:start"")
                        .kamelet(""my-aggregate?count=5"")
                        .to(""log:info"")
                        .to(""mock:result"");
{code}

davsclaus:1618298201:2021-04-13T15:16:41.185+0000:1618298201:2021-04-13T15:16:41.185+0000:eg the EIP call with
{code}
 .kamelet(""my-aggregate?count=5"")
{code}

Allows to let 
{code}
     .to(""log:info"")
     .to(""mock:result"");
{code}

be sub flow from the kamelet (eg like splitter, aggregate etc), eg it can also be as:
{code}
                from(""direct:start"")
                        .kamelet(""my-aggregate?count=5"")
                            .to(""log:info"")
                            .to(""mock:result"")
                        .end(); // end kamelet block
{code}
davsclaus:1618298307:2021-04-13T15:18:27.341+0000:1618298307:2021-04-13T15:18:27.341+0000:Using the endpoint with to is much harder as we cannot control 100% how to continue routing at the right thread when kamelet:sink is called in the route template.
Otherwise we would need to do some ""hacks"" when building the route, and detect that in ToReifier that the endpoint is a kamelet and do some kind of transformation to a pseudo Kamelet EIP. 
davsclaus:1618362330:2021-04-14T09:05:30.400+0000:1618362330:2021-04-14T09:05:30.400+0000:The Kamelet EIP is the solution for this"
0,CAMEL-16471,Improvement,Minor,None,None,"

Enhancement

",Resolved,Fixed,3.10.0,Unassigned,Hokutor,0,1,2021-04-08 16:21:28+00:00,2021-04-10 06:01:26+00:00,"As of camel release version 3.9, camel-huaweicloud-smn component supports initializing the SMN client based on cloud region only.


As an alternative option, Huaweicloud SDK now supports initializing the endpoint based on fully qualified endpoint url as per the documentation here.
https://github.com/huaweicloud/huaweicloud-sdk-java-v3#31-initialize-the-serviceclient-with-specified-endpoint-top


We should have the same feature enabled for camel-huaweicloud-smn too",
0,CAMEL-16470,Improvement,Major,"3.7.3, 3.8.0, 3.9.0","3.7.4, 3.10.0","
None
",Resolved,Fixed,"3.7.4, 3.10.0",Andrea Cosentino,Tom Cassimon,0,1,2021-04-08 09:32:53+00:00,2021-04-14 08:52:05+00:00,"When using multiple datasources for jpa in the same route, the EntityManager first created gets reused for the second jpa call, but this is the wrong EntityManager (for datasource 1 instead of datasource 2).


This re-use is found in the JpaHelper class where the EntityManager is stored as property on the Exchange.


The outcome of this PR will still result in re-use of the Entitymanager but storing the EntityManager in a map with the hashCode of the EntityManagerFactory as a key.","TCke83:1617846389:2021-04-08T09:46:29.712+0000:1617846389:2021-04-08T09:46:29.712+0000:Pull request submitted, could this be backported to 3.7.x also?"
0,CAMEL-16469,New Feature,Major,None,3.10.0,"
None
",Resolved,Fixed,3.10.0,Andrea Cosentino,Andrea Cosentino,0,1,2021-04-08 05:44:46+00:00,2021-04-08 06:40:22+00:00,No Desc,
0,CAMEL-16468,Improvement,Major,None,3.11.0,"
None
",Resolved,Fixed,3.11.0,Maciej Swiderski,Claus Ibsen,0,4,2021-04-08 04:32:29+00:00,2021-06-05 05:45:24+00:00,"See this blog
https://blog.kie.org/2021/04/how-to-interact-with-business-processes-using-camel-routes.html


The enum in the producer class is not public.


We should make it public, and make it easier to set the operation because you need the prefix + the enum value.


CamelJBPMOperationstartProcess
CamelJBPMOperationabortProcessInstance
...


And we should make it ignore case, so you can use nicer names.


CamelJBPMOperationStartProcess


Also not sure why we need this prefix. So we can likely also support it without the prefix.","egonzale:1622163338:2021-05-28T08:55:38.248+0000:1622163338:2021-05-28T08:55:38.248+0000:[~swiderski.maciej] Can you assign this to me. Don't have permissions for doing it myself.
acosentino:1622163573:2021-05-28T08:59:33.681+0000:1622163573:2021-05-28T08:59:33.681+0000:There is no need for having this assigned, we usually give the possibility of assigning issues to contributors involved for a longer period even if they are not committer. Feel free to work on this, the comment is enough. It's been a while and I don't think [~swiderski.maciej] is working on this anymore.
swiderski.maciej:1622163728:2021-05-28T09:02:08.509+0000:1622163728:2021-05-28T09:02:08.509+0000:I tried to assign that to you [~egonzale] but in the assignee drop down it does not find your user name. +1 to [~acosentino], just work on it :)
egonzale:1622163962:2021-05-28T09:06:02.460+0000:1622163962:2021-05-28T09:06:02.460+0000:[~acosentino] thx for pointing out the procedure.
[~swiderski.maciej] long time no see :)
egonzale:1622706246:2021-06-03T15:44:06.472+0000:1622706246:2021-06-03T15:44:06.472+0000:Just for doc purposes.
https://github.com/apache/camel/pull/5621"
0,CAMEL-16467,Task,Major,None,3.13.0,"
None
",Resolved,Fixed,3.13.0,Andrea Cosentino,Andrea Cosentino,0,1,2021-04-07 07:29:43+00:00,2021-11-05 13:52:23+00:00,"It makes sense to collect all the aws examples, google examples of azure examples into a middle folder.


Let's start with the plain camel-examples repo.","acosentino:1636003596:2021-11-04T13:26:36.887+0000:1636003596:2021-11-04T13:26:36.887+0000:Camel-examples done.
acosentino:1636091543:2021-11-05T13:52:23.097+0000:1636091543:2021-11-05T13:52:23.097+0000:I think we can consider this done, since in karaf and sb, there are only single examples for aws etc."
0,CAMEL-16466,Task,Major,None,3.10.0,"
None
",Resolved,Fixed,3.10.0,Andrea Cosentino,Andrea Cosentino,0,1,2021-04-07 06:59:32+00:00,2021-04-07 07:13:36+00:00,Related to jsonpath removal from karaf,
0,CAMEL-16465,Task,Major,None,3.11.0,"
None
",Resolved,Fixed,3.11.0,Andrea Cosentino,Andrea Cosentino,0,1,2021-04-07 06:42:04+00:00,2021-06-01 06:29:15+00:00,No Desc,"acosentino:1617766446:2021-04-07T11:34:06.148+0000:1617766446:2021-04-07T11:34:06.148+0000:Kinesis done.
acosentino:1622500151:2021-06-01T06:29:11.605+0000:1622500151:2021-06-01T06:29:11.605+0000:Finally completed. All the components, except the xray which it is special, are now done."
0,CAMEL-16464,Task,Major,None,3.10.0,"
None
",Resolved,Fixed,3.10.0,Andrea Cosentino,Andrea Cosentino,0,5,2021-04-07 06:27:24+00:00,2021-11-04 11:49:19+00:00,"The needed upgrade of json-smart and accessors smart shows troubles with asm version. Since the karaf features maintenace is best effort, I'm going to remove it.","vladk:1621562587:2021-05-21T10:03:07.529+0000:1621562587:2021-05-21T10:03:07.529+0000:And how I have to use camel-jsonpath in karaf? Or I cannot use camel 3.10?
acosentino:1621562949:2021-05-21T10:09:09.525+0000:1621562949:2021-05-21T10:09:09.525+0000:It has been removed because of cve on json-smart. Upgrading the version wasn't working on karaf and OSGi in general. So since OSGi support is best effort we removed the feature. There is no easy way of solving this kid d of situation.
davsclaus:1621567126:2021-05-21T11:18:46.948+0000:1621567126:2021-05-21T11:18:46.948+0000:You can always install osgi bundles manually yourself - just look at the 3.10 feature what bundles it uses, and install them yourself. About json-smart then it has a CVE in that older version, but camel-jsonpath should work with jackson also
vladk:1621567387:2021-05-21T11:23:07.828+0000:1621567387:2021-05-21T11:23:07.828+0000:Thank you for your answers. I will try it
catshout:1623886195:2021-06-17T07:29:55.005+0000:1623886195:2021-06-17T07:29:55.005+0000:Hi [~davsclaus] [~acosentino] as we're using the [https://camel.apache.org/components/3.7.x/languages/jsonpath-language.html] component in our routes, what is your recommendation to include this with Karaf/Camel based runtime?

Best
Gerald
davsclaus:1623887449:2021-06-17T07:50:49.474+0000:1623887449:2021-06-17T07:50:49.474+0000:We found a way to add it back into 3.11
acosentino:1623887895:2021-06-17T07:58:15.270+0000:1623887895:2021-06-17T07:58:15.270+0000:So in the next LTS Karaf will be supported for json-path
michael992:1635993025:2021-11-04T10:30:25.240+0000:1635993025:2021-11-04T10:30:25.240+0000:'We found a way to add it back into 3.11' great thanks !
michael992:1635997573:2021-11-04T11:46:13.763+0000:1635997759:2021-11-04T11:49:19.964+0000:[~acosentino] [~davsclaus]
There is still a bug with this component this method 
{code:java}
jsonpathWriteAsString
{code}
 work on local this mean split elements are json strings but on karaf is stay as map this require to do extra {code:java}
.marshal().json(Jackson)
{code}
"
0,CAMEL-16463,Task,Major,None,3.10.0,"
None
",Resolved,Fixed,3.10.0,Andrea Cosentino,Andrea Cosentino,0,1,2021-04-07 06:25:53+00:00,2021-04-07 06:47:18+00:00,No Desc,
0,CAMEL-16462,Improvement,Major,None,3.10.0,"
None
",Resolved,Fixed,3.10.0,Claus Ibsen,Claus Ibsen,0,1,2021-04-07 04:59:28+00:00,2021-04-07 05:22:50+00:00,The java.util.Scanner is too heavy if you just have a string with comma as seperator,
0,CAMEL-16461,Bug,Major,None,,"
None
",Resolved,Information Provided,None,Unassigned,Claudio Miranda,0,2,2021-04-06 23:40:55+00:00,2021-09-30 10:34:31+00:00,"Using the AWS2S3StreamUploadProducer and setting the header ""CamelAwsS3Key"" and not setting the keyName in query parameter, it throws the NPE
 




java.lang.NullPointerException: null
        at org.apache.camel.component.aws2.s3.utils.AWS2S3Utils.determineFileName(AWS2S3Utils.java:75)","claudio4j:1617723983:2021-04-06T23:46:23.093+0000:1617723983:2021-04-06T23:46:23.093+0000:https://github.com/apache/camel/pull/5300
acosentino:1617741957:2021-04-07T04:45:57.733+0000:1617741957:2021-04-07T04:45:57.733+0000:The header in this case cannot be used. It must be static. Suppose you send an exchange to the streaming upload producer with a dynamic header with date as suffix: if on each exchange you change the keyname there is no way to track where the multipart upload is pointing. I will documentation for this but this is by design."
0,CAMEL-16460,Improvement,Major,None,3.10.0,"
None
",Resolved,Fixed,3.10.0,Freeman Yue Fang,Freeman Yue Fang,0,1,2021-04-06 15:42:56+00:00,2021-04-07 13:14:26+00:00,"currently it's hardcode as Locale.US, but this should be configurable from WebClient Configurer.",
0,CAMEL-16459,Bug,Major,3.9.0,3.10.0,"
None
",Resolved,Fixed,3.10.0,Jiri Ondrusek,Jiri Ondrusek,0,1,2021-04-06 11:35:20+00:00,2021-04-08 04:32:38+00:00,"When following route:




        from(""platform-http:/hello"").
        choice().when().jsonpath(""$.room[?(@.temperature > 20)]"").
            setBody(simple(""HOT"")).
        otherwise().
            setBody(constant(""WARM"")).
        end();




Is executed with body




{room:{temperature:30}}




Exception is triggered:


com.jayway.jsonpath.PathNotFoundException: Missing property in path $['room']
	at com.jayway.jsonpath.internal.path.PathToken.handleObjectProperty(PathToken.java:72)
	at com.jayway.jsonpath.internal.path.PropertyPathToken.evaluate(PropertyPathToken.java:79)
	at com.jayway.jsonpath.internal.path.RootPathToken.evaluate(RootPathToken.java:62)
	at com.jayway.jsonpath.internal.path.CompiledPath.evaluate(CompiledPath.java:53)
	at com.jayway.jsonpath.internal.path.CompiledPath.evaluate(CompiledPath.java:61)
	at com.jayway.jsonpath.JsonPath.read(JsonPath.java:187)
	at com.jayway.jsonpath.internal.JsonContext.read(JsonContext.java:102)
	at com.jayway.jsonpath.internal.JsonContext.read(JsonContext.java:89)
	at org.apache.camel.jsonpath.JsonPathEngine.readWithAdapter(JsonPathEngine.java:262)
	at org.apache.camel.jsonpath.JsonPathEngine.doRead(JsonPathEngine.java:187)
	at org.apache.camel.jsonpath.JsonPathEngine.read(JsonPathEngine.java:105)
	at org.apache.camel.jsonpath.JsonPathExpression.evaluateJsonPath(JsonPathExpression.java:190)
	at org.apache.camel.jsonpath.JsonPathExpression.evaluate(JsonPathExpression.java:144)
	at org.apache.camel.support.ExpressionAdapter.evaluate(ExpressionAdapter.java:45)
	at org.apache.camel.support.ExpressionSupport.matches(ExpressionSupport.java:36)
	at org.apache.camel.processor.FilterProcessor.matches(FilterProcessor.java:77)
	at org.apache.camel.processor.ChoiceProcessor.process(ChoiceProcessor.java:71)
	at org.apache.camel.processor.errorhandler.RedeliveryErrorHandler$SimpleTask.run(RedeliveryErrorHandler.java:463)
	at org.apache.camel.impl.engine.DefaultReactiveExecutor$Worker.schedule(DefaultReactiveExecutor.java:179)
	at org.apache.camel.impl.engine.DefaultReactiveExecutor.scheduleMain(DefaultReactiveExecutor.java:64)
	at org.apache.camel.processor.Pipeline.process(Pipeline.java:184)
	at org.apache.camel.impl.engine.CamelInternalProcessor.process(CamelInternalProcessor.java:398)
	at org.apache.camel.component.platform.http.vertx.VertxPlatformHttpConsumer.lambda$handleRequest$2(VertxPlatformHttpConsumer.java:184)
	at io.vertx.core.impl.ContextImpl.lambda$executeBlocking$2(ContextImpl.java:313)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)
	at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)
	at java.base/java.lang.Thread.run(Thread.java:834)
org.apache.camel.CamelExecutionException: Exception occurred during execution on the exchange: Exchange[C7B428C77B12413-0000000000000000]
	at org.apache.camel.CamelExecutionException.wrapCamelExecutionException(CamelExecutionException.java:45)
	at org.apache.camel.support.ExchangeHelper.extractResultBody(ExchangeHelper.java:698)
	at org.apache.camel.impl.engine.DefaultProducerTemplate.extractResultBody(DefaultProducerTemplate.java:591)
	at org.apache.camel.impl.engine.DefaultProducerTemplate.extractResultBody(DefaultProducerTemplate.java:587)
	at org.apache.camel.impl.engine.DefaultProducerTemplate.sendBody(DefaultProducerTemplate.java:189)
	at org.apache.camel.impl.engine.DefaultProducerTemplate.sendBody(DefaultProducerTemplate.java:195)
	at org.apache.camel.jsonpath.JsonPathPojoTransformTest.testPojo(JsonPathPojoTransformTest.java:46)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.junit.platform.commons.util.ReflectionUtils.invokeMethod(ReflectionUtils.java:688)
	at org.junit.jupiter.engine.execution.MethodInvocation.proceed(MethodInvocation.java:60)
	at org.junit.jupiter.engine.execution.InvocationInterceptorChain$ValidatingInvocation.proceed(InvocationInterceptorChain.java:131)
	at org.junit.jupiter.engine.extension.TimeoutExtension.intercept(TimeoutExtension.java:149)
	at org.junit.jupiter.engine.extension.TimeoutExtension.interceptTestableMethod(TimeoutExtension.java:140)
	at org.junit.jupiter.engine.extension.TimeoutExtension.interceptTestMethod(TimeoutExtension.java:84)
	at org.junit.jupiter.engine.execution.ExecutableInvoker$ReflectiveInterceptorCall.lambda$ofVoidMethod$0(ExecutableInvoker.java:115)
	at org.junit.jupiter.engine.execution.ExecutableInvoker.lambda$invoke$0(ExecutableInvoker.java:105)
	at org.junit.jupiter.engine.execution.InvocationInterceptorChain$InterceptedInvocation.proceed(InvocationInterceptorChain.java:106)
	at org.junit.jupiter.engine.execution.InvocationInterceptorChain.proceed(InvocationInterceptorChain.java:64)
	at org.junit.jupiter.engine.execution.InvocationInterceptorChain.chainAndInvoke(InvocationInterceptorChain.java:45)
	at org.junit.jupiter.engine.execution.InvocationInterceptorChain.invoke(InvocationInterceptorChain.java:37)
	at org.junit.jupiter.engine.execution.ExecutableInvoker.invoke(ExecutableInvoker.java:104)
	at org.junit.jupiter.engine.execution.ExecutableInvoker.invoke(ExecutableInvoker.java:98)
	at org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.lambda$invokeTestMethod$6(TestMethodTestDescriptor.java:210)
	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)
	at org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.invokeTestMethod(TestMethodTestDescriptor.java:206)
	at org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.execute(TestMethodTestDescriptor.java:131)
	at org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.execute(TestMethodTestDescriptor.java:65)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$5(NodeTestTask.java:139)
	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$7(NodeTestTask.java:129)
	at org.junit.platform.engine.support.hierarchical.Node.around(Node.java:137)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$8(NodeTestTask.java:127)
	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.executeRecursively(NodeTestTask.java:126)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.execute(NodeTestTask.java:84)
	at java.base/java.util.ArrayList.forEach(ArrayList.java:1540)
	at org.junit.platform.engine.support.hierarchical.SameThreadHierarchicalTestExecutorService.invokeAll(SameThreadHierarchicalTestExecutorService.java:38)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$5(NodeTestTask.java:143)
	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$7(NodeTestTask.java:129)
	at org.junit.platform.engine.support.hierarchical.Node.around(Node.java:137)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$8(NodeTestTask.java:127)
	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.executeRecursively(NodeTestTask.java:126)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.execute(NodeTestTask.java:84)
	at java.base/java.util.ArrayList.forEach(ArrayList.java:1540)
	at org.junit.platform.engine.support.hierarchical.SameThreadHierarchicalTestExecutorService.invokeAll(SameThreadHierarchicalTestExecutorService.java:38)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$5(NodeTestTask.java:143)
	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$7(NodeTestTask.java:129)
	at org.junit.platform.engine.support.hierarchical.Node.around(Node.java:137)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$8(NodeTestTask.java:127)
	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.executeRecursively(NodeTestTask.java:126)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.execute(NodeTestTask.java:84)
	at org.junit.platform.engine.support.hierarchical.SameThreadHierarchicalTestExecutorService.submit(SameThreadHierarchicalTestExecutorService.java:32)
	at org.junit.platform.engine.support.hierarchical.HierarchicalTestExecutor.execute(HierarchicalTestExecutor.java:57)
	at org.junit.platform.engine.support.hierarchical.HierarchicalTestEngine.execute(HierarchicalTestEngine.java:51)
	at org.junit.platform.launcher.core.EngineExecutionOrchestrator.execute(EngineExecutionOrchestrator.java:108)
	at org.junit.platform.launcher.core.EngineExecutionOrchestrator.execute(EngineExecutionOrchestrator.java:88)
	at org.junit.platform.launcher.core.EngineExecutionOrchestrator.lambda$execute$0(EngineExecutionOrchestrator.java:54)
	at org.junit.platform.launcher.core.EngineExecutionOrchestrator.withInterceptedStreams(EngineExecutionOrchestrator.java:67)
	at org.junit.platform.launcher.core.EngineExecutionOrchestrator.execute(EngineExecutionOrchestrator.java:52)
	at org.junit.platform.launcher.core.DefaultLauncher.execute(DefaultLauncher.java:96)
	at org.junit.platform.launcher.core.DefaultLauncher.execute(DefaultLauncher.java:75)
	at org.apache.maven.surefire.junitplatform.JUnitPlatformProvider.execute(JUnitPlatformProvider.java:188)
	at org.apache.maven.surefire.junitplatform.JUnitPlatformProvider.invokeAllTests(JUnitPlatformProvider.java:154)
	at org.apache.maven.surefire.junitplatform.JUnitPlatformProvider.invoke(JUnitPlatformProvider.java:128)
	at org.apache.maven.surefire.booter.ForkedBooter.runSuitesInProcess(ForkedBooter.java:428)
	at org.apache.maven.surefire.booter.ForkedBooter.execute(ForkedBooter.java:162)
	at org.apache.maven.surefire.booter.ForkedBooter.run(ForkedBooter.java:562)
	at org.apache.maven.surefire.booter.ForkedBooter.main(ForkedBooter.java:548)
Caused by: org.apache.camel.ExpressionEvaluationException: org.apache.camel.CamelExchangeException: Cannot read message body as supported JSON value. Exchange[]
	at org.apache.camel.jsonpath.JsonPathExpression.evaluate(JsonPathExpression.java:159)
	at org.apache.camel.support.ExpressionAdapter.evaluate(ExpressionAdapter.java:45)
	at org.apache.camel.processor.TransformProcessor.process(TransformProcessor.java:47)
	at org.apache.camel.processor.errorhandler.RedeliveryErrorHandler$SimpleTask.run(RedeliveryErrorHandler.java:463)
	at org.apache.camel.impl.engine.DefaultReactiveExecutor$Worker.schedule(DefaultReactiveExecutor.java:179)
	at org.apache.camel.impl.engine.DefaultReactiveExecutor.scheduleMain(DefaultReactiveExecutor.java:64)
	at org.apache.camel.processor.Pipeline.process(Pipeline.java:184)
	at org.apache.camel.impl.engine.CamelInternalProcessor.process(CamelInternalProcessor.java:398)
	at org.apache.camel.component.direct.DirectProducer.process(DirectProducer.java:96)
	at org.apache.camel.impl.engine.SharedCamelInternalProcessor.process(SharedCamelInternalProcessor.java:217)
	at org.apache.camel.impl.engine.SharedCamelInternalProcessor$1.process(SharedCamelInternalProcessor.java:111)
	at org.apache.camel.impl.engine.DefaultAsyncProcessorAwaitManager.process(DefaultAsyncProcessorAwaitManager.java:83)
	at org.apache.camel.impl.engine.SharedCamelInternalProcessor.process(SharedCamelInternalProcessor.java:108)
	at org.apache.camel.support.cache.DefaultProducerCache.send(DefaultProducerCache.java:190)
	at org.apache.camel.impl.engine.DefaultProducerTemplate.send(DefaultProducerTemplate.java:176)
	at org.apache.camel.impl.engine.DefaultProducerTemplate.send(DefaultProducerTemplate.java:172)
	at org.apache.camel.impl.engine.DefaultProducerTemplate.send(DefaultProducerTemplate.java:153)
	at org.apache.camel.impl.engine.DefaultProducerTemplate.sendBody(DefaultProducerTemplate.java:187)
	... 70 more
Caused by: org.apache.camel.CamelExchangeException: Cannot read message body as supported JSON value. Exchange[]
	at org.apache.camel.jsonpath.JsonPathEngine.doRead(JsonPathEngine.java:213)
	at org.apache.camel.jsonpath.JsonPathEngine.read(JsonPathEngine.java:105)
	at org.apache.camel.jsonpath.JsonPathExpression.evaluateJsonPath(JsonPathExpression.java:190)
	at org.apache.camel.jsonpath.JsonPathExpression.evaluate(JsonPathExpression.java:144)
	... 87 more",
0,CAMEL-16458,Improvement,Major,None,3.10.0,"
None
",Resolved,Fixed,3.10.0,Claus Ibsen,Claus Ibsen,0,1,2021-04-06 10:09:57+00:00,2021-04-10 11:39:30+00:00,"1)
We can look at optimizing this, as if a producer is singleton, then it can be reused.
The Enricher EIP uses an acquire/release pattern which is only needed for non singleton producers to be thread safe.
And the same for Poll Enricher (consumer cache) NO PROBLEM


2)
And the destination endpoint can be optimized in case its static - then we dont need to evaluate a dynamic destination.
And the same for Poll Enricher","davsclaus:1617940809:2021-04-09T12:00:09.769+0000:1618025967:2021-04-10T11:39:27.409+0000:TODO: Enricher to use SendDynamicProcessor to send instead of its own code *DONE*
TOOD: Optimize for static endpoint *NOT NEEDED*"
0,CAMEL-16457,Improvement,Major,None,3.10.0,"
None
",Resolved,Fixed,3.10.0,Unassigned,Claus Ibsen,0,1,2021-04-06 09:39:23+00:00,2021-04-06 10:07:50+00:00,"MessageID are often not in use, and the copyResults method should skip creating a new message id, if it was not in use.",
0,CAMEL-16456,Task,Major,None,3.10.0,"
None
",Resolved,Fixed,3.10.0,Otavio Rodolfo Piske,Otavio Rodolfo Piske,0,1,2021-04-06 08:14:59+00:00,2021-04-09 05:06:26+00:00,ActiveMQ's BrokerService is used by multiple services. It may be moved to test infra and reduce test code duplication.,
0,CAMEL-16455,Improvement,Major,None,3.10.0,"
None
",Resolved,Fixed,3.10.0,Claus Ibsen,Claus Ibsen,0,1,2021-04-06 07:59:02+00:00,2021-04-08 14:25:23+00:00,A ticket to remember to look at using a ExchangeTask for optimizing the circuit breakers like we do in some of the core EIPs like pipeline,"davsclaus:1617848720:2021-04-08T10:25:20.815+0000:1617863115:2021-04-08T14:25:15.633+0000:TODO: resilience4j *DONE*
TODO: microprofile-faulttolerance *DONE*"
0,CAMEL-16454,Improvement,Major,None,3.10.0,"
None
",Resolved,Fixed,3.10.0,Claus Ibsen,Claus Ibsen,0,1,2021-04-06 07:26:59+00:00,2021-04-06 07:59:14+00:00,org.apache.camel.spi.CircuitBreakerConstants,
0,CAMEL-16453,Bug,Major,3.9.0,"3.7.4, 3.10.0","
None
",Resolved,Fixed,"3.7.4, 3.10.0",Unassigned,Samrat Dhillon,0,1,2021-04-05 18:19:24+00:00,2021-04-06 04:49:58+00:00,"Incorrect spans (with incorrect parentId) are created by camel-zipkin when using parallelProcessing with recipientList or multicast e.g. consider the below route


public void configure() throws Exception 

{

restConfiguration()
 .component(""netty-http"")
 .host(""0.0.0.0"")
 .port(8081)
 .bindingMode(RestBindingMode.json);

rest().get(""/demo"").produces(""text/plain"")
 .route().recipientList().method(CamelRoute.class).parallelProcessing();


 from(""direct:a"")
 .to(""mock:c"");

from(""direct:b"")
 .to(""mock:d"");


 }


 


The spans created for this are as follows. mock:c is supposed to have direct:a as the parent. But according to span information both mock:d and mock:c has parent ""direct:b""


 


{""traceId"":""b2c6777c39c6ad9e"",""parentId"":""1a139ce652082f20"",""id"":""5322e166bb04c216"",""kind"":""CLIENT"",""name"":""mock://c"",""timestamp"":1617630636132009,""duration"":3564,""localEndpoint"":\{""serviceName"":""mock://c"",""ipv4"":""192.168.56.1""}

,""tags"":{""camel.client.endpoint.url"":""mock://c"",""camel.client.exchange.id"":""62B17BA80F06ABA-0000000000000001"",""camel.client.exchange.pattern"":""InOut""}}

{""traceId"":""b2c6777c39c6ad9e"",""parentId"":""1a139ce652082f20"",""id"":""1d23da2b33a4969c"",""kind"":""CLIENT"",""name"":""mock://d"",""timestamp"":1617630636132011,""duration"":3596,""localEndpoint"":\{""serviceName"":""mock://d"",""ipv4"":""192.168.56.1""}

,""tags"":{""camel.client.endpoint.url"":""mock://d"",""camel.client.exchange.id"":""62B17BA80F06ABA-0000000000000002"",""camel.client.exchange.pattern"":""InOut""}}

{""traceId"":""b2c6777c39c6ad9e"",""parentId"":""e81809492156bfe3"",""id"":""1a139ce652082f20"",""kind"":""SERVER"",""name"":""http://0.0.0.0:8081/demo"",""timestamp"":1617630636130430,""duration"":23706,""localEndpoint"":\{""serviceName"":""direct://b"",""ipv4"":""192.168.56.1""}

,""tags"":{""camel.server.endpoint.url"":""http://0.0.0.0:8081/demo?httpMethodRestrict=GET"",""camel.server.exchange.id"":""62B17BA80F06ABA-0000000000000002"",""camel.server.exchange.pattern"":""InOut""}}

{""traceId"":""b2c6777c39c6ad9e"",""parentId"":""6ee96f0a005d441a"",""id"":""53a64f899175a1be"",""kind"":""SERVER"",""name"":""http://0.0.0.0:8081/demo"",""timestamp"":1617630636130428,""duration"":23708,""localEndpoint"":\{""serviceName"":""direct://a"",""ipv4"":""192.168.56.1""}

,""tags"":{""camel.server.endpoint.url"":""http://0.0.0.0:8081/demo?httpMethodRestrict=GET"",""camel.server.exchange.id"":""62B17BA80F06ABA-0000000000000001"",""camel.server.exchange.pattern"":""InOut""}}

{""traceId"":""b2c6777c39c6ad9e"",""parentId"":""b2c6777c39c6ad9e"",""id"":""6ee96f0a005d441a"",""kind"":""CLIENT"",""name"":""direct://a"",""timestamp"":1617630636125011,""duration"":30645,""localEndpoint"":\{""serviceName"":""direct://a"",""ipv4"":""192.168.56.1""}

,""tags"":{""camel.client.endpoint.url"":""direct://b"",""camel.client.exchange.id"":""62B17BA80F06ABA-0000000000000002"",""camel.client.exchange.pattern"":""InOut""}}

{""traceId"":""b2c6777c39c6ad9e"",""parentId"":""b2c6777c39c6ad9e"",""id"":""e81809492156bfe3"",""kind"":""CLIENT"",""name"":""direct://b"",""timestamp"":1617630636125011,""duration"":30652,""localEndpoint"":\{""serviceName"":""direct://b"",""ipv4"":""192.168.56.1""}

,""tags"":{""camel.client.endpoint.url"":""direct://a"",""camel.client.exchange.id"":""62B17BA80F06ABA-0000000000000001"",""camel.client.exchange.pattern"":""InOut""}}

{""traceId"":""b2c6777c39c6ad9e"",""id"":""b2c6777c39c6ad9e"",""kind"":""SERVER"",""name"":""http://0.0.0.0:8081/demo"",""timestamp"":1617630636095939,""duration"":61810,""localEndpoint"":\{""serviceName"":""rest://get:/demo"",""ipv4"":""192.168.56.1""}

,""tags"":{""camel.server.endpoint.url"":""http://0.0.0.0:8081/demo?httpMethodRestrict=GET"",""camel.server.exchange.id"":""62B17BA80F06ABA-0000000000000000"",""camel.server.exchange.pattern"":""InOut""}}",
0,CAMEL-16452,Improvement,Minor,None,,"
None
",Open,Unresolved,None,Unassigned,Claus Ibsen,0,1,2021-04-05 16:38:35+00:00,2022-09-02 17:49:21+00:00,"Camel has been optimized so much that profiling now reveals that when using JDKs thread pool then every time a a task is submitted then a FutureTask is created which then costs object allocations.


We can look at having a PooledFutureTask where you can execute runAndReset instead. However this prevents using future get to get a result. But in some use-cases we do not use this, such as WireTap EIP and (and maybe some other EIPs)


java.util.concurrent.FutureTask#runAndReset",
0,CAMEL-16451,New Feature,Major,None,3.10.0,"
None
",Resolved,Fixed,3.10.0,Claus Ibsen,Claus Ibsen,0,1,2021-04-05 08:17:51+00:00,2021-04-11 07:54:29+00:00,"Currently its only components that has support for exchange pooling.


Some EIPs like WireTap, Splitter, Multicast, Aggregate etc also creates sub exchanges. The WireTap is easier to implement. Multicast, Aggregated based EIPs is complex and would require some more clever work to make this roboust.","davsclaus:1617612479:2021-04-05T16:47:59.928+0000:1617939737:2021-04-09T11:42:17.206+0000:TODO: WireTap *DONE*
TODO: Splitter *DONE*
TODO: Recipient List *DONE*
TODO: Multicast *DONE*
TODO: Aggregate *WONT FIX*
TODO: Enrich *DONE*
TODO: Circuit Breaker MP *DONE*
TODO: Circuit Breaker Resilience4j *DONE*
TODO: Circuit Breaker Hystrix *DEPRECATED*


davsclaus:1617679812:2021-04-06T11:30:12.999+0000:1617679812:2021-04-06T11:30:12.999+0000:The Aggregate EIP is a bit too complex as the aggregation strategy can use or not use the pooled exchange. And also the exchange may be stored in an aggregation repository on disk, which can be re-loaded if stopping the JVM and starting it again. 
"
0,CAMEL-16450,Improvement,Major,None,3.10.0,"
None
",Resolved,Fixed,3.10.0,Claus Ibsen,Claus Ibsen,0,1,2021-04-05 06:05:43+00:00,2021-04-05 16:38:53+00:00,"We can optimize to only use dynamic producer if the endpoint is dynamic.
Also we can add support for exchange pooling.",
0,CAMEL-16419,Bug,Minor,3.8.0,,"
None
",Resolved,Information Provided,None,Unassigned,Paolo Patierno,0,2,2021-03-28 20:12:27+00:00,2021-04-05 06:01:58+00:00,"This project [1] uses the maven-assembly-plugin to build fat JARs for the Camel applications it provides; if fat JARs are built and run they work perfectly.


I tried to add the camel-main dependency to the root pom and to the f1-telemetry-udp-kafka project pom as well, in order to change the application to use the Main class but I noticed that even if without using that class but just adding the camel-main in the pom, the JAR doesn't work anymore.


If you try to do so, doing a mvn package and then running




java -jar f1-telemetry-udp-kafka/target/f1-telemetry-udp-kafka-1.0-SNAPSHOT-jar-with-dependencies.jar




it fails with the following error:




2021-03-28 22:11:19 ERROR F1UdpKafkaApp:52 - Error starting CamelContext
org.apache.camel.FailedToCreateRouteException: Failed to create route route1 at: >>> Aggregate[io.ppatierno.formula1.DriversRouteBuilder$1@1649b0e6 -> [Split[bean[ref:drivers-splitter method:splitDrivers] -> [process[Processor@0x5f8edcc5], To[kafka:f1-telemetry-drivers?brokers=localhost:9092&clientId=drivers&valueSerializer=io.ppatierno.formula1.DriverSerializer], Log[${body}], Log[Driver[id = ${body.participantData.driverId}, hashtag = ${body.hashtag}]]]]]] <<< in route: Route(route1)[From[direct:drivers] -> [Aggregate[io.ppatiern... because of Error parsing [10000] as a java.time.Duration.
        at org.apache.camel.reifier.RouteReifier.doCreateRoute(RouteReifier.java:240)
        at org.apache.camel.reifier.RouteReifier.createRoute(RouteReifier.java:74)
        at org.apache.camel.impl.DefaultModelReifierFactory.createRoute(DefaultModelReifierFactory.java:49)
        at org.apache.camel.impl.DefaultCamelContext.startRouteDefinitions(DefaultCamelContext.java:604)
        at org.apache.camel.impl.DefaultCamelContext.startRouteDefinitions(DefaultCamelContext.java:556)
        at org.apache.camel.impl.engine.AbstractCamelContext.doInit(AbstractCamelContext.java:2756)
        at org.apache.camel.support.service.BaseService.init(BaseService.java:83)
        at org.apache.camel.impl.engine.AbstractCamelContext.init(AbstractCamelContext.java:2475)
        at org.apache.camel.support.service.BaseService.start(BaseService.java:111)
        at org.apache.camel.impl.engine.AbstractCamelContext.start(AbstractCamelContext.java:2492)
        at io.ppatierno.formula1.F1UdpKafkaApp.main(F1UdpKafkaApp.java:49)
Caused by: java.lang.IllegalArgumentException: Error parsing [10000] as a java.time.Duration.
        at org.apache.camel.support.CamelContextHelper.parse(CamelContextHelper.java:556)
        at org.apache.camel.support.CamelContextHelper.parseDuration(CamelContextHelper.java:500)
        at org.apache.camel.reifier.AbstractReifier.parseDuration(AbstractReifier.java:74)
        at org.apache.camel.reifier.AggregateReifier.createAggregator(AggregateReifier.java:138)
        at org.apache.camel.reifier.AggregateReifier.createProcessor(AggregateReifier.java:52)
        at org.apache.camel.reifier.ProcessorReifier.makeProcessor(ProcessorReifier.java:835)
        at org.apache.camel.reifier.ProcessorReifier.addRoutes(ProcessorReifier.java:576)
        at org.apache.camel.reifier.RouteReifier.doCreateRoute(RouteReifier.java:236)
        ... 10 more
Caused by: org.apache.camel.NoTypeConversionAvailableException: No type converter available to convert from type: java.lang.String to the required type: java.time.Duration with value 10000
        at org.apache.camel.impl.converter.CoreTypeConverterRegistry.mandatoryConvertTo(CoreTypeConverterRegistry.java:275)
        at org.apache.camel.impl.converter.CoreTypeConverterRegistry.mandatoryConvertTo(CoreTypeConverterRegistry.java:207)
        at org.apache.camel.support.CamelContextHelper.parse(CamelContextHelper.java:553)
        ... 17 more","davsclaus:1616964907:2021-03-29T04:55:07.659+0000:1616964907:2021-03-29T04:55:07.659+0000:See this FAQ
https://camel.apache.org/manual/latest/faq/how-do-i-use-a-big-uber-jar.html
davsclaus:1616965017:2021-03-29T04:56:57.300+0000:1616965017:2021-03-29T04:56:57.300+0000:it smells like you do not include all the metadata files from META-INF when building fat jar.
In this case its some type converter metadata files that would be missing.
davsclaus:1617059666:2021-03-30T07:14:26.264+0000:1617059666:2021-03-30T07:14:26.264+0000:Okay trying to reproduce, found your code at
https://github.com/ppatierno/formula1-telemetry-kafka

BTW you can use BOM for camel
https://search.maven.org/artifact/org.apache.camel/camel-bom
davsclaus:1617060706:2021-03-30T07:31:46.704+0000:1617060706:2021-03-30T07:31:46.704+0000:So its the jar-with-dependencies goal that assemble a fat jar which causes service files from camel to be overridden.
So when adding camel-main the order of the JARs is shifted and the plugin then causes the services files to be overriden in different order causing it to fail.

So that it worked before, was a ""bit of luck"".
ppatierno:1617061407:2021-03-30T07:43:27.110+0000:1617061407:2021-03-30T07:43:27.110+0000:So what's the best solution in your opinion? Using the maven shade plugin?
davsclaus:1617063066:2021-03-30T08:11:06.350+0000:1617063066:2021-03-30T08:11:06.350+0000:Okay I got something working. Attaching an old fashioned diff file.
davsclaus:1617063186:2021-03-30T08:13:06.153+0000:1617063186:2021-03-30T08:13:06.153+0000:I had to use a custom assembly descriptor where I work around the TypeConverterLoader clash. 

There is 2 JARs generated, but the my-jar works. I think you can twinker with this to make only 1 jar generated and with the name you want.

Then in your source code you have in src/main/resources the TypeConverterLoader file, you can then add missing converters as you need.
I also made you use camel-core-engine so you can trim down the number of camel JARs you need.
davsclaus:1617065298:2021-03-30T08:48:18.368+0000:1617065298:2021-03-30T08:48:18.368+0000:I created a JIRA to research if we can come up with a way to make assembly plugin for fat-jar just work out of the box - as its only the type converter loader files that clashes. The other files are unique folders / names.
davsclaus:1617255169:2021-04-01T13:32:49.822+0000:1617255169:2021-04-01T13:32:49.822+0000:[~ppatierno] in Camel 3.10 onwards you can do this in the pom.xml of that module where you use Camel

{code}
  <build>
    <plugins>
      <plugin>
        <groupId>org.apache.camel</groupId>
        <artifactId>camel-maven-plugin</artifactId>
        <version>${camel.version}</version>
        <executions>
          <execution>
            <goals>
              <goal>prepare-fatjar</goal>
            </goals>
          </execution>
        </executions>
      </plugin>
      <plugin>
        <groupId>org.apache.maven.plugins</groupId>
        <artifactId>maven-assembly-plugin</artifactId>
        <configuration>
          <archive>
            <manifest>
              <mainClass>io.ppatierno.formula1.F1UdpKafkaApp</mainClass>
            </manifest>
          </archive>
        </configuration>
      </plugin>
    </plugins>
  </build>
  {code}

Then the fatjar works - and you can add camel-main and any other Camel JARs and not get in trouble.
ppatierno:1617520628:2021-04-04T15:17:08.352+0000:1617520628:2021-04-04T15:17:08.352+0000:[~davsclaus] that's cool! Is there an ETA for the 3.10 release to be out?
davsclaus:1617573718:2021-04-05T06:01:58.426+0000:1617573718:2021-04-05T06:01:58.426+0000:We aim for may in 5-6 weeks"
0,CAMEL-16418,Bug,Major,"3.7.3, 3.8.0, 3.9.0","3.7.4, 3.10.0","
None
",Resolved,Fixed,"3.7.4, 3.10.0",Claus Ibsen,Samrat Dhillon,0,1,2021-03-28 18:34:40+00:00,2021-03-29 13:55:02+00:00,"Using circuit breaker pattern with camel netty http will result in memory leaks. Netty will report ByteBuff leak as highlighted in the below stack trace. This can be reproduced very easily with a simple route definition (code sample attached). Note that the leak has nothing to do with actual circuit breaker timeouts and will result irrespectively and every time the netty http producer is called. Also it occurs with implementation of camel-reslience4j and camel-microprofile


 


LEAK: ByteBuf.release() was not called before it's garbage-collected. See https://netty.io/wiki/reference-counted-objects.html for more information.


Recent access records: 


#1:


io.netty.handler.codec.http.HttpObjectAggregator$AggregatedFullHttpMessage.release(HttpObjectAggregator.java:379)


       io.netty.util.ReferenceCountUtil.release(ReferenceCountUtil.java:88)


       io.netty.channel.SimpleChannelInboundHandler.channelRead(SimpleChannelInboundHandler.java:106)


    io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379)


    io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365)


      io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:357)


       io.netty.handler.codec.MessageToMessageDecoder.channelRead(MessageToMessageDecoder.java:103)


    io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379)


    io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365)


      io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:357)


       io.netty.handler.codec.MessageToMessageDecoder.channelRead(MessageToMessageDecoder.java:103)


    io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379)


    io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365)


      io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:357)


io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext.fireChannelRead(CombinedChannelDuplexHandler.java:436)


       io.netty.handler.codec.ByteToMessageDecoder.fireChannelRead(ByteToMessageDecoder.java:324)


       io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:296)


       io.netty.channel.CombinedChannelDuplexHandler.channelRead(CombinedChannelDuplexHandler.java:251)


    io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379)


    io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365)


      io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:357)


       io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1410)


    io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379)


    io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365)


       io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:919)


       io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:166)


       io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:719)


       io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:655)


       io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:581)


       io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:493)


       io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:989)


       io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)


       java.base/java.lang.Thread.run(Thread.java:834)


#2:


       io.netty.buffer.AdvancedLeakAwareCompositeByteBuf.retain(AdvancedLeakAwareCompositeByteBuf.java:36)


org.apache.camel.component.netty.http.NettyHttpProducer$NettyHttpProducerCallback.done(NettyHttpProducer.java:123)


       org.apache.camel.component.netty.NettyProducer$NettyProducerCallback.done(NettyProducer.java:555)


  org.apache.camel.component.netty.handlers.ClientChannelHandler.channelRead0(ClientChannelHandler.java:229)


       io.netty.channel.SimpleChannelInboundHandler.channelRead(SimpleChannelInboundHandler.java:99)


    io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379)


    io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365)


      io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:357)


       io.netty.handler.codec.MessageToMessageDecoder.channelRead(MessageToMessageDecoder.java:103)


    io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379)


    io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365)


      io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:357)


       io.netty.handler.codec.MessageToMessageDecoder.channelRead(MessageToMessageDecoder.java:103)


    io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379)


    io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365)


      io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:357)


io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext.fireChannelRead(CombinedChannelDuplexHandler.java:436)


       io.netty.handler.codec.ByteToMessageDecoder.fireChannelRead(ByteToMessageDecoder.java:324)


       io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:296)


       io.netty.channel.CombinedChannelDuplexHandler.channelRead(CombinedChannelDuplexHandler.java:251)


    io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379)


    io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365)


      io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:357)


       io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1410)


    io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379)


    io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365)


       io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:919)


       io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:166)


       io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:719)


       io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:655)


       io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:581)


       io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:493)


       io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:989)


       io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)


       java.base/java.lang.Thread.run(Thread.java:834)


#3:


io.netty.handler.codec.http.HttpObjectAggregator$AggregatedFullHttpMessage.release(HttpObjectAggregator.java:379)


org.apache.camel.component.netty.http.DefaultNettyHttpBinding.toCamelMessage(DefaultNettyHttpBinding.java:332)


org.apache.camel.component.netty.http.handlers.HttpClientChannelHandler.getResponseMessage(HttpClientChannelHandler.java:57)


  org.apache.camel.component.netty.handlers.ClientChannelHandler.channelRead0(ClientChannelHandler.java:178)


       io.netty.channel.SimpleChannelInboundHandler.channelRead(SimpleChannelInboundHandler.java:99)


    io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379)


    io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365)


      io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:357)


       io.netty.handler.codec.MessageToMessageDecoder.channelRead(MessageToMessageDecoder.java:103)


    io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379)


    io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365)


      io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:357)


       io.netty.handler.codec.MessageToMessageDecoder.channelRead(MessageToMessageDecoder.java:103)


    io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379)


    io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365)


      io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:357)


io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext.fireChannelRead(CombinedChannelDuplexHandler.java:436)


       io.netty.handler.codec.ByteToMessageDecoder.fireChannelRead(ByteToMessageDecoder.java:324)


       io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:296)


       io.netty.channel.CombinedChannelDuplexHandler.channelRead(CombinedChannelDuplexHandler.java:251)


    io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379)


    io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365)


      io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:357)


       io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1410)


    io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379)


    io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365)


       io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:919)


       io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:166)


       io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:719)


       io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:655)


       io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:581)


       io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:493)


       io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:989)


       io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)


       java.base/java.lang.Thread.run(Thread.java:834)


#4:


       org.apache.camel.component.netty.NettyConverter.toByteArray(NettyConverter.java:59)


org.apache.camel.component.netty.NettyConverterLoader.lambda$registerConverters$0(NettyConverterLoader.java:29)


       org.apache.camel.support.SimpleTypeConverter.convertTo(SimpleTypeConverter.java:101)


   org.apache.camel.impl.converter.CoreTypeConverterRegistry.doConvertTo(CoreTypeConverterRegistry.java:478)


   org.apache.camel.impl.converter.CoreTypeConverterRegistry.doConvertTo(CoreTypeConverterRegistry.java:356)


     org.apache.camel.impl.converter.CoreTypeConverterRegistry.convertTo(CoreTypeConverterRegistry.java:203)


org.apache.camel.component.netty.http.DefaultNettyHttpBinding.toCamelMessage(DefaultNettyHttpBinding.java:329)


org.apache.camel.component.netty.http.handlers.HttpClientChannelHandler.getResponseMessage(HttpClientChannelHandler.java:57)


  org.apache.camel.component.netty.handlers.ClientChannelHandler.channelRead0(ClientChannelHandler.java:178)


       io.netty.channel.SimpleChannelInboundHandler.channelRead(SimpleChannelInboundHandler.java:99)


    io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379)


    io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365)


      io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:357)


       io.netty.handler.codec.MessageToMessageDecoder.channelRead(MessageToMessageDecoder.java:103)


    io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379)


    io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365)


      io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:357)


       io.netty.handler.codec.MessageToMessageDecoder.channelRead(MessageToMessageDecoder.java:103)


    io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379)


    io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365)


      io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:357)


io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext.fireChannelRead(CombinedChannelDuplexHandler.java:436)


       io.netty.handler.codec.ByteToMessageDecoder.fireChannelRead(ByteToMessageDecoder.java:324)


       io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:296)


       io.netty.channel.CombinedChannelDuplexHandler.channelRead(CombinedChannelDuplexHandler.java:251)


    io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379)


    io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365)


      io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:357)


       io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1410)


    io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379)


    io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365)


       io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:919)


       io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:166)


       io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:719)


       io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:655)


       io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:581)


       io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:493)


       io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:989)


       io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)


       java.base/java.lang.Thread.run(Thread.java:834)


#5:


      io.netty.buffer.AdvancedLeakAwareCompositeByteBuf.getBytes(AdvancedLeakAwareCompositeByteBuf.java:230)


       io.netty.buffer.AdvancedLeakAwareCompositeByteBuf.getBytes(AdvancedLeakAwareCompositeByteBuf.java:36)


       org.apache.camel.component.netty.NettyConverter.toByteArray(NettyConverter.java:57)


org.apache.camel.component.netty.NettyConverterLoader.lambda$registerConverters$0(NettyConverterLoader.java:29)


       org.apache.camel.support.SimpleTypeConverter.convertTo(SimpleTypeConverter.java:101)


   org.apache.camel.impl.converter.CoreTypeConverterRegistry.doConvertTo(CoreTypeConverterRegistry.java:478)


   org.apache.camel.impl.converter.CoreTypeConverterRegistry.doConvertTo(CoreTypeConverterRegistry.java:356)


     org.apache.camel.impl.converter.CoreTypeConverterRegistry.convertTo(CoreTypeConverterRegistry.java:203)


org.apache.camel.component.netty.http.DefaultNettyHttpBinding.toCamelMessage(DefaultNettyHttpBinding.java:329)


org.apache.camel.component.netty.http.handlers.HttpClientChannelHandler.getResponseMessage(HttpClientChannelHandler.java:57)


  org.apache.camel.component.netty.handlers.ClientChannelHandler.channelRead0(ClientChannelHandler.java:178)


       io.netty.channel.SimpleChannelInboundHandler.channelRead(SimpleChannelInboundHandler.java:99)


    io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379)


    io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365)


      io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:357)


       io.netty.handler.codec.MessageToMessageDecoder.channelRead(MessageToMessageDecoder.java:103)


    io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379)


    io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365)


      io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:357)


       io.netty.handler.codec.MessageToMessageDecoder.channelRead(MessageToMessageDecoder.java:103)


    io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379)


    io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365)


      io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:357)


io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext.fireChannelRead(CombinedChannelDuplexHandler.java:436)


       io.netty.handler.codec.ByteToMessageDecoder.fireChannelRead(ByteToMessageDecoder.java:324)


       io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:296)


       io.netty.channel.CombinedChannelDuplexHandler.channelRead(CombinedChannelDuplexHandler.java:251)


    io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379)


    io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365)


      io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:357)


       io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1410)


    io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379)


    io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365)


       io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:919)


       io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:166)


       io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:719)


       io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:655)


       io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:581)


       io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:493)


       io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:989)


       io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)


       java.base/java.lang.Thread.run(Thread.java:834)


#6:


       io.netty.buffer.AdvancedLeakAwareCompositeByteBuf.retain(AdvancedLeakAwareCompositeByteBuf.java:36)


io.netty.handler.codec.http.HttpObjectAggregator$AggregatedFullHttpMessage.retain(HttpObjectAggregator.java:355)


io.netty.handler.codec.http.HttpObjectAggregator$AggregatedFullHttpResponse.retain(HttpObjectAggregator.java:554)


org.apache.camel.component.netty.http.DefaultNettyHttpBinding.toCamelMessage(DefaultNettyHttpBinding.java:327)


org.apache.camel.component.netty.http.handlers.HttpClientChannelHandler.getResponseMessage(HttpClientChannelHandler.java:57)


  org.apache.camel.component.netty.handlers.ClientChannelHandler.channelRead0(ClientChannelHandler.java:178)


       io.netty.channel.SimpleChannelInboundHandler.channelRead(SimpleChannelInboundHandler.java:99)


    io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379)


    io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365)


      io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:357)


       io.netty.handler.codec.MessageToMessageDecoder.channelRead(MessageToMessageDecoder.java:103)


    io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379)


    io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365)


      io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:357)


       io.netty.handler.codec.MessageToMessageDecoder.channelRead(MessageToMessageDecoder.java:103)


    io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379)


    io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365)


      io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:357)


io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext.fireChannelRead(CombinedChannelDuplexHandler.java:436)


       io.netty.handler.codec.ByteToMessageDecoder.fireChannelRead(ByteToMessageDecoder.java:324)


       io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:296)


       io.netty.channel.CombinedChannelDuplexHandler.channelRead(CombinedChannelDuplexHandler.java:251)


    io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379)


    io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365)


      io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:357)


       io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1410)


    io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379)


    io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365)


       io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:919)


       io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:166)


       io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:719)


       io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:655)


       io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:581)


       io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:493)


       io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:989)


       io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)


       java.base/java.lang.Thread.run(Thread.java:834)


#7:


       Hint: 'handler' will handle the message from this point.


       io.netty.buffer.AdvancedLeakAwareCompositeByteBuf.touch(AdvancedLeakAwareCompositeByteBuf.java:36)


io.netty.handler.codec.http.HttpObjectAggregator$AggregatedFullHttpMessage.touch(HttpObjectAggregator.java:367)


io.netty.handler.codec.http.HttpObjectAggregator$AggregatedFullHttpResponse.touch(HttpObjectAggregator.java:560)


io.netty.handler.codec.http.HttpObjectAggregator$AggregatedFullHttpResponse.touch(HttpObjectAggregator.java:494)


       io.netty.channel.DefaultChannelPipeline.touch(DefaultChannelPipeline.java:116)


    io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362)


      io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:357)


       io.netty.handler.codec.MessageToMessageDecoder.channelRead(MessageToMessageDecoder.java:103)


    io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379)


    io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365)


      io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:357)


       io.netty.handler.codec.MessageToMessageDecoder.channelRead(MessageToMessageDecoder.java:103)


    io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379)


    io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365)


      io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:357)


io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext.fireChannelRead(CombinedChannelDuplexHandler.java:436)


       io.netty.handler.codec.ByteToMessageDecoder.fireChannelRead(ByteToMessageDecoder.java:324)


       io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:296)


       io.netty.channel.CombinedChannelDuplexHandler.channelRead(CombinedChannelDuplexHandler.java:251)


    io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379)


    io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365)


      io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:357)


       io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1410)


    io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379)


    io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365)


       io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:919)


       io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:166)


       io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:719)


       io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:655)


       io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:581)


       io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:493)


       io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:989)


       io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)


       java.base/java.lang.Thread.run(Thread.java:834)


#8:


  io.netty.buffer.AdvancedLeakAwareCompositeByteBuf.addComponent(AdvancedLeakAwareCompositeByteBuf.java:920)


       io.netty.handler.codec.MessageAggregator.appendPartialContent(MessageAggregator.java:333)


       io.netty.handler.codec.MessageAggregator.decode(MessageAggregator.java:298)


       io.netty.handler.codec.MessageToMessageDecoder.channelRead(MessageToMessageDecoder.java:88)


    io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379)


    io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365)


      io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:357)


       io.netty.handler.codec.MessageToMessageDecoder.channelRead(MessageToMessageDecoder.java:103)


    io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379)


    io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365)


      io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:357)


io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext.fireChannelRead(CombinedChannelDuplexHandler.java:436)


       io.netty.handler.codec.ByteToMessageDecoder.fireChannelRead(ByteToMessageDecoder.java:324)


       io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:296)


       io.netty.channel.CombinedChannelDuplexHandler.channelRead(CombinedChannelDuplexHandler.java:251)


    io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379)


    io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365)


      io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:357)


       io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1410)


    io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379)


    io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365)


       io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:919)


       io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:166)


       io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:719)


       io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:655)


       io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:581)


       io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:493)


       io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:989)


       io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)


       java.base/java.lang.Thread.run(Thread.java:834)


Created at:


       io.netty.buffer.AbstractByteBufAllocator.compositeDirectBuffer(AbstractByteBufAllocator.java:223)


       io.netty.buffer.AbstractByteBufAllocator.compositeBuffer(AbstractByteBufAllocator.java:201)


       io.netty.handler.codec.MessageAggregator.decode(MessageAggregator.java:271)


       io.netty.handler.codec.MessageToMessageDecoder.channelRead(MessageToMessageDecoder.java:88)


    io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379)


    io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365)


      io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:357)


       io.netty.handler.codec.MessageToMessageDecoder.channelRead(MessageToMessageDecoder.java:103)


    io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379)


    io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365)


      io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:357)


io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext.fireChannelRead(CombinedChannelDuplexHandler.java:436)


       io.netty.handler.codec.ByteToMessageDecoder.fireChannelRead(ByteToMessageDecoder.java:324)


       io.netty.handler.codec.ByteToMessageDecoder.fireChannelRead(ByteToMessageDecoder.java:311)


       io.netty.handler.codec.ByteToMessageDecoder.callDecode(ByteToMessageDecoder.java:432)


       io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:276)


       io.netty.channel.CombinedChannelDuplexHandler.channelRead(CombinedChannelDuplexHandler.java:251)


    io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379)


    io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365)


      io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:357)


       io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1410)


    io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379)


    io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365)


       io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:919)


       io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:166)


       io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:719)


       io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:655)


       io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:581)


       io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:493)


       io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:989)


       io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)


       java.base/java.lang.Thread.run(Thread.java:834)",
0,CAMEL-16417,New Feature,Minor,3.8.0,3.10.0,"
None
",Resolved,Fixed,3.10.0,Unassigned,Jesse Gorzinski,0,2,2021-03-27 17:35:18+00:00,2021-05-03 13:31:02+00:00,"The JT400 component has the new feature (last year) to send and receive messages from IBM i message queues.


That support is great, but it lacks a feature that has been a common need in several use cases I have encountered. Ot would be very useful if Camel could receive a message, do some processing, and reply to the message. In its current form, the Camel endpoint can only send a new message to the queue, not reply to a received message.


 


I will happily work on this, so feel free to assign to me.","ThePrez:1616837910:2021-03-27T17:38:30.521+0000:1616837910:2021-03-27T17:38:30.521+0000:[https://issues.apache.org/jira/projects/CAMEL/issues/CAMEL-15170]

For reference, this is where the new message queue support was added

 
davsclaus:1616909293:2021-03-28T13:28:13.501+0000:1616909293:2021-03-28T13:28:13.501+0000:Yes sure Jesse, you are welcome to work on this.

"
0,CAMEL-16416,Dependency upgrade,Major,None,None,"
None
",Resolved,Fixed,3.10.0,Unassigned,Marat Gubaidullin,0,1,2021-03-26 16:41:31+00:00,2021-03-28 13:26:33+00:00,No Desc,
0,CAMEL-16415,Task,Major,None,None,"
None
",Resolved,Cannot Reproduce,None,Unassigned,Guillaume Nodet,0,1,2021-03-26 15:22:33+00:00,2022-09-02 17:47:04+00:00,No Desc,
0,CAMEL-16414,Improvement,Major,"2.25.3, 3.8.0",3.10.0,"
None
",Resolved,Fixed,3.10.0,Ramu,Jens Kordowski,0,4,2021-03-26 15:01:50+00:00,2021-04-14 08:03:46+00:00,"The kafka producer supports the possibility to pass on a (custom) timestamp with the record. The camel-kafka component does not leverage this, currently. A Camel header seems like a good option to provide this. The consumer already creates a kafka.TIMESTAMP header (not yet documented). I suggest to use a different header to avoid misconfiguration in case of ""kafka to kafka"" scenarios. kafka.OVERRIDE_TIMESTAMP (being a one-time header) looks like a good idea, similar to the existing kafka.OVERRIDE_TOPIC.


What do you think?","davsclaus:1616909242:2021-03-28T13:27:22.775+0000:1616909242:2021-03-28T13:27:22.775+0000:Yes you are welcome to work on a PR
Mahas_M:1617860740:2021-04-08T13:45:40.381+0000:1617860740:2021-04-08T13:45:40.381+0000:Hi I'm Mahas Milhar can i start this project?

 
ramu11:1617862119:2021-04-08T14:08:39.689+0000:1617862119:2021-04-08T14:08:39.689+0000:Hi
 it is done.i have already raised pull request.

jenskordowski:1618289988:2021-04-13T12:59:48.469+0000:1618289988:2021-04-13T12:59:48.469+0000:I just checked the PR, thanks for providing it. I have an improvement proposal though. It requires a java.lang.Long as datatype. In a lot of cases headers are sent as text (String), for instance sending a header via some rest client to a route. Do you want me to add a new improvement item for this? (I can provide the PR also myself, just a little short on time currently. Maybe someone picks it up in the meantime.)
ramu11:1618333805:2021-04-14T01:10:05.408+0000:1618333805:2021-04-14T01:10:05.408+0000:[~jenskordowski]  we have discussed accepting date in String format. But kafkaProducer class accepts time in Long format.

so we have to do lot of transformations depending on the input time format. There are lot of time formats we can set in String and it does eventually adds complexity at camel-kafka side. 

Please raise a new Jira with the Improvement to provide time as string format. In this case camel-kafka should have a utility/helper method to convert string date format to Long format . Helper method should accept all existing time formats and have a logic to convert to Long

Coming to other question ,if any jira in un assigned state. any body can own and work. if you want to work on jira own
and change to inprogress.

If you can not own jira,then at least update the jira saying working on the jira so that others know some body is already working




jenskordowski:1618358626:2021-04-14T08:03:46.970+0000:1618358626:2021-04-14T08:03:46.970+0000:Hi Ramu,

my suggestion is not to support different date / time formats, but support a long of datatype string. not a lot of conversion necessary to support this. I will raise a new improvement item later today."
0,CAMEL-16413,Bug,Major,3.8.0,3.10.0,"
None
",Resolved,Fixed,3.10.0,Claus Ibsen,Suneet Kumar,0,2,2021-03-26 14:56:30+00:00,2021-03-31 13:09:01+00:00,"During shutdown process, whenever a partition is revoked, `onPartitionsRevoked` method is called, which is forcing `commitSync`  even when `autoCommitOnStop` is set to none.


 


```


 DEBUG org.apache.camel.component.kafka.KafkaConsumer: - onPartitionsRevoked: **-Thread 0 from topic **


DEBUG org.apache.camel.component.kafka.KafkaConsumer: - Forcing commitSync **-Thread 0 from topic ** with offset: 31621


```","davsclaus:1616909331:2021-03-28T13:28:51.182+0000:1616909331:2021-03-28T13:28:51.182+0000:Try with Camel 3.9.0 where we have fixed and improved the kafka component.
davsclaus:1617146452:2021-03-31T07:20:52.769+0000:1617146452:2021-03-31T07:20:52.769+0000:Ah I looked in the code, and yes we should make camel-kafka commit accordingly to the autoCommitOnStop configuration option.

Thanks for reproting.
suneetk92:1617166145:2021-03-31T12:49:05.674+0000:1617167011:2021-03-31T13:03:31.005+0000:Yes, it was still causing issue in 3.9.0.

I was trying to fix it, but seems like you have already fixed it.:)

 

Do you mind sharing the Pull Request id?
davsclaus:1617166494:2021-03-31T12:54:54.608+0000:1617166613:2021-03-31T12:56:53.791+0000:https://github.com/apache/camel/commit/73c674b54df5ff741939629abd4564583f98c199

and

https://github.com/apache/camel/commit/f9b1a3da477ccb3989bc67f6aa8a10f344d6321a
suneetk92:1617166937:2021-03-31T13:02:17.030+0000:1617166970:2021-03-31T13:02:50.621+0000:Here, it is checking both isStoppingOrStopped() and isSuspendingOrSuspended()
 [https://github.com/apache/camel/blob/73c674b54df5ff741939629abd4564583f98c199/components/camel-kafka/src/main/java/org/apache/camel/component/kafka/KafkaConsumer.java#L339]

 

So, shouldn't 
 boolean stopping = isStoppingOrStopped() || isSuspendingOrSuspended();
davsclaus:1617167341:2021-03-31T13:09:01.629+0000:1617167341:2021-03-31T13:09:01.629+0000:Yeah its actually better to check for !isRunAllowed so I am doing a new commit for that."
0,CAMEL-16412,Bug,Minor,"3.7.3, 3.8.0","3.7.4, 3.10.0","
None
",Resolved,Fixed,"3.7.4, 3.10.0",Claus Ibsen,Remco Schoen,0,2,2021-03-26 14:25:46+00:00,2021-03-29 05:49:27+00:00,"We are using environment variables in our Location of the propertiesPlaceholder to control the location of our properties during the different stages of our deployments, according to his doc:


https://camel.apache.org/manual/latest/using-propertyplaceholder.html#UsingPropertyPlaceholder-UsingSystemandEnvironmentVariablesinLocations.


<propertiesLocation resolver=""file"" path=""${env.SECRETS_LOCATION}/tif.secrets""/>


This now results in a FileNotFoundException:


 




Caused by: java.io.FileNotFoundException: ${env:SECRETS_LOCATION}/tif.secrets (No such file or directory)Caused by: java.io.FileNotFoundException: ${env:SECRETS_LOCATION}/tif.secrets (No such file or directory) at java.base/java.io.FileInputStream.open0(Native Method) at java.base/java.io.FileInputStream.open(FileInputStream.java:219) at java.base/java.io.FileInputStream.<init>(FileInputStream.java:157) at java.base/java.io.FileInputStream.<init>(FileInputStream.java:112) at org.apache.camel.component.properties.FilePropertiesSource.loadPropertiesFromLocation(FilePropertiesSource.java:51) ... 63 more



 


I think the change in CAMEL-15781 causes this.


 


A workaround is to replace ""env:"" with ""env."".",
0,CAMEL-16411,Task,Major,None,None,"
None
",Resolved,Cannot Reproduce,None,Unassigned,Guillaume Nodet,0,1,2021-03-26 14:12:42+00:00,2022-09-02 17:46:55+00:00,No Desc,
0,CAMEL-16410,Bug,Minor,3.8.0,3.10.0,"
None
",Resolved,Fixed,3.10.0,Claus Ibsen,Sylvain Dusart,0,2,2021-03-26 11:44:01+00:00,2021-03-29 09:00:42+00:00,"With the following route (defined in Groovy) :




ZipFileDataFormat zipFile = new ZipFileDataFormat()
zipFile.setUsingIterator(true)

from(""file:/path/to/zippedInput?antInclude=*.zip&delete=true"")
                        .log('Detected file ""${headers.CamelFileAbsolutePath}""')
                        .unmarshal(zipFile)
                        .split(bodyAs(Iterator)).streaming()
                        .to(""file:/path/to/target/dir"")
                        .log('Extracted file ""${headers.CamelFileName}"" to ""${headers.CamelFileNameProduced}""')
                        .end()




no error is thrown when an invalid zip file (empty file or any data file) is treated.


The correction applied to CAMEL-14748 works only when usingIterator is false in org.apache.camel.dataformat.zipfile.ZipFileDataFormat#unmarshal.","sdusart:1616730752:2021-03-26T11:52:32.440+0000:1616730752:2021-03-26T11:52:32.440+0000:I think the problem is present in camel-tarfile too byt I did not tried to reproduce it.
davsclaus:1616979642:2021-03-29T09:00:42.003+0000:1616979642:2021-03-29T09:00:42.003+0000:Fixed tarfile too."
0,CAMEL-16409,Task,Major,None,None,"
None
",Resolved,Fixed,3.10.0,Andrea Cosentino,Claus Ibsen,0,1,2021-03-26 10:07:16+00:00,2021-03-26 13:40:59+00:00,"It seems its a copy/paste for the google-storage component. 


It should be


Manage and invoke Google Cloud Functions",
0,CAMEL-16408,Improvement,Major,None,3.10.0,"
None
",Resolved,Cannot Reproduce,3.10.0,Unassigned,Claus Ibsen,0,1,2021-03-26 08:17:48+00:00,2021-03-26 11:05:07+00:00,"We should filter out all Camel* headers, but it ends up being included as HTTP header


    ""headers"": 

{
        ""camelhttpmethod"": ""GET"",
        ""content-length"": ""9"",
        ""host"": ""localhost:8080""
    }

,",
0,CAMEL-16407,Bug,Major,3.9.0,3.10.0,"
None
",Resolved,Fixed,3.10.0,Jeremy Ross,Jeremy Ross,0,2,2021-03-25 23:28:23+00:00,2021-04-15 05:32:17+00:00,No Desc,"jeremyross:1616686622:2021-03-25T23:37:02.549+0000:1616686721:2021-03-25T23:38:41.732+0000:[~davsclaus] Pushed a commit for this. Any way we can get this in 3.9.0?
davsclaus:1616707011:2021-03-26T05:16:51.207+0000:1616707011:2021-03-26T05:16:51.207+0000:No we cannot
davsclaus:1616909607:2021-03-28T13:33:27.091+0000:1616909607:2021-03-28T13:33:27.091+0000:Its strange if you have problems again. As the lifecycle when calling start() ensures that the right phases are invoked, eg build, init, start. So doBuild should be invoked if you call start() etc, if not already started, or build or init phase has been triggered beforehand.

Do you have any kind of reproducer, as we want to optimize the camel components to do their build/init ""stuff"" earlier than in start phase."
0,CAMEL-16406,Task,Major,None,3.10.0,"
None
",Resolved,Fixed,3.10.0,Andrea Cosentino,Andrea Cosentino,0,1,2021-03-25 14:17:52+00:00,2021-03-26 13:29:07+00:00,No Desc,
0,CAMEL-16405,New Feature,Major,2.23.2,3.10.0,"
None
",Resolved,Fixed,3.10.0,Unassigned,Anand Kumar,0,2,2021-03-25 13:23:36+00:00,2021-04-06 05:47:55+00:00,"Hi


we are trying queryTimeout for sql-stored component.


For each sql-stored component call, we wanted to set queryTImeout but not able to achieve as queryTimeout option not available as options","anand311010g:1616650078:2021-03-25T13:27:58.497+0000:1616650078:2021-03-25T13:27:58.497+0000:Getting below error. Tried with below approaches

 

Caused by: org.apache.camel.ResolveEndpointFailedException: Failed to resolve endpoint: *sql-stored://classpath:sql/stored-proc.sql?dataSource=%23dataSource&template.queryTimeout=3* due to: There are 1 parameters that couldn't be set on the endpoint. Check the uri if the parameters are spelt correctly and that they are properties of the endpoint. Unknown parameters=[\{template.queryTimeout=3}]

Caused by: org.apache.camel.ResolveEndpointFailedException: Failed to resolve endpoint: *sql-stored://classpath:sql/stored-proc.sql?dataSource=%23dataSource&templateOptions.queryTimeout=3* due to: There are 1 parameters that couldn't be set on the endpoint. Check the uri if the parameters are spelt correctly and that they are properties of the endpoint. Unknown parameters=[\{template.queryTimeout=3}]
acosentino:1616650341:2021-03-25T13:32:21.313+0000:1616650341:2021-03-25T13:32:21.313+0000:There is no queryTimeout option on those components. By the way this is a question, so ask on the users mailing list or on chat.
anand311010g:1616656876:2021-03-25T15:21:16.543+0000:1616656876:2021-03-25T15:21:16.543+0000:HI [~cibsen@e-ma.net]

I have raised Jira as Improvement as per your suggestion

http://camel.465427.n5.nabble.com/camel-sql-stored-component-queryTimeout-option-not-present-td5915586.html#a5915595"
0,CAMEL-16404,Improvement,Major,None,3.11.0,"
None
",Resolved,Won't Fix,3.11.0,Unassigned,Claus Ibsen,0,2,2021-03-25 12:19:47+00:00,2021-06-09 13:55:48+00:00,"Instead of allowing to define both routes and route templates in a RouteTemplate (too many things).


Then we may want to have a special RouteTemplateBuilder that has a subset DSL that are tailored for route templates.


This also helps discovery of route templates, as you can look for RouteTemplateBuilder instances. And ensure they are discovered before regular routes etc.","klease78:1623160195:2021-06-08T21:49:55.584+0000:1623160195:2021-06-08T21:49:55.584+0000:[~davsclaus] Is the idea to create a class such as RouteTemplatesConfigurer which would search for and load only route template definition builders, analogous to the RoutesConfigurer?  Or add a configureRouteTemplates method to RoutesConfigurer?
These new RouteTemplateBuilders would handle only the routesTemplate DSL (in java, xml or yaml) and the current XXXRoutesBuilderLoader implementations would no longer handle routesTemplate but only routes and rests.
Do I have the correct understanding of your idea?
davsclaus:1623218143:2021-06-09T13:55:43.347+0000:1623218143:2021-06-09T13:55:43.347+0000:Lets move this to later as this is not a problem anymore at this moment, and lets get 3.11 to be stable as LTS."
0,CAMEL-16403,Improvement,Major,None,4.x,"
None
",Open,Unresolved,4.x,Unassigned,Claus Ibsen,0,2,2021-03-25 11:52:42+00:00,2023-08-09 09:21:04+00:00,"With SensitiveUtils we know have a full list of known property names that are sensitive.
We can use this in endpoint uri parsing to know that its value should be used as-is (eg like it was RAW( ))


Thought with RAW() there is still some decoding due to URI invalid chars, eg you can't have special chars in the uri, so they get decimal encoded. 


Another approach: We could also just generate a random uuid as placeholder for the value, which is backed in some internal registry/vault which then is used to lookup the actual value, when in use.


However the uri may be used to call external service, like a http / ftp with username:password combination, so you may want an uri representation with the actual value. Likewise if there is some api tokens in the uri.",
0,CAMEL-16402,Task,Major,None,,"
None
",Resolved,Invalid,None,Unassigned,Evgeny,0,2,2021-03-25 08:38:05+00:00,2021-03-25 09:55:05+00:00,"When I reading csv files in split,  I need to get get field names and calculate index for each name. It's OK via groovy.


I try to store indexes in some heades. I need it because csv file coud contain fields in arbitrary order. 


In one file: name, ID, address...


In other file: ID, address, name...


<when>


<simple>${headers[CamelSplitIndex]} == 0</simple>


<transform>


<groovy>


<![CDATA[


String[] AllData = exchange.getIn().getBody().split(';');


//some processing


//and store to headers for next using


//for case name, ID, address...


exchange.getIn().getHeaders().put(""Name"", NameValue); //0


exchange.getIn().getHeaders().put(""ID"", IDValue); //1


exchange.getIn().getHeaders().put(""Address"", AddressValue); //2
]]>


</groovy>


</transform>


I use index for each field, to get correct value when I going to insert in database.


But each time split (new step) read new line from csv file, headers a lost their value.


While ${headers[CamelSplitIndex]} == 0 headers contain fields index.


But when  ${headers[CamelSplitIndex]} > 0 all headers loose the info.


How to create real global variables, which will be avialable in any <when> cases and slplit steps?","davsclaus:1616632951:2021-03-25T08:42:31.190+0000:1616632951:2021-03-25T08:42:31.190+0000:Ask for help on the user mailing list, or the chat room first.
Zelezny:1616637007:2021-03-25T09:50:07.814+0000:1616637007:2021-03-25T09:50:07.814+0000:OK.
Zelezny:1616637305:2021-03-25T09:55:05.393+0000:1616637305:2021-03-25T09:55:05.393+0000:I'm a new in camel apache and before worked as back-end developer.
With programming languages like C/C++, C# alway could get info about ara of visibility for variables. 
For current problem I coudn't find info.

A have some suggestion about this already.
May you tell me about headers area of visibility, please. It will strongly help me with camel in future."
0,CAMEL-16401,Bug,Minor,None,3.10.0,"
None
",Resolved,Fixed,3.10.0,Luca Burgazzoli,Luca Burgazzoli,0,1,2021-03-25 08:22:08+00:00,2021-03-25 11:08:37+00:00,No Desc,
0,CAMEL-16400,Improvement,Major,None,3.10.0,"
None
",Resolved,Fixed,3.10.0,Otavio Rodolfo Piske,Claus Ibsen,0,2,2021-03-24 17:27:44+00:00,2021-06-15 14:44:36+00:00,"We should seperate our tests into unit and integration tests.


The integration tests are dominatingly the tests that uses test containers.


This can be done by



maven surefire plugin phase test (unit test) and verify (integration)
naming test classes as *Test.java (unit test) and *IT.java (integration)



The naming is important as its the surefire plugin that is configured the run tests in those two phases where it filters by name - source code are in the same src/test/java folder.


So we can start by trying this on one camel component first



rename the tests
make surefire plugin run test vs verify phase accordingly (may need to configure in some parent/root pom)



And then review and then repeat for the other components.","orpiske:1618374413:2021-04-14T12:26:53.063+0000:1618374413:2021-04-14T12:26:53.063+0000:The following issue will become invalid once camel-pulsar is split (it probably already is, due to the migration to test-infra): https://issues.apache.org/jira/browse/CAMEL-13454
orpiske:1618804437:2021-04-19T11:53:57.870+0000:1618804437:2021-04-19T11:53:57.870+0000:Almost done w/ it. All components were modified. For now, only the final cleanup remains to be done.
davsclaus:1618828863:2021-04-19T18:41:03.605+0000:1618828863:2021-04-19T18:41:03.605+0000:Great work Otavio
orpiske:1618887823:2021-04-20T11:03:43.578+0000:1618887823:2021-04-20T11:03:43.578+0000:[~davsclaus] thanks!

 

I think we can keep this one open for just a few more days, while I go through the CI tests and make sure everything is working. I've already pushed some fixes today, but subsequent ones will have to wait today's test.
davsclaus:1619829131:2021-05-01T08:32:11.382+0000:1619829131:2021-05-01T08:32:11.382+0000:Is there more work to do here?
orpiske:1619829380:2021-05-01T08:36:20.495+0000:1619829380:2021-05-01T08:36:20.495+0000:[~davsclaus] I think we can close this one. The tests for all the components have been split."
0,CAMEL-16399,Task,Minor,None,4.x,"
None
",Open,Unresolved,4.x,Andrea Cosentino,Andrea Cosentino,0,1,2021-03-24 14:31:49+00:00,2023-08-09 09:21:09+00:00,No Desc,
0,CAMEL-16398,Task,Major,None,3.10.0,"
None
",Resolved,Fixed,3.10.0,Andrea Cosentino,Andrea Cosentino,0,1,2021-03-24 14:24:17+00:00,2021-03-24 14:30:49+00:00,No Desc,
0,CAMEL-16397,Improvement,Major,None,3.10.0,"
None
",Resolved,Fixed,3.10.0,Claus Ibsen,Claus Ibsen,0,1,2021-03-24 12:56:06+00:00,2021-03-24 17:44:50+00:00,"We should use the jsonpath idiom style they use for setting up jsonpath and evaluate and get the result.


They favour using


return JsonPath.using(configuration).parse(str).read(path);",
0,CAMEL-16396,Bug,Major,None,3.10.0,"
None
",Resolved,Fixed,3.10.0,James Netherton,James Netherton,0,1,2021-03-24 12:25:51+00:00,2021-03-26 13:23:07+00:00,"CAMEL-15585 subtly changed the behaviour of HealthCheckRegistryRepository.matchConfiguration, where it now attempts to match the health check configuration based on the id of the parent check.


https://github.com/apache/camel/blob/41e5be070279a77aec13b8aba7c387015b75bccc/core/camel-health/src/main/java/org/apache/camel/impl/health/HealthCheckRegistryRepository.java#L114


The original implementation of iterating over the configuration keys and using the key as a match works correctly. So this code should be restored. E.g this:


https://github.com/apache/camel/blob/camel-3.5.0/core/camel-health/src/main/java/org/apache/camel/impl/health/HealthCheckRegistryRepository.java#L111-L120",
0,CAMEL-16395,Improvement,Major,None,3.10.0,"
None
",Resolved,Fixed,3.10.0,James Netherton,James Netherton,0,2,2021-03-24 09:51:38+00:00,2021-03-25 14:47:51+00:00,"I noticed there's some non-deterministic behaviour going on with the Camel health check config in camel-main. Consider the following configuration to disable the 'netty' route from the RouteHealthCheck:


camel.health.config[netty].enabled = true
camel.health.config[timer].enabled = false


In BaseMainSupport there is this logic:


https://github.com/apache/camel/blob/master/core/camel-main/src/main/java/org/apache/camel/main/BaseMainSupport.java#L989


Depending on the order in which the config properties are processed, RoutesHealthCheckRepository will either be enabled or disabled.


I think the code on line 989 in BaseMainSupport support is not required. I think it's enough to just add the configuration like here:


https://github.com/apache/camel/blob/master/core/camel-main/src/main/java/org/apache/camel/main/BaseMainSupport.java#L990","davsclaus:1616579207:2021-03-24T17:46:47.502+0000:1616579207:2021-03-24T17:46:47.502+0000:Ah good catch, you are welcome to fix this."
0,CAMEL-16394,New Feature,Major,None,3.10.0,"
None
",Resolved,Fixed,3.10.0,Claus Ibsen,Luca Burgazzoli,0,4,2021-03-24 08:27:01+00:00,2021-05-05 18:04:54+00:00,"Now that we have route templates and kamelets, we should explore the option to have route local beans in addition to route local properties. This would be very useful when dealing with EIPs or endpoints that require specific beans.


As example, assuming I have the following template:




routeTemplate()
  .from(""direct:start"")
  .to(""aws2-s3:...?amazonS3Client=#myClient"")




Then myClient need to be created at global scope and there's no way to create one that is specific for the template.


We should provide something like:




routeTemplate()
    .templateParameter(""region"")
    .templateParameter(""bucket"")
    .configure((RouteTemplateContext context) -> { 
        // the lambda mechanism here is used as illustration
        // purpose to stress the fact that the materialization
        // of beans should be delayed till the route is reified
        context.bind(
            ""myClient"", 
            S3Client.builder()
                .region(context.getProperty(""region""))
                .build()
        );
    })
    .from(""direct:start"")
    .to(""aws2-s3:{{bucket}}?amazonS3Client=#myClient"")




So when the route is materialized, the configure method is invoked, the myClient bean is registered to the current template context and retrieved by the reifier to materialize the route.","davsclaus:1620109981:2021-05-04T14:33:01.945+0000:1620109981:2021-05-04T14:33:01.945+0000:Yeah this is great for Java DSL, I wonder for other DSLs like YAML DSL if we can come up with a way of configuring that bean/code that should happen.
But let take one battle at a time.

davsclaus:1620110386:2021-05-04T14:39:46.990+0000:1620163300:2021-05-05T05:21:40.899+0000:TODO: TemplatedRouteBuilder bind method (local override) *DONE*
TODO: RouteTemplateDefinition bind method (local override) *DONE*
davsclaus:1620114289:2021-05-04T15:44:49.995+0000:1620114664:2021-05-04T15:51:04.326+0000:TODO: Adding ThreadLocal to DefaultRegistry to have the override capability but we need to optimize as thread local would only be used during route templates *DONE*
davsclaus:1620162022:2021-05-05T05:00:22.467+0000:1620185895:2021-05-05T11:38:15.984+0000:TODO: If local bean then property placeholders with its key should be made unique via a hash value as otherwise endpoint uris may be computed with old value and used existing from endpoint registry, eg to(""bean:{{myBar}}"") *DONE*
davsclaus:1620185941:2021-05-05T11:39:01.620+0000:1620189907:2021-05-05T12:45:07.454+0000:TODO: local bean binding as supplier (only eval once) eg if #myClient is used 2 times in the template, then you want to refer to the same bean instance, despite the supplier is used to create it. *DONE*
davsclaus:1620189913:2021-05-05T12:45:13.806+0000:1620196570:2021-05-05T14:36:10.071+0000:TODO: Documentation *DONE*"
0,CAMEL-16393,Bug,Major,2.25.3,"2.25.4, 3.4.6, 3.7.4, 3.10.0","
None
",Resolved,Information Provided,"2.25.4, 3.4.6, 3.7.4, 3.10.0",Claus Ibsen,Stefano Linguerri,0,3,2021-03-23 17:24:38+00:00,2021-03-24 17:44:40+00:00,"The first result from $.concat(...) seems to be ""cached""


Eg, given json:


{{

{""payload"": \{""id"": 1, ""first_name"": ""Marie"", ""last_name"": ""Rose"" }

 }}}


The expression:


jsonpath(""$.concat($.payload.first_name,\"" \"",$.payload.last_name)"")


Will always returns Marie Rose on following calls with different values in the input json.


Please find attached reproducer maven project with junit test.","acosentino:1616491887:2021-03-23T17:31:27.325+0000:1616491887:2021-03-23T17:31:27.325+0000:For the moment I set the fix version to all the active branches, lets check.
davsclaus:1616552954:2021-03-24T10:29:14.162+0000:1616552954:2021-03-24T10:29:14.162+0000:Its possible that its a bug in the concat function
davsclaus:1616557664:2021-03-24T11:47:44.159+0000:1616557664:2021-03-24T11:47:44.159+0000:Yes its a bug in jsonpath library and its concat function
davsclaus:1616559239:2021-03-24T12:13:59.077+0000:1616579080:2021-03-24T17:44:40.479+0000:Okay its a bug in jsonpath, reported in their issue tracker
https://github.com/json-path/JsonPath/issues/680
davsclaus:1616559770:2021-03-24T12:22:50.144+0000:1616559770:2021-03-24T12:22:50.144+0000:Do not use the concat function, its also not really documented on their website page (so you found it somewhere elsewhere)
davsclaus:1616579067:2021-03-24T17:44:27.339+0000:1616579067:2021-03-24T17:44:27.339+0000:I have added a WARN on the camel jsonpath documentation page about the concat function has a bug, with reference to this JIRA ticket.

There is nothing we can do in Camel itself. There is a suggested workaround in the docs."
0,CAMEL-16392,Improvement,Major,None,None,"
None
",Resolved,Fixed,3.12.0,Andrea Cosentino,Andrea Cosentino,0,1,2021-03-23 16:00:29+00:00,2021-08-24 05:30:32+00:00,"Currently you can only pass a pulsar client, without the possibility of creating the client from parameters. It's really limitating from kamelet pov.",
0,CAMEL-16391,Improvement,Minor,None,None,"
None
",Resolved,Fixed,3.10.0,James Netherton,James Netherton,0,1,2021-03-23 13:46:44+00:00,2021-03-29 14:33:54+00:00,"I did a quick revisit of camel-microprofile-health and noticed a few things that can be tidied up. The initial implementation pre-dates some of the improvements that were made to the Camel Health APIs, so some stuff is now obsolete. So I'd like to:



Deprecate and eventually remove CamelMicroProfileLivenessCheck / CamelMicroProfileReadinessCheck as AbstractHealthCheck provides its own methods for marking a check as exclusively for liveness or readiness.




Remove CamelMicroProfileContextCheck as there's a similar thing already in camel-health",
0,CAMEL-16390,New Feature,Major,3.9.0,3.11.0,"
None
",Resolved,Implemented,3.11.0,Jeremy Ross,Jeremy Ross,1,2,2021-03-23 13:31:49+00:00,2021-06-19 19:03:32+00:00,"This will be a new `raw` operation that allows users to specify URL, URL parameters, http body, and http method. This will allow a lot more flexibility in using the salesforce APIs with raw payloads.",
0,CAMEL-16389,Task,Major,None,None,"
None
",Resolved,Fixed,3.10.0,Colm O hEigeartaigh,Colm O hEigeartaigh,0,2,2021-03-23 12:49:18+00:00,2023-02-15 04:31:42+00:00,"There is a issue in json-smart, and the project appears not to be updated any longer: https://github.com/json-path/JsonPath/issues/676


It's used in two components:
 * camel-chunk - Appears to be no longer needed
 * camel-jsonpath - I propose to swap it out to use Jackson instead via https://github.com/json-path/JsonPath/blob/master/README.md#jsonprovider-spi","davsclaus:1616475372:2021-03-23T12:56:12.986+0000:1616475372:2021-03-23T12:56:12.986+0000:Colm, there was already ticket CAME-16375
coheigea:1616476737:2021-03-23T13:18:57.107+0000:1616476737:2021-03-23T13:18:57.107+0000:Oops, sorry about that."
0,CAMEL-16388,Wish,Major,3.8.0,3.12.0,"
None
",Resolved,Fixed,3.12.0,Jeremy Ross,Jeremy Ross,0,4,2021-03-22 23:28:33+00:00,2021-09-21 17:22:45+00:00,"Putting this out here for a discussion. 


The salesforce REST APIs support XML and JSON. However, it's clear from the official documentation and examples that JSON is the first-class citizen. All the examples are in JSON and there's only this one, sad reference to XML serialization:  


XML serialization is similar to SOAP API. XML requests are supported in UTF-8 and UTF-16, and XML responses are provided in UTF-8.


This leaves us Camel maintainers with the not-fun activity of guessing how salesforce expects its myriad types to be serialized to XML. 


I suspect that Camel users don't really care that much which serialization format is used. Both have equal parity with salesforce, and as a Camel user I just care that Camel serializes and deserializes my DTOs correctly. Wire format is an abstraction that shouldn't matter. This is the crux of my argument.


Camel's support for both formats is a maintenance burden, and a barrier to developing future features and support for newer APIs. Serialization format isn't a concern to users, and supporting both formats is of no real value. Therefore, I'd like to consider dropping XML support, leaving JSON as the supported format.


Note that this does not affect the `rawPayload` option. Users would still be welcome to provide their own raw payloads in either format. 


Paging for comment: zregvart davsclaus jbonofre","davsclaus:1616447666:2021-03-23T05:14:26.235+0000:1616447666:2021-03-23T05:14:26.235+0000:Fine with me, the more we can make this component easier to maintain the better.
jeremyross:1616476678:2021-03-23T13:17:58.507+0000:1616476678:2021-03-23T13:17:58.507+0000:One minor correction. XML does *not* have parity with JSON in some of the salesforce APIs, e.g., plain composite supports JSON only. 
zregvart:1616638684:2021-03-25T10:18:04.463+0000:1616638684:2021-03-25T10:18:04.463+0000:+1, we can do this in a minor version right after a LTS version has been released. This also eliminates the need for xstream and simplifies the code paths quite a bit.
jawwad124:1616660046:2021-03-25T16:14:06.324+0000:1616660069:2021-03-25T16:14:29.050+0000:We have been working on Salesforce integration with SAP. As SAP is the old system we had to use XML formats, which is why most of the integration is written in XML format. 

Going to watch this ticket to see what you guys finalize (y)
jeremyross:1616663180:2021-03-25T17:06:20.293+0000:1616663180:2021-03-25T17:06:20.293+0000:[~jawwad124] You can continue to use XML for SAP. This issue just concerns the serialization format for the salesforce APIs. 
zregvart:1616718619:2021-03-26T08:30:19.112+0000:1616718619:2021-03-26T08:30:19.112+0000:[~jawwad124] inform our decision, it would be good to explain a bit your use cases. Do you use data transfer objects (DTOs) generated by the camel-salesforce-maven-plugin, or pass through the raw XML? Do you rely on the DTOs being able to serialize to XML?
jawwad124:1617169459:2021-03-31T13:44:19.870+0000:1617169487:2021-03-31T13:44:47.213+0000:Hi [~zregvart]

In my case we have SAP sending data in XML format (SOAP). Then we use XSLT to transform SOAP payload to directly map to Salesforce DTO compatible XML's. As we don't have raw format support in some cases then we map these XML's using XStream on to DTO and send them over as JSON.
zregvart:1617172860:2021-03-31T14:41:00.746+0000:1617172860:2021-03-31T14:41:00.746+0000:[~jawwad124] do you think in your use case you can utilize mapping technology instead? We have several mapping components in Camel that could help you. Dozer and Atlasmap spring to mind first.
jeremyross:1617175396:2021-03-31T15:23:16.287+0000:1617175396:2021-03-31T15:23:16.287+0000:[~jawwad124] We have a new raw operation planned (CAMEL-16390) that should allow you to continue to use XML. Would that work for you?
jawwad124:1617179818:2021-03-31T16:36:58.535+0000:1617179818:2021-03-31T16:36:58.535+0000:Yes raw operation should work for me. Or I will explore Atlasmap where I need alternative mappings. Thanks. For now I guess raw will work fine.
davsclaus:1617338252:2021-04-02T12:37:32.335+0000:1617338252:2021-04-02T12:37:32.335+0000:Okay let's deprecate XML in 3.10, and then remove it after next LTS.
davsclaus:1631920278:2021-09-18T07:11:18.486+0000:1631920278:2021-09-18T07:11:18.486+0000:[~jeremyross] are you able to work on this?
jeremyross:1631945766:2021-09-18T14:16:06.408+0000:1631945766:2021-09-18T14:16:06.408+0000:[~davsclaus] sure. We added deprecation warnings in 3.11.0. Ok to to remove XML support for 3.12?
davsclaus:1631950357:2021-09-18T15:32:37.268+0000:1631950357:2021-09-18T15:32:37.268+0000:Yeah sure"
0,CAMEL-16387,Task,Major,None,3.16.0,"
None
",Resolved,Fixed,3.16.0,Otavio Rodolfo Piske,Otavio Rodolfo Piske,0,2,2021-03-22 18:11:00+00:00,2022-02-03 20:13:03+00:00,No Desc,"ffang:1643879757:2022-02-03T17:15:57.085+0000:1643879757:2022-02-03T17:15:57.085+0000:The root cause is this error
{code}
org.apache.hadoop.net.ConnectTimeoutException: 60000 millis timeout while waiting for channel to be ready for connect. ch : java.nio.channels.SocketChannel[connection-pending remote=/192.168.224.3:50010]
{code}

192.168.224.3 is an internal ip used by docker container, and this internal ip isn't accessible on mac by docker desktop,
We should specify dfs.client.use.datanode.hostname=true so that force a client to retrieve a hostname instead of an IP address and perform its own lookup of the hostname to get a routable path to that host.

More details can be found [here|https://support.datameer.com/hc/en-us/articles/213151023-java-nio-channels-SocketChannel-connection-pending-remote-IP-port-].

I will send a PR to address this and re-enable this test on mac
ffang:1643880095:2022-02-03T17:21:35.466+0000:1643880095:2022-02-03T17:21:35.466+0000:Patch attached
https://github.com/apache/camel/pull/6885"
0,CAMEL-16386,New Feature,Major,None,None,"
None
",Resolved,Won't Fix,3.x,Unassigned,Nikola Micić,1,3,2021-03-22 16:47:01+00:00,2022-09-02 17:46:27+00:00,"I would like to propose a new component for RSocket. 


The idea is to implement it in a similar way like already existing components for HTTP and WebSocket. Currently RSocket in Java is implemented using Netty via TCP and WebSocket protocols. Apache Camel already has component for Netty which is also a good example from using as a model.  


Uri of the new component could be like:



rsocket:tcp://host:port?<options> 
rsocket:websocket://host:port?<options>.","nikolamicic21:1616673738:2021-03-25T20:02:18.989+0000:1616673738:2021-03-25T20:02:18.989+0000:I would like as well to start working on the new component
acosentino:1616674550:2021-03-25T20:15:50.778+0000:1616674550:2021-03-25T20:15:50.778+0000:You're welcome to start.
nikolamicic21:1616844544:2021-03-27T19:29:04.939+0000:1616844544:2021-03-27T19:29:04.939+0000:Thanks for the reply. I will start working on it."
0,CAMEL-16385,Test,Minor,None,3.10.0,"
None
",Resolved,Fixed,3.10.0,Andrea Cosentino,Claus Ibsen,0,1,2021-03-22 15:41:55+00:00,2021-03-24 14:46:16+00:00,"CamelJbpmTest.org.apache.camel.itest.springboot.CamelJbpmTest


Its likely some kind of classpath problem",
0,CAMEL-16384,Improvement,Major,None,3.10.0,"
None
",Resolved,Fixed,3.10.0,Claus Ibsen,Claus Ibsen,0,1,2021-03-22 15:04:31+00:00,2021-03-22 15:06:03+00:00,"Asked on the user forum
http://camel.465427.n5.nabble.com/How-to-load-all-properties-from-CamelContext-td5914362.html",
0,CAMEL-16383,Improvement,Major,None,3.10.0,"
None
",Resolved,Fixed,3.10.0,Claus Ibsen,Claus Ibsen,0,1,2021-03-22 14:24:54+00:00,2021-03-22 15:06:12+00:00,"The scheduler has option concurrentTasks which is 1 by default. But if you set it to 2+ then you would have the scheduler 2+ times which is not intentional.


What users meant to configure is the pool size, so the thread pool may have 2+ threads instead of a single as worker",
0,CAMEL-16382,Bug,Major,"3.7.0, 3.8.0",3.9.0,"
None
",Resolved,Fixed,3.9.0,Claus Ibsen,James Netherton,0,2,2021-03-22 10:53:22+00:00,2021-03-23 05:44:47+00:00,"Not sure if this is a general issue across all components or whether I'm misunderstanding the autowiring mechanics.


If I configure the Infinispan component to disable autowiring, AutowiredLifecycleStrategy will go ahead and do it anyway.


For example, in camel-quarkus if I set a property like:


camel.component.infinispan.autowired-enabled=false


I still see Camel autowire the CacheContainer into the component:




2021-03-22 10:33:22,169 INFO  [org.apa.cam.imp.eng.AutowiredLifecycleStrategy] (main) Autowired property: cacheContainer on component: infinispan as exactly one instance of type: org.infinispan.client.hotrod.RemoteCacheManager (org.infinispan.client.hotrod.RemoteCacheManager) found in the registry
2021-03-22 10:33:22,180 INFO  [org.apa.cam.mai.BaseMainSupport] (main) Auto-configuration summary
2021-03-22 10:33:22,181 INFO  [org.apa.cam.mai.BaseMainSupport] (main)     camel.component.infinispan.autowiredEnabled=false




The background to this is from investigating https://github.com/apache/camel-quarkus/issues/2344.",davsclaus:1616385240:2021-03-22T11:54:00.094+0000:1616385240:2021-03-22T11:54:00.094+0000:Ah yeah we need to check if its disabled on the component in that lifecycle thingy
0,CAMEL-16381,Improvement,Major,None,3.11.0,"
None
",Resolved,Fixed,3.11.0,Andrea Cosentino,Claus Ibsen,0,1,2021-03-22 06:45:53+00:00,2021-06-11 08:07:56+00:00,"We have a number of dependencies (version numbers in properties section) in parent/pom.xml that we should move to camel-karaf to its own pom.xml file.


For example all the felix dependencies.",davsclaus:1623297561:2021-06-10T11:59:21.545+0000:1623297561:2021-06-10T11:59:21.545+0000:I moved the felix stuff
0,CAMEL-16379,New Feature,Major,None,3.12.0,"
None
",Resolved,Fixed,3.12.0,Guillaume Nodet,Claus Ibsen,0,2,2021-03-20 06:46:21+00:00,2021-08-21 10:52:24+00:00,JDK 16 is GA now. So lets look at what it takes to get core camel to build and support this.,"gnodet:1624235339:2021-06-21T08:28:59.707+0000:1624235339:2021-06-21T08:28:59.707+0000:{{camel-karaf}} fails on JDK 16.
{code}
[INFO] Scanning for projects...
[INFO] 
[INFO] ------------< org.apache.camel.karaf:camel-osgi-activator >-------------
[INFO] Building Camel Karaf :: OSGi Activator (deprecated) 3.11.0-SNAPSHOT
[INFO] --------------------------------[ jar ]---------------------------------
[INFO] 
[INFO] --- maven-enforcer-plugin:1.4.1:enforce (enforce-maven-version) @ camel-osgi-activator ---
[INFO] 
[INFO] --- camel-bundle-plugin:3.11.0-SNAPSHOT:cleanVersions (versions) @ camel-osgi-activator ---
[INFO] 
[INFO] --- build-helper-maven-plugin:1.12:add-source (default) @ camel-osgi-activator ---
[INFO] Source directory: /Users/gnodet/work/git/camel-karaf/components/camel-osgi-activator/src/generated/java added.
[INFO] 
[INFO] --- build-helper-maven-plugin:1.12:add-resource (default) @ camel-osgi-activator ---
[INFO] 
[INFO] --- depends-maven-plugin:1.2:generate-depends-file (generate-depends-file) @ camel-osgi-activator ---
[INFO] Created: /Users/gnodet/work/git/camel-karaf/components/camel-osgi-activator/target/classes/META-INF/maven/dependencies.properties
[INFO] 
[INFO] --- maven-resources-plugin:3.1.0:resources (default-resources) @ camel-osgi-activator ---
[INFO] Using 'UTF-8' encoding to copy filtered resources.
[INFO] skip non existing resourceDirectory /Users/gnodet/work/git/camel-karaf/components/camel-osgi-activator/src/main/resources
[INFO] Copying 2 resources
[INFO] 
[INFO] --- maven-compiler-plugin:3.8.1:compile (default-compile) @ camel-osgi-activator ---
[INFO] Nothing to compile - all classes are up to date
[INFO] 
[INFO] --- camel-package-maven-plugin:3.11.0-SNAPSHOT:generate-component (generate) @ camel-osgi-activator ---
[INFO] Stale files detected, re-generating.
[INFO] Skipping index generation, everything is up to date.
[INFO] Generated other.properties containing 1 Camel other: osgi-activator
[INFO] Validation complete
[INFO] 
[INFO] --- maven-resources-plugin:3.1.0:testResources (default-testResources) @ camel-osgi-activator ---
[INFO] Using 'UTF-8' encoding to copy filtered resources.
[INFO] skip non existing resourceDirectory /Users/gnodet/work/git/camel-karaf/components/camel-osgi-activator/src/test/resources
[INFO] 
[INFO] --- maven-compiler-plugin:3.8.1:testCompile (default-testCompile) @ camel-osgi-activator ---
[INFO] Changes detected - recompiling the module!
[INFO] Compiling 2 source files to /Users/gnodet/work/git/camel-karaf/components/camel-osgi-activator/target/test-classes
[INFO] 
[INFO] --- maven-surefire-plugin:3.0.0-M4:test (default-test) @ camel-osgi-activator ---
[INFO] 
[INFO] --- camel-bundle-plugin:3.11.0-SNAPSHOT:manifest (bundle-manifest) @ camel-osgi-activator ---
[INFO] Stale files detected, re-generating manifest.
[INFO] 
[INFO] --- maven-jar-plugin:3.2.0:jar (default-jar) @ camel-osgi-activator ---
[INFO] Building jar: /Users/gnodet/work/git/camel-karaf/components/camel-osgi-activator/target/camel-osgi-activator-3.11.0-SNAPSHOT.jar
[INFO] 
[INFO] --- maven-site-plugin:3.7.1:attach-descriptor (attach-descriptor) @ camel-osgi-activator ---
[INFO] Skipping because packaging 'jar' is not pom.
[INFO] 
[INFO] --- maven-assembly-plugin:3.2.0:single (default) @ camel-osgi-activator ---
[INFO] Reading assembly descriptor: src/assembly/test-bundles.xml
[INFO] Copying files to /Users/gnodet/work/git/camel-karaf/components/camel-osgi-activator/target/test-bundles
[INFO] 
[INFO] --- maven-surefire-plugin:3.0.0-M4:test (default) @ camel-osgi-activator ---
[INFO] 
[INFO] -------------------------------------------------------
[INFO]  T E S T S
[INFO] -------------------------------------------------------
[INFO] Running org.apache.camel.component.osgi.activator.CamelOsgiActivatorIT
SLF4J: Failed to load class ""org.slf4j.impl.StaticLoggerBinder"".
SLF4J: Defaulting to no-operation (NOP) logger implementation
SLF4J: See http://www.slf4j.org/codes.html#StaticLoggerBinder for further details.
Error installing bundle listed in startup.properties with url: mvn:org.apache.karaf.features/org.apache.karaf.features.extension/4.3.2 and startlevel: 1
java.lang.reflect.InaccessibleObjectException: Unable to make field private static final java.lang.Object java.net.URL.streamHandlerLock accessible: module java.base does not ""opens java.net"" to unnamed module @29444d75
	at java.base/java.lang.reflect.AccessibleObject.checkCanSetAccessible(AccessibleObject.java:357)
	at java.base/java.lang.reflect.AccessibleObject.checkCanSetAccessible(AccessibleObject.java:297)
	at java.base/java.lang.reflect.Field.checkCanSetAccessible(Field.java:177)
	at java.base/java.lang.reflect.Field.setAccessible(Field.java:171)
	at org.apache.felix.framework.util.SecureAction._swapStaticFieldIfNotClass(SecureAction.java:998)
	at org.apache.felix.framework.util.SecureAction.swapStaticFieldIfNotClass(SecureAction.java:983)
	at org.apache.felix.framework.URLHandlers.unregisterFrameworkListsForContextSearch(URLHandlers.java:346)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:78)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:567)
	at org.apache.felix.framework.util.SecureAction.invoke(SecureAction.java:893)
	at org.apache.felix.framework.URLHandlers.unregisterFrameworkInstance(URLHandlers.java:661)
	at org.apache.felix.framework.URLHandlersActivator.stop(URLHandlersActivator.java:75)
	at org.apache.felix.framework.util.SecureAction.stopActivator(SecureAction.java:720)
	at org.apache.felix.framework.Felix$SystemBundleActivator.stop(Felix.java:5224)
	at org.apache.felix.framework.util.SecureAction.stopActivator(SecureAction.java:720)
	at org.apache.felix.framework.Felix.stopBundle(Felix.java:2795)
	at org.apache.felix.framework.Felix$2.run(Felix.java:1154)
java.lang.reflect.InaccessibleObjectException: Unable to make field private static volatile java.net.ContentHandlerFactory java.net.URLConnection.factory accessible: module java.base does not ""opens java.net"" to unnamed module @29444d75
	at java.base/java.lang.reflect.AccessibleObject.checkCanSetAccessible(AccessibleObject.java:357)
	at java.base/java.lang.reflect.AccessibleObject.checkCanSetAccessible(AccessibleObject.java:297)
	at java.base/java.lang.reflect.Field.checkCanSetAccessible(Field.java:177)
	at java.base/java.lang.reflect.Field.setAccessible(Field.java:171)
	at org.apache.felix.framework.util.SecureAction._swapStaticFieldIfNotClass(SecureAction.java:1019)
	at org.apache.felix.framework.util.SecureAction.swapStaticFieldIfNotClass(SecureAction.java:983)
	at org.apache.felix.framework.URLHandlers.unregisterFrameworkListsForContextSearch(URLHandlers.java:361)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:78)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:567)
	at org.apache.felix.framework.util.SecureAction.invoke(SecureAction.java:893)
	at org.apache.felix.framework.URLHandlers.unregisterFrameworkInstance(URLHandlers.java:661)
	at org.apache.felix.framework.URLHandlersActivator.stop(URLHandlersActivator.java:75)
	at org.apache.felix.framework.util.SecureAction.stopActivator(SecureAction.java:720)
	at org.apache.felix.framework.Felix$SystemBundleActivator.stop(Felix.java:5224)
	at org.apache.felix.framework.util.SecureAction.stopActivator(SecureAction.java:720)
	at org.apache.felix.framework.Felix.stopBundle(Felix.java:2795)
	at org.apache.felix.framework.Felix$2.run(Felix.java:1154)
{code}

This looks similar to FELIX-6430, so opening the packages as indicated in that patch should work."
0,CAMEL-16378,Bug,Minor,"3.7.3, 3.8.0",3.10.0,"
None
",Resolved,Fixed,3.10.0,Claus Ibsen,Peterson Machado,0,2,2021-03-19 21:37:21+00:00,2021-03-22 13:53:02+00:00,"When using MDC in Camel (with custom mdc keys configured) values are not being propagate when using Split with parallel processing.


 


Please see the attached test class MDCSplitParallelProcessingTest.java, created based on the existing MDCAsyncTest.java.","davsclaus:1616373010:2021-03-22T08:30:10.031+0000:1616373010:2021-03-22T08:30:10.031+0000:Try with 3.9.0 when its released
davsclaus:1616377325:2021-03-22T09:42:05.728+0000:1616377325:2021-03-22T09:42:05.728+0000:You should avoid using MDC logging - its bad practice in a more reactive world. 
davsclaus:1616377700:2021-03-22T09:48:20.741+0000:1616377700:2021-03-22T09:48:20.741+0000:Discussing to deprecate MDC
http://camel.465427.n5.nabble.com/Deprecating-MDC-logging-td5914774.html
davsclaus:1616390798:2021-03-22T13:26:38.221+0000:1616390798:2021-03-22T13:26:38.221+0000:Working on a fix inside the multicast/splitter. However this further complicates the EIP with extra code when MDC is enabled.
davsclaus:1616392382:2021-03-22T13:53:02.762+0000:1616392382:2021-03-22T13:53:02.762+0000:Thanks for the unit test."
0,CAMEL-16377,Bug,Minor,3.7.3,"3.7.4, 3.10.0","
None
",Resolved,Information Provided,"3.7.4, 3.10.0",Unassigned,Dmytro Chasovskyi,0,2,2021-03-19 12:04:39+00:00,2021-03-19 13:55:59+00:00,"Hi, this is more like a question.


I am switching from the 2.24 version to 3.7.3, and I am getting an error in the .recepietnList. StackOverflow question


The error itself:


CaughtExceptionType: org.apache.camel.FailedToCreateProducerException  CaughtExceptionMessage: Failed to create Producer for endpoint: direct:xyz. Reason: java.lang.NullPointerException  StackTrace: org.apache.camel.FailedToCreateProducerException: Failed to create Producer for endpoint: direct:xyz Reason: java.lang.NullPointerExceptionCaughtExceptionType: org.apache.camel.FailedToCreateProducerException  CaughtExceptionMessage: Failed to create Producer for endpoint: direct:xyz. Reason: java.lang.NullPointerException  StackTrace: org.apache.camel.FailedToCreateProducerException: Failed to create Producer for endpoint: direct:xyz. Reason: java.lang.NullPointerException at org.apache.camel.support.cache.DefaultProducerCache.acquireProducer(DefaultProducerCache.java:154) at org.apache.camel.processor.RecipientListProcessor.createProcessorExchangePairs(RecipientListProcessor.java:219) at org.apache.camel.processor.MulticastProcessor.process(MulticastProcessor.java:276) at org.apache.camel.processor.RecipientList.sendToRecipientList(RecipientList.java:222) at org.apache.camel.processor.RecipientList.process(RecipientList.java:185) at org.apache.camel.processor.Pipeline$PipelineTask.run(Pipeline.java:90) at org.apache.camel.impl.engine.DefaultReactiveExecutor$Worker.schedule(DefaultReactiveExecutor.java:148) at org.apache.camel.impl.engine.DefaultReactiveExecutor.scheduleMain(DefaultReactiveExecutor.java:60) at org.apache.camel.processor.Pipeline.process(Pipeline.java:147) at org.apache.camel.impl.engine.CamelInternalProcessor.process(CamelInternalProcessor.java:312) at org.apache.camel.component.seda.SedaConsumer.sendToConsumers(SedaConsumer.java:274) at org.apache.camel.component.seda.SedaConsumer.doRun(SedaConsumer.java:187) at org.apache.camel.component.seda.SedaConsumer.run(SedaConsumer.java:130) at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1130) at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:630) at java.base/java.lang.Thread.run(Thread.java:832)Caused by: java.lang.NullPointerException at org.apache.camel.support.cache.ServicePool$SinglePool.acquire(ServicePool.java:210) at org.apache.camel.support.cache.ServicePool$SinglePool.acquire(ServicePool.java:193) at org.apache.camel.support.cache.ServicePool.acquire(ServicePool.java:109) at org.apache.camel.support.cache.DefaultProducerCache.acquireProducer(DefaultProducerCache.java:125) ... 15 more


It looks like the behavior changed between versions. Is there a way how I can address it? I walked through the migration guide, search StackOverflow, but there is no progress. Any idea?","davsclaus:1616131499:2021-03-19T13:24:59.231+0000:1616131499:2021-03-19T13:24:59.231+0000:Can you build a reproducer example or show some code / route what you are doing. And what component/endpoint do you use in the recipient list.
ChameleonTartu:1616132874:2021-03-19T13:47:54.850+0000:1616133110:2021-03-19T13:51:50.759+0000:[~davsclaus]

 

The code I am using to test the route:

 

SpringBoot app
{code:java}
@SpringBootApplication
@PropertySource(""classpath:application-test.properties"")
class TestApp {
  public static void main(String[] args) {
    SpringApplication.run(TestApp.class, args);
  }
}
{code}

  

SpringRunner, invoking Spring Boot spp:

 
{code:java}
@RunWith(SpringRunner.class)
@TestPropertySource(locations = ""application-test.properties"")
@SpringBootTest(classes = TestApp.class, webEnvironment = DEFINED_PORT)
public class FunctionalTest {
  @Autowired
  private EventConsumeCreator eventConsumerCreator;
  private List<Endpoint> consumers;
  private static final MockComponent MOCK_COMPONENT = new MockComponent();
  @Before
  public void before() {
    // Setting Wiremock and LogAsserts
    consumers = eventConsumerCreator.getConsumers();
    consumers.clear();
    consumers.add(new MockEndpoint(""direct:xyz"", MOCK_COMPONENT));
  }
  @Test
  public checkNumEvents() {
    // Make requests to endpoints
    // Verify logs
    // Check wiremock asserts
    assertThat(numEvents(consumers), is(1));
  }
}
{code}

  

Utility class creating direct endpoints:
{code:java}
@Component
public class EventConsumerCreator {
  private List<Endpoint> consumers = new LinkedList<>();
  private CamelContext camelContext;
  @Autowired
  public EventConsumerCreator(CamelContext camelContext){
    this.camelContext = camelContext;
  }
  public List<Endpoint> getConsumers() {
    return consumers;
  }
  public Endpoint createConsumer(String identifier) {
    Endpoint endpoint = createEndpoint(identifier);
    consumers.add(endpoint);
    return endpoint;
  }
  private Endpoint createEndpoint(String identifier) {
    DirectComponent component = camelContext.getComponent(""direct"", DirectComponent.class);
    try{
      return component.createEndpoint(""direct://"" + identifier);
    }
    catch (Exception e) {
      throw new RuntimeException(e);
    }
  }
}
{code}

  

{{In the simplified version of the endpoint itself, I removed properties setting and logging:}}
{code:java}
from(""direct:abc"")
  .route(""abc-123"")
  .streamCaching()
  .recipientList(exchangeProperty(""xyz"")).parallelProcessing() // returns ""[direct:xyz]""
  .log(""Success""){code}
davsclaus:1616133351:2021-03-19T13:55:51.927+0000:1616133351:2021-03-19T13:55:51.927+0000:Well that is because you create this stuff manually - its not a Camel problem. When you manually do it outside Camel handling itself, then you need to start the endpoint / consumers etc as its likely they are not started.

Use chat room or the mailing list to get more help. Closing JIRA."
0,CAMEL-16376,Dependency upgrade,Major,None,"3.7.4, 3.9.0","
None
",Resolved,Fixed,"3.7.4, 3.9.0",Claus Ibsen,Claus Ibsen,0,1,2021-03-19 10:08:46+00:00,2021-03-19 10:46:50+00:00,No Desc,
0,CAMEL-16375,Task,Major,None,None,"
None
",Resolved,Duplicate,3.10.0,Andrea Cosentino,Andrea Cosentino,0,1,2021-03-19 08:20:29+00:00,2021-03-23 12:57:36+00:00,No Desc,acosentino:1616475456:2021-03-23T12:57:36.292+0000:1616475456:2021-03-23T12:57:36.292+0000:[~coheigea] please check next time if there is already a ticket and if it's assigned.
0,CAMEL-16374,Improvement,Major,None,3.12.0,"
None
",Resolved,Fixed,3.12.0,Karen Lease,Claus Ibsen,0,3,2021-03-19 06:23:52+00:00,2021-07-28 14:55:11+00:00,"Currently onCompletion is only 1 per route, and you can only have it in



success
failure
both (default)



However you may want to it easier to separate routes for either success or failure.
Today you cannot do this.","grigoni:1617145890:2021-03-31T07:11:30.318+0000:1617145906:2021-03-31T07:11:46.751+0000:hello [~davsclaus], I have defined a quite simple route (camel 3.7.3) with a global onCompletion. this is never triggered
on 3.4.x it was working, will the fix also land in LTS?



davsclaus:1617146529:2021-03-31T07:22:09.295+0000:1617146577:2021-03-31T07:22:57.443+0000:No, try with 3.7.4 when its released
klease78:1625650496:2021-07-07T17:34:56.873+0000:1625650496:2021-07-07T17:34:56.873+0000:I have proposed changes to allow both success and failure routes on the same onCompletion route. Please review https://github.com/apache/camel/pull/5810 to see if the solution is acceptable.
klease78:1627391912:2021-07-27T21:18:32.782+0000:1627391912:2021-07-27T21:18:32.782+0000:Should it be possible to add any number of OnCompletion to a route, as for global OnCompletion? This is actually the easiest solution and seems to work correctly according to unit tests. Limiting the route to either one OnCompletion which handles all outcomes or 2, one for normal completion and one for failure is also possible but requires slightly more changes.
davsclaus:1627419104:2021-07-28T04:51:44.601+0000:1627419104:2021-07-28T04:51:44.601+0000:Yeah you are welcome to try with that, then its similar for global vs route scoped.
davsclaus:1627429997:2021-07-28T07:53:17.518+0000:1627429997:2021-07-28T07:53:17.518+0000:Karen, I added your account karma to self assign tickets in JIRA
klease78:1627440952:2021-07-28T10:55:52.368+0000:1627440952:2021-07-28T10:55:52.368+0000:Thanks [~davsclaus]. I created the PR: https://github.com/apache/camel/pull/5879"
0,CAMEL-16373,Bug,Minor,3.8.0,None,"
None
",Closed,Fixed,None,Unassigned,Reji Mathews,0,2,2021-03-18 21:39:14+00:00,2021-03-18 21:54:04+00:00,"I just noticed that while building the source locally, the autogenerated pages in docs/components/modules/ROOT/pages , 


page-source  in .adoc files have weird path value. 


 


Originally it was 


:page-source: components/camel-sql/src/main/docs/sql-component.adoc 


 


On building, , it becomes 


:page-source: componentscamel-sqlsrcmaindocssql-component.adoc


 





 


 


Is this a bug? Its affecting all the components","acosentino:1616075171:2021-03-18T21:46:11.104+0000:1616075171:2021-03-18T21:46:11.104+0000:It's something wrong on your side
contactreji:1616075623:2021-03-18T21:53:43.526+0000:1616075623:2021-03-18T21:53:43.526+0000:Strange. Am actually building as is. I use a windows machine. Am wondering if that made a difference (because its the path slashes which got affected). Either way, will close those now since its related to my env. Thanks
contactreji:1616075644:2021-03-18T21:54:04.729+0000:1616075644:2021-03-18T21:54:04.729+0000:Related to local env setup."
0,CAMEL-16372,Wish,Minor,3.8.0,,"
None
",Resolved,Fixed,None,Unassigned,Reji Mathews,0,2,2021-03-18 20:39:08+00:00,2021-03-18 21:31:13+00:00,"update https://github.com/mathewsreji/camel/blob/SMN_DOC_UPDATE/docs/components/modules/ROOT/nav.adoc . Add category for huawei cloud components and move the camel-hwcloud-smn documentations as item under the category
Add camel-huaweicloud under components folder and move camel-hwcloud-smn inside it","acosentino:1616073687:2021-03-18T21:21:27.283+0000:1616073687:2021-03-18T21:21:27.283+0000:Until we don't have multiple components this doesn't make really sense, don't you think so?
contactreji:1616074245:2021-03-18T21:30:45.287+0000:1616074245:2021-03-18T21:30:45.287+0000:[~acosentino] sounds good. We are on our way to add more huawei cloud components. I will re-open this issue once we have the next one ready to ship. Thanks :)
contactreji:1616074273:2021-03-18T21:31:13.392+0000:1616074273:2021-03-18T21:31:13.392+0000:To be revisited when next huawei cloud component is ready to ship"
0,CAMEL-16371,Improvement,Minor,None,,"
None
",Resolved,Information Provided,None,Unassigned,Stepan Shcherbakov,1,2,2021-03-18 15:58:56+00:00,2021-03-22 08:33:39+00:00,"In my project i have to controll all executors manually. That is why i would like to make ExecutorService for DefaultShutdownStrategy in my way. 
Unfortionally, getExecutorService() method has private access. Because of that i have to overwrite all doShutdown() method, write my own ShutdownTask (because it is also not allowed) to make my own ExecutorService.
Some Camel classes have setExecutorService() method, but DefaultShutdownStrategy hasnt.


Is it possible to make this class more tunable?


Thank you!",davsclaus:1616373211:2021-03-22T08:33:31.083+0000:1616373211:2021-03-22T08:33:31.083+0000:You can plugin a custom ExecutorServiceManager which controls all thread pools / executor services that Camel uses. Also what the shutdown strategy uses.
0,CAMEL-16370,Bug,Major,"3.8.0, 3.11.0",3.14.0,"
None
",Resolved,Fixed,3.14.0,Unassigned,Jason,0,6,2021-03-18 15:12:22+00:00,2021-11-14 09:02:38+00:00,"We are consuming Salesforce platform-events following the documented recommendations and our connection will not reconnect after being disconnected, apparently, from Salesforce.  I am not quite certain as to the circumstances that Salesforce sends some sort of disconnect signal, but that is what's logged from the SubscriptionHelper class. Our initial connection to Salesforce is successful and we are able to receive platform-events up until the point of the spontaneous disconnection.  Re-connection fails consistently and always in the same way.  Logging is slightly different across version, but the behavior seems to always be the same.


Our only work around for this is to run our service consuming this message like a cron job and restart it every 15 minutes (period we settled on through experimentation).  This is not how we'd prefer to sun this service, it's quite hacky and we'd like to not have to force a restart to work around what appears to an issue with how the reconnect is handled.


 


Here is the stacktrace:


[DEBUG] 2021-03-17 13:30:48,513 org.apache.camel.component.salesforce.internal.streaming.SubscriptionHelper$5 [SalesforceHttpClient@60c73e58-25 ] - Received messages [

{clientId=[--------redacted--------], channel=/meta/connect, id=21, successful=true}]
[DEBUG]
 2021-03-17 13:30:48,513 org.apache.camel.component.salesforce.internal.streaming.SubscriptionHelper 
[SalesforceHttpClient@60c73e58-25 ]
 - 
[CHANNEL:META_CONNECT]
: {clientId=[--------redacted--------], channel=/meta/connect, id=21, successful=true}

[DEBUG] 2021-03-17 13:32:38,588 org.apache.camel.component.salesforce.internal.streaming.SubscriptionHelper$5 [SalesforceHttpClient@60c73e58-25 ] - Received messages [

{clientId=[--------redacted--------], channel=/meta/connect, id=22, successful=true}]



[DEBUG]
 2021-03-17 13:32:38,589 org.apache.camel.component.salesforce.internal.streaming.SubscriptionHelper 
[SalesforceHttpClient@60c73e58-25 ]
 - 
[CHANNEL:META_CONNECT]
: {clientId=[--------redacted--------], channel=/meta/connect, id=22, successful=true}

[DEBUG] 2021-03-17 13:34:28,665 org.apache.camel.component.salesforce.internal.streaming.SubscriptionHelper$5 [SalesforceHttpClient@60c73e58-25 ] - Received messages [

{clientId=[--------redacted--------], channel=/meta/connect, id=23, successful=true}]



[DEBUG]
 2021-03-17 13:34:28,666 org.apache.camel.component.salesforce.internal.streaming.SubscriptionHelper 
[SalesforceHttpClient@60c73e58-25 ]
 - 
[CHANNEL:META_CONNECT]
: {clientId=[--------redacted--------], channel=/meta/connect, id=23, successful=true}

[DEBUG] 2021-03-17 13:34:28,766 org.apache.camel.component.salesforce.internal.streaming.SubscriptionHelper$5 [SalesforceHttpClient@60c73e58-32 ] - Received messages [

{channel=/meta/disconnect}

, {clientId=[--------redacted--------], advice=

{reconnect=none, interval=0}, channel=/meta/connect, id=24, error=401::Authentication invalid, successful=false}]



[INFO ]
 2021-03-17 13:34:28,769 org.apache.camel.component.salesforce.internal.streaming.SubscriptionHelper 
[SalesforceHttpClient@60c73e58-26 ]
 - Restarting on unexpected disconnect from Salesforce...



[DEBUG]
 2021-03-17 13:34:28,769 org.apache.camel.component.salesforce.internal.streaming.SubscriptionHelper 
[SalesforceHttpClient@60c73e58-26 ]
 - Waiting to disconnect...



[DEBUG]
 2021-03-17 13:34:28,770 org.apache.camel.component.salesforce.internal.streaming.SubscriptionHelper 
[SalesforceHttpClient@60c73e58-32 ]
 - 
[CHANNEL:META_CONNECT]
: {clientId=
[--------redacted--------]
, advice={reconnect=none, interval=0}

, channel=/meta/connect, id=24, error=401::Authentication invalid, successful=false}[WARN ] 2021-03-17 13:34:28,771 org.apache.camel.component.salesforce.internal.streaming.SubscriptionHelper [SalesforceHttpClient@60c73e58-32 ] - Connect failure: {clientId=[--------redacted--------], advice=

{reconnect=none, interval=0}

, channel=/meta/connect, id=24, error=401::Authentication invalid, successful=false}
[DEBUG] 2021-03-17 13:34:33,769 org.apache.camel.component.salesforce.internal.streaming.SubscriptionHelper [SalesforceHttpClient@60c73e58-26 ] - Pausing for 0 msecs before restart attempt
[DEBUG] 2021-03-17 13:34:33,770 org.apache.camel.component.salesforce.internal.streaming.SubscriptionHelper [SalesforceHttpClient@60c73e58-26 ] - Stopped the helper and destroyed the client
[DEBUG] 2021-03-17 13:34:33,862 org.apache.camel.component.salesforce.internal.streaming.SubscriptionHelper$5 [SalesforceHttpClient@60c73e58-30 ] - Received messages [{ext={sfdc=

{failureReason=401::Authentication invalid}

, replay=true, payload.format=true}, advice=

{reconnect=none}, channel=/meta/handshake, id=25, error=403::Handshake denied, successful=false}]
[DEBUG]
 2021-03-17 13:34:33,863 org.apache.camel.component.salesforce.internal.streaming.SubscriptionHelper 
[SalesforceHttpClient@60c73e58-30 ]
 - 
[CHANNEL:META_HANDSHAKE]
: {ext={sfdc={failureReason=401::Authentication invalid}, replay=true, payload.format=true}, advice={reconnect=none}

, channel=/meta/handshake, id=25, error=403::Handshake denied, successful=false}
[WARN ] 2021-03-17 13:34:33,863 org.apache.camel.component.salesforce.internal.streaming.SubscriptionHelper [SalesforceHttpClient@60c73e58-30 ] - Handshake failure: {ext={sfdc=

{failureReason=401::Authentication invalid}

, replay=true, payload.format=true}, advice=

{reconnect=none}

, channel=/meta/handshake, id=25, error=403::Handshake denied, successful=false}
[INFO ] 2021-03-17 13:34:33,863 org.apache.camel.component.salesforce.internal.streaming.SubscriptionHelper [SalesforceHttpClient@60c73e58-30 ] - Cleaning session (logout) from SalesforceSession before restarting client
[INFO ] 2021-03-17 13:34:33,867 org.cometd.bayeux.client.ClientSession [SalesforceHttpClient@60c73e58-30 ] - Exception while invoking listener org.apache.camel.component.salesforce.internal.streaming.SubscriptionHelper$1@7574cf75java.lang.NullPointerException: null    at org.apache.camel.component.salesforce.internal.streaming.SubscriptionHelper$1.onMessage(SubscriptionHelper.java:148)    at org.cometd.common.AbstractClientSession$AbstractSessionChannel.notifyOnMessage(AbstractClientSession.java:583)    at org.cometd.common.AbstractClientSession$AbstractSessionChannel.notifyMessageListeners(AbstractClientSession.java:568)    at org.cometd.common.AbstractClientSession.notifyListeners(AbstractClientSession.java:308)    at org.cometd.common.AbstractClientSession.lambda$receive$4(AbstractClientSession.java:269)    at org.cometd.bayeux.Promise$2.succeed(Promise.java:103)    at org.cometd.common.AsyncFoldLeft$AbstractLoop.run(AsyncFoldLeft.java:199)    at org.cometd.common.AsyncFoldLeft.run(AsyncFoldLeft.java:93)    at org.cometd.common.AbstractClientSession.extendIncoming(AbstractClientSession.java:103)    at org.cometd.common.AbstractClientSession.receive(AbstractClientSession.java:263)    at org.cometd.client.BayeuxClient.failHandshake(BayeuxClient.java:721)    at org.cometd.client.BayeuxClient.processHandshake(BayeuxClient.java:707)    at org.cometd.client.BayeuxClient.processMessages(BayeuxClient.java:615)    at org.cometd.client.BayeuxClient.access$2000(BayeuxClient.java:101)    at org.cometd.client.BayeuxClient$MessageTransportListener.onMessages(BayeuxClient.java:1260)    at org.cometd.client.transport.LongPollingTransport$2.onComplete(LongPollingTransport.java:240)    at org.eclipse.jetty.client.ResponseNotifier.notifyComplete(ResponseNotifier.java:218)    at org.eclipse.jetty.client.ResponseNotifier.notifyComplete(ResponseNotifier.java:210)    at org.eclipse.jetty.client.HttpReceiver.terminateResponse(HttpReceiver.java:481)    at org.eclipse.jetty.client.HttpReceiver.terminateResponse(HttpReceiver.java:461)    at org.eclipse.jetty.client.HttpReceiver.responseSuccess(HttpReceiver.java:424)    at org.eclipse.jetty.client.http.HttpReceiverOverHTTP.messageComplete(HttpReceiverOverHTTP.java:365)    at org.eclipse.jetty.http.HttpParser.handleContentMessage(HttpParser.java:585)    at org.eclipse.jetty.http.HttpParser.parseContent(HttpParser.java:1702)    at org.eclipse.jetty.http.HttpParser.parseNext(HttpParser.java:1531)    at org.eclipse.jetty.client.http.HttpReceiverOverHTTP.parse(HttpReceiverOverHTTP.java:204)    at org.eclipse.jetty.client.http.HttpReceiverOverHTTP.process(HttpReceiverOverHTTP.java:144)    at org.eclipse.jetty.client.http.HttpReceiverOverHTTP.receive(HttpReceiverOverHTTP.java:79)    at org.eclipse.jetty.client.http.HttpChannelOverHTTP.receive(HttpChannelOverHTTP.java:131)    at org.eclipse.jetty.client.http.HttpConnectionOverHTTP.onFillable(HttpConnectionOverHTTP.java:169)    at org.eclipse.jetty.io.AbstractConnection$ReadCallback.succeeded(AbstractConnection.java:311)    at org.eclipse.jetty.io.FillInterest.fillable(FillInterest.java:105)    at org.eclipse.jetty.io.ssl.SslConnection$DecryptedEndPoint.onFillable(SslConnection.java:540)    at org.eclipse.jetty.io.ssl.SslConnection.onFillable(SslConnection.java:395)    at org.eclipse.jetty.io.ssl.SslConnection$2.succeeded(SslConnection.java:161)    at org.eclipse.jetty.io.FillInterest.fillable(FillInterest.java:105)    at org.eclipse.jetty.io.ChannelEndPoint$1.run(ChannelEndPoint.java:104)    at org.eclipse.jetty.util.thread.strategy.EatWhatYouKill.runTask(EatWhatYouKill.java:336)    at org.eclipse.jetty.util.thread.strategy.EatWhatYouKill.doProduce(EatWhatYouKill.java:313)    at org.eclipse.jetty.util.thread.strategy.EatWhatYouKill.tryProduce(EatWhatYouKill.java:171)    at org.eclipse.jetty.util.thread.strategy.EatWhatYouKill.run(EatWhatYouKill.java:129)    at org.eclipse.jetty.util.thread.ReservedThreadExecutor$ReservedThread.run(ReservedThreadExecutor.java:375)    at org.eclipse.jetty.util.thread.QueuedThreadPool.runJob(QueuedThreadPool.java:773)    at org.eclipse.jetty.util.thread.QueuedThreadPool$Runner.run(QueuedThreadPool.java:905)    at java.base/java.lang.Thread.run(Thread.java:834)
[ERROR] 2021-03-17 13:36:23,773 org.apache.camel.component.salesforce.internal.streaming.SubscriptionHelper [SalesforceHttpClient@60c73e58-26 ] - Error restarting: Exception during HANDSHAKE: 401::Authentication invalidorg.apache.camel.CamelException: Exception during HANDSHAKE: 401::Authentication invalid    at org.apache.camel.component.salesforce.internal.streaming.SubscriptionHelper.connect(SubscriptionHelper.java:223)    at org.apache.camel.component.salesforce.internal.streaming.SubscriptionHelper.doStart(SubscriptionHelper.java:212)    at org.apache.camel.component.salesforce.internal.streaming.SubscriptionHelper.performClientRestart(SubscriptionHelper.java:304)    at org.apache.camel.component.salesforce.internal.streaming.SubscriptionHelper.access$1000(SubscriptionHelper.java:60)    at org.apache.camel.component.salesforce.internal.streaming.SubscriptionHelper$4.run(SubscriptionHelper.java:249)    at org.eclipse.jetty.util.thread.QueuedThreadPool.runJob(QueuedThreadPool.java:773)    at org.eclipse.jetty.util.thread.QueuedThreadPool$Runner.run(QueuedThreadPool.java:905)    at java.base/java.lang.Thread.run(Thread.java:834)Caused by: org.apache.camel.component.salesforce.api.SalesforceException: 401::Authentication invalid    at org.apache.camel.component.salesforce.internal.streaming.SubscriptionHelper.getFailure(SubscriptionHelper.java:340)    at org.apache.camel.component.salesforce.internal.streaming.SubscriptionHelper.access$300(SubscriptionHelper.java:60)    at org.apache.camel.component.salesforce.internal.streaming.SubscriptionHelper$1.onMessage(SubscriptionHelper.java:132)    at org.cometd.common.AbstractClientSession$AbstractSessionChannel.notifyOnMessage(AbstractClientSession.java:583)    at org.cometd.common.AbstractClientSession$AbstractSessionChannel.notifyMessageListeners(AbstractClientSession.java:568)    at org.cometd.common.AbstractClientSession.notifyListeners(AbstractClientSession.java:308)    at org.cometd.common.AbstractClientSession.lambda$receive$4(AbstractClientSession.java:269)    at org.cometd.bayeux.Promise$2.succeed(Promise.java:103)    at org.cometd.common.AsyncFoldLeft$AbstractLoop.run(AsyncFoldLeft.java:199)    at org.cometd.common.AsyncFoldLeft.run(AsyncFoldLeft.java:93)    at org.cometd.common.AbstractClientSession.extendIncoming(AbstractClientSession.java:103)    at org.cometd.common.AbstractClientSession.receive(AbstractClientSession.java:263)    at org.cometd.client.BayeuxClient.failHandshake(BayeuxClient.java:721)    at org.cometd.client.BayeuxClient.processHandshake(BayeuxClient.java:707)    at org.cometd.client.BayeuxClient.processMessages(BayeuxClient.java:615)    at org.cometd.client.BayeuxClient.access$2000(BayeuxClient.java:101)    at org.cometd.client.BayeuxClient$MessageTransportListener.onMessages(BayeuxClient.java:1260)    at org.cometd.client.transport.LongPollingTransport$2.onComplete(LongPollingTransport.java:240)    at org.eclipse.jetty.client.ResponseNotifier.notifyComplete(ResponseNotifier.java:218)    at org.eclipse.jetty.client.ResponseNotifier.notifyComplete(ResponseNotifier.java:210)    at org.eclipse.jetty.client.HttpReceiver.terminateResponse(HttpReceiver.java:481)    at org.eclipse.jetty.client.HttpReceiver.terminateResponse(HttpReceiver.java:461)    at org.eclipse.jetty.client.HttpReceiver.responseSuccess(HttpReceiver.java:424)    at org.eclipse.jetty.client.http.HttpReceiverOverHTTP.messageComplete(HttpReceiverOverHTTP.java:365)    at org.eclipse.jetty.http.HttpParser.handleContentMessage(HttpParser.java:585)    at org.eclipse.jetty.http.HttpParser.parseContent(HttpParser.java:1702)    at org.eclipse.jetty.http.HttpParser.parseNext(HttpParser.java:1531)    at org.eclipse.jetty.client.http.HttpReceiverOverHTTP.parse(HttpReceiverOverHTTP.java:204)    at org.eclipse.jetty.client.http.HttpReceiverOverHTTP.process(HttpReceiverOverHTTP.java:144)    at org.eclipse.jetty.client.http.HttpReceiverOverHTTP.receive(HttpReceiverOverHTTP.java:79)    at org.eclipse.jetty.client.http.HttpChannelOverHTTP.receive(HttpChannelOverHTTP.java:131)    at org.eclipse.jetty.client.http.HttpConnectionOverHTTP.onFillable(HttpConnectionOverHTTP.java:169)    at org.eclipse.jetty.io.AbstractConnection$ReadCallback.succeeded(AbstractConnection.java:311)    at org.eclipse.jetty.io.FillInterest.fillable(FillInterest.java:105)    at org.eclipse.jetty.io.ssl.SslConnection$DecryptedEndPoint.onFillable(SslConnection.java:540)    at org.eclipse.jetty.io.ssl.SslConnection.onFillable(SslConnection.java:395)    at org.eclipse.jetty.io.ssl.SslConnection$2.succeeded(SslConnection.java:161)    at org.eclipse.jetty.io.FillInterest.fillable(FillInterest.java:105)    at org.eclipse.jetty.io.ChannelEndPoint$1.run(ChannelEndPoint.java:104)    at org.eclipse.jetty.util.thread.strategy.EatWhatYouKill.runTask(EatWhatYouKill.java:336)    at org.eclipse.jetty.util.thread.strategy.EatWhatYouKill.doProduce(EatWhatYouKill.java:313)    at org.eclipse.jetty.util.thread.strategy.EatWhatYouKill.tryProduce(EatWhatYouKill.java:171)    at org.eclipse.jetty.util.thread.strategy.EatWhatYouKill.run(EatWhatYouKill.java:129)    at org.eclipse.jetty.util.thread.ReservedThreadExecutor$ReservedThread.run(ReservedThreadExecutor.java:375)    ... 3 common frames omitted
[ERROR] 2021-03-17 13:36:23,774 org.apache.camel.component.salesforce.internal.streaming.SubscriptionHelper [SalesforceHttpClient@60c73e58-26 ] - Failed to restart after pausing for 0 msecs","davsclaus:1616373384:2021-03-22T08:36:24.325+0000:1616373384:2021-03-22T08:36:24.325+0000:It seems like you get a 401 and 403 auth error from Salesforce.

You are welcome to try with Camel 3.9.0 when its released in a little while.
jasonholmberg:1616480880:2021-03-23T14:28:00.078+0000:1616480901:2021-03-23T14:28:21.669+0000:This works in in Camel 2.23.1 and auth only fails when a forced restart of the connection occurs. 
davsclaus:1616481389:2021-03-23T14:36:29.116+0000:1616481389:2021-03-23T14:36:29.116+0000:So you are saying a very old Camel 2.23.1 works for you. But when using Camel 3.8.0 it does not
jasonholmberg:1616502608:2021-03-23T20:30:08.787+0000:1616502608:2021-03-23T20:30:08.787+0000:Yes, that is correct.
jasonholmberg:1616564373:2021-03-24T13:39:33.693+0000:1616564373:2021-03-24T13:39:33.693+0000:Yes, pre 3.x versions seem to work fine.  I have not done exhaustive testing on all 3.x version. The 3.x version authenticate correctly into Salesforce and work fine up until This is logged:

[INFO ] 2021-03-17 13:34:28,769 org.apache.camel.component.salesforce.internal.streaming.SubscriptionHelper [SalesforceHttpClient@60c73e58-26 ] - Restarting on unexpected disconnect from Salesforce...

At that point the 3.x versions do not seem to be able to renegotiate a connection.  Under the same circumstances, the old versions like 2.23.1 are able to renegotiate the connection.
davsclaus:1617146766:2021-03-31T07:26:06.907+0000:1617146766:2021-03-31T07:26:06.907+0000:Can you try with Camel 3.9.0 ?
jasonholmberg:1617599531:2021-04-05T13:12:11.242+0000:1617599531:2021-04-05T13:12:11.242+0000:I will try with Camel 3.9.0 and report back with the results.
davsclaus:1618829952:2021-04-19T18:59:12.092+0000:1618829952:2021-04-19T18:59:12.092+0000:In the top comment above with the logging output, can you tell us which Camel version that is
jasonholmberg:1620800123:2021-05-12T14:15:23.899+0000:1620800134:2021-05-12T14:15:34.524+0000:I'm pretty sure it is v2.23.1
davsclaus:1623022540:2021-06-07T07:35:40.323+0000:1623022540:2021-06-07T07:35:40.323+0000:There is a new 3.10.0 release did you try with that
an.scaldaferri@gmail.com:1623221484:2021-06-09T14:51:24.273+0000:1623221484:2021-06-09T14:51:24.273+0000:Hi,

we have same issue, but we use camel-quarkus-salesforce component (version 1.8.0). After the handshake we receive this error:

Exception while invoking listener org.apache.camel.component.salesforce.internal.streaming.SubscriptionHelper$1@7abb1619: java.lang.NullPointerException
an.scaldaferri@gmail.com:1625034882:2021-06-30T14:34:42.406+0000:1625034882:2021-06-30T14:34:42.406+0000:We have the same issue with the new release 3.10.0.
davsclaus:1625036416:2021-06-30T15:00:16.396+0000:1625036416:2021-06-30T15:00:16.396+0000:Do you mean 3.11.0 as this was just released
an.scaldaferri@gmail.com:1625464218:2021-07-05T13:50:18.026+0000:1625464218:2021-07-05T13:50:18.026+0000:We have the same issue with the new release 3.11.0.
 
an.scaldaferri@gmail.com:1627958146:2021-08-03T10:35:46.388+0000:1627958146:2021-08-03T10:35:46.388+0000:We have found a workaround, use one user for each subscription to Salesforce.


We have verified that the error is returned if the same username is used for multiple applications/subscriptions (e.g. the error occurred when application A uses user AA, application B uses user AA to connect to the other Salesforce Event).
We have not checked whether the application scales horizontally and the error is returned, but in our case this is not a requirement.

 
hemangajmera:1634705160:2021-10-20T12:46:00.206+0000:1634705160:2021-10-20T12:46:00.206+0000:Hi

   I am user camel version 3.11.0 and facing same error. Here is the relevant section of the log...

```

2021-10-20 11:46:51,697 org.apache.camel.component.salesforce.internal.streaming.SubscriptionHelper.performClientRestart - Restarting on unexpected disconnect from Salesforce... 
2021-10-20 11:46:51,699 org.apache.camel.component.salesforce.internal.streaming.SubscriptionHelper.onMessage - Connect failure: \{clientId=1ah1n3glbijn0qkia6xuwk25k15d, advice={reconnect=none, interval=0}, channel=/meta/connect, id=99, error=401::Authentication invalid, successful=false} 
2021-10-20 11:46:51,798 org.apache.camel.component.salesforce.internal.streaming.SubscriptionHelper.onMessage - Handshake failure: \{ext={sfdc={failureReason=401::Authentication invalid}, replay=true, payload.format=true}, advice=\{reconnect=none}, channel=/meta/handshake, id=100, error=403::Handshake denied, successful=false} 
2021-10-20 11:46:51,799 org.apache.camel.component.salesforce.internal.streaming.SubscriptionHelper.onMessage - Cleaning session (logout) from SalesforceSession before restarting client 
2021-10-20 11:46:51,902 org.cometd.bayeux.client.ClientSession.notifyOnMessage - Exception while invoking listener org.apache.camel.component.salesforce.internal.streaming.SubscriptionHelper$1@1e2d0dfa 
java.lang.NullPointerException: null 
 at org.apache.camel.component.salesforce.internal.streaming.SubscriptionHelper$1.onMessage(SubscriptionHelper.java:148) 
 at org.cometd.common.AbstractClientSession$AbstractSessionChannel.notifyOnMessage(AbstractClientSession.java:583) 
 at org.cometd.common.AbstractClientSession$AbstractSessionChannel.notifyMessageListeners(AbstractClientSession.java:568) 
 at org.cometd.common.AbstractClientSession.notifyListeners(AbstractClientSession.java:308) 
 at org.cometd.common.AbstractClientSession.lambda$receive$4(AbstractClientSession.java:269) 
 at org.cometd.bayeux.Promise$2.succeed(Promise.java:103) 
 at org.cometd.common.AsyncFoldLeft$AbstractLoop.run(AsyncFoldLeft.java:199) 
 at org.cometd.common.AsyncFoldLeft.run(AsyncFoldLeft.java:93) 
 at org.cometd.common.AbstractClientSession.extendIncoming(AbstractClientSession.java:103) 
 at org.cometd.common.AbstractClientSession.receive(AbstractClientSession.java:263) 
 at org.cometd.client.BayeuxClient.failHandshake(BayeuxClient.java:721) 
 at org.cometd.client.BayeuxClient.processHandshake(BayeuxClient.java:707) 
 at org.cometd.client.BayeuxClient.processMessages(BayeuxClient.java:615) 
 at org.cometd.client.BayeuxClient.access$2000(BayeuxClient.java:101) 
 at org.cometd.client.BayeuxClient$MessageTransportListener.onMessages(BayeuxClient.java:1260) 
 at org.cometd.client.transport.LongPollingTransport$2.onComplete(LongPollingTransport.java:240) 
 at org.eclipse.jetty.client.ResponseNotifier.notifyComplete(ResponseNotifier.java:218) 
 at org.eclipse.jetty.client.ResponseNotifier.notifyComplete(ResponseNotifier.java:210) 
 at org.eclipse.jetty.client.HttpReceiver.terminateResponse(HttpReceiver.java:481) 
 at org.eclipse.jetty.client.HttpReceiver.terminateResponse(HttpReceiver.java:461) 
 at org.eclipse.jetty.client.HttpReceiver.responseSuccess(HttpReceiver.java:424) 
 at org.eclipse.jetty.client.http.HttpReceiverOverHTTP.messageComplete(HttpReceiverOverHTTP.java:365) 
 at org.eclipse.jetty.http.HttpParser.handleContentMessage(HttpParser.java:591) 
 at org.eclipse.jetty.http.HttpParser.parseContent(HttpParser.java:1716) 
 at org.eclipse.jetty.http.HttpParser.parseNext(HttpParser.java:1545) 
 at org.eclipse.jetty.client.http.HttpReceiverOverHTTP.parse(HttpReceiverOverHTTP.java:204) 
 at org.eclipse.jetty.client.http.HttpReceiverOverHTTP.process(HttpReceiverOverHTTP.java:144) 
 at org.eclipse.jetty.client.http.HttpReceiverOverHTTP.receive(HttpReceiverOverHTTP.java:79) 
 at org.eclipse.jetty.client.http.HttpChannelOverHTTP.receive(HttpChannelOverHTTP.java:131) 
 at org.eclipse.jetty.client.http.HttpConnectionOverHTTP.onFillable(HttpConnectionOverHTTP.java:172) 
 at org.eclipse.jetty.io.AbstractConnection$ReadCallback.succeeded(AbstractConnection.java:311) 
 at org.eclipse.jetty.io.FillInterest.fillable(FillInterest.java:105) 
 at org.eclipse.jetty.io.ssl.SslConnection$DecryptedEndPoint.onFillable(SslConnection.java:555) 
 at org.eclipse.jetty.io.ssl.SslConnection.onFillable(SslConnection.java:410) 
 at org.eclipse.jetty.io.ssl.SslConnection$2.succeeded(SslConnection.java:164) 
 at org.eclipse.jetty.io.FillInterest.fillable(FillInterest.java:105) 
 at org.eclipse.jetty.io.ChannelEndPoint$1.run(ChannelEndPoint.java:104) 
 at org.eclipse.jetty.util.thread.strategy.EatWhatYouKill.runTask(EatWhatYouKill.java:338) 
 at org.eclipse.jetty.util.thread.strategy.EatWhatYouKill.doProduce(EatWhatYouKill.java:315) 
 at org.eclipse.jetty.util.thread.strategy.EatWhatYouKill.tryProduce(EatWhatYouKill.java:173) 
 at org.eclipse.jetty.util.thread.strategy.EatWhatYouKill.run(EatWhatYouKill.java:131) 
 at org.eclipse.jetty.util.thread.ReservedThreadExecutor$ReservedThread.run(ReservedThreadExecutor.java:383) 
 at org.eclipse.jetty.util.thread.QueuedThreadPool.runJob(QueuedThreadPool.java:882) 
 at org.eclipse.jetty.util.thread.QueuedThreadPool$Runner.run(QueuedThreadPool.java:1036) 
 at java.base/java.lang.Thread.run(Unknown Source) 
2021-10-20 11:48:41,799 org.apache.camel.component.salesforce.internal.streaming.SubscriptionHelper.performClientRestart - Error restarting: Exception during HANDSHAKE: 401::Authentication invalid 
org.apache.camel.CamelException: Exception during HANDSHAKE: 401::Authentication invalid 
 at org.apache.camel.component.salesforce.internal.streaming.SubscriptionHelper.connect(SubscriptionHelper.java:223) 
 at org.apache.camel.component.salesforce.internal.streaming.SubscriptionHelper.doStart(SubscriptionHelper.java:212) 
 at org.apache.camel.component.salesforce.internal.streaming.SubscriptionHelper.performClientRestart(SubscriptionHelper.java:304) 
 at org.apache.camel.component.salesforce.internal.streaming.SubscriptionHelper.access$1000(SubscriptionHelper.java:60) 
 at org.apache.camel.component.salesforce.internal.streaming.SubscriptionHelper$4.run(SubscriptionHelper.java:249) 
 at org.eclipse.jetty.util.thread.QueuedThreadPool.runJob(QueuedThreadPool.java:882) 
 at org.eclipse.jetty.util.thread.QueuedThreadPool$Runner.run(QueuedThreadPool.java:1036) 
 at java.base/java.lang.Thread.run(Unknown Source) 
Caused by: org.apache.camel.component.salesforce.api.SalesforceException: 401::Authentication invalid 
 at org.apache.camel.component.salesforce.internal.streaming.SubscriptionHelper.getFailure(SubscriptionHelper.java:340) 
 at org.apache.camel.component.salesforce.internal.streaming.SubscriptionHelper.access$300(SubscriptionHelper.java:60) 
 at org.apache.camel.component.salesforce.internal.streaming.SubscriptionHelper$1.onMessage(SubscriptionHelper.java:132) 
 at org.cometd.common.AbstractClientSession$AbstractSessionChannel.notifyOnMessage(AbstractClientSession.java:583) 
 at org.cometd.common.AbstractClientSession$AbstractSessionChannel.notifyMessageListeners(AbstractClientSession.java:568) 
 at org.cometd.common.AbstractClientSession.notifyListeners(AbstractClientSession.java:308) 
 at org.cometd.common.AbstractClientSession.lambda$receive$4(AbstractClientSession.java:269) 
 at org.cometd.bayeux.Promise$2.succeed(Promise.java:103) 
 at org.cometd.common.AsyncFoldLeft$AbstractLoop.run(AsyncFoldLeft.java:199) 
 at org.cometd.common.AsyncFoldLeft.run(AsyncFoldLeft.java:93) 
 at org.cometd.common.AbstractClientSession.extendIncoming(AbstractClientSession.java:103) 
 at org.cometd.common.AbstractClientSession.receive(AbstractClientSession.java:263) 
 at org.cometd.client.BayeuxClient.failHandshake(BayeuxClient.java:721) 
 at org.cometd.client.BayeuxClient.processHandshake(BayeuxClient.java:707) 
 at org.cometd.client.BayeuxClient.processMessages(BayeuxClient.java:615) 
 at org.cometd.client.BayeuxClient.access$2000(BayeuxClient.java:101) 
 at org.cometd.client.BayeuxClient$MessageTransportListener.onMessages(BayeuxClient.java:1260) 
 at org.cometd.client.transport.LongPollingTransport$2.onComplete(LongPollingTransport.java:240) 
 at org.eclipse.jetty.client.ResponseNotifier.notifyComplete(ResponseNotifier.java:218) 
 at org.eclipse.jetty.client.ResponseNotifier.notifyComplete(ResponseNotifier.java:210) 
 at org.eclipse.jetty.client.HttpReceiver.terminateResponse(HttpReceiver.java:481) 
 at org.eclipse.jetty.client.HttpReceiver.terminateResponse(HttpReceiver.java:461) 
 at org.eclipse.jetty.client.HttpReceiver.responseSuccess(HttpReceiver.java:424) 
 at org.eclipse.jetty.client.http.HttpReceiverOverHTTP.messageComplete(HttpReceiverOverHTTP.java:365) 
 at org.eclipse.jetty.http.HttpParser.handleContentMessage(HttpParser.java:591) 
 at org.eclipse.jetty.http.HttpParser.parseContent(HttpParser.java:1716) 
 at org.eclipse.jetty.http.HttpParser.parseNext(HttpParser.java:1545) 
 at org.eclipse.jetty.client.http.HttpReceiverOverHTTP.parse(HttpReceiverOverHTTP.java:204) 
 at org.eclipse.jetty.client.http.HttpReceiverOverHTTP.process(HttpReceiverOverHTTP.java:144) 
 at org.eclipse.jetty.client.http.HttpReceiverOverHTTP.receive(HttpReceiverOverHTTP.java:79) 
 at org.eclipse.jetty.client.http.HttpChannelOverHTTP.receive(HttpChannelOverHTTP.java:131) 
 at org.eclipse.jetty.client.http.HttpConnectionOverHTTP.onFillable(HttpConnectionOverHTTP.java:172) 
 at org.eclipse.jetty.io.AbstractConnection$ReadCallback.succeeded(AbstractConnection.java:311) 
 at org.eclipse.jetty.io.FillInterest.fillable(FillInterest.java:105) 
 at org.eclipse.jetty.io.ssl.SslConnection$DecryptedEndPoint.onFillable(SslConnection.java:555) 
 at org.eclipse.jetty.io.ssl.SslConnection.onFillable(SslConnection.java:410) 
 at org.eclipse.jetty.io.ssl.SslConnection$2.succeeded(SslConnection.java:164) 
 at org.eclipse.jetty.io.FillInterest.fillable(FillInterest.java:105) 
 at org.eclipse.jetty.io.ChannelEndPoint$1.run(ChannelEndPoint.java:104) 
 at org.eclipse.jetty.util.thread.strategy.EatWhatYouKill.runTask(EatWhatYouKill.java:338) 
 at org.eclipse.jetty.util.thread.strategy.EatWhatYouKill.doProduce(EatWhatYouKill.java:315) 
 at org.eclipse.jetty.util.thread.strategy.EatWhatYouKill.tryProduce(EatWhatYouKill.java:173) 
 at org.eclipse.jetty.util.thread.strategy.EatWhatYouKill.run(EatWhatYouKill.java:131) 
 at org.eclipse.jetty.util.thread.ReservedThreadExecutor$ReservedThread.run(ReservedThreadExecutor.java:383) 
 ... 3 common frames omitted 
2021-10-20 11:48:41,801 org.apache.camel.component.salesforce.internal.streaming.SubscriptionHelper.performClientRestart - Failed to restart after pausing for 0 msecs

```
hemangajmera:1634705294:2021-10-20T12:48:14.002+0000:1634705294:2021-10-20T12:48:14.002+0000:[~davsclaus], can you please change the affected version to 3.11.0.

 

I don't have way to reproduce it, but restart makes it works fine with the same connection parameters.
hemangajmera:1634705487:2021-10-20T12:51:27.013+0000:1634705487:2021-10-20T12:51:27.013+0000:Other related issues are CAMEL-12871 and CAMEL-12484
vsedykh:1635128163:2021-10-25T10:16:03.923+0000:1635128163:2021-10-25T10:16:03.923+0000:Hello!

 

I also faced the same issue on the 3.11 camel version.

In most cases, restart works fine, but sometimes it failed and always in logs I see the same error:
*403::Handshake denied*

When such an error happens, for some reason session is null and logout fails with NPE.

Maybe it makes sense to add a check for null for a session before calling logout.

Hope it helps.
davsclaus:1635128583:2021-10-25T10:23:03.613+0000:1635128583:2021-10-25T10:23:03.613+0000:Yeah avoiding the NPE makes sense. You are welcome to fix this by attaching a path to this JIRA or send a github PR
vsedykh:1635293773:2021-10-27T08:16:13.999+0000:1635293773:2021-10-27T08:16:13.999+0000:Sure I will, but first I wanted to make sure that checking for null resolves the problem. Unfortunattely not. NPE is fixed but there is another error:
{code:java}
2021-10-27T07:52:11.307+0000 [SalesforceHttpClient@7e8279e5-22] WARN [,] o.a.c.c.s.i.s.SubscriptionHelper - Handshake failure: {ext={sfdc={failureReason=401::Authentication invalid}, replay=true, payload.format=true}, advice={reconnect=none}, channel=/meta/handshake, id=784, error=403::Handshake denied, successful=false}2021-10-27T07:52:11.309+0000 [SalesforceHttpClient@7e8279e5-22] INFO [,] o.a.c.c.s.i.s.SubscriptionHelper - Cleaning session (logout) from SalesforceSession before restarting client2021-10-27T07:52:11.327+0000 [SalesforceHttpClient@7e8279e5-22] INFO [,] o.a.c.c.s.i.s.SubscriptionHelper - Cleaning session is not possible, session is null2021-10-27T08:00:15.464+0000 [SalesforceHttpClient@7e8279e5-25] ERROR [,] o.a.c.c.s.i.s.SubscriptionHelper - Error restarting: Exception during HANDSHAKE: 401::Authentication invalidorg.apache.camel.CamelException: Exception during HANDSHAKE: 401::Authentication invalidat org.apache.camel.component.salesforce.internal.streaming.SubscriptionHelper.connect(SubscriptionHelper.java:227)at org.apache.camel.component.salesforce.internal.streaming.SubscriptionHelper.doStart(SubscriptionHelper.java:216)at org.apache.camel.component.salesforce.internal.streaming.SubscriptionHelper.performClientRestart(SubscriptionHelper.java:308)at org.apache.camel.component.salesforce.internal.streaming.SubscriptionHelper.access$1000(SubscriptionHelper.java:60)at org.apache.camel.component.salesforce.internal.streaming.SubscriptionHelper$4.run(SubscriptionHelper.java:253)at org.eclipse.jetty.util.thread.QueuedThreadPool.runJob(QueuedThreadPool.java:882)at org.eclipse.jetty.util.thread.QueuedThreadPool$Runner.run(QueuedThreadPool.java:1036)at java.base/java.lang.Thread.run(Thread.java:829)Caused by: org.apache.camel.component.salesforce.api.SalesforceException: 401::Authentication invalidat org.apache.camel.component.salesforce.internal.streaming.SubscriptionHelper.getFailure(SubscriptionHelper.java:344)
{code}
I'm not sure yet how to resolve such an issue. I would be grateful for any thoughts.
davsclaus:1635294422:2021-10-27T08:27:02.931+0000:1635294422:2021-10-27T08:27:02.931+0000:That new error is better than a NPE as it better tells that real problem, so its a great step on the way
jeremyross:1636797761:2021-11-13T18:02:41.239+0000:1636797761:2021-11-13T18:02:41.239+0000:[~jasonholmberg] [~an.scaldaferri@gmail.com] [~hemangajmera] [~vsedykh] Just pushed a commit for this. Please test with 3.14.0-SNAPSHOT and let me know if this helps."
0,CAMEL-16369,Test,Major,3.9.0,3.9.0,"
None
",Resolved,Fixed,3.9.0,Unassigned,Claus Ibsen,0,1,2021-03-18 06:25:57+00:00,2021-03-18 08:08:00+00:00,"The new concurrent build may cause JMX test to fail flaky on CI like reported


org.apache.camel.builder.endpoint.PahoTest.testPaho
org.apache.camel.builder.endpoint.LanguageEndpointStaticTest.testLanguageFluent


Its about JMX MBean not found. As camel-management is on classpath then JMX gets enabled. We can make those tests disable JMX to prevent this.",
0,CAMEL-16338,Wish,Trivial,None,,"

performance

",Resolved,Won't Fix,None,Unassigned,Stepan Shcherbakov,0,2,2021-03-11 10:44:16+00:00,2021-03-12 12:33:12+00:00,"There is Component interface in camel with methods:


 




Endpoint createEndpoint(String uri) throws Exception;



and




Endpoint createEndpoint(String uri, Map<String, Object> parameters) throws Exception;




This signature is OK, but, when i write my own components, its uncomfortable.
For example, i work with RabbitMqComponent and i would like to configure RabbitMqEndpoint.
When i call RabbitMqComponent#createEndpoint i have to cast Endpoint to RabbitMqEndpoint.


 


May be Component interface should be like that:




public interface Component<T extends Endpoint> extends CamelContextAware, Service {
    T createEndpoint(String uri) throws Exception;


    T createEndpoint(String uri, Map<String, Object> parameters) throws Exception;
}



or it would lead to backward compability problems?","davsclaus:1615509362:2021-03-12T08:36:02.789+0000:1615509362:2021-03-12T08:36:02.789+0000:Yeah that is a too invasive change for very little gain. Especially when its for extending other components.

Camel end users shouldn't often not work with those APIs directly but use the route DSL, component DSL, endpoint DSL etc.
styopa1769:1615523592:2021-03-12T12:33:12.555+0000:1615523592:2021-03-12T12:33:12.555+0000:[~davsclaus] , I got it. 
Thank you for your reply!"
0,CAMEL-16337,Improvement,Major,None,3.9.0,"
None
",Resolved,Fixed,3.9.0,Claus Ibsen,Claus Ibsen,0,1,2021-03-11 09:29:05+00:00,2021-03-12 11:32:06+00:00,"To not forget about this idea.


We can recycle parts from old exchangeId, as we can break it into 2 parts, upper part that is uuid for lifetime of context, and lower part that is uuid per exchange.
So we can keep upper part as constant, and swap out the lower part.","davsclaus:1615518903:2021-03-12T11:15:03.106+0000:1615518903:2021-03-12T11:15:03.106+0000:The default uuid is generated as 32 char String. With first 16 as uuid, and last 16 as inc counter.
We can make a alternative short default that is 16 char (50% size) String, with 5 char upper, 1 sep, and 10 counter (16 values per digit)
davsclaus:1615519926:2021-03-12T11:32:06.849+0000:1615519926:2021-03-12T11:32:06.849+0000:Added a short generator that is 50% the size"
0,CAMEL-16336,Improvement,Major,3.9.0,3.9.0,"
None
",Resolved,Fixed,3.9.0,Unassigned,James Netherton,0,2,2021-03-11 07:58:13+00:00,2021-03-11 12:49:49+00:00,"See discussion in Zulip about CustomSlackHttpClient here:


https://camel.zulipchat.com/#narrow/stream/257298-camel/topic/CustomSlackHttpClient


The slack-api-client is bound to okhttp 4.x and CustomSlackHttpClient seems to be an effort to make the component bin compatible with okhttp client 3.x. But the RequestBody.create method signature used is referencing the 4.x APIs instead of 3.x.


Perhaps we should override and force okhttp 3.x in the component pom.xml and do the necessary bin compat tweaks in CustomSlackHttpClient? I'm no expert on okhttp or the slack-api-client so not sure if this can work reliably.",
0,CAMEL-16335,Task,Minor,None,,"

easy
help-wanted

",Open,Unresolved,None,Andrea Cosentino,Andrea Cosentino,0,1,2021-03-11 06:02:34+00:00,2023-11-14 13:26:00+00:00,No Desc,
0,CAMEL-16334,Task,Major,None,None,"
None
",Resolved,Fixed,3.9.0,Andrea Cosentino,Andrea Cosentino,0,1,2021-03-11 06:02:14+00:00,2021-03-12 07:35:02+00:00,No Desc,
0,CAMEL-16333,Task,Major,None,None,"
None
",Resolved,Fixed,3.9.0,Andrea Cosentino,Andrea Cosentino,0,1,2021-03-11 06:01:19+00:00,2021-03-11 07:33:50+00:00,No Desc,
0,CAMEL-16332,Task,Major,None,None,"
None
",Resolved,Fixed,3.9.0,Andrea Cosentino,Andrea Cosentino,0,1,2021-03-11 06:01:01+00:00,2021-03-12 15:46:37+00:00,No Desc,
0,CAMEL-16331,Improvement,Major,3.9.0,3.9.0,"
None
",Resolved,Fixed,3.9.0,Claus Ibsen,Claus Ibsen,0,1,2021-03-10 18:23:45+00:00,2021-03-12 13:11:59+00:00,"When we use polling consumer via consumer template on a component that does not have a special polling consumer impl, but rely on the default consumer, should not use pooled exchange when creating exchange as the exchange will be reset before data is returned, and then its empty.",
0,CAMEL-16330,Task,Major,None,None,"
None
",Resolved,Duplicate,3.x,Unassigned,Claus Ibsen,0,1,2021-03-10 11:12:32+00:00,2021-03-11 11:42:07+00:00,No Desc,
0,CAMEL-16329,Task,Major,None,3.9.0,"
None
",Resolved,Fixed,3.9.0,Andrea Cosentino,Andrea Cosentino,0,1,2021-03-10 11:10:17+00:00,2021-03-10 11:27:39+00:00,"This would make the stream a real stream, otherwise you will end up consuming the same email on each poll",
0,CAMEL-16328,Improvement,Minor,3.9.0,None,"
None
",Resolved,Fixed,3.9.0,James Netherton,James Netherton,0,1,2021-03-10 10:20:34+00:00,2021-03-10 11:59:31+00:00,Seems support for a custom Slack server URL got lost in CAMEL-16255 (I.e the serverUrl option). It's useful for testing and setting a custom URL prefix if needed.,
0,CAMEL-16327,Bug,Major,"3.6.0, 3.7.0, 3.7.1, 3.7.2, 3.8.0",3.9.0,"
None
",Resolved,Duplicate,3.9.0,Unassigned,Damiano Fontana,0,3,2021-03-10 08:48:59+00:00,2021-03-15 09:10:46+00:00,"Kafka Consumer Component configured with 



autoCommitEnable == false
allowManualCommit == true
autoCommitOnStop == none



always commits the last seen offset for every partition when route is shut down.


What's happens is the following:



consumer.unsubscribe() is called
onPartitionsRevoked() is called
commitOffset() with forceCommit == true is called","acosentino:1615535237:2021-03-12T15:47:17.294+0000:1615535237:2021-03-12T15:47:17.294+0000:[~omarsmak] is this fixed with your latest commit on kafka?
omarsmak:1615770605:2021-03-15T09:10:05.450+0000:1615770646:2021-03-15T09:10:46.034+0000:[~acosentino] [~dfontana@cuebiq.com] yes that is fixed by CAMEL-16343. The issue as has been highlighted is that, whenever onPartitionsRevoked called internally in the Kafka Consumer, it was committing offsets regardless if you set `autoCommitEnable` or not. Now if you set `autoCommitEnable` to `false`, it will not commit any offsets."
0,CAMEL-16326,Improvement,Major,None,3.9.0,"
None
",Resolved,Fixed,3.9.0,Claus Ibsen,Claus Ibsen,0,1,2021-03-10 08:47:16+00:00,2021-03-12 08:31:32+00:00,"We could potentially optimize TO_ENDPOINT which is stored as property on the exchange, which takes up an entry in the map. As its commonly in use, we could store it directly on the Exchange.


pro: no object garbage
con: new api to retrieve the information","davsclaus:1615425491:2021-03-11T09:18:11.680+0000:1615501368:2021-03-12T06:22:48.898+0000:Optimising for known set property keys to be stored in a quicker way.

TODO: ExchangePropertyKey *DONE*
TODO: api on Exchange *DONE*
TODO: getInternalProperties *DONE*
TODO: message history *DONE*
TODO: optimize EIPs and elsewhere in camel-core *DONE*
TODO: Add note to migration doc *DONE*
"
0,CAMEL-16325,Bug,Major,None,,"
None
",Resolved,Invalid,None,Unassigned,Nishtha Rai,0,2,2021-03-10 07:59:04+00:00,2021-03-10 10:13:32+00:00,"Hi,


We have created a simple camel route -


@Override@Override public void configure() throws Exception { from(""file://C:/in/?fileName=Input_UTF8.txt"") .process(exchange -> 

{           System.out.println(""Headers after in: ""+ exchange.getIn().getHeaders());     }

)         .onCompletion()           .process(exchange -> {                 sendFooter(exchange);                 System.out.println(""Headers after Footer: ""+ exchange.getIn().getHeaders());           })                   .end()                      .process(exchange -> {  sendHeader(exchange);  System.out.println(""Headers after header: ""+ exchange.getIn().getHeaders());        }) .split(body().tokenize(lineSeperator)) .streaming()   .to(""file://C:/out/?fileName=Output.txt&fileExist=Append"") .process(exchange -> {           System.out.println(""Headers after each record: ""+ exchange.getIn().getHeaders());     }); } private void sendHeader(Exchange exchange) { ProducerTemplate template = getContext().createProducerTemplate(); template.sendBodyAndHeaders(""file://C:/out/?fileName=Output.txt&fileExist=Append"",""header1,header2"",exchange.getIn().getHeaders());    } private void sendFooter(Exchange exchange) { ProducerTemplate template = getContext().createProducerTemplate();               template.sendBodyAndHeaders(""file://C:/out/?fileName=Output.txt&fileExist=Append"",""footer"",exchange.getIn().getHeaders()); }


 


CamelFileNameProduced header is not coming when there is no data in the file (header and footer will be there) although it is creating a file in the destination directory.","davsclaus:1615336920:2021-03-10T08:42:00.821+0000:1615336920:2021-03-10T08:42:00.821+0000:Ask first on the mailing list or chat room to get help
nishtha.rai:1615339546:2021-03-10T09:25:46.728+0000:1615339546:2021-03-10T09:25:46.728+0000:[~davsclaus] Could you please share details of mailing list or any link for chat room
davsclaus:1615342412:2021-03-10T10:13:32.453+0000:1615342412:2021-03-10T10:13:32.453+0000:https://camel.apache.org/community/support/"
0,CAMEL-16324,Bug,Major,3.9.0,3.9.0,"
None
",Resolved,Fixed,3.9.0,Claus Ibsen,Claus Ibsen,0,1,2021-03-09 19:31:08+00:00,2021-03-09 19:37:53+00:00,"This commit causes spring TX to not work
https://github.com/apache/camel/commit/ee5a18c8b4989ce2933203c47220830c9c7a8a82",
0,CAMEL-16323,New Feature,Major,None,3.9.0,"
None
",Resolved,Fixed,3.9.0,Andrea Cosentino,Andrea Cosentino,0,1,2021-03-09 17:35:08+00:00,2021-03-17 07:53:15+00:00,No Desc,"acosentino:1615535554:2021-03-12T15:52:34.089+0000:1615535554:2021-03-12T15:52:34.089+0000:First implementation is pushed, for the moment it support listing the secrets. I'll add more operations next week."
0,CAMEL-16322,Improvement,Major,None,None,"
None
",Resolved,Fixed,3.9.0,Andrea Cosentino,Andrea Cosentino,0,1,2021-03-09 17:24:45+00:00,2021-03-10 11:15:27+00:00,No Desc,
0,CAMEL-16321,Improvement,Major,None,None,"
None
",Resolved,Fixed,3.9.0,Andrea Cosentino,Andrea Cosentino,0,1,2021-03-09 17:24:29+00:00,2021-03-10 06:47:02+00:00,No Desc,
0,CAMEL-16320,Improvement,Major,None,3.x,"
None
",Resolved,Won't Fix,3.x,Unassigned,Nicola Ferraro,0,2,2021-03-09 13:59:05+00:00,2022-09-02 17:44:29+00:00,"I'm running the following integration:


 




- from:
    uri: ""timer:yaml""
    parameters:
      period: ""10000""
    steps:
    - to: ""netty-http:https://github.com/apache/camel/raw/7204aa132662ab6cb8e3c5afea8b9b0859eff0e8/docs/img/logo.png""
    - to: ""log:info""
 



With `kamel local run netty.yaml`.


It hits a redirect on Github, but there's no way to ""follow redirects"" in the component documentation, like for the ""http"" component.


Error:


 




2021-03-09 14:58:45,031 WARN  [org.apa.cam.com.tim.TimerConsumer] (Camel Thread #1 - NettyClientTCPWorker) Error processing exchange. Exchange[1AC7E2A0D31F4A0-0000000000000000]. Caused by: [org.apache.camel.component.netty.http.NettyHttpOperationFailedException - Netty HTTP operation failed invoking null with statusCode: 302, redirectLocation: https://raw.githubusercontent.com/apache/camel/7204aa132662ab6cb8e3c5afea8b9b0859eff0e8/docs/img/logo.png]: org.apache.camel.component.netty.http.NettyHttpOperationFailedException: Netty HTTP operation failed invoking null with statusCode: 302, redirectLocation: https://raw.githubusercontent.com/apache/camel/7204aa132662ab6cb8e3c5afea8b9b0859eff0e8/docs/img/logo.png","davsclaus:1615347899:2021-03-10T11:44:59.412+0000:1615347899:2021-03-10T11:44:59.412+0000:Oh this is a bit tricky as netty-http (their http layer on top of netty) is very low-level. And its essentially camel-netty that makes a TCP call masked as http. So we would have to add redirect support ourselves, and have check for circular refernce, eg A -> B -> C -> B
And  have a max deep to follow
davsclaus:1662111869:2022-09-02T17:44:29.944+0000:1662111869:2022-09-02T17:44:29.944+0000:use vertx-http instead of some better http component"
0,CAMEL-16319,Improvement,Major,None,3.9.0,"
None
",Resolved,Fixed,3.9.0,Claus Ibsen,Claus Ibsen,0,1,2021-03-09 13:08:46+00:00,2021-03-10 08:41:10+00:00,"Consumers that starts the routing by calling the first processor, have AsyncCallback as lambda which creates a new instance per message.


If pooled we can for some consumers avoid this and reuse the lambda. But we need to find a way to make this transparent so the lambda can work in prototype vs pooled mode.","davsclaus:1615269636:2021-03-09T14:00:36.506+0000:1615269636:2021-03-09T14:00:36.506+0000:This requires to go over each component that has consumers, and see if they do something special for their AsyncCallback or we can use a default one.

TODO: camel-timer *DONE*"
0,CAMEL-16318,Bug,Minor,"3.7.2, 3.8.0","3.7.4, 3.9.0","
None
",Resolved,Fixed,"3.7.4, 3.9.0",Unassigned,Jörg Jansen,0,1,2021-03-09 08:46:22+00:00,2021-03-09 11:45:41+00:00,"Running camel-kafka within camel-karaf causes a ClassNotFoundException, when using a customized AuthenticationCallbackHandler.


As the callback classname is converter to String, the ContextClassLoader is not aware of it.","jansenj:1615251066:2021-03-09T08:51:06.563+0000:1615251066:2021-03-09T08:51:06.563+0000:Should be fixed, by adding the property to method updateClassProperties. 
In this case, the provided class is used, instead of creating a new Class from given String. 

 

I will provide a PR soon."
0,CAMEL-16317,Bug,Major,3.7.2,"3.7.4, 3.9.0","
None
",Closed,Invalid,"3.7.4, 3.9.0",Unassigned,Eemeli Lottonen,0,2,2021-03-09 08:28:11+00:00,2021-03-09 12:02:46+00:00,https://camel.zulipchat.com/#narrow/stream/257298-camel/topic/SFTP.20component.20fails.20to.20parse.20query.20parameter/near/229438207,davsclaus:1615249916:2021-03-09T08:31:56.266+0000:1615249916:2021-03-09T08:31:56.266+0000:The converter must somehow return null instead of 3000 Duration
0,CAMEL-16316,Bug,Minor,"3.1.0, 3.7.2",3.10.0,"
None
",Resolved,Fixed,3.10.0,Claus Ibsen,Zoltán Nébli,0,2,2021-03-08 13:10:39+00:00,2021-03-23 06:20:02+00:00,"The




CompletableFuture<Exchange> asyncSend(String endpointUri, Processor processor)



method is not thread safe because the processor is passed as a lambda to the executor service:




getExecutorService().submit(() -> getProducerCache().asyncSendExchange(endpoint, pattern, processor,
 resultProcessor, inExchange, exchangeFuture));



and therefore if the caller use the original Exchange reference in the Processor, for example




request -> request.setBody(originalExchange.getIn().getBody(...))



the executorService thread will use a dirty Exchange body in cases where the original executor thread runs faster.
On the other hand this method is thread safe because the new Exchange object can be populated from the original exchange:




CompletableFuture<Exchange> asyncSend(String endpointUri, Exchange exchange)



I think the solution would be processing the request with the passed processor then submit the job to the executor service or clearly mention this in the API doc. This behavior is currently not straightforward.


Of course you can pass references with the 2. method also which will become dirty but I think the clear intention here is sending a clean Exchange asynchronously to an endpoint with either a Processor or an exact Exchange object.","davsclaus:1615183093:2021-03-08T13:58:13.236+0000:1615183093:2021-03-08T13:58:13.236+0000:Camel 3.1 is rather old, try with 3.7.3
ezolnbl:1615197693:2021-03-08T18:01:33.009+0000:1615197693:2021-03-08T18:01:33.009+0000:there is no 3.7.3 version on maven central but there is 3.7.2 and the implementation is very similar of the *asyncSendExchange* method:
{code:java}
CompletableFuture<Exchange> exchangeFuture = new CompletableFuture();
this.getExecutorService().submit(() -> {
 return this.getProducerCache().asyncSendExchange(endpoint, pattern, processor, resultProcessor, inExchange, exchangeFuture);
});
return exchangeFuture;{code}
the processor lambda is not evaluated until a thread from the executor threadpool starts work on it.
davsclaus:1616451602:2021-03-23T06:20:02.756+0000:1616451602:2021-03-23T06:20:02.756+0000:Added note to javadoc about the thread-safety issue"
0,CAMEL-16315,Improvement,Major,None,None,"
None
",Resolved,Fixed,"3.7.4, 3.9.0",Andrea Cosentino,Andrea Cosentino,0,1,2021-03-08 12:28:42+00:00,2021-03-08 14:19:05+00:00,"https://netty.io/4.1/api/io/netty/handler/ssl/SslContext.html


We need to manage SSLParameters like the newHandler",
0,CAMEL-16314,Improvement,Major,3.9.0,3.9.0,"
None
",Resolved,Fixed,3.9.0,Claus Ibsen,Claus Ibsen,0,1,2021-03-08 09:11:25+00:00,2021-03-17 10:05:21+00:00,Some components should not allow pooled exchanges as they does some special processing that prevents handling pooled exchanges,"davsclaus:1615171754:2021-03-08T10:49:14.075+0000:1615189189:2021-03-08T15:39:49.886+0000:camel-jetty *DONE*
camel-jms *DONE*
camel-sjms *DONE*
camel-netty *DONE*
camel-netty-http *DONE*
camel-reactor  *WONT FIX*
camel-rxjava  *WONT FIX*
camel-spring-rabbitmq *DONE*
davsclaus:1615189273:2021-03-08T15:41:13.124+0000:1615189273:2021-03-08T15:41:13.124+0000:We can late take a look at this again if we can make some of these supported pooled, however as now they have been disabled for these components.
davsclaus:1615189299:2021-03-08T15:41:39.167+0000:1615189299:2021-03-08T15:41:39.167+0000:spring-rabbit is similar in structure as jms/sjms so it was disabled like they were."
0,CAMEL-16313,Improvement,Major,3.8.0,3.9.0,"
None
",Resolved,Fixed,3.9.0,Jiri Ondrusek,Jiri Ondrusek,0,1,2021-03-08 08:17:26+00:00,2021-03-08 15:57:02+00:00,"Splunk offers free licence (https://docs.splunk.com/Documentation/Splunk/8.1.2/Admin/MoreaboutSplunkFree) with very limited features. One of them is that ""There are no users or roles."". It would be nice to allow camel-splunk component to not require credentials. It should be a very simple change, just to add conditions here: https://github.com/apache/camel/blob/master/components/camel-splunk/src/main/java/org/apache/camel/component/splunk/SplunkConnectionFactory.java#L116


 


This could allow creation of junit tests with testcontainer (splunk free server).",
0,CAMEL-16312,New Feature,Major,None,3.10.0,"
None
",Resolved,Won't Fix,3.10.0,Unassigned,Claus Ibsen,0,2,2021-03-07 07:51:33+00:00,2021-05-03 13:54:33+00:00,"We should be able to specify what input a parameter can accept, so you can restrict this.


We should be able to specify the parameter



type (string, boolean, int, long, float)
min range
max range
regexp pattern
enum of valid choices
etc
example",davsclaus:1620021273:2021-05-03T13:54:33.936+0000:1620021273:2021-05-03T13:54:33.936+0000:This is done at the kamelet side of things as its follow a json spec standarad that defines such features.
0,CAMEL-16311,Improvement,Major,None,3.9.0,"
None
",Resolved,Fixed,3.9.0,Claus Ibsen,Claus Ibsen,0,1,2021-03-06 14:38:15+00:00,2021-03-06 14:39:23+00:00,"When you use freemarker you dont want it to load templates with all kind of locale names in the filename, but just the file name as-is.",
0,CAMEL-16310,New Feature,Minor,None,3.9.0,"

feature

",Resolved,Fixed,3.9.0,Unassigned,Anthony Defraine,0,1,2021-03-05 21:40:11+00:00,2021-03-08 12:01:55+00:00,"Allow to use a different container than the default DirectMessageListenerContainer 
It will allow us to configure more properties (number of consumers, max consumers, ...)


https://docs.spring.io/spring-amqp/reference/html/#choose-container",
0,CAMEL-16309,Bug,Major,"3.7.0, 3.7.1, 3.7.2, 3.7.3, 3.8.0","3.7.4, 3.9.0","
None
",Resolved,Fixed,"3.7.4, 3.9.0",Andrea Cosentino,Laurence Reading,0,2,2021-03-05 18:01:19+00:00,2021-03-06 14:19:20+00:00,"The RestOpenApiReader has a typo such that it generates an incorrect schema:


https://github.com/apache/camel/blob/3382b4dd6de52024b15efdb081e3f386af1b52f2/components/camel-openapi-java/src/main/java/org/apache/camel/openapi/RestOpenApiReader.java#L124


reads:




prop.type = ""sting"";



 


This should read:




prop.type = ""string"";



 


This causes it to generate a schema like:



	""responses"": {
		""200"": {
			""content"": {
				""text/plain"": {
					""schema"": {
						""format"": ""string"",
						""type"": ""sting""
					}
				}
			},
			""description"": ""Returns status code 200 when the report is returned""
		



Which run used to generate a client creates code that looks for a ""Sting"" type which does not exist","Mahas_M:1614948629:2021-03-05T20:50:29.251+0000:1614948629:2021-03-05T20:50:29.251+0000:Hi, I am Mahas Milhar from University of Jaffna department of computer Science, Sri Lanka. I want to work with this project for Gsoc 2021 please help me to start this project 
Thank you "
0,CAMEL-16308,Task,Major,None,None,"
None
",Resolved,Fixed,3.9.0,Andrea Cosentino,Andrea Cosentino,0,1,2021-03-05 06:12:14+00:00,2021-03-05 08:31:12+00:00,No Desc,
0,CAMEL-16307,Bug,Major,None,None,"
None
",Closed,Fixed,3.9.0,Peter Palaga,Peter Palaga,0,1,2021-03-04 20:30:08+00:00,2021-03-08 09:10:29+00:00,"Originally found in Camel Quarkus https://github.com/apache/camel-quarkus/issues/2302


After asking about this on https://github.com/Azure/azure-sdk-for-java/issues/19612 it seems to be a feature rather than a bug. We are using DataLakeFileClient.openQueryInputStream() for something it was not designed for. Although there are other endpoints in the API that would allow to get the file without the newline appended, DataLakeFileClient.openQueryInputStream() seems to be the only one returning an InputStream. The others work with an OutputStream, etc. and so they'd require storing the whole file in memory or on disk, which would ineffective for us. 


I am going to solve it via a custom InputStream that filters the last newline out.",
0,CAMEL-16306,New Feature,Minor,3.7.2,Future,"
None
",Open,Unresolved,Future,Unassigned,Raymond,0,2,2021-03-04 19:13:53+00:00,2023-08-09 09:21:29+00:00,"In the current SJMS implementation the docs says:


 


""Currently the only correlation strategy is to use the JMSCorrelationId.""


 


I would like to correlate by property just as the JMS component has (correlationProperty ). or by JMSMessageId (UseJMSMessageIDAsCorrelationId).","davsclaus:1614929615:2021-03-05T15:33:35.470+0000:1614929615:2021-03-05T15:33:35.470+0000:There is a bit of work to support such kind, especially the latter as you only know the actual JMSMessageID after the message is sent. 
The former is easier.

See the jms component and you can copy over its code to camel-sjms where it needs to be. 
"
0,CAMEL-16305,Bug,Minor,None,"3.7.3, 3.9.0","
None
",Resolved,Fixed,"3.7.3, 3.9.0",James Netherton,James Netherton,0,1,2021-03-04 14:10:21+00:00,2021-03-04 15:54:30+00:00,"If you use the camel-servicenow-maven-plugin to generate model classes, they are not able to be compiled because the @Generated annotation is missing the generator name value.",jamesnetherton:1614838276:2021-03-04T14:11:16.536+0000:1614838276:2021-03-04T14:11:16.536+0000:I guess we should probably backport this to 3.7.x since it should be a simple fix?
0,CAMEL-16304,New Feature,Minor,None,None,"
None
",Resolved,Abandoned,3.x,Unassigned,Luca Burgazzoli,0,1,2021-03-04 13:39:13+00:00,2022-09-02 17:43:14+00:00,We should think about providing a seda like component based on JCTools,
0,CAMEL-16303,Task,Major,None,None,"
None
",Resolved,Fixed,"3.7.3, 3.9.0",Andrea Cosentino,Andrea Cosentino,0,1,2021-03-04 09:42:03+00:00,2021-03-05 06:07:04+00:00,"For example take this:


 




///usr/bin/env jbang ""$0"" ""$@"" ; exit $?
//DEPS org.apache.camel:camel-core-engine:3.8.0
//DEPS org.apache.camel:camel-main:3.8.0
//DEPS org.apache.camel:camel-direct:3.8.0
//DEPS org.apache.camel:camel-google-bigquery:3.8.0
//DEPS org.slf4j:slf4j-nop:1.7.25
import java.util.*;
import org.apache.camel.*;
import org.apache.camel.spi.*;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.main.Main;
Main main = new Main();
main.configure().addRoutesBuilder(new RouteBuilder() {
 @Override
 public void configure() throws Exception {
 EndpointUriFactory factory = getContext().adapt(ExtendedCamelContext.class).getEndpointUriFactory(""google-bigquery-sql"");
 Map<String, Object> config = Map.of(
 ""projectId"", ""test"", 
 ""query"", ""insert into test.test values (1,1)""
 );
 String uri = factory.buildUri(""google-bigquery-sql"", config, false);
 System.out.println(""uri = "" + uri);
 from(""direct:start"").to(uri);
 }
});
main.run();
 




 


The output of this jbang jsh file will be


uri = google-biginsert into test.test values (1,1)-sql:test:insert into test.test values (1,1)


which is wrong, the google-bigquery-sql is now google-big<query path param>-sql:..


I think for google big query we need to rename the query path param, but maybe the generation and substitution needs to be checked again",acosentino:1614853632:2021-03-04T18:27:12.457+0000:1614853632:2021-03-04T18:27:12.457+0000:Need to backport to 3.7.x
0,CAMEL-16302,New Feature,Major,None,3.9.0,"
None
",Resolved,Fixed,3.9.0,Claus Ibsen,Claus Ibsen,0,1,2021-03-04 08:58:23+00:00,2021-03-05 14:05:03+00:00,"We can add support for letting property placeholders be optional, if the key starts with ?


eg so you can do




to(""kafka:cheese?{{?maxBlock}}"")




And maxBlock is a key=value


But for endpoints we should allow the value to indicate its optional which makes the option optional.




to(""kafka:cheese?maxBlockMs={{?myBlock}}"")




So the producer will then only use maxBlockMs if there is a value, otherwise the uri becomes ""kafka:cheese""","davsclaus:1614832041:2021-03-04T12:27:21.967+0000:1614832041:2021-03-04T12:27:21.967+0000:So by marking a key with ? then its marked as optional. We could also use ""optional:"" as prefix, eg 

{code}
{{optional:myBlock}}
{code}

However then its regarded as a function, eg optional which is not really what it is, but we can make some workaround for that. Using ? is shorter. 
davsclaus:1614901965:2021-03-05T07:52:45.942+0000:1614921514:2021-03-05T13:18:34.185+0000:TODO: optional placeholders for endpoint URIs *DONE*
TODO: optional placeholders for endpoint DSL *DONE*
TODO: optional placeholders for EIPs *DONE*
TODO: update docs *DONE*
"
0,CAMEL-16301,New Feature,Minor,None,3.9.0,"

feature

",Resolved,Fixed,3.9.0,Unassigned,Anthony Defraine,0,1,2021-03-04 07:48:11+00:00,2021-03-05 15:31:52+00:00,"Allow endpoint to override prefetchCount from component. Validated by Claus Ibsen


https://camel.zulipchat.com/#narrow/stream/257298-camel/topic/camel-spring-rabbitmq/near/228564416


Working on the patch",
0,CAMEL-16300,Task,Major,None,3.9.0,"
None
",Resolved,Fixed,3.9.0,Andrea Cosentino,Andrea Cosentino,0,1,2021-03-03 17:10:36+00:00,2021-03-03 17:36:26+00:00,No Desc,
0,CAMEL-16299,Task,Major,None,None,"
None
",Resolved,Fixed,3.9.0,Otavio Rodolfo Piske,Otavio Rodolfo Piske,0,1,2021-03-03 16:49:26+00:00,2021-03-12 08:45:17+00:00,"In some cases, it would be good for the client code to fine tune the service configuration. Currently, this is one on a per service basis, but a more elegant solution would be desirable.


 


One idea would be to allow the services to be customized using something like:


 


 




MyServiceFactory
.withCustomConfig(<here we pass a configuration object>)
.createService();",orpiske:1615443491:2021-03-11T14:18:11.449+0000:1615443491:2021-03-11T14:18:11.449+0000:Fixed with: https://github.com/apache/camel/pull/5195
0,CAMEL-16298,Bug,Major,None,3.9.0,"
None
",Resolved,Fixed,3.9.0,Claus Ibsen,Claus Ibsen,0,1,2021-03-03 15:58:59+00:00,2021-03-03 16:40:35+00:00,"Reported on chat
https://camel.zulipchat.com/#narrow/stream/257298-camel/topic/PollEnrich.20endpoint.20DSL.20using.20producer.20instead.20of.20consumer


It is using producer builder, but it should be using consumer builder.","davsclaus:1614760835:2021-03-03T16:40:35.141+0000:1614760835:2021-03-03T16:40:35.141+0000:As this is an API breaking in pollEnrich with the endpoint-dsl then lets make this for 3.9 onwards in case some 3.7.x users upgrade and use it, but didn't need consumer only options."
0,CAMEL-16297,Bug,Major,"3.7.2, 3.8.0","3.7.3, 3.9.0","
None
",Resolved,Duplicate,"3.7.3, 3.9.0",Unassigned,Claus Ibsen,0,1,2021-03-03 14:09:30+00:00,2021-03-03 14:09:48+00:00,"Reported on chat
https://camel.zulipchat.com/#narrow/stream/257298-camel/topic/split.20with.20AggregationStrategy.20is.20ignored.20when.20using.20transac",davsclaus:1614751788:2021-03-03T14:09:48.678+0000:1614751788:2021-03-03T14:09:48.678+0000:CAMEL-16295
0,CAMEL-16296,Bug,Minor,3.6.0,"3.7.3, 3.9.0","
None
",Resolved,Fixed,"3.7.3, 3.9.0",Claus Ibsen,Piotr Swiderski,0,3,2021-03-03 12:54:17+00:00,2021-03-03 13:38:43+00:00,"I try to create as2 server using camel-as2. I created a simple server in camel-context and installed bundle on Karaf.





When I install bundle in Karaf for the first time, everything is fine. When I uninstall and install bundle in Karaf I get an error.","davsclaus:1614747393:2021-03-03T12:56:33.411+0000:1614747393:2021-03-03T12:56:33.411+0000:try with 3.8.0
davsclaus:1614747480:2021-03-03T12:58:00.551+0000:1614747480:2021-03-03T12:58:00.551+0000:It smells like there is some code to stop http server in doStop of the as2 component that is not called.
acosentino:1614747549:2021-03-03T12:59:09.183+0000:1614747549:2021-03-03T12:59:09.183+0000:I think it could be something related to windows too. 
pswid:1614748651:2021-03-03T13:17:31.361+0000:1614748651:2021-03-03T13:17:31.361+0000:with 3.8.0 I have the same error.
acosentino:1614749073:2021-03-03T13:24:33.362+0000:1614749073:2021-03-03T13:24:33.362+0000:on the endpoint there is an as2ServerConnection. It is created but never released.
davsclaus:1614749840:2021-03-03T13:37:20.462+0000:1614749840:2021-03-03T13:37:20.462+0000:Yeah I have looked too, and can see the same problem. Have a fix to stop all connections when the component is being stopped. Push a commit in a moment"
0,CAMEL-16295,Bug,Major,3.8.0,"3.7.4, 3.9.0","
None
",Resolved,Fixed,"3.7.4, 3.9.0",Claus Ibsen,Sita Geßner,0,3,2021-03-03 10:40:45+00:00,2021-03-16 13:17:29+00:00,"After migration from Camel 2.25.x to Camel 3.8.0 have the problem that my AggregationStrategy is ignored, when using .transacted() in the routedefinition.


The breakpoint in the AggregationStrategy doesn't trigger. After removing transacted from the routedefinition everything is fine and the AggregationStrategy is used and the breakpoint triggers.


 


Reproducer:


https://github.com/razilein/cameltest","davsclaus:1614753772:2021-03-03T14:42:52.051+0000:1614753772:2021-03-03T14:42:52.051+0000:Thanks for reporting and the reproducer.
I have a fix in the works.
sgessner:1615168437:2021-03-08T09:53:57.236+0000:1615168437:2021-03-08T09:53:57.236+0000:[~davsclaus] Did you not plan to release the version 3.8.1?
davsclaus:1615168954:2021-03-08T10:02:34.140+0000:1615168954:2021-03-08T10:02:34.140+0000:No its not a LTS release
catom1:1615781074:2021-03-15T12:04:34.533+0000:1615781074:2021-03-15T12:04:34.533+0000:Hi,

i've tried the new 3.7.3 LTS release but the problem still persists.

If I debug the MulticastProcessor class the sequence of execution seems wrong in the MulticastTransactedTask (on line 589 - 593):
{code:java}
// accept the exchange as a result
completion.submit(exchangeResult -> exchangeResult.accept(exchange));

// aggregate exchanges if any
aggregate();{code}
The aggregate method is called before the exchangeResult.accept(exchange) what leads to an empty completion.poll() on line 355 of the code, so no aggregation is done. In the MulticastReactiveTask the aggregate is called inside the completion.submit function, should this not be the same in the MulticastTransactedTask?
{code:java}
completion.submit(exchangeResult -> {
    // accept the exchange as a result 
    exchangeResult.accept(exchange)); 
    // aggregate exchanges if any 
    aggregate();
}{code}
Am i missing something here?
davsclaus:1615781749:2021-03-15T12:15:49.137+0000:1615781749:2021-03-15T12:15:49.137+0000:Ah yeah that seems resonable. You are welcome to submit a PR
catom1:1615870595:2021-03-16T12:56:35.486+0000:1615870595:2021-03-16T12:56:35.486+0000:[~davsclaus] is there a date when the version 3.7.4 will be released ?
davsclaus:1615871849:2021-03-16T13:17:29.537+0000:1615871849:2021-03-16T13:17:29.537+0000:No but it will be a while since 3.7.3 was just released"
0,CAMEL-16294,Improvement,Major,None,3.9.0,"
None
",Resolved,Fixed,3.9.0,Claus Ibsen,Claus Ibsen,0,1,2021-03-03 10:19:44+00:00,2021-03-03 13:03:01+00:00,"When using PollingConsumer (not normal Consumer) then an exchange polled may go via the EventDrivePollingConsumer as internal queue. And when so, there exchange may not have a way for handing over the uow, so it can be in the exchange the polling consumer receive, and for it to handle.",
0,CAMEL-16293,Task,Major,None,3.9.0,"
None
",Resolved,Fixed,3.9.0,Andrea Cosentino,Andrea Cosentino,0,1,2021-03-03 09:46:07+00:00,2021-03-08 07:23:06+00:00,Where we have autocreation the default value should be false,
0,CAMEL-16292,Improvement,Major,None,"3.7.3, 3.9.0","
None
",Resolved,Fixed,"3.7.3, 3.9.0",Claus Ibsen,Claus Ibsen,0,1,2021-03-03 07:28:31+00:00,2021-03-03 07:28:36+00:00,No Desc,
0,CAMEL-16291,Bug,Major,None,"2.25.4, 3.7.3, 3.9.0","
None
",Resolved,Fixed,"2.25.4, 3.7.3, 3.9.0",Freeman Yue Fang,Freeman Yue Fang,0,1,2021-03-02 19:11:48+00:00,2021-03-02 19:20:19+00:00,"javax.ws.rs.core.Response is an interface, not a concrete class to unmarshal. Just need to pass the inputstream to next processor.


We need to address this for async mode, since sync mode is correct",
0,CAMEL-16290,New Feature,Major,None,4.x,"
None
",Open,Unresolved,4.x,Unassigned,Claus Ibsen,0,1,2021-03-02 17:01:26+00:00,2023-08-09 09:21:35+00:00,"When using camel-main as standalone then we only have support for loading .properties file for configuration.


Some users are on the yaml wagon, so we could consider adding a new camel-main-yaml module that adds support for loading configuration from yaml and comes out of the box with the yaml dsl too. 


We can then make some kind of Main class for yaml that can startup Camel and load application.yaml as configuration and load routes .yaml files as routes. Then you can run Camel standalone in this yaml world.


And then this can be a way for also running Kamelets standalone by having camel-kamelet included and being able to load kamelets yaml spec files.


Yes they are intended for k8s but it may be okay to try to develop and play with kamelets without an entire k8s platform.",
0,CAMEL-16289,Improvement,Major,None,None,"
None
",Resolved,Won't Fix,3.x,Unassigned,Claus Ibsen,0,1,2021-03-02 16:25:17+00:00,2022-09-02 17:42:24+00:00,"The camel-tracing module has decorators. One for kafka, but we need one for vertx-kafka.
They may have the same header keys so its mostly a copy/paste. But check with the source code what the keys are named in camel-vertx-kafka.",davsclaus:1662111744:2022-09-02T17:42:24.749+0000:1662111744:2022-09-02T17:42:24.749+0000:vertx-kafka is deprecated
0,CAMEL-16258,Bug,Minor,None,3.9.0,"
None
",Resolved,Fixed,3.9.0,Claus Ibsen,Claus Ibsen,0,1,2021-02-25 08:34:15+00:00,2021-02-25 10:07:52+00:00,"There was some code changes to modularize and avoid JVM system properties and it affected this. Now these options are set on DefaultCamelContext in some special way.


We need to leverage this in the routes collector to use this to filter excluded route builders.",
0,CAMEL-16257,Task,Major,None,,"
None
",Resolved,Abandoned,None,Unassigned,Claus Ibsen,0,3,2021-02-24 15:30:12+00:00,2022-06-29 07:36:38+00:00,"Users are looking for webservice examples without CXF.


We could use a light example that uses Camel's platform-http as HTTP server and then camel-soap to marshal to/from SOAP message.


The are different payload modes we can use with RAW or JAXB where the latter requires to build Java objects with annotations.


However this lacks the possibility to generate a wsdl file as contract. So this approach may work for contract first development.","thefreakingmind:1614302937:2021-02-26T09:28:57.664+0000:1614302937:2021-02-26T09:28:57.664+0000:[~davsclaus]Hello, I am looking forward to contribute in Apache Camel. Can I pick this as my first Task??
metters:1615129795:2021-03-07T23:09:55.434+0000:1615129813:2021-03-07T23:10:13.930+0000:[~thefreakingmind], just do it. All contributions are appreciated"
0,CAMEL-16256,Task,Minor,3.8.0,3.11.0,"
None
",Resolved,Fixed,3.11.0,Unassigned,Ivan B,1,4,2021-02-24 14:10:57+00:00,2021-05-20 04:28:57+00:00,"Steps to reproduce:


 



Clone the github project
cd to camel-examples\examples\camel-example-spring-ws
execute mvn clean install
execute mvn jetty:run



Expected:


A WSDL is available at http://localhost:8080/increment/increment.wsdl


Actual:


error messages appear in console during execution.


at http://localhost:8080/increment/increment.wsdl the 503 error is shown


maven output:


https://paste.ubuntu.com/p/4NNYk24K7S/","davsclaus:1614150597:2021-02-24T15:09:57.115+0000:1614150597:2021-02-24T15:09:57.115+0000:Help is welcome to fix the example
klease78:1621345878:2021-05-18T21:51:18.636+0000:1621406544:2021-05-19T14:42:24.510+0000:I can take this issue. It's caused by a mix of spring versions because org.springframework.ws uses 5.0.19.RELEASE but in general Camel uses 5.3.6. I also found some other missing runtime WS dependencies related to Java 11 or later.

In the camel-examples pom hierarchy there is no profile for jdk9s-build as there is in the camel-parent pom. That could be added to the global examples/pom.xml in case any other examples are also missing such runtime dependencies when running with java versions after 1.8.x."
0,CAMEL-16255,New Feature,Trivial,None,3.9.0,"

features

",Closed,Fixed,3.9.0,Unassigned,Anthony Defraine,0,1,2021-02-24 13:06:33+00:00,2021-03-03 15:37:01+00:00,"Slack provide object model though their slack-api-model dependency.
It would be nice to be able to use it to send rich text blocks to fully use the new design of slack message.


The point is to add this functionality without breaking the current component.


I have a functional code in production on my side I can submit.",
0,CAMEL-16254,Task,Major,None,None,"
None
",Closed,Fixed,3.9.0,Omar Al-Safi,Omar Al-Safi,0,1,2021-02-24 09:26:54+00:00,2021-02-24 10:29:41+00:00,Currently is not supported,
0,CAMEL-16253,Improvement,Minor,None,None,"
None
",Resolved,Fixed,3.9.0,James Netherton,James Netherton,0,1,2021-02-23 14:37:47+00:00,2021-03-02 11:33:25+00:00,"Currently the LRA client gets the LRA URL from the HTTP response header Long-Running-Action. Which is fine when only one such header is returned and is ordered in such a way where the new LRA is first in the order of headers.


I was testing with the latest Narayana LRA coordinator bits and noticed that this fails where there are multiple active LRAs.


We should first check for the Location header, as it will contain the URL to the LRA. If that's not present, try the Long-Running-Action header if there's only one of them. Failing those, fallback on the response body which should also contain the LRA URL.",
0,CAMEL-16252,Bug,Major,3.7.0,"3.7.3, 3.9.0","
None
",Closed,Fixed,"3.7.3, 3.9.0",Omar Al-Safi,Christian Müller,0,2,2021-02-23 14:12:26+00:00,2021-02-26 11:35:16+00:00,"Already asked the question in the mailing list. Claus Ibsen stated that this is actually a bug: 


Ad 1)
Yes that seems like a little bug. You are welcome to create a JIRA ticket.


Here is my description of the bug:
<dependency>
     <groupId>org.apache.camel.springboot</groupId>
     <artifactId>camel-azure-storage-blob-starter</artifactId>
    <version>3.7.0</version>
 </dependency>


We are currently trying to integrate azure cloud by using the camel-azure-storage-blob component. Everything works fine until we activate stream caching and camel starts to spool the payload. In this case we get the following error:


 Caused by: java.lang.IllegalArgumentException: InputStream of body exchange does not support mark/rest operations.


            at org.apache.camel.component.azure.storage.blob.BlobStreamAndLength.createBlobStreamAndLengthFromExchangeBody(BlobStreamAndLength.java:52)


            at org.apache.camel.component.azure.storage.blob.operations.BlobOperations.uploadBlockBlob(BlobOperations.java:181)


I have looked into the source and think that the component does not load the stream properly from the FileInputStreamCache object.","omarsmak:1614236904:2021-02-25T15:08:24.721+0000:1614236904:2021-02-25T15:08:24.721+0000:Hi [~mueller110], 

How do you enable the stream caching, can you please share with me DSL code/steps that have you taken here? The way I see it in [FileInputStreamCache|https://github.com/apache/camel/blob/e53235ba80bb6ad43e786380edb207f526b105bc/core/camel-support/src/main/java/org/apache/camel/converter/stream/FileInputStreamCache.java], it doesn't support mark operation. 
The issue is, the {{InputStream}} implementation that is required by Azure SDK needs to implement both {{mark}} and {{reset}} and hence throwing this exception before processing the input stream. 
omarsmak:1614239953:2021-02-25T15:59:13.692+0000:1614239953:2021-02-25T15:59:13.692+0000:Okay I checked again, Azure SDK needs only {{reset}} operation and hence the fix should be straightforward. Nevertheless, It would be nice if you can attache a snippet of your route, just to confirm the issue. 
mueller110:1614245266:2021-02-25T17:27:46.261+0000:1614245266:2021-02-25T17:27:46.261+0000:Hi [~omarsmak], 
i attached the code snippet. we activate camels stream caching via springboot:

camel:
  springboot:
    stream-caching-enabled: true

Thx for looking into the problem!
Regards Christian
omarsmak:1614310510:2021-02-26T11:35:10.563+0000:1614310510:2021-02-26T11:35:10.563+0000:[~mueller110] should be fixed now. It will be released with 3.7.3 and 3.9.0"
0,CAMEL-16251,Task,Major,None,None,"
None
",Resolved,Fixed,3.9.0,Andrea Cosentino,Andrea Cosentino,0,1,2021-02-23 13:25:48+00:00,2021-03-10 16:07:14+00:00,"We did a great work looking at performance, allocation, GC etc


I think it makes sense to move all the jmh and performance test in a separated repository and also add there some projects to check the behavior of camel under load and by using JFR. 


We have already some work done by myself and lb in k-runtime.",acosentino:1615361328:2021-03-10T15:28:48.863+0000:1615361328:2021-03-10T15:28:48.863+0000:Also Itest-performance module should be moved.
0,CAMEL-16250,Improvement,Minor,3.8.0,3.9.0,"
None
",Resolved,Fixed,3.9.0,Unassigned,Aurélien Pupier,0,1,2021-02-23 10:55:51+00:00,2021-02-27 08:02:14+00:00,"StringHelper.dashToCamelCase(""a-"")




is throwing a StringIndexOutOfBoundsException


it is useful tohandle it at this level so that we can pass even incomplete string during development phase",apupier:1614056779:2021-02-23T13:06:19.881+0000:1614056779:2021-02-23T13:06:19.881+0000:start workign on it
0,CAMEL-16249,Improvement,Minor,3.8.0,,"
None
",Resolved,Information Provided,None,Unassigned,Aurélien Pupier,0,2,2021-02-23 10:35:24+00:00,2022-09-02 17:41:22+00:00,"camel.sink.endpoint.tag=latest 




or



camel.source.endpoint.containerId=<containerId>




reports unknown property valdiation error although they are valid


see https://github.com/apache/camel-kafka-connector-examples/issues/293#issuecomment-784022194


Should it be somethign to add in Catalog? or need to fiw the valdiation algorithm?","davsclaus:1614386941:2021-02-27T08:49:01.013+0000:1614386941:2021-02-27T08:49:01.013+0000:This is because camel-catalog validation API is for normal Camel, not CKC.

CKC uses its special way of configuring properties. So this would require to add special support for CKC in the camel-catalog, or let ckc have it own catalog api for validation.
davsclaus:1619497639:2021-04-27T12:27:19.130+0000:1619497639:2021-04-27T12:27:19.130+0000:CKC is switching to kamelets so its configuration model may change also."
0,CAMEL-16248,Improvement,Minor,3.8.0,,"
None
",Resolved,Information Provided,None,Unassigned,Aurélien Pupier,0,2,2021-02-23 10:32:29+00:00,2022-09-02 17:41:05+00:00,"camel.dataformat.fhirJson.enabled




is reporting an unknown property validation error although it is a valid setting.


See https://github.com/apache/camel-kafka-connector-examples/issues/292#issuecomment-784018926


Should it be added to the catalog? Or shoudl it be fixed in the validation algorithm?","davsclaus:1614386960:2021-02-27T08:49:20.282+0000:1614386960:2021-02-27T08:49:20.282+0000:This is because camel-catalog validation API is for normal Camel, not CKC.

CKC uses its special way of configuring properties. So this would require to add special support for CKC in the camel-catalog, or let ckc have it own catalog api for validation."
0,CAMEL-16247,Bug,Major,3.8.0,,"
None
",Resolved,Invalid,None,Unassigned,Aurélien Pupier,0,1,2021-02-23 10:30:04+00:00,2021-02-24 10:31:23+00:00,"for instance, using



camel.source.path.apiName=search
camel.source.path.methodName=searchByUrl
camel.source.endpoint.url=/Patient




is reporting an ""unknow property"" validation error for camel.source.endpoint.url although it is a parameter method https://camel.apache.org/components/latest/fhir-component.html#_api_search


see https://github.com/apache/camel-kafka-connector-examples/issues/292#issuecomment-784095340","apupier:1614133883:2021-02-24T10:31:23.033+0000:1614133883:2021-02-24T10:31:23.033+0000:my bad, the Camel Catalog is not providing validation at all for camel.source.xx properties. This is part of Camel language Server"
0,CAMEL-16246,Task,Major,None,3.9.0,"
None
",Closed,Fixed,3.9.0,Omar Al-Safi,Omar Al-Safi,0,1,2021-02-23 10:25:41+00:00,2021-02-25 11:59:35+00:00,remove the old camel-azure component,"omarsmak:1614149889:2021-02-24T14:58:09.819+0000:1614150787:2021-02-24T15:13:07.809+0000:* Remove from Camel main repo -> DONE
* Remove from Camel Springboot -> DONE
* Remove from Camel Karaf -> DONE"
0,CAMEL-16245,Improvement,Major,None,None,"
None
",Resolved,Fixed,3.9.0,Andrea Cosentino,Raffaele Marcello,0,1,2021-02-22 21:58:01+00:00,2021-02-23 06:04:41+00:00,"Fix guava version imported inside the pom.


Need to change pom configuration to setup the right guava version.


The exceptiongenerates is similar to this:




Message:N/AStack trace:java.lang.NoSuchMethodError: com.google.common.io.ByteStreams.exhaust(Ljava/io/InputStream;)J
	at com.google.api.client.http.ConsumingInputStream.close(ConsumingInputStream.java:40)
	at java.base/java.util.zip.InflaterInputStream.close(InflaterInputStream.java:232)
	at java.base/java.util.zip.GZIPInputStream.close(GZIPInputStream.java:137)
	at com.fasterxml.jackson.core.json.UTF8StreamJsonParser._closeInput(UTF8StreamJsonParser.java:254)
	at com.fasterxml.jackson.core.base.ParserBase.close(ParserBase.java:369)
	at com.google.api.client.json.jackson2.JacksonParser.close(JacksonParser.java:48)
	at com.google.api.client.json.JsonParser.parse(JsonParser.java:363)
	at com.google.api.client.json.JsonParser.parse(JsonParser.java:335)
	at com.google.api.client.json.JsonObjectParser.parseAndClose(JsonObjectParser.java:79)
	at com.google.api.client.json.JsonObjectParser.parseAndClose(JsonObjectParser.java:73)
	at com.google.api.client.http.HttpResponse.parseAs(HttpResponse.java:451)
	at com.google.auth.oauth2.ServiceAccountCredentials.refreshAccessToken(ServiceAccountCredentials.java:447)
	at com.google.auth.oauth2.OAuth2Credentials.refresh(OAuth2Credentials.java:160)
	at com.google.auth.oauth2.OAuth2Credentials.getRequestMetadata(OAuth2Credentials.java:147)
	at com.google.auth.http.HttpCredentialsAdapter.initialize(HttpCredentialsAdapter.java:91)
	at com.google.cloud.http.HttpTransportOptions$1.initialize(HttpTransportOptions.java:159)
	at com.google.cloud.http.CensusHttpModule$CensusHttpRequestInitializer.initialize(CensusHttpModule.java:109)
	at com.google.api.client.http.HttpRequestFactory.buildRequest(HttpRequestFactory.java:88)
	at com.google.api.client.googleapis.services.AbstractGoogleClientRequest.buildHttpRequest(AbstractGoogleClientRequest.java:404)
	at com.google.api.client.googleapis.services.AbstractGoogleClientRequest.executeUnparsed(AbstractGoogleClientRequest.java:514)
	at com.google.api.client.googleapis.services.AbstractGoogleClientRequest.executeUnparsed(AbstractGoogleClientRequest.java:455)
	at com.google.api.client.googleapis.services.AbstractGoogleClientRequest.execute(AbstractGoogleClientRequest.java:565)
	at com.google.cloud.storage.spi.v1.HttpStorageRpc.get(HttpStorageRpc.java:421)
	at com.google.cloud.storage.StorageImpl$4.call(StorageImpl.java:297)
	at com.google.cloud.storage.StorageImpl$4.call(StorageImpl.java:294)
	at com.google.api.gax.retrying.DirectRetryingExecutor.submit(DirectRetryingExecutor.java:105)
	at com.google.cloud.RetryHelper.run(RetryHelper.java:76)
	at com.google.cloud.RetryHelper.runWithRetries(RetryHelper.java:50)
	at com.google.cloud.storage.StorageImpl.get(StorageImpl.java:293)
	at org.apache.camel.component.google.storage.GoogleCloudStorageEndpoint.doStart(GoogleCloudStorageEndpoint.java:87)
	at org.apache.camel.support.service.BaseService.start(BaseService.java:115)
	at org.apache.camel.support.service.ServiceHelper.startService(ServiceHelper.java:84)
	at org.apache.camel.processor.SendProcessor.doStart(SendProcessor.java:230)
	at org.apache.camel.support.service.BaseService.start(BaseService.java:115)
	at org.apache.camel.support.service.ServiceHelper.startService(ServiceHelper.java:84)
	at org.apache.camel.support.service.ServiceHelper.startService(ServiceHelper.java:101)
	at org.apache.camel.processor.errorhandler.RedeliveryErrorHandler.doStart(RedeliveryErrorHandler.java:1487)
	at org.apache.camel.support.ChildServiceSupport.start(ChildServiceSupport.java:60)
	at org.apache.camel.support.service.ServiceHelper.startService(ServiceHelper.java:84)
	at org.apache.camel.support.service.ServiceHelper.startService(ServiceHelper.java:101)
	at org.apache.camel.impl.engine.DefaultChannel.doStart(DefaultChannel.java:126)
	at org.apache.camel.support.service.BaseService.start(BaseService.java:115)
	at org.apache.camel.support.service.ServiceHelper.startService(ServiceHelper.java:84)
	at org.apache.camel.support.service.ServiceHelper.startService(ServiceHelper.java:87)
	at org.apache.camel.processor.Pipeline.doStart(Pipeline.java:154)
	at org.apache.camel.support.service.BaseService.start(BaseService.java:115)
	at org.apache.camel.support.service.ServiceHelper.startService(ServiceHelper.java:84)
	at org.apache.camel.support.processor.DelegateAsyncProcessor.doStart(DelegateAsyncProcessor.java:79)
	at org.apache.camel.support.service.BaseService.start(BaseService.java:115)
	at org.apache.camel.support.service.ServiceHelper.startService(ServiceHelper.java:84)
	at org.apache.camel.impl.engine.RouteService.startChildServices(RouteService.java:398)
	at org.apache.camel.impl.engine.RouteService.doWarmUp(RouteService.java:195)
	at org.apache.camel.impl.engine.RouteService.warmUp(RouteService.java:121)
	at org.apache.camel.impl.engine.InternalRouteStartupManager.doWarmUpRoutes(InternalRouteStartupManager.java:306)
	at org.apache.camel.impl.engine.InternalRouteStartupManager.safelyStartRouteServices(InternalRouteStartupManager.java:189)
	at org.apache.camel.impl.engine.InternalRouteStartupManager.doStartOrResumeRoutes(InternalRouteStartupManager.java:147)
	at org.apache.camel.impl.engine.AbstractCamelContext.doStartCamel(AbstractCamelContext.java:3150)
	at org.apache.camel.impl.engine.AbstractCamelContext.doStartContext(AbstractCamelContext.java:2846)
	at org.apache.camel.impl.engine.AbstractCamelContext.doStart(AbstractCamelContext.java:2797)
	at org.apache.camel.support.service.BaseService.start(BaseService.java:115)
	at org.apache.camel.impl.engine.AbstractCamelContext.start(AbstractCamelContext.java:2492)
	at org.apache.camel.impl.DefaultCamelContext.start(DefaultCamelContext.java:169)
	at org.apache.camel.test.junit5.CamelTestSupport.startCamelContext(CamelTestSupport.java:719)
	at org.apache.camel.test.junit5.CamelTestSupport.doSetUp(CamelTestSupport.java:494)
	at org.apache.camel.test.junit5.CamelTestSupport.setUp(CamelTestSupport.java:366)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.junit.platform.commons.util.ReflectionUtils.invokeMethod(ReflectionUtils.java:688)
	at org.junit.jupiter.engine.execution.MethodInvocation.proceed(MethodInvocation.java:60)
	at org.junit.jupiter.engine.execution.InvocationInterceptorChain$ValidatingInvocation.proceed(InvocationInterceptorChain.java:131)
	at org.junit.jupiter.engine.extension.TimeoutExtension.intercept(TimeoutExtension.java:149)
	at org.junit.jupiter.engine.extension.TimeoutExtension.interceptLifecycleMethod(TimeoutExtension.java:126)
	at org.junit.jupiter.engine.extension.TimeoutExtension.interceptBeforeEachMethod(TimeoutExtension.java:76)
	at org.junit.jupiter.engine.execution.ExecutableInvoker$ReflectiveInterceptorCall.lambda$ofVoidMethod$0(ExecutableInvoker.java:115)
	at org.junit.jupiter.engine.execution.ExecutableInvoker.lambda$invoke$0(ExecutableInvoker.java:105)
	at org.junit.jupiter.engine.execution.InvocationInterceptorChain$InterceptedInvocation.proceed(InvocationInterceptorChain.java:106)
	at org.junit.jupiter.engine.execution.InvocationInterceptorChain.proceed(InvocationInterceptorChain.java:64)
	at org.junit.jupiter.engine.execution.InvocationInterceptorChain.chainAndInvoke(InvocationInterceptorChain.java:45)
	at org.junit.jupiter.engine.execution.InvocationInterceptorChain.invoke(InvocationInterceptorChain.java:37)
	at org.junit.jupiter.engine.execution.ExecutableInvoker.invoke(ExecutableInvoker.java:104)
	at org.junit.jupiter.engine.execution.ExecutableInvoker.invoke(ExecutableInvoker.java:98)
	at org.junit.jupiter.engine.descriptor.ClassBasedTestDescriptor.invokeMethodInExtensionContext(ClassBasedTestDescriptor.java:490)
	at org.junit.jupiter.engine.descriptor.ClassBasedTestDescriptor.lambda$synthesizeBeforeEachMethodAdapter$19(ClassBasedTestDescriptor.java:475)
	at org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.lambda$invokeBeforeEachMethods$2(TestMethodTestDescriptor.java:167)
	at org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.lambda$invokeBeforeMethodsOrCallbacksUntilExceptionOccurs$5(TestMethodTestDescriptor.java:195)
	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)
	at org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.invokeBeforeMethodsOrCallbacksUntilExceptionOccurs(TestMethodTestDescriptor.java:195)
	at org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.invokeBeforeEachMethods(TestMethodTestDescriptor.java:164)
	at org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.execute(TestMethodTestDescriptor.java:127)
	at org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.execute(TestMethodTestDescriptor.java:65)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$5(NodeTestTask.java:139)
	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$7(NodeTestTask.java:129)
	at org.junit.platform.engine.support.hierarchical.Node.around(Node.java:137)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$8(NodeTestTask.java:127)
	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.executeRecursively(NodeTestTask.java:126)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.execute(NodeTestTask.java:84)
	at java.base/java.util.ArrayList.forEach(ArrayList.java:1541)
	at org.junit.platform.engine.support.hierarchical.SameThreadHierarchicalTestExecutorService.invokeAll(SameThreadHierarchicalTestExecutorService.java:38)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$5(NodeTestTask.java:143)
	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$7(NodeTestTask.java:129)
	at org.junit.platform.engine.support.hierarchical.Node.around(Node.java:137)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$8(NodeTestTask.java:127)
	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.executeRecursively(NodeTestTask.java:126)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.execute(NodeTestTask.java:84)
	at java.base/java.util.ArrayList.forEach(ArrayList.java:1541)
	at org.junit.platform.engine.support.hierarchical.SameThreadHierarchicalTestExecutorService.invokeAll(SameThreadHierarchicalTestExecutorService.java:38)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$5(NodeTestTask.java:143)
	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$7(NodeTestTask.java:129)
	at org.junit.platform.engine.support.hierarchical.Node.around(Node.java:137)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$8(NodeTestTask.java:127)
	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.executeRecursively(NodeTestTask.java:126)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.execute(NodeTestTask.java:84)
	at org.junit.platform.engine.support.hierarchical.SameThreadHierarchicalTestExecutorService.submit(SameThreadHierarchicalTestExecutorService.java:32)
	at org.junit.platform.engine.support.hierarchical.HierarchicalTestExecutor.execute(HierarchicalTestExecutor.java:57)
	at org.junit.platform.engine.support.hierarchical.HierarchicalTestEngine.execute(HierarchicalTestEngine.java:51)
	at org.junit.platform.launcher.core.EngineExecutionOrchestrator.execute(EngineExecutionOrchestrator.java:108)
	at org.junit.platform.launcher.core.EngineExecutionOrchestrator.execute(EngineExecutionOrchestrator.java:88)
	at org.junit.platform.launcher.core.EngineExecutionOrchestrator.lambda$execute$0(EngineExecutionOrchestrator.java:54)
	at org.junit.platform.launcher.core.EngineExecutionOrchestrator.withInterceptedStreams(EngineExecutionOrchestrator.java:67)
	at org.junit.platform.launcher.core.EngineExecutionOrchestrator.execute(EngineExecutionOrchestrator.java:52)
	at org.junit.platform.launcher.core.DefaultLauncher.execute(DefaultLauncher.java:96)
	at org.junit.platform.launcher.core.DefaultLauncher.execute(DefaultLauncher.java:84)
	at org.eclipse.jdt.internal.junit5.runner.JUnit5TestReference.run(JUnit5TestReference.java:98)
	at org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:41)
	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:542)
	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:770)
	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:464)
	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:210)",
0,CAMEL-16244,Bug,Major,3.8.0,3.9.0,"
None
",Resolved,Fixed,3.9.0,Claus Ibsen,Babak Vahdat,0,2,2021-02-21 15:46:07+00:00,2021-02-27 12:52:35+00:00,"See the following repo as reproducer:


https://github.com/bvahdat/camel-rest-multiple-consumer-bug","bvahdat:1613894138:2021-02-21T15:55:38.954+0000:1613894138:2021-02-21T15:55:38.954+0000:I assume this's a side effect of routes not being lazily started anymore:

[https://camel.apache.org/manual/latest/camel-3x-upgrade-guide-3_8.html#_route_startup_procedure_change]
davsclaus:1614387919:2021-02-27T09:05:19.106+0000:1614387919:2021-02-27T09:05:19.106+0000:Yeah the problem is actually the xml file is discovered twice on spring-boot
davsclaus:1614388274:2021-02-27T09:11:14.736+0000:1614388274:2021-02-27T09:11:14.736+0000:The problem is that spring boot triggers 2x context-refreshed-event which is what Camel uses to trigger to startup.
davsclaus:1614388922:2021-02-27T09:22:02.305+0000:1614388922:2021-02-27T09:22:02.305+0000:And you need to turn off rest configuration in the maven plugin as <rests> xml file is not valid for this. Its only for old fashioned spring <beans> xml files

                  <configuration>
                      <restConfiguration>false</restConfiguration>
                      <outputDirectory>${project.basedir}/src/main/resources/camel-rest</outputDirectory>
                      <specificationUri>${project.basedir}/src/main/resources/openapi.yaml</specificationUri>
                  </configuration>

bvahdat:1614401543:2021-02-27T12:52:23.912+0000:1614401543:2021-02-27T12:52:23.912+0000:I confirm that's fixed using the latest {{3.9.0-SNAPSHOT}} codebase with {{restConfiguration}} being turned off, thanks!"
0,CAMEL-16243,Bug,Major,None,3.x,"
None
",Resolved,Invalid,3.x,Unassigned,Pawan Mundhra,0,3,2021-02-21 08:50:19+00:00,2021-02-21 18:16:54+00:00,"Recently we upgraded our Application's overall camel version from 2.16.0 to 3.4.4. We are using several camel components in our applications such as:


camel-jms, camel-restlet, camel-restlet, cale-zookeeper, camel-file, camel-rest, etc...


 


One of the component we used in our Application was camel-restlet component (version 2.16.0) where after migration to camel 3.x, we are facing issue in service start-up.


Issue #1 : It seems camel removed the restlet component after 3.x. Could not find much documentation which would let us know how to migrate the existing camel-restlet component


Issue #2 : We gave a try to upgrade the camel-restlet component to 3.0.0-RC2. But during start-up of our service, we faced an error as mentioned in the below stack trace.




Exception in thread ""main"" java.lang.NoSuchMethodError: org.apache.camel.CamelContext.getRestConfiguration(Ljava/lang/String;Z)Lorg/apache/camel/spi/RestConfiguration;
        at org.apache.camel.component.restlet.RestletComponent.doStart(RestletComponent.java:215)
        at org.apache.camel.support.service.BaseService.start(BaseService.java:115)
        at org.apache.camel.impl.engine.AbstractCamelContext.startService(AbstractCamelContext.java:3026)
        at org.apache.camel.impl.engine.AbstractCamelContext.startServices(AbstractCamelContext.java:3032)
        at org.apache.camel.impl.engine.AbstractCamelContext.doStartCamel(AbstractCamelContext.java:2759)
        at org.apache.camel.impl.engine.AbstractCamelContext.doStartContext(AbstractCamelContext.java:2658)
        at org.apache.camel.impl.engine.AbstractCamelContext.doStart(AbstractCamelContext.java:2621)
        at org.apache.camel.support.service.BaseService.start(BaseService.java:115)
        at org.apache.camel.impl.engine.AbstractCamelContext.start(AbstractCamelContext.java:2453)
        at com.nri.csd.inf.console.service.GatewayService.startCamelContextIfNotStarted(GatewayService.java:201)
        at com.nri.csd.inf.console.service.GatewayService.postStart(GatewayService.java:100)
        at com.nri.csd.inf.console.service.AbstractLaunchableService.start(AbstractLaunchableService.java:216)
        at com.nri.csd.inf.console.ConsoleLauncher.main(ConsoleLauncher.java:96)




Found in the code that RestletComponent java class in camel-restlet-3.0.0-RC2 version has an API doStart() in which at line 215, there is a call to CamelContext class's method getRestConfiguration(""restlet"", true) (class in camel-api jar).


 




210    @Override
211    protected void doStart() throws Exception {
212        super.doStart();        
213   
214         // configure component options
215        RestConfiguration config = getCamelContext().getRestConfiguration(""restlet"", true);
216        // configure additional options on spark configuration
217        if (config.getComponentProperties() != null && !config.getComponentProperties().isEmpty()) {
218            setProperties(this, config.getComponentProperties());
219        }        
220            
221           cleanupConverters(enabledConverters);        
222              
223           component.start();     
2234   }




The API called at line 215 above (i.e. getRestConfiguration) seems to be removed from the class org.apache.camel.CamelContext in library camel-api during upgradation to 3.2 from 3.1.


Refer this https://camel.apache.org/manual/latest/camel-3x-upgrade-guide-3_2.html


 


However the above API in org.apache.camel.CamelContext in camel-api-3.0.0-RC2 is modified but I am having a transitive dependency upon camel-api-3.4 library (as we need to use camel-jms component as well) and it seems that both camel-api-3.4.4 and camel-api-3.0.0-RC2 cannot be kept together as it gives me some other error if both these libraries are present in the classpath.




java.lang.ClassNotFoundException: org.apache.camel.EndpointProducerResolver
        at java.base/jdk.internal.loader.BuiltinClassLoader.loadClass(BuiltinClassLoader.java:583)
        at java.base/jdk.internal.loader.ClassLoaders$AppClassLoader.loadClass(ClassLoaders.java:178)




This is because the class org.apache.camel.EndpointProducerResolver is present in camel-api-3.4.4 but not present in camel-api-3.0.0-RC2. 


So it seems there is some cyclic dependency where I am trapped.


Please suggest what course of action can be taken for this issue with minimum impact or what is the compatibility of camel-restlet component and camel-api, camel-support libraries. We want all to be compatible with camel 3.4.4 version.","acosentino:1613869323:2021-02-21T09:02:03.475+0000:1613869323:2021-02-21T09:02:03.475+0000:3.0 Rc2 components can only be used with 3.0 Rc2 core. So it's normal it doesn't work with 3.2. restlest has been removed and you should use camel rest
davsclaus:1613869742:2021-02-21T09:09:02.827+0000:1613869742:2021-02-21T09:09:02.827+0000:camel-restlet is removed, as documented in the migration guide. And its deprecated in 2.x.
davsclaus:1613869811:2021-02-21T09:10:11.200+0000:1613869811:2021-02-21T09:10:11.200+0000:And use the user mailing list to ask for help and suggestions what to do
pawanmundhra:1613871054:2021-02-21T09:30:54.003+0000:1613871054:2021-02-21T09:30:54.003+0000:Hi [~acosentino] 

Thanks for the quick check.

As you suggest to use camel-rest, is there any guideline document for migrating camel-reslet to camel-rest ?
davsclaus:1613896000:2021-02-21T16:26:40.870+0000:1613896000:2021-02-21T16:26:40.870+0000:Sorry there is no specific guide on migrating from restlet to rest.

Especially if you use rest-dsl, then you should be able to change to use another component like, camel-servlet, camel-undertow or something else.
pawanmundhra:1613902278:2021-02-21T18:11:18.384+0000:1613902278:2021-02-21T18:11:18.384+0000:We are using RestletEndpoint to get Protocol, host, port, uriPattern, etc. in a very simplified way. Now that RestletEndpoint does not exist, we need to map these in a different way and it has an extra development effort. It would have been good to have some sort of document for migration. 

Also could not find strong reason why camel-restlet component was considered for removal after 3.x
acosentino:1613902614:2021-02-21T18:16:54.343+0000:1613902614:2021-02-21T18:16:54.343+0000:Migrating from camel 2 to Camel 3 needs a migration effort. From 2.16 to 3 without touching code was impossible. At the time of switching from 2 to 3, we decided what component were ok to be removed. We had alternatives like the rest dsl and we focused on it."
0,CAMEL-16242,Bug,Major,None,3.10.0,"
None
",Resolved,Fixed,3.10.0,Claus Ibsen,Claus Ibsen,0,2,2021-02-20 17:26:14+00:00,2021-03-25 08:40:51+00:00,"When you use route templates, and that would in fact also matter for property placeholders, and you use some placeholder that are in an expression with single quote, then you can have a problem with values that use quotes, such as a name John O'Niel.


Report at camel-k at
https://github.com/apache/camel-k-runtime/issues/632",davsclaus:1616626584:2021-03-25T06:56:24.994+0000:1616626584:2021-03-25T06:56:24.994+0000:Okay have a solution where we for the Camel languages will automatic replace the single quoted placeholders with double quotes instead.
0,CAMEL-16241,Bug,Minor,3.8.0,"3.7.3, 3.9.0","
None
",Resolved,Fixed,"3.7.3, 3.9.0",Claus Ibsen,David Voit,0,2,2021-02-19 14:30:37+00:00,2021-03-02 09:34:51+00:00,"Using the following endpoint to line with the endpoint configuration, the http request fails


 


.to(https(""inline"").authenticationPreemptive(true).authMethod(""Basic"").authUsername(""{{prop.username}}"").authPassword(""{{prop.password}}""))


 


If I'm using the equivalent line of:


.to(""https://inline?authMethod=Basic&authPassword={{prop.password}}&authUsername={{prop.username}}&authenticationPreemptive=true"")


 


the request are working fine.


 


Debugging this one shows that with the endpoint setup, BasicAuthenticationHttpClientConfigurer is initialized with the properties, so here username=""props.username"".


 


With just the java dsl, the correct username is loaded in the constructor.","davsclaus:1614646393:2021-03-02T08:53:13.661+0000:1614646393:2021-03-02T08:53:13.661+0000:What is prop.username is that some placeholder, eg {{xxx}} - as otherwise its just literal text that is used as-is
davsclaus:1614646536:2021-03-02T08:55:36.595+0000:1614646536:2021-03-02T08:55:36.595+0000:Added unit test
https://github.com/apache/camel/commit/78202e80576aa9fb93699b17e275399ba96b9a3a
david.voit@osram-os.com:1614647529:2021-03-02T09:12:09.445+0000:1614647529:2021-03-02T09:12:09.445+0000:Hi,

I created some reproducer if this is not already clear:

[https://github.com/davidvoit/endpoint-issue-reproducer]

Thanks,

David
david.voit@osram-os.com:1614648174:2021-03-02T09:22:54.475+0000:1614648174:2021-03-02T09:22:54.475+0000:Ah I see where the discrepance is comming from Jira removed the curly brackets. This should be properties. Sorry for the confussion.
davsclaus:1614648664:2021-03-02T09:31:04.084+0000:1614648664:2021-03-02T09:31:04.084+0000:Ah thanks yeah I can see the problem and have a fix in the works
davsclaus:1614648720:2021-03-02T09:32:00.465+0000:1614648720:2021-03-02T09:32:00.465+0000:Your browser made it!"
0,CAMEL-16238,Improvement,Major,3.7.0,3.9.0,"
None
",Resolved,Fixed,3.9.0,Claus Ibsen,fly,0,3,2021-02-19 11:49:14+00:00,2021-02-25 06:55:49+00:00,"I found that when I called the shutdown method on camelcontext, the registry on camelcontext was not released and still held the bean instance. This can lead to a memory leak.","acosentino:1613707028:2021-02-19T11:57:08.138+0000:1613707028:2021-02-19T11:57:08.138+0000:This is a jira, please ask on the user mailing list first or on zulip chat.
weborld:1613708135:2021-02-19T12:15:35.922+0000:1613708135:2021-02-19T12:15:35.922+0000:Isn't that a bug? Can't I feed back bugs here?
acosentino:1613708344:2021-02-19T12:19:04.911+0000:1613708344:2021-02-19T12:19:04.911+0000:Raising an issue with just a little and how-to is a question, not a bug, and usually the question should be submitted on chat or on Mailing list.
weborld:1613708651:2021-02-19T12:24:11.368+0000:1613708651:2021-02-19T12:24:11.368+0000:So I changed the title to mention that this is a memory leak bug
weborld:1613709221:2021-02-19T12:33:41.789+0000:1613709221:2021-02-19T12:33:41.789+0000:Can we reopen this issue now?
davsclaus:1613710595:2021-02-19T12:56:35.321+0000:1613710595:2021-02-19T12:56:35.321+0000:What is your use-case? 

When Camel shutdown it goes into a state where its not startable again (we cannot guarantee that all 3rd party libraries and whatnot would support that). 
And as Andrea says you should take this discussion OUT of JIRA and to the mailing list or the chat room.

So continue there....
davsclaus:1613714753:2021-02-19T14:05:53.938+0000:1613714753:2021-02-19T14:05:53.938+0000:You can create a PR where you set 

registry = null

in the forceStopLazyInitialization method
weborld:1613715027:2021-02-19T14:10:27.987+0000:1613715027:2021-02-19T14:10:27.987+0000:When Camel shutdown, shouldn't you release the corresponding DefaultRegistry? 
DefaultRegistry always holds the objects in it. Won't it lead to a memory leak?
davsclaus:1614207336:2021-02-25T06:55:36.355+0000:1614207336:2021-02-25T06:55:36.355+0000:In Camel 3 we now have a fallback registry which is an internal map - and yeah it can benefit when stopping to clear that map, and null the registry reference, to cleanup nicely."
0,CAMEL-16237,Improvement,Major,None,3.12.0,"
None
",Resolved,Fixed,3.12.0,Unassigned,Claus Ibsen,0,1,2021-02-19 09:04:03+00:00,2021-07-20 12:23:22+00:00,"The user agent of camel-http tells its java etc


""Apache-HttpClient/4.5.13 (Java/11.0.10)""


You may want to easily disable this or set a different information.


So we need an option on the component level to set this globally.",
0,CAMEL-16236,Improvement,Minor,None,,"
None
",Resolved,Fixed,None,Zoran Regvart,Claus Ibsen,0,1,2021-02-19 05:27:36+00:00,2021-09-21 07:03:02+00:00,"Apple now has x86 and silicon architectures so the binaries should mention which it uses.
https://camel.apache.org/download/


For example


MacOS 64bit binary


-->


MacOS (x86) 64bit binary",
0,CAMEL-16235,Bug,Minor,3.7.0,3.9.0,"
None
",Resolved,Fixed,3.9.0,Claus Ibsen,Siva Kuna,0,1,2021-02-18 21:42:36+00:00,2021-03-17 10:51:13+00:00,"Below is my dependency configuration in build.gradle script of my project




ext {
    versions = [
        camel : ""3.5.0"",
        springBoot : ""2.3.0.RELEASE"",
    ]
}

dependencies {
    compile group: 'org.springframework.boot', name: 'spring-boot-starter-web', version: versions.springBoot    
    compile group: 'org.apache.camel.springboot', name: 'camel-servlet-starter', version: versions.camel    
    compile group: 'javax.inject', name: 'javax.inject', version: '1'    

    compile group: 'org.apache.camel', name: 'camel-core',          version: versions.camel
    compile group: 'org.apache.camel', name: 'camel-http',          version: versions.camel
    compile group: 'org.apache.camel', name: 'camel-jackson',       version: versions.camel
    compile group: 'org.apache.camel', name: 'camel-rest-openapi',  version: versions.camel
    compile group: 'org.apache.camel', name: 'camel-aws2-s3',       version: versions.camel    
    compile group: 'org.apache.camel', name: 'camel-swagger-java',  version: versions.camel    
}




 Below is a RouteBuilder class




public class MyRouteBuilder extends RouteBuilder {
    @Override
    public void configure() throws Exception {
        this.restConfiguration().bindingMode(RestBindingMode.json)
            .clientRequestValidation(true).apiProperty(""api.title"", ""MyAPI"") 
            .apiProperty(""api.version"", ""1.0"").apiProperty(""cors"", ""true"")
            .apiContextPath(""api-doc"");
    }
}



 


When I start the Spring Boot application the camel-servlet-starter starts the ServletComponent and I can access the api-doc URL. But the same code fails when I upgrade the Camel version to 3.7.0.


This is what I discovered when I tried to understand why camel-servlet-starter starts in 3.5.0 and fails in 3.7.0


Below is the definition of Servlet Component Bean in org.apache.camel.component.servlet.springboot.ServletComponentAutoConfiguration class of camel-servlet-starter-3.5.x




@Lazy    
@Bean(name = ""servlet-component"")    
@ConditionalOnMissingBean(ServletComponent.class)    
public ServletComponent configureServletComponent() throws Exception {          
    ServletComponent component = new ServletComponent();        
    component.setCamelContext(camelContext);
}



When Spring starts Camel routes, it asks RestApiEndpoint to create REST API Consumer and Spring initializes the Servlet Component by invoking ServletComponentAutoConfiguration.configureServletComponent(). 


This is changed in camel-servlet-starter-3.7.x




@Lazy 
@Bean 
public ComponentCustomizer configureServletComponent() { 
    return new ComponentCustomizer() { 
        @Override 
        public void configure(String name, Component target) {  
            CamelPropertiesHelper.copyProperties(camelContext, configuration, target); 
        } 

        @Override 
        public boolean isEnabled(String name, Component target) { 
            return HierarchicalPropertiesEvaluator.evaluate(applicationContext,   
                         ""camel.component.customizer"", 
                          ""camel.component.servlet.customizer"") 
                    && target instanceof ServletComponent; } 
        }; 
}



Spring fails to start CamelContext with the below exception stack trace:



org.apache.camel.FailedToStartRouteException: Failed to start route route1 because of null 
  at org.apache.camel.impl.engine.RouteService.warmUp(RouteService.java:122) ~[camel-base-engine-3.7.0.jar:3.7.0] 
  at org.apache.camel.impl.engine.InternalRouteStartupManager.doWarmUpRoutes(InternalRouteStartupManager.java:270) ~[camel-base-engine-3.7.0.jar:3.7.0] 
  at org.apache.camel.impl.engine.InternalRouteStartupManager.safelyStartRouteServices(InternalRouteStartupManager.java:157) ~[camel-base-engine-3.7.0.jar:3.7.0] 
  at org.apache.camel.impl.engine.InternalRouteStartupManager.doStartOrResumeRoutes(InternalRouteStartupManager.java:115) ~[camel-base-engine-3.7.0.jar:3.7.0] 
  at org.apache.camel.impl.engine.AbstractCamelContext.doStartCamel(AbstractCamelContext.java:2889) ~[camel-base-engine-3.7.0.jar:3.7.0] 
  at org.apache.camel.impl.engine.AbstractCamelContext.doStartContext(AbstractCamelContext.java:2702) ~[camel-base-engine-3.7.0.jar:3.7.0] 
  at org.apache.camel.impl.engine.AbstractCamelContext.doStart(AbstractCamelContext.java:2665) ~[camel-base-engine-3.7.0.jar:3.7.0] 
  at org.apache.camel.spring.boot.SpringBootCamelContext.doStart(SpringBootCamelContext.java:43) ~[camel-spring-boot-3.7.0.jar:3.7.0] 
  at org.apache.camel.support.service.BaseService.start(BaseService.java:115) ~[camel-api-3.7.0.jar:3.7.0] 
  at org.apache.camel.impl.engine.AbstractCamelContext.start(AbstractCamelContext.java:2431) ~[camel-base-engine-3.7.0.jar:3.7.0] 
  at org.apache.camel.spring.SpringCamelContext.start(SpringCamelContext.java:130) ~[camel-spring-3.7.0.jar:3.7.0] 
  at org.apache.camel.spring.SpringCamelContext.onApplicationEvent(SpringCamelContext.java:167) ~[camel-spring-3.7.0.jar:3.7.0] 
  at org.springframework.context.event.SimpleApplicationEventMulticaster.doInvokeListener(SimpleApplicationEventMulticaster.java:203) ~[spring-context-5.3.1.jar:5.3.1] 
  at org.springframework.context.event.SimpleApplicationEventMulticaster.invokeListener(SimpleApplicationEventMulticaster.java:196) ~[spring-context-5.3.1.jar:5.3.1] 
  at org.springframework.context.event.SimpleApplicationEventMulticaster.multicastEvent(SimpleApplicationEventMulticaster.java:161) ~[spring-context-5.3.1.jar:5.3.1] 
  at org.springframework.context.support.AbstractApplicationContext.publishEvent(AbstractApplicationContext.java:426) ~[spring-context-5.3.1.jar:5.3.1] 
  at org.springframework.context.support.AbstractApplicationContext.publishEvent(AbstractApplicationContext.java:383) ~[spring-context-5.3.1.jar:5.3.1] 
  at org.springframework.context.support.AbstractApplicationContext.finishRefresh(AbstractApplicationContext.java:945) ~[spring-context-5.3.1.jar:5.3.1] 
  at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:591) ~[spring-context-5.3.1.jar:5.3.1] 
  at org.springframework.boot.web.servlet.context.ServletWebServerApplicationContext.refresh(ServletWebServerApplicationContext.java:144) ~[spring-boot-2.4.0.jar:2.4.0] 
  at org.springframework.boot.SpringApplication.refresh(SpringApplication.java:767) ~[spring-boot-2.4.0.jar:2.4.0] 
  at org.springframework.boot.SpringApplication.refresh(SpringApplication.java:759) ~[spring-boot-2.4.0.jar:2.4.0] 
  at org.springframework.boot.SpringApplication.refreshContext(SpringApplication.java:426) ~[spring-boot-2.4.0.jar:2.4.0] 
  at org.springframework.boot.SpringApplication.run(SpringApplication.java:326) ~[spring-boot-2.4.0.jar:2.4.0] 
  at com.guidewire.surepath.document.management.box.DocumentManagementBoxApplication.main(DocumentManagementBoxApplication.java:16) ~[main/:na]
Caused by: java.lang.IllegalStateException: Cannot find RestApiConsumerFactory in Registry or as a Component to use 
  at org.apache.camel.component.rest.RestApiEndpoint.createConsumer(RestApiEndpoint.java:278) ~[camel-rest-3.7.0.jar:3.7.0] 
  at org.apache.camel.impl.engine.DefaultRoute.addServices(DefaultRoute.java:575) ~[camel-base-engine-3.7.0.jar:3.7.0] 
  at org.apache.camel.impl.engine.DefaultRoute.onStartingServices(DefaultRoute.java:160) ~[camel-base-engine-3.7.0.jar:3.7.0] 
  at org.apache.camel.impl.engine.RouteService.doWarmUp(RouteService.java:150) ~[camel-base-engine-3.7.0.jar:3.7.0] 
  at org.apache.camel.impl.engine.RouteService.warmUp(RouteService.java:120) ~[camel-base-engine-3.7.0.jar:3.7.0]



Spring starts CamelContext successfully if I register the servlet component in the RouteBuilder class


Below is a RouteBuilder class




public class MyRouteBuilder extends RouteBuilder {
    @Override
    public void configure() throws Exception {
        this.restConfiguration().bindingMode(RestBindingMode.json)
            .clientRequestValidation(true).apiProperty(""api.title"", ""MyAPI"") 
            .apiProperty(""api.version"", ""1.0"").apiProperty(""cors"", ""true"")
            .component(""servlet"")             
            .apiContextPath(""api-doc"");
    }
}



 


Are developers mandated to register ServletComponent in the RouteBuilder class?",
0,CAMEL-16234,New Feature,Major,None,None,"
None
",Open,Unresolved,None,Luca Burgazzoli,Claus Ibsen,0,1,2021-02-18 16:17:17+00:00,2023-12-20 09:59:40+00:00,"Today we put stuff into camel-main for various things you can configure. Most of that are stuff that is in core.


But when we have components outside core, that are pluggable, then it would be great if they can provide their own configuration with them, and then have that as metadata and a configuration class (for java based configuration).


We need the maven tooling to generate those meta data file, and java based configuration fluent builders.


Then for java you can register the addon in main ala


main.configure(MyFooThingy.class)
   .someFooStuffHere(true)
   .someOtherFooish(123)
.end()


For example camel-saga, and the 3 circuit breakers are today hardcoded into camel-main.
Those can be candidates to try out with.",davsclaus:1703037466:2023-12-20T09:57:46.384+0000:1703037466:2023-12-20T09:57:46.384+0000:[~lb] fyi
0,CAMEL-16233,Bug,Major,3.9.0,3.9.0,"
None
",Resolved,Fixed,3.9.0,Claus Ibsen,Claus Ibsen,0,1,2021-02-18 13:35:46+00:00,2021-02-18 14:18:33+00:00,"Just a reminder that unforseen that camel-jetty has a failing test


Caused by: org.apache.camel.NoTypeConversionAvailableException: No type converter available to convert from type: org.apache.http.entity.mime.MultipartFormEntity to the required type: java.io.InputStream with value org.apache.http.entity.mime.MultipartFormEntity@17856f0
	at org.apache.camel.impl.converter.CoreTypeConverterRegistry.mandatoryConvertTo(CoreTypeConverterRegistry.java:275)
	at org.apache.camel.support.MessageSupport.getMandatoryBody(MessageSupport.java:115)
	... 81 more",
0,CAMEL-16232,Improvement,Major,3.8.0,3.9.0,"
None
",Resolved,Fixed,3.9.0,Jiri Ondrusek,Jiri Ondrusek,0,1,2021-02-18 12:16:18+00:00,2021-02-18 16:09:58+00:00,"If two-way ssl is used with camel-http component and ssl parameters are taken from sytem properties, connection fails.


 


Reason is that  system properties `javax.net.ssl.keyStorePassword` and `javax.net.ssl.keyStore`are ignored.  Problem is caused by difference in https://github.com/apache/httpcomponents-core/blob/4.4.x/httpcore/src/main/java/org/apache/http/ssl/SSLContexts.java#L43 vs https://github.com/apache/httpcomponents-core/blob/4.4.x/httpcore/src/main/java/org/apache/http/ssl/SSLContexts.java#L62",
0,CAMEL-16231,Improvement,Major,None,3.9.0,"
None
",Resolved,Won't Fix,3.9.0,Claus Ibsen,Claus Ibsen,0,1,2021-02-17 15:05:47+00:00,2021-02-27 08:46:11+00:00,"We should optimize to filter on key names only, as if you are skipping a header then getting the value is waste, some 3rd party libraries uses special parsing to return their values.


For example camel-http","davsclaus:1614220450:2021-02-25T10:34:10.286+0000:1614220450:2021-02-25T10:34:10.286+0000:camel-cxf is the only that uses the headerValue
davsclaus:1614220956:2021-02-25T10:42:36.626+0000:1614220956:2021-02-25T10:42:36.626+0000:Also we should optimize to match on header keys as-is first, before doing any lower case as that creates garbage objects
davsclaus:1614386771:2021-02-27T08:46:11.561+0000:1614386771:2021-02-27T08:46:11.561+0000:Looked into this and its not worth the trouble. "
0,CAMEL-16230,Improvement,Minor,3.7.2,3.10.0,"
None
",Resolved,Fixed,3.10.0,Claus Ibsen,Alex,0,2,2021-02-17 15:03:01+00:00,2021-03-23 08:50:35+00:00,"Unable to use camel placeholders in a CamelSpringBootTest:


 This does not work:





        AdviceWith.adviceWith(camelContext, ""person-import"", route -> {
            route.replaceFromWith(""direct:csv"");
            route.mockEndpointsAndSkip(""{{camel.placeholder}}"");
        });





This does:




        AdviceWith.adviceWith(camelContext, ""person-import"", route -> {
            route.replaceFromWith(""direct:csv"");
            route.mockEndpointsAndSkip(""jpa:MyEntity"");
        });




My route is defined like so:




        from(""{{camel.person.csv.file}}"")
                .id(""person-import"")
                .unmarshal(bindy)
                .process(new CamelLogger())
                .to(""{{camel.placeholder}}"")
        ;





My placeholder is application.yaml of Spring Boot




camel:
  placeholder: ""jpa:MyEntity""




Please advise
Best Regards
Alex","davsclaus:1616459977:2021-03-23T08:39:37.276+0000:1616459977:2021-03-23T08:39:37.276+0000:Placeholders was not supported there, but its a good idea to add support for this
davsclaus:1616460368:2021-03-23T08:46:08.110+0000:1616460391:2021-03-23T08:46:31.656+0000:This is only those special methods in AdviceWithRoyteBuilder like the mockEndpointAndSkip you are using. You can resolve the placeholder first with

{code}
String pattern = getContext().resolvePropertyPlaceholders(""{{camel.placeholder}}"");
route.mockEndpointsAndSkip(pattern);
{code}"
0,CAMEL-16229,Task,Minor,3.7.2,3.9.0,"
None
",Resolved,Fixed,3.9.0,Unassigned,Alex,0,2,2021-02-17 14:57:42+00:00,2021-03-17 10:56:35+00:00,"The following documentation on mocking and testing existing routes is not updated for camel v3:


https://camel.apache.org/components/latest/mock-component.html#_mocking_existing_endpoints


 




        AdviceWith.adviceWith(context.getRouteDefinitions().get(0), context, new AdviceWithRouteBuilder() {
            @Override
            public void configure() throws Exception {
                // mock all endpoints
                mockEndpoints();
            }
        });




 


We can see in the migration guide here that context.getRouteDefinitions no longer exists:


https://camel.apache.org/manual/latest/camel-3-migration-guide.html


New style:




AdviceWith.adviceWith(context, ""myRoute"", a -> {
  a.replaceFromWith(""direct:start"");
}




Also some extensive examples using Spring Boot and mocking will be greatly appreciated.


Best Regards,
Alexander","davsclaus:1613545375:2021-02-17T15:02:55.998+0000:1613545375:2021-02-17T15:02:55.998+0000:People is welcome to help with docs. You can just click the ""edit this page"" button and submit a PR"
0,CAMEL-16228,Task,Major,None,3.x,"
None
",Resolved,Auto Closed,3.x,Unassigned,Andrea Cosentino,0,4,2021-02-17 12:33:42+00:00,2022-01-16 18:42:11+00:00,"Currently in the .adoc of our documentation we are using (for example)


xref:components::kafka-component.adoc[KafkaIdempotentRepository]


This is ok for master branch and latest documentation.


The problem arises when we look at older active branch, all the link to components in 3.7.x for example are still pointi to latest. We need to change the docs in the following way 


xref:3.7.x@components::kafka-component.adoc[KafkaIdempotentRepository]


We need to do this for 3.8.x, 3.7.x and 3.4.x","acosentino:1613539664:2021-02-17T13:27:44.416+0000:1613539664:2021-02-17T13:27:44.416+0000:What do you think [~zregvart] ?
acosentino:1613541285:2021-02-17T13:54:45.915+0000:1613541285:2021-02-17T13:54:45.915+0000:I noticed this while removing aws components.
zregvart:1613544776:2021-02-17T14:52:56.254+0000:1613544776:2021-02-17T14:52:56.254+0000:The only version that's fixed to {{latest}} is the user manual. 

We build against different versions of (Camel) components and sub-projects. From those we need to point to a specific (compatible) version. I think mostly we point from (Camel) components to (Camel) components and from sub-projects to (Camel) component documentation.

For {{xref}} within the same (Antora) component and module, we should use the shortest version, e.g. {{xref:path}} (as in this [section|https://docs.antora.org/antora/2.2/asciidoc/page-to-page-xref/#same-module]), this results in addressing the same (Antora) component and version.

For Camel, Spring Boot and Karaf, that are released at the same time as Camel, so the version is the same, I _think_ we can use the intrinsic attribute {{:page-component-version:}} (per Antora [documentation|https://docs.antora.org/antora/2.3/page/intrinsic-attributes/#page-attributes]), e.g. {{xref:\{page-component-version\}@components::....adoc}}.

For other sub projects (K, Kafka Connector, Quarkus), we need to manage separately the version of Camel is referenced there. I don't know of a per- (Antora) component Asciidoc attribute feature, so I don't think we can set an attribute like {{camel-version}} in (say) Camel K's documentation to (say) {{3.7.x}}, and have it maintained for across releases. So for this aspect of the problem I don't have a solution.

Either way, we would need to go through a large number of {{xref}} links across multiple branches we build and make sure that the version is parameterized. I remember doing scripts and some Java code around that when we first created the documentation, so something like that to automate the process would be needed.

[~djencks] your thoughts would be appreciated here.
djencks:1613556929:2021-02-17T18:15:29.636+0000:1613556929:2021-02-17T18:15:29.636+0000:I'm afraid I don't understand the problem yet.  A couple of specific examples would really help.

Meanwhile, some comments....

 
 * If Camel (core), Spring Boot and Karaf are released in lockstep, I wonder if it would be more appropriate to have them all parts of the same distributed component.  Basically, do you want the navigation tree to change when you go say from a camel component to the spring boot info about it?  I'd think it might possibly be nicer to have the links to spring boot and karaf pages nested under the link to the component page in the navigation.
 * If you need all the links from say camel-quarkus version X to refer to camel components version Y you can define an attribute in the camel-quarkus version X antora.yml:

```

asciidoctor:

  attributes:

    camel-components-version: Y

```

and use that in your xref: `href:\{camel-components-version}@components:languages:foo.adoc[]`
acosentino:1613557454:2021-02-17T18:24:14.155+0000:1613557454:2021-02-17T18:24:14.155+0000:The problem is in the user-manual. If you have any link to components/endpoints/eip in non-generated adocs, they won't follow the versioning, so if you are on a page of user-manual with a link to a component page, you'll have always a link to the latest version, no matters if you are looking at 3.7.x, 3.8.x or 3.4.x, you will arrive to latest anyway.
djencks:1613558492:2021-02-17T18:41:32.620+0000:1613558492:2021-02-17T18:41:32.620+0000:That doesn't make sense to me yet.  AFAICT there's only one published version of the user manual, so there's only one possible target for each xref, and it seems quite reasonable to me that the target should be the latest version, as naturally happens when you don't specify the version.  Perhaps a really specific example of one existing page with an actual link and explaining what you want the target to be would help.
zregvart:1613560969:2021-02-17T19:22:49.690+0000:1613560969:2021-02-17T19:22:49.690+0000:Thanks [~djencks] now I understand that we can set attributes per component in [antora.yml|https://docs.antora.org/antora/2.3/component-attributes/#hard-set], I was not aware of this until now. This will help when we point from sub-project to Camel documentation (other than the manual) of specific version.

There are a number of issues that we have with the root cause of poor version management, I'll try to enumerate the ones I know about:
* Release process doesn't account for changing the (Antora) component version, this would be a non-issue if we were not publishing LTS, last release and latest versions. We usually followup a release by changing the {{version}} in {{antora.yml}} and change the version in {{xref}} links (examples: [ccfcfcf6|https://github.com/apache/camel/commit/ccfcfcf6023aac038dd60d08071ec4f38a3b3a2e]. [af07b7f4|https://github.com/apache/camel-spring-boot/commit/af07b7f4ee312c4ee9e34077b760ac500b97f7fc], [baa6bf97|https://github.com/apache/camel-spring-boot/commit/baa6bf9798234e4fac6ccbc12746d5567f3829e3]). For this I think a proper solution is including a {{camel-version}} attribute in {{antora.yml}} and referencing that from {{xref}} links. Then we would need to change the {{version}} and {{camel-version}} in {{antora.yml}}.
* We forget to version links in the (Antora) ""components"" component, which end up pointing to the {{latest}} version (examples: [ae16cbd0|https://github.com/apache/camel/commit/ae16cbd0b86b1d90e4364f8f3de2dd8cffde8be0], [ae16cbd0|https://github.com/apache/camel/commit/ae16cbd0b86b1d90e4364f8f3de2dd8cffde8be0]. I think same solution should apply here, we add {{camel-version}} attribute.

I think a lot of our problems would go away if we go through all xrefs, and make sure that all xrefs that do not point to the user manual point to a version dictated by the attribute, for now I think we only need {{camel-version}}, we could also need {{camel-quarkus-version}} and similar if we end up pointing from ""components"" component to the Camel Quarkus documentation for example.

We could merge camel-spring-boot and camel-karaf into a distributed ""components"" component, but I would not tackle this for this issue.
djencks:1613563582:2021-02-17T20:06:22.070+0000:1613563582:2021-02-17T20:06:22.070+0000:In general a per component attribute is probably best, but the particular change you pointed to looks wrong to me. Eip is already in the components component, so I’d expect removing the component segment from the xref would be a better change.
djencks:1613568809:2021-02-17T21:33:29.441+0000:1613568809:2021-02-17T21:33:29.441+0000:I would like it if I could write an Asciidoctor extension to validate xrefs according to some rules, but I don't think it will be possible for a long time, until inline nodes are recognized during parsing and before conversion, so they can be examined by a tree processor.  I'll keep thinking about it however.
davsclaus:1642329731:2022-01-16T18:42:11.249+0000:1642329731:2022-01-16T18:42:11.249+0000:So much have improved/change for the website, so lets close old ticket.

Create ticket on github at camel-website for tickets about the website"
0,CAMEL-16227,Bug,Major,3.7.2,"3.7.3, 3.9.0","
None
",Resolved,Fixed,"3.7.3, 3.9.0",Unassigned,Krzysztof Jamróz,0,2,2021-02-17 10:54:56+00:00,2021-02-18 16:08:31+00:00,"Netty when configured with reuseChannel=true invokes wrong AsyncCallback. It invokes callback registered by first netty invocation in given route multiple times. This can be observed by debugging NettyReuseChannelTest. This seems not to cause serious problems at least in simple cases, because both callbacks (from SendProcessor) do not do much and simply continue routing. I am not sure if in more complex cases this could cause more problems.


However there is one observable issue caused by this behavior: event notifications contain wrong endpoint and wrong time taken. I attached a test for it.


Another problem is that this behavior makes it harder (if possible at all) to fix CAMEL-16178 for case with reuseChannel=true.","krzysztofjamroz:1613532136:2021-02-17T11:22:16.760+0000:1613532136:2021-02-17T11:22:16.760+0000:The underlying issue is that each {{NettyProducer}} (there are 2 of them - one for each {{to(""netty:tcp..."")}}) has its own {{NettyCamelStateCorrelationManager}}, each with separate map of {{NettyCamelState}}. And when netty is invoked second time, what is supposed to reuse channel, it really reuses it but registers callback in wrong correlation manager. {{NettyCamelState}} should be registered in correlation manager for producer that opened the channel but uses correlation manager of sending producer. Then, when response is processed first {{NettyCamelState}} is found, not the second one.

I am not sure how this should be a fixed:
 # Looking up correct correlation manager in {{processWithConnectedChannel}} would need some information which currently is not there, eg. new property on Exchange with correlation manager or original producer similar to {{NETTY_CHANNEL}}
 # Moving {{NettyCamelStateCorrelationManager}} from {{NettyProducer}} to {{NettyEndpoint}} seems to be risky or wrong
 # There is no room to store additional data in {{Channel}} itself
 # Reusing the same {{NettyProducer}} when {{reuseChannel=true}} is probably wrong, because each endpoint can have slightly different configuration
 # Something different?
krzysztofjamroz:1613629127:2021-02-18T14:18:47.620+0000:1613629127:2021-02-18T14:18:47.620+0000:Netty Channel has attributes which I used to store appropriate correlation manager. PR: https://github.com/apache/camel/pull/5101
davsclaus:1613635711:2021-02-18T16:08:31.235+0000:1613635711:2021-02-18T16:08:31.235+0000:Thanks for working and fixing this"
0,CAMEL-16226,Bug,Major,3.8.0,3.9.0,"
None
",Resolved,Fixed,3.9.0,Alex Dettinger,Alex Dettinger,0,2,2021-02-17 09:48:47+00:00,2021-02-17 10:29:41+00:00,No Desc,"acosentino:1613528363:2021-02-17T10:19:23.244+0000:1613528363:2021-02-17T10:19:23.244+0000:Can you please report the input and how you were using the dataformat? Thanks
aldettinger:1613528755:2021-02-17T10:25:55.603+0000:1613528981:2021-02-17T10:29:41.008+0000:I fix it in [this commit|https://github.com/apache/camel/commit/e48fcd602622bc2dc59ce17faf7900bf3340a1c6] it includes a test showing the scenario."
0,CAMEL-16225,Bug,Minor,"3.7.0, 3.7.1, 3.7.2, 3.8.0","3.7.3, 3.9.0","
None
",Resolved,Fixed,"3.7.3, 3.9.0",Unassigned,Jörg Jansen,0,1,2021-02-17 07:44:11+00:00,2021-02-17 08:35:03+00:00,"I'm running apache-camel within a apache-karaf container.
Now I recognized the problem, that the route-list command failed, with
the following scenario:


I have route configured where bundle1 reads the data from a file and
forwards the content to a route of bundle 2, using a VmEndpoint.


After startup the route-list command works fine, but as soon as an
incoming message has been processed, the command failed with a
NullPointerException.


I think the problem is located in the DefaultManagementObjectNameStrategy.
Here I can see, the in method getObjectNameForRoute(..)
The camelContext is picked from the Endpoint.
Is there a special reason, why it is not read from the provided route directly?


 




@Override
public ObjectName getObjectNameForRoute(org.apache.camel.Route route) throws MalformedObjectNameException {
    Endpoint ep = route.getEndpoint();
    String id = route.getId();

    StringBuilder buffer = new StringBuilder();
    buffer.append(domainName).append("":"");
    buffer.append(KEY_CONTEXT + ""="").append(getContextId(ep.getCamelContext())).append("","");
    buffer.append(KEY_TYPE + ""="" + TYPE_ROUTE + "","");
    buffer.append(KEY_NAME + ""="").append(ObjectName.quote(id));
    return createObjectName(buffer);
} 



As in my test-case the context of the endpoint and route differ, this
seems to be the reason, why the JMX-object could not be resolved.",
0,CAMEL-16224,Task,Major,None,None,"
None
",Resolved,Fixed,3.9.0,Andrea Cosentino,Andrea Cosentino,1,2,2021-02-17 06:26:54+00:00,2021-02-24 09:03:06+00:00,No Desc,"acosentino:1613514608:2021-02-17T06:30:08.914+0000:1613514630:2021-02-17T06:30:30.959+0000:[~rmarcello] feel free to work on this if you have time, you'll need to have a look at [https://github.com/apache/camel-spring-boot]

Let me know if you intend to work on this, otherwise I'll go ahead.
rmarcello:1613518302:2021-02-17T07:31:42.475+0000:1613518302:2021-02-17T07:31:42.475+0000:I am already working on it :)
rmarcello:1613821269:2021-02-20T19:41:09.114+0000:1613821269:2021-02-20T19:41:09.114+0000:Hi, I have prepared the module and I am testing it but I am having some problems with vom.google.guava:guava dependency.

I udersatand already an improvement to make on the component. Maybe I need to open another issue on it.

I am trying to resolve the problem also on the spring-boot-starter but till now without success. [~acosentino] Do you have any suggestion on ""avoid guava version to be replaced from bom""?"
0,CAMEL-16223,Task,Major,None,3.x,"
None
",Resolved,Won't Fix,3.x,Andrea Cosentino,Andrea Cosentino,0,2,2021-02-17 06:26:16+00:00,2021-04-08 10:04:00+00:00,No Desc,"acosentino:1613514562:2021-02-17T06:29:22.833+0000:1613514562:2021-02-17T06:29:22.833+0000:[~rmarcello] feel free to work on this. You'll need to have look at https://github.com/apache/camel-karaf/

in particular at this file: [https://github.com/apache/camel-karaf/blob/master/platforms/karaf/features/src/main/resources/features.xml]

After adding the feature, under platforms/karaf/features just run mvn verify and check if it works.

Let me know if you intend to work on this, otherwise I'll go ahead.
rmarcello:1613518575:2021-02-17T07:36:15.197+0000:1613518575:2021-02-17T07:36:15.197+0000:Ok, I will try, I am new on this maybe I will need a bit more.
rmarcello:1613648279:2021-02-18T19:37:59.708+0000:1613648279:2021-02-18T19:37:59.708+0000:Hi, is there a way to securely and automatically provide the bundle list ? Can I read something somewhere?
acosentino:1615334020:2021-03-10T07:53:40.446+0000:1615334020:2021-03-10T07:53:40.446+0000:No, it is try and fix.
acosentino:1615334052:2021-03-10T07:54:12.349+0000:1615334052:2021-03-10T07:54:12.349+0000:By the way this is not critical, OSGi support is best effort.
acosentino:1617847440:2021-04-08T10:04:00.592+0000:1617847440:2021-04-08T10:04:00.592+0000:We can live without the Karaf feature"
0,CAMEL-16222,Improvement,Major,None,3.9.0,"
None
",Resolved,Fixed,3.9.0,Claus Ibsen,Claus Ibsen,0,1,2021-02-16 15:15:37+00:00,2021-02-25 06:20:53+00:00,It would be good to have an factory API for creating Exchange that the components uses (DefaultEndpoint). As this allows Camel to optimize certain use-cases by having a hook via the factory API.,"davsclaus:1613600909:2021-02-18T06:28:29.278+0000:1613600909:2021-02-18T06:28:29.278+0000:After some experimentation I think we should focus this on

- consumers only
- use per consumer factory so there is no race condition if one global pool

There are other places in EIPs where sub exchanges are created (aggregator, splitter, wire tap) but it would complicate matters if they are also pooled.

By using per consumer we can also use that for back pressure where we can work on some  limits you can specify.
This requires some modest API addition to Consumer and to implement this across all the components, so the consumers in these components will use this new API instead of the classic.


davsclaus:1613632937:2021-02-18T15:22:17.773+0000:1613718554:2021-02-19T15:09:14.875+0000:TODO: Upgrade 3.9 doc update about API change in Consumer *DONE*
davsclaus:1614154651:2021-02-24T16:17:31.692+0000:1614154651:2021-02-24T16:17:31.692+0000:See more details in CAMEL-16213"
0,CAMEL-16221,Improvement,Major,None,Future,"
None
",Open,Unresolved,Future,Unassigned,Luca Burgazzoli,1,6,2021-02-16 14:33:19+00:00,2023-07-17 11:41:04+00:00,"As today URIs are the primary mechanism Camel uses internally to describe endpoints but I think it is time to re-consider the dependency on URIs for camel internals and leave the URIs as an external representation of endpoints


As example:



the Endpoint DSL is required to generate the related endpoint URI to leverage Camel's APIs but to create an endpoint, the schema and a map of options, would be more than enough.
components that wrap other components, such as kamelets, master & co may need to re-create URIs to create instances of the delegated endpoints which is cumbersome as there's lot of options to take into account (RAW, url-encoding, placeholders)
the YAML DSL and camel-kafka-connectors are using and Endpoint DSL alike syntax where a user can define endpoints by scheme + option pairs without the need of writing URIs.","lb:1613457657:2021-02-16T14:40:57.448+0000:1613457657:2021-02-16T14:40:57.448+0000:/cc [~davsclaus] [~gnodet]
davsclaus:1613459599:2021-02-16T15:13:19.366+0000:1613459599:2021-02-16T15:13:19.366+0000:10 years ago there was an attempt for a component/endpoint to be able to do something like that, but back then we didnt have any details like we have today from the camel-catalog, and its api where we can build uri from scheme + options.

So we are in a better situation today, where an Endpoint can be configured in more ways, but be able to unique identify itself as an uri.
With the generated configurer we are now also able to set those map parameters in a consistent and safe way on the endpoint. However we need to go via the component class as each component may do something special, but there is api for uri, Map of parameters so that is close to what we need.
We can then add a new (scheme, map) and then we should be able to create the endpoint and have it represent itself as uri.

gnodet:1613461315:2021-02-16T15:41:55.526+0000:1613461315:2021-02-16T15:41:55.526+0000:Some endpoints also use the {{path}} inside the URI, so we'd need a reserved property for that.
We could use a simple map with {{scheme}} and {{path}} being reserved and let it opened for other properties.  A single map could have the benefit to be easily translated from json/yaml maybe.
lb:1613463428:2021-02-16T16:17:08.073+0000:1613463428:2021-02-16T16:17:08.073+0000:looks like an URI :)
davsclaus:1613464576:2021-02-16T16:36:16.942+0000:1613464576:2021-02-16T16:36:16.942+0000:Yeah the context path is build up of a set of parameters, eg those marked with @UriPath.
But surely we can add reserved keys.

And then there are components that has lenient parameters (eg like http clients).

And then there are some options that are multi-valued, where you in uri repeat the parameter with a prefix xxx.foo=123&xxx.bar=456, where the key name is xxx (multivalue = true).


lb:1613523321:2021-02-17T08:55:21.397+0000:1613523527:2021-02-17T08:58:47.669+0000:[~gnodet] maybe we do not need to reserve a specific property for the path as example:

camel-http has http:httpUri as syntax
camel-infinispan has infinispan:cacheName

So in fact, we may only need to use such properties (and check that components are doing the right things)

[~davsclaus] we could think to have the EndpointUriFactory to be able to marshal and unmarshal endpoint uris, like:

{code:java}
String uri = EndpointUriFactory.buildUri(
    ""http"", Map.of(""httpUri"", ""/a/b/c"", ""foo"", ""bar""));
EndpointDefinition definition = EndpointUriFactory.parseUri(
    ""http://a/b/c?foo=bar"");
{code}

Maybe EndpointDefinition.toString() should then compute the uri
davsclaus:1627430357:2021-07-28T07:59:17.254+0000:1627430357:2021-07-28T07:59:17.254+0000:You can build those uris today via ExtendedCamelContext, where context-path and query parameters are assembled correctly (such as your http and infinispan example)

{code}
getEndpointUriFactory(""http"").buildUri(""http"", map goes here);
{code}



ggrzybek:1668580987:2022-11-16T14:43:07.726+0000:1668581276:2022-11-16T14:47:56.171+0000:Just to provide some summary:
* if there are two slashes ({{//}}) after first colon, what follows is _always_ the _authority_ ({{java.net.URI#getAuthority()}}), so:
** {{file:/path/to/file.txt}} - authority is null and {{/path/to/file.txt}} is the path
** {{file://path/to/file.txt}} - {{path}} is the authority, {{/to/file.txt}} is the path
** {{file:///path/to/file.txt}} - authority is null and the path is {{/path/to/file.txt}}
* if there's no slash after first colon, the URI is always _opaque_ - it never has any path ({{java.net.URI#getPath()}}), it has only three components:
** scheme
** scheme-specific part
** fragment
* if there's a scheme, the URI is always absolute (whether or not there's a slash after scheme)
* if there's no scheme, the URI is never absolute (even in {{java.net.URI.create(""/hello"")}})."
0,CAMEL-16220,Improvement,Major,None,3.9.0,"
None
",Resolved,Fixed,3.9.0,Claus Ibsen,Claus Ibsen,0,1,2021-02-16 12:59:53+00:00,2021-02-17 07:18:02+00:00,"If using http producer and there are no override headers, or something else that change what uri to send to, then we should optimize and not build URI object but could use URI based on init/build phase.","davsclaus:1613463895:2021-02-16T16:24:55.628+0000:1613463895:2021-02-16T16:24:55.628+0000:optimize camel-http
there is potential a little bit in camel-vertx-http too"
0,CAMEL-16219,Improvement,Major,None,3.9.0,"
None
",Resolved,Fixed,3.9.0,Claus Ibsen,Claus Ibsen,0,1,2021-02-16 12:16:05+00:00,2021-03-17 10:09:14+00:00,"Currently template parameters requires a value so either they are mandatory or has a default value.


But there can be some use-cases where you want an optional parameter, and if there is no value, then its not in use, eg in endpoint uris as part of query parameters (key=value) then if no value then dont include the key.","davsclaus:1614924678:2021-03-05T14:11:18.841+0000:1615946950:2021-03-17T10:09:10.871+0000:TODO: optional parameters in model *DONE*
TODO: use {{?key} syntax *DONE*
TODO: camel-kamelet test *DONE*
TODO: update docs *DONE*"
0,CAMEL-16218,Improvement,Major,None,None,"
None
",Resolved,Fixed,3.9.0,Andrea Cosentino,Claus Ibsen,0,1,2021-02-16 09:22:58+00:00,2021-02-16 15:51:33+00:00,"Sonarqube and others will report these to use SecureRandom instead. But this is only for security related use such as crypto, certificates and whatnot.


In Camel we use random numbers in some places, and there is also the random function in the simple language.


So mark those with // NOSONAR in the source code (same line as new Random() are).
And then only use SecureRandom in security matters.",
0,CAMEL-16217,Improvement,Major,None,3.9.0,"
None
",Resolved,Fixed,3.9.0,Claus Ibsen,Claus Ibsen,0,1,2021-02-16 08:49:52+00:00,2021-02-16 10:23:45+00:00,"If sending to the same endpoint all the time, we can optimize and use previous lookup.",
0,CAMEL-16216,Bug,Minor,"3.6.0, 3.7.0, 3.7.2, 3.8.0",,"
None
",Resolved,Information Provided,None,Unassigned,Josef Tember,0,2,2021-02-16 08:32:17+00:00,2021-02-17 09:51:47+00:00,"I created a ticket: reffering to


http://mail-archives.apache.org/mod_mbox/camel-users/202102.mbox/%3CCAGB5yN%3Dv0PZSTEPvEO0O6i2CRZMO1YiF4X9e%3DwNZsmLROJYiTQ%40mail.gmail.com%3E


 


Also tried it with Version 3.6.0, 3.7.0, 3.7.2, 3.8.0


I'm trying to make an http-call with dynamic timeout, passed by header




Map<String,Object> headerMap=new HashMap<>();
headerMap.put(Exchange.HTTP_URI, ""http://myserver.example.com"");
headerMap.put(""timeout"", 5000);
main.getCamelTemplate().sendBodyAndHeaders(""direct:test_http_dynamic"",null,headerMap);



the endpoint looks like this:


 




from(""direct:test_http_dynamic"")
 .toD(""http:test.dyn?socketTimeout=${in.header.timeout}"");



This leads to this Stacktrace:




org.apache.camel.ResolveEndpointFailedException: Failed to resolve endpoint: http://http:test.dyn
due to: Failed to resolve endpoint: http://http:test.dyn due to: The uri part is not configured
correctly. You have duplicated the http(s) protocol.
 at org.apache.camel.impl.engine.AbstractCamelContext.doGetEndpoint(AbstractCamelContext.java:912)
~[camel-base-engine-3.7.0.jar:3.7.0]
 at org.apache.camel.impl.engine.AbstractCamelContext.getEndpoint(AbstractCamelContext.java:798)
~[camel-base-engine-3.7.0.jar:3.7.0]
 at org.apache.camel.support.CamelContextHelper.getMandatoryEndpoint(CamelContextHelper.java:73)
~[camel-support-3.7.0.jar:3.7.0]
 at org.apache.camel.support.ExchangeHelper.resolveEndpoint(ExchangeHelper.java:112)
~[camel-support-3.7.0.jar:3.7.0]



 


=== Possible Workaround:


change RouteDefinition to - turning off optimizer:


 




from(""direct:test_http_dynamic_workaround"")
.toD().allowOptimisedComponents(false).cacheSize(10).uri(""http:test.dyn?socketTimeout=${in.header.timeout}"");","davsclaus:1613523848:2021-02-17T09:04:08.641+0000:1613523848:2021-02-17T09:04:08.641+0000:Okay looked into this.

socket timeout cannot be dynamic for optimized toD. ToD is supporting context-path / query parameters etc.
So turn off the optimizer, which leads to growing number of endpoints/http clients connecting to the same host but with different socket timeout.
That is probably a bad design. Stick to a given timeout configuration (not dynamic)




temberjosef:1613525864:2021-02-17T09:37:44.685+0000:1613525864:2021-02-17T09:37:44.685+0000:Thank your for your quick answer.

I don't contact the same host with different timeouts - i contact different hosts/URIs with different timeouts depending what product they create.

The Number of hosts/URIs are final - about 20 of them. And each of them has a different, but static timeout .

 

I understand, that the optimizer may not build for this scenario.

But is it ok to turn off the optimizer for my purpose?

 

 

 
davsclaus:1613526707:2021-02-17T09:51:47.853+0000:1613526707:2021-02-17T09:51:47.853+0000:Yes as long you dont have unlimited different socket timeout values, that leads to a lot of different endpoint uri's.

Just mind that if you connect to the same host and use different timeouts, then they use each their own http client, as the timeout is client specific.

"
0,CAMEL-16215,Improvement,Major,None,3.9.0,"
None
",Resolved,Fixed,3.9.0,Claus Ibsen,Claus Ibsen,0,1,2021-02-15 17:51:04+00:00,2021-09-27 10:26:09+00:00,"As the http component uses this to know if status is okay within ranges 200..299 and so on, we can optimize it due it uses string split which uses regexp in older JDKs.


We can be smarter and with ranges that dont need to be parsed each time, but initialized from the component.",davsclaus:1613428819:2021-02-16T06:40:19.468+0000:1613428819:2021-02-16T06:40:19.468+0000:Also done for the other http components
0,CAMEL-16214,New Feature,Major,None,,"
None
",Resolved,Invalid,None,Unassigned,Claus Ibsen,0,1,2021-02-15 17:28:36+00:00,2021-02-17 09:06:57+00:00,"We can look at using vertx case insensitive map which may be faster than the default map we use in camel-core, for users on camel-quarkus / vertx etc.


It will use the same plugin mehanism as we have for the camel-headersmap component","davsclaus:1613524017:2021-02-17T09:06:57.879+0000:1613524017:2021-02-17T09:06:57.879+0000:We cannot do this as the vertx case insensitive map is for string values only, and Camel headers can be any object type."
0,CAMEL-16213,New Feature,Major,None,3.9.0,"
None
",Resolved,Fixed,3.9.0,Claus Ibsen,Luca Burgazzoli,0,2,2021-02-15 15:20:26+00:00,2021-02-25 06:21:00+00:00,"By default a brand new exchange is created for each message received by a component and that's usually fine but for very simple routes, like those created by the camel-kafka-connector or the Kantive Sources in camel-k it may be useful to have an option to create pools of reusable exchanges as:



exchanges are short living objects and routes are simple
exchanges are heavy (multiple maps for properties and headers)
camel-kafka-connector and knative sources are likely to receive the same messages type, with the same set of headers so the maps allocated by the exchange can safely be recycled to reduce allocations and resizing



In addition to the reason above, we can leverages exchange pooling to:



implement back pressure driven by the resource constraints to be sure we don't exceed resources consumption and we don't degrade the the service (i.e. long GC pause)
have a way to create tailored exchanges, i.e. by providing an exchange that does not have in/out but just in



An example of fast and efficient ASL2 licensed object pooling: https://github.com/chrisvest/stormpot","davsclaus:1613629509:2021-02-18T14:25:09.738+0000:1613629509:2021-02-18T14:25:09.738+0000:Okay have the experiment working with core camel, and all tests passes. 

So its the component consumers that have pooling (eg file, timer, etc.)
Then they reuse their own created exchanges and we can the optimize for that.


davsclaus:1613636010:2021-02-18T16:13:30.168+0000:1613636010:2021-02-18T16:13:30.168+0000:Since we use a private pool per consumer (so they create the same kind of exchanges) then we dont need any advanced pooling system, and can use jdk collections.
davsclaus:1613721192:2021-02-19T15:53:12.643+0000:1613721192:2021-02-19T15:53:12.643+0000:If we have pooled exchanges that are recycled, and a consumers AsyncCallback task is the same for all exchanges (eg timer consumer). We could potentially create that once, and reuse as well. 

There is something to think about as that is 1 less object to create per message.
davsclaus:1613773782:2021-02-20T06:29:42.537+0000:1614150528:2021-02-24T15:08:48.519+0000:TODO: PooledExchange interface and move new api added to extended exchange to here *DONE*
TODO: DefaultPooledExchange impl extending DefaultExchange and created by the factory *DONE*
TODO: ExchangeFactory javadoc to highlight its for consumer only *DONE*
TODO: statistics enabled off by default *DONE*
TODO: configuration option in camel-main to turn this on|off *DONE*
TODO: all components that has consumer to use the factory *DONE*
TODO: add unit test in camel-core *DONE*
TODO: capture metrics in pooled factory so we can gather how many exchanges are pooled (also jmx mbean) *DONE*
TODO: recycle OUT when its DefaultMessage vs special implementation (check if any problems - eg camel-jms maybe?) *WONT FIX* (we do not reuse OUT)
TODO: external pool with eviction (caffeine or the one luca mentioned?)

davsclaus:1613813016:2021-02-20T17:23:36.098+0000:1613813016:2021-02-20T17:23:36.098+0000:So we now reduces by 4-6 objects per consumed message depending on OUT is in use or not (exchange, in, out, properties, 2 x map).

In a little example with a total of 10.000.000 allocations for 2 min running, then it was reduced by about 5% - most of the allocations are outside camel. But there are more potential in the http components to optimize.
davsclaus:1613869596:2021-02-21T09:06:36.017+0000:1614074641:2021-02-23T18:04:01.337+0000:TODO: a *DONE*
TODO: camel-atom *WONT FIX*
TODO: all the aws2 components *DONE*
TODO: b *DONE*
TODO: c *DONE*
TODO: camel-cxf *WONT FIX*
TODO: d *DONE*
TODO: e *DONE*
TODO: camel-flatpack *WONT FIX*
TODO: f *DONE*
TODO: camel-grpc *WONT FIX*
TODO: g *DONE*
TODO: h *DONE*
TODO: camel-irc *DONE*
TODO: i *DONE*
TODO: camel-jetty *DONE*
TODO: camel-jms *DONE*
TODO: j *DONE*
TODO: camel-kafka *DONE*
TODO: k *DONE*
TODO: l *DONE*
TODO: m *DONE*
TODO: camel-netty *DONE*
TODO: camel-netty-http *DONE*
TODO: n *DONE*
TODO: o *DONE*
TODO: camel-platform-vertx *DONE*
TODO: camel-pulsar *DONE*
TODO: p *DONE*
TODO: camel-quartz *WONT FIX*
TODO: q *DONE*
TODO: camel-rabbitmq *DONE*
TODO: camel-resteasy *WONT FIX*
TODO: camel-rss *WONT FIX*
TODO: r *DONE*
TODO: all camel-spring *DONE*
TODO: camel-servlet *DONE*
TODO: camel-sjms/camel-sjms2 *DONE*
TODO: s *DONE*
TODO: camel-twitter *WONT FIX*
TODO: t *DONE*
TODO: u *DONE*
TODO: v *DONE*
TODO: w *DONE*
TODO: x *DONE*
TODO: y *DONE*
TODO: z *DONE*
davsclaus:1614041893:2021-02-23T08:58:13.424+0000:1614115002:2021-02-24T05:16:42.432+0000:TODO: attachments message should reset *DONE*
TODO: update component maven archetype *DONE*"
0,CAMEL-16212,New Feature,Minor,None,Future,"
None
",Open,Unresolved,Future,Unassigned,Peter Palaga,0,1,2021-02-15 10:59:33+00:00,2023-07-17 11:41:25+00:00,"We currently (mis)use the fact that current model classes have JAXB annotations to discover CSimple expressions in Camel Quarkus - see https://github.com/apache/camel-quarkus/blob/master/extensions/csimple/deployment/src/main/java/org/apache/camel/quarkus/component/csimple/deployment/CSimpleProcessor.java#L337-L347


davsclaus mentioned recently that he would like to remove JAXB from Camel Core. It would be nice if Camel provided an API for route introspection at build time before JAXB is removed.",
0,CAMEL-16211,Task,Minor,3.8.0,3.9.0,"
None
",Resolved,Fixed,3.9.0,Claus Ibsen,Luca Burgazzoli,0,2,2021-02-15 10:18:26+00:00,2021-10-13 14:25:31+00:00,"From https://github.com/apache/camel/pull/5088#discussion_r576060177:


That API is not really for end users, as that would mean they build those model classes outside the DSL and then take that model (which is a route) and add to a route (doesnt make so much sense). We should possibly mark in the javadoc that this is only for internal usage. And maybe come up with a different name, and deprecate the old name.",davsclaus:1613524256:2021-02-17T09:10:56.991+0000:1613524256:2021-02-17T09:10:56.991+0000:Added some javadoc comment about this
0,CAMEL-16210,Bug,Major,"3.6.0, 3.7.2, 3.8.0","3.7.3, 3.9.0","
None
",Resolved,Fixed,"3.7.3, 3.9.0",Claus Ibsen,Claus Ibsen,0,1,2021-02-15 09:51:06+00:00,2021-02-15 10:18:03+00:00,Reported by end user.,
0,CAMEL-16209,Improvement,Minor,None,,"
None
",Open,Unresolved,None,Andrea Cosentino,Luca Burgazzoli,0,1,2021-02-15 09:34:50+00:00,2021-02-25 09:54:30+00:00,"A user reported some issues with aws kinesis on SO: https://stackoverflow.com/questions/66177095/camel-application-re-processing-kinesis-records


I think the issues falls into two categories:
1. partitioning: some work is in progress on camel-k side, see: https://github.com/apache/camel-k/issues/1779 and commit 8cc227b65b0 on apache-camel
2. restart from an index: see https://issues.apache.org/jira/browse/CAMEL-15562",
0,CAMEL-16208,Improvement,Minor,None,3.x,"
None
",Resolved,Won't Fix,3.x,Unassigned,Claus Ibsen,0,1,2021-02-15 06:14:04+00:00,2021-12-01 19:24:11+00:00,This uses too much funky functional code that is slower and creates object overhead. A simple for loop would be quicker.,"davsclaus:1638357851:2021-12-01T19:24:11.016+0000:1638357851:2021-12-01T19:24:11.016+0000:So vertx-kafka is not recommended as quarkus is not using it anymore, and its not so active maintained. The regular camel-kafka has been improved a lot since."
0,CAMEL-16207,Improvement,Major,None,3.9.0,"
None
",Resolved,Fixed,3.9.0,Claus Ibsen,Claus Ibsen,0,1,2021-02-15 06:11:34+00:00,2021-02-15 15:03:17+00:00,"Instead of reg exp pattern that causes overhead compared to a quick startsWith check, then lets add a way for quickly filtering by startsWith.


Then we can check for starts with


Camel*
camel*
org.apache.camel.*


As they are not intended as protocol/user headers.",
